# 《公会经理》技术架构文档（策略集中+执行分散混合版）

## 1. 项目概述
### 1.1 项目背景与目标
### 1.2 架构设计原则与理念
### 1.3 技术栈选型说明
### 1.4 开发阶段规划（MVP优先）

---

## 📋 **第一阶段：基础设施锁定（第1-2周）** 🚨 **AI代码生成必备**

## 2. 调试与监控系统（基础设施优先）
### 2.1 开发调试工具
#### 2.1.1 Playwright (Electron) E2E测试环境
#### 2.1.2 Sentry (Electron) 错误监控集成
##### 2.1.2.1 Releases & Health 追踪配置
- 版本发布关联：每次构建自动创建Release记录
- 健康度监控：Session健康状态实时追踪
- 部署追踪：版本部署状态和回滚监控
- 用户影响评估：版本质量和稳定性分析

##### 2.1.2.2 采样率配置策略
- 错误采样率：100%（生产环境全量错误收集）
- 性能采样率：10%（避免过度性能数据收集）
- 调试采样率：50%（开发环境适中采样）
- 动态采样：基于错误频率自动调整

##### 2.1.2.3 Event Loop Block Detection（Electron专用）
- 主进程监控：threshold 500ms，检测主线程阻塞
- 渲染进程ANR：captureStackTrace启用，5秒阈值
- 配置示例：@sentry/electron + @sentry/node-native集成
- 监控范围：覆盖Phaser游戏循环和React渲染
#### 2.1.3 开发者工具集成 (DevTools Extensions)
#### 2.1.4 热重载与实时调试

### 2.2 日志系统
#### 2.2.1 分级日志架构
#### 2.2.2 日志收集策略
#### 2.2.3 日志持久化方案 (logs/ 目录)
#### 2.2.4 日志分析工具

### 2.3 监控面板
#### 2.3.1 实时性能监控
#### 2.3.2 内存泄漏检测
#### 2.3.3 事件流可视化 (开发期必需)
#### 2.3.4 AI状态监控面板

### 2.4 诊断工具
#### 2.4.1 崩溃报告系统
#### 2.4.2 性能采样工具
#### 2.4.3 用户行为追踪
#### 2.4.4 自动化测试报告

### 2.5 **第2章测试执行清单**
#### 2.5.1 本章测试映射
- **单元测试**：日志分级器、监控数据收集器、诊断工具核心逻辑
- **集成测试**：Sentry-Electron集成、监控面板与后端数据同步
- **E2E测试**：完整监控流程（错误触发→收集→上报→面板显示）

#### 2.5.2 本章冒烟断言
```typescript
// 监控系统冒烟测试示例
describe('监控系统冒烟测试', () => {
  it('应能正常启动Sentry监控', async () => {
    await startApp()
    const sentryInit = await checkSentryInitialization()
    expect(sentryInit).toBe(true)
  })
  
  it('应能检测Event Loop阻塞', async () => {
    await simulateEventLoopBlock(600) // 超过500ms阈值
    const blockAlert = await waitForBlockAlert()
    expect(blockAlert.threshold).toBe(500)
    expect(blockAlert.actualDuration).toBeGreaterThan(500)
  })
})
```

#### 2.5.3 覆盖率与门禁引用
- 覆盖率阈值：依照 **3.3.2条** 执行
- 质量门禁：依照 **3.3.3条** 的PR检查清单
- 性能基线：依照 **3.4.2条** 的告警阈值

## 3. 测试策略与质量门禁（统一法规）🏛️
### 3.1 测试金字塔与范围定义
#### 3.1.1 测试层级比例标准
```
测试金字塔标准配比：
├── 单元测试：70% (快速反馈，<2秒执行)
├── 集成测试：20% (组件协作验证)  
├── E2E测试：10% (关键路径验证)
└── 专项测试：按需 (性能、安全、AI行为)
```

#### 3.1.2 各层级定义与职责
- **单元测试**：纯函数、工具类、业务逻辑核心算法
- **集成测试**：组件间协作、API契约、数据流验证
- **E2E测试**：用户关键路径、跨系统集成、回归保护
- **专项测试**：性能基准、安全扫描、AI决策验证

#### 3.1.3 Electron特定测试策略
- **主进程测试**：窗口管理、IPC通信、系统集成
- **渲染进程测试**：React组件、Phaser场景、UI交互
- **进程间测试**：IPC契约、数据同步、安全边界

### 3.2 工具链与基线配置
#### 3.2.1 核心工具栈
- **单元测试**：Vitest (快速) + Jest (复杂场景)
- **集成测试**：React Testing Library + Phaser Test Utils
- **E2E测试**：Playwright for Electron (官方推荐)
- **代码质量**：ESLint + TypeScript 严格模式

#### 3.2.2 Playwright Electron配置标准
```javascript
// playwright.config.js - Electron配置模板
module.exports = {
  testDir: './e2e',
  timeout: 30000,
  use: {
    // Electron特定配置
    executablePath: require('electron'),
    args: ['./dist/main/main.js'],
    env: { NODE_ENV: 'test' }
  },
  projects: [{
    name: 'electron',
    use: { ...devices['Desktop Electron'] }
  }]
}
```

#### 3.2.3 测试数据与Fixtures规范
- **测试数据隔离**：每个测试独立数据库实例
- **Fixtures标准化**：统一的测试数据生成器
- **Mock策略**：第三方依赖一律Mock，内部模块按需Mock

### 3.3 质量门禁（CI/CD红线）🚦
#### 3.3.1 PR合并必须通过项
- ✅ **代码检查**：ESLint + TypeScript编译通过
- ✅ **单元测试**：通过率100%，覆盖率≥70%
- ✅ **集成测试**：核心功能集成验证通过
- ✅ **Electron冒烟**：应用启动→主窗口→基础交互正常

#### 3.3.2 覆盖率阈值标准
```yaml
# 覆盖率门禁配置
coverage_thresholds:
  global:
    statements: 70%    # 语句覆盖率基线
    functions: 70%     # 函数覆盖率基线  
    branches: 65%      # 分支覆盖率基线
    lines: 70%         # 行覆盖率基线
  
  # 关键模块更高要求
  critical_modules:
    ai_engine: 85%     # AI引擎核心算法
    security: 90%      # 安全相关模块
    data_integrity: 85% # 数据完整性模块
```

#### 3.3.3 主干/预发分支额外门禁
- ✅ **E2E关键路径**：用户核心流程端到端验证
- ✅ **性能基线**：启动时间、内存占用、帧率稳定性
- ✅ **安全扫描**：依赖漏洞、代码安全审计
- ✅ **AI行为验证**：关键决策场景回归测试

#### 3.3.4 发布门禁标准
- ✅ **全量测试套件**：所有层级测试100%通过
- ✅ **性能回归检测**：关键指标不得低于基线5%
- ✅ **兼容性验证**：目标平台(Windows/macOS/Linux)验证
- ✅ **安全合规检查**：Electron安全基线、数据加密验证

### 3.4 观测与告警基线
#### 3.4.1 Sentry Electron初始化标准
```javascript
// Sentry初始化模板 - 主进程
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  release: `guild-manager@${app.getVersion()}`,
  
  // 采样率配置
  tracesSampleRate: 0.1,        // 性能监控10%采样
  sampleRate: 1.0,              // 错误监控100%采样
  
  // Electron特定配置  
  integrations: [
    new Sentry.Integrations.Electron.ElectronMainIntegration({
      captureRendererCrashes: true  // 捕获渲染进程崩溃
    })
  ],
  
  // 隐私保护
  beforeSend: filterSensitiveData
});
```

#### 3.4.2 Event Loop Block检测阈值
- **主进程阻塞阈值**：500ms (影响窗口响应)
- **渲染进程ANR阈值**：5000ms (影响用户交互)
- **游戏循环阻塞阈值**：33ms (影响60fps流畅度)
- **告警升级策略**：连续3次阻塞→警告，连续10次→严重告警

#### 3.4.3 性能监控基线
- **应用启动时间**：<3秒 (从点击到主窗口显示)
- **内存占用基线**：启动<200MB，稳定运行<500MB  
- **CPU占用基线**：空闲<5%，游戏运行<30%
- **磁盘I/O基线**：存档操作<100ms，资源加载<500ms

## 4. 开发规范与最佳实践（代码生成标准）
### 4.1 代码规范
#### 4.1.1 TypeScript 编码规范（严格模式）
#### 4.1.2 React 组件规范（函数式 + Hooks）
#### 4.1.3 Phaser 开发规范（Scene架构）
#### 4.1.4 事件命名规范（强类型）

### 4.2 架构规范
#### 4.2.1 模块划分原则（SOLID原则）
#### 4.2.2 依赖管理规范（ESM模块）
#### 4.2.3 接口设计原则（契约优先）
#### 4.2.4 错误处理规范（统一异常）

### 4.3 文档规范
#### 4.3.1 代码注释规范（TSDoc）
#### 4.3.2 API文档规范
#### 4.3.3 架构文档维护
#### 4.3.4 变更记录要求

### 4.4 AI代码生成约束
#### 4.4.1 代码一致性保证
#### 4.4.2 命名规范统一
#### 4.4.3 架构模式固定
#### 4.4.4 重构安全策略

### 4.5 **第4章测试执行清单**
#### 4.5.1 本章测试映射
- **单元测试**：代码规范检查器、命名规范验证器、架构模式验证
- **集成测试**：规范与实际代码一致性验证、工具链集成测试
- **E2E测试**：代码生成→规范检查→构建成功的完整流程

#### 4.5.2 本章冒烟断言
```typescript
describe('开发规范冒烟测试', () => {
  it('TypeScript严格模式应正常工作', async () => {
    const tsConfig = await loadTSConfig()
    expect(tsConfig.strict).toBe(true)
    expect(tsConfig.noImplicitAny).toBe(true)
  })
  
  it('ESLint规则应能正确检测违规', async () => {
    const violations = await runESLintOnSample()
    expect(violations.length).toBe(0) // 示例代码应无违规
  })
})
```

#### 4.5.3 覆盖率与门禁引用
- 代码质量检查：依照 **3.3.1条** 的PR检查要求
- 规范一致性验证：依照 **3.2.3条** 的Mock策略

## 5. Electron安全基线与构建工具链（不可回退基座）
### 5.1 Electron安全配置
#### 5.1.1 进程隔离策略（contextIsolation: true）
#### 5.1.2 Node集成禁用（nodeIntegration: false）
#### 5.1.3 预加载脚本安全（安全API桥接）
#### 5.1.4 远程内容限制（webSecurity: true）

### 5.2 CSP策略配置
#### 5.2.1 内容安全策略定义
#### 5.2.2 脚本源控制
#### 5.2.3 样式源限制
#### 5.2.4 资源加载控制

### 5.3 构建工具链
#### 5.3.1 electron-vite 配置（HMR + 构建优化）
#### 5.3.2 electron-builder 配置（多平台打包）
#### 5.3.3 代码签名策略
#### 5.3.4 自动更新安全机制

### 5.4 安全审计
#### 5.4.1 依赖漏洞扫描
#### 5.4.2 安全基线检查
#### 5.4.3 权限最小化原则
#### 5.4.4 安全更新策略

### 5.5 **第5章测试执行清单**
#### 5.5.1 本章测试映射
- **单元测试**：安全配置验证器、CSP策略解析器、权限检查器
- **集成测试**：Electron安全集成测试、构建工具链验证
- **E2E测试**：完整安全策略在真实环境下的有效性验证

#### 5.5.2 本章冒烟断言
```typescript
describe('Electron安全基线冒烟测试', () => {
  it('contextIsolation应已启用', async () => {
    const mainWindow = await createTestWindow()
    const webContents = mainWindow.webContents
    expect(webContents.getWebPreferences().contextIsolation).toBe(true)
    expect(webContents.getWebPreferences().nodeIntegration).toBe(false)
  })
  
  it('CSP策略应阻止不安全脚本', async () => {
    const response = await injectUnsafeScript()
    expect(response.blocked).toBe(true)
    expect(response.violation).toContain('Content-Security-Policy')
  })
})
```

#### 5.5.3 覆盖率与门禁引用
- 安全测试覆盖率：依照 **3.3.2条** critical_modules.security标准
- 安全合规检查：依照 **3.3.4条** 发布门禁的安全验证要求

---

## 🏗️ **第二阶段：架构基础建立（第3-4周）**

## 6. 系统总体架构
### 6.1 架构概览图
### 6.2 模块职责划分
### 6.3 技术栈集成方案
#### 6.3.1 Electron + React 19 + Phaser 3 集成架构
##### 6.3.1.1 React 19 特性配置清单（AI代码生成必读）
- ✅ **React Compiler**：启用自动优化，无需手动memoization
- ✅ **新JSX Transform**：mandatory requirement，旧语法不兼容
- ⚠️ **Concurrent Rendering**：默认启用，检查render副作用
- ✅ **Actions API**：异步状态管理，pending/error自动处理
- ⚠️ **Breaking Changes**：useReducer类型参数变更，ref转发规则更严格

##### 6.3.1.2 升级指导与兼容性
- 📋 **官方升级指南**：https://react.dev/blog/2024/04/25/react-19-upgrade-guide
- 🔧 **迁移工具**：先升级到React 18.3过渡版本
- 🧪 **特性开关**：生产环境逐步启用新特性
- ⚠️ **依赖检查**：确保第三方库React 19兼容性
#### 6.3.2 进程间通信机制（IPC安全设计）
#### 6.3.3 双引擎协同策略
### 6.4 开发环境配置

### 6.5 **第6章测试执行清单**
#### 6.5.1 本章测试映射
- **单元测试**：架构组件单元测试、技术栈集成模块测试
- **集成测试**：React+Phaser集成测试、IPC通信协议测试
- **E2E测试**：完整架构下的端到端功能验证

#### 6.5.2 本章冒烟断言
```typescript
describe('系统架构冒烟测试', () => {
  it('React 19应能正常渲染', async () => {
    const { render } = await import('react-testing-library')
    const component = render(<TestComponent />)
    expect(component.getByTestId('react-19-feature')).toBeTruthy()
  })
  
  it('Phaser引擎应能正常初始化', async () => {
    const game = new Phaser.Game(testConfig)
    await game.scene.start('TestScene')
    expect(game.isRunning).toBe(true)
  })
})
```

#### 6.5.3 覆盖率与门禁引用
- 架构组件覆盖率：依照 **3.3.2条** 基线标准
- 集成测试门禁：依照 **3.3.1条** PR合并要求

## 7. 事件架构与管理（通信基础）
### 7.1 事件总线设计
#### 7.1.1 EventBus架构（类型安全）
#### 7.1.2 强类型事件定义（TypeScript）
#### 7.1.3 事件命名规范
#### 7.1.4 事件优先级机制

### 7.2 事件字典文档
#### 7.2.1 系统事件清单
#### 7.2.2 游戏事件清单
#### 7.2.3 UI事件清单
#### 7.2.4 AI事件清单

### 7.3 跨模块通信契约
#### 7.3.1 Electron ↔ React通信协议
#### 7.3.2 React ↔ Phaser通信机制
#### 7.3.3 事件流控制
#### 7.3.4 契约版本管理

### 7.4 事件调试工具
#### 7.4.1 事件追踪面板
#### 7.4.2 事件性能分析
#### 7.4.3 事件异常处理
#### 7.4.4 实时事件监控

### 7.5 **第7章测试执行清单**
#### 7.5.1 本章测试映射
- **单元测试**：事件总线核心逻辑、事件类型定义、优先级算法
- **集成测试**：跨模块事件通信、契约版本兼容性
- **E2E测试**：完整事件流（发送→处理→响应）端到端验证

#### 7.5.2 本章冒烟断言
```typescript
describe('事件架构冒烟测试', () => {
  it('事件总线应能正常发送和接收', async () => {
    const eventBus = new EventBus()
    let received = false
    
    eventBus.on('test:event', () => { received = true })
    eventBus.emit('test:event')
    
    expect(received).toBe(true)
  })
  
  it('强类型事件应能正确验证', async () => {
    const invalidEvent = { type: 'invalid', payload: 'wrong' }
    expect(() => validateEvent(invalidEvent)).toThrow()
  })
})
```

#### 7.5.3 覆盖率与门禁引用
- 事件系统覆盖率：依照 **3.3.2条** 基线要求
- 通信协议测试：依照 **3.1.3条** Electron特定测试策略

---

## 🛠️ **第三阶段：前端基础（第5-6周）**

## 8. 前端架构设计
### 8.1 Electron 主进程架构
#### 8.1.1 窗口管理（安全窗口配置）
#### 8.1.2 菜单系统
#### 8.1.3 文件系统访问（受限权限）
#### 8.1.4 系统集成（安全边界）

### 8.2 React 19 渲染进程架构
#### 8.2.1 应用结构设计
##### 8.2.1.1 React 19 应用架构模式
- **函数式组件优先**：全面使用React 19函数式组件+Hooks
- **自动优化机制**：React Compiler自动处理性能优化
- **并发安全渲染**：确保组件在并发模式下正确工作
- **新状态管理**：利用Actions API简化异步状态处理

##### 8.2.1.2 组件开发约束（AI代码生成规范）
- 🚫 **禁用模式**：class组件、手动memo、componentDidUpdate
- ✅ **推荐模式**：useCallback自动优化、Suspense边界、Error boundaries
- 🔧 **迁移策略**：逐步替换旧模式组件
- 📋 **类型安全**：TypeScript严格模式，React 19类型定义
#### 8.2.2 组件设计规范（函数式组件）
#### 8.2.3 状态管理方案（Zustand）
#### 8.2.4 路由设计

### 8.3 Phaser 3 游戏引擎集成
#### 8.3.1 场景管理架构
#### 8.3.2 游戏对象体系
#### 8.3.3 物理引擎配置
#### 8.3.4 资源加载策略

### 8.4 UI与游戏引擎交互
#### 8.4.1 React-Phaser 通信机制
#### 8.4.2 数据同步方案
#### 8.4.3 性能优化策略
#### 8.4.4 内存管理

### 8.5 **第8章测试执行清单**
#### 8.5.1 本章测试映射
- **单元测试**：React组件单元测试、Phaser场景单元测试、UI交互逻辑
- **集成测试**：React-Phaser集成测试、状态管理集成验证
- **E2E测试**：前端完整用户交互流程测试

#### 8.5.2 本章冒烟断言
```typescript
describe('前端架构冒烟测试', () => {
  it('主窗口应能正常创建和显示', async () => {
    const window = await createMainWindow()
    expect(window.isVisible()).toBe(true)
    expect(window.webContents.isLoading()).toBe(false)
  })
  
  it('React组件应能正常渲染到Electron', async () => {
    const { findByTestId } = render(<App />)
    const mainComponent = await findByTestId('main-app')
    expect(mainComponent).toBeTruthy()
  })
})
```

#### 8.5.3 覆盖率与门禁引用
- React组件覆盖率：依照 **3.3.2条** 基线标准
- UI交互测试：依照 **3.1.2条** 集成测试定义

---

## 🎮 **第四阶段：游戏核心开发（第7-12周）**

## 9. 游戏核心系统
### 9.1 游戏循环设计
#### 9.1.1 主循环架构
#### 9.1.2 时间管理系统
#### 9.1.3 帧率控制
#### 9.1.4 暂停/恢复机制

### 9.2 资源管理系统（增强版）
#### 9.2.1 资源加载器设计
#### 9.2.2 美术资源组织结构
#### 9.2.3 音频引擎集成（Web Audio API）
#### 9.2.4 资源缓存策略
#### 9.2.5 内存管理与优化

### 9.3 输入处理系统
#### 9.3.1 键盘事件处理
#### 9.3.2 鼠标/触摸事件
#### 9.3.3 输入映射配置
#### 9.3.4 输入状态管理

### 9.4 **第9章测试执行清单**
#### 9.4.1 本章测试映射
- **单元测试**：游戏循环核心算法、资源管理器、输入处理器
- **集成测试**：游戏系统与引擎集成、资源加载与缓存集成
- **E2E测试**：完整游戏会话（启动→加载→运行→退出）

#### 9.4.2 本章冒烟断言
```typescript
describe('游戏核心系统冒烟测试', () => {
  it('游戏循环应能稳定运行60fps', async () => {
    const game = await startTestGame()
    const fps = await measureFPS(1000) // 测试1秒
    expect(fps).toBeCloseTo(60, 5)
  })
  
  it('资源应能正常加载和缓存', async () => {
    const loader = new ResourceLoader()
    const texture = await loader.load('test-texture.png')
    expect(texture.loaded).toBe(true)
    expect(loader.cache.has('test-texture.png')).toBe(true)
  })
})
```

#### 9.4.3 覆盖率与门禁引用
- 游戏核心逻辑覆盖率：依照 **3.3.2条** 基线要求
- 性能基线验证：依照 **3.4.3条** 性能监控基线

## 10. 业务逻辑架构
### 10.1 游戏数据模型
#### 10.1.1 公会实体设计
#### 10.1.2 成员属性系统
#### 10.1.3 任务系统模型
#### 10.1.4 经济系统设计

### 10.2 游戏逻辑层
#### 10.2.1 业务规则引擎
#### 10.2.2 事件驱动架构
#### 10.2.3 状态机设计
#### 10.2.4 数据校验机制

### 10.3 数据持久化
#### 10.3.1 SQLite本地存储方案
#### 10.3.2 存档系统设计
#### 10.3.3 数据版本控制
#### 10.3.4 存档迁移策略

### 10.4 **第10章测试执行清单**
#### 10.4.1 本章测试映射
- **单元测试**：业务规则引擎、数据模型验证、存档系统逻辑
- **集成测试**：业务逻辑与数据层集成、状态机流转验证
- **E2E测试**：完整业务流程（创建公会→招募成员→执行任务→保存存档）

#### 10.4.2 本章冒烟断言
```typescript
describe('业务逻辑架构冒烟测试', () => {
  it('公会应能正常创建和初始化', async () => {
    const guild = await createGuild({ name: 'Test Guild' })
    expect(guild.id).toBeTruthy()
    expect(guild.members.length).toBe(0)
    expect(guild.treasury).toBe(1000) // 初始资金
  })
  
  it('存档应能正常保存和加载', async () => {
    const originalData = await generateTestSaveData()
    await savegame.save('test-slot', originalData)
    const loadedData = await savegame.load('test-slot')
    expect(loadedData).toEqual(originalData)
  })
})
```

#### 10.4.3 覆盖率与门禁引用
- 业务逻辑覆盖率：依照 **3.3.2条** 基线标准
- 数据完整性测试：依照 **3.3.2条** critical_modules.data_integrity要求

## 11. AI行为引擎架构（核心复杂度）
### 11.1 AI架构总体设计
#### 11.1.1 三层AI架构概述
#### 11.1.2 FSM与行为树协同机制
#### 11.1.3 决策优先级系统
#### 11.1.4 AI性能优化策略

### 11.2 有限状态机(FSM)设计
#### 11.2.1 状态定义与转换规则
#### 11.2.2 宏观状态控制（日常行为）
#### 11.2.3 状态持久化与恢复
#### 11.2.4 状态调试工具

### 11.3 行为树(BT)系统
#### 11.3.1 行为树节点设计
#### 11.3.2 复杂决策序列（战斗、谈判）
#### 11.3.3 条件评估与动作执行
#### 11.3.4 行为树可视化编辑器

### 11.4 AI人格与关系系统
#### 11.4.1 人格模板定义
#### 11.4.2 关系网络影响机制
#### 11.4.3 情绪系统与触发器
#### 11.4.4 人格演化与成长

### 11.5 AI场景与事件系统
#### 11.5.1 具体场景实例
#### 11.5.2 事件触发概率算法
#### 11.5.3 事件链与连锁反应
#### 11.5.4 AI决策日志系统

### 11.6 **第11章测试执行清单**
#### 11.6.1 本章测试映射
- **单元测试**：FSM状态转换逻辑、行为树节点算法、人格特征计算
- **集成测试**：AI各子系统协作、决策引擎集成验证
- **E2E测试**：AI在复杂场景下的完整决策流程
- **专项测试**：AI性能压力测试、决策质量评估

#### 11.6.2 本章冒烟断言
```typescript
describe('AI行为引擎冒烟测试', () => {
  it('FSM应能正确处理状态转换', async () => {
    const ai = new AIEntity({ personality: 'friendly' })
    ai.fsm.setState('idle')
    ai.fsm.handleEvent('player_approach')
    expect(ai.fsm.currentState).toBe('greeting')
  })
  
  it('行为树应能执行基础决策序列', async () => {
    const behaviorTree = new BehaviorTree(greetingSequence)
    const result = await behaviorTree.execute(testContext)
    expect(result.status).toBe('SUCCESS')
    expect(result.actions).toContain('say_hello')
  })
  
  it('AI决策应在合理时间内完成', async () => {
    const startTime = Date.now()
    const decision = await ai.makeDecision(complexScenario)
    const duration = Date.now() - startTime
    expect(duration).toBeLessThan(100) // 100ms内完成决策
    expect(decision).toBeTruthy()
  })
})
```

#### 11.6.3 覆盖率与门禁引用
- AI核心算法覆盖率：依照 **3.3.2条** critical_modules.ai_engine要求(85%)
- AI性能测试：依照 **3.4.3条** 性能监控基线
- AI行为验证：依照 **3.3.3条** 主干分支AI行为回归测试

---

## 💾 **第五阶段：数据与持久化（第13-15周）**

## 12. 数据库设计架构
### 12.1 SQLite数据库架构
#### 12.1.1 数据库选型和配置
#### 12.1.2 表结构设计
#### 12.1.3 索引优化策略
#### 12.1.4 查询性能优化

### 12.2 数据模型设计
#### 12.2.1 游戏实体关系设计
#### 12.2.2 数据完整性约束
#### 12.2.3 数据版本控制
#### 12.2.4 迁移脚本管理

### 12.3 ORM与数据访问层
#### 12.3.1 TypeORM集成
#### 12.3.2 Repository模式
#### 12.3.3 事务管理
#### 12.3.4 连接池配置

### 12.4 **第12章测试执行清单**
#### 12.4.1 本章测试映射
- **单元测试**：数据模型验证、ORM映射逻辑、查询构建器
- **集成测试**：数据库连接、事务管理、迁移脚本验证
- **E2E测试**：完整数据流（写入→查询→更新→删除）
- **专项测试**：数据库性能测试、并发访问测试

#### 12.4.2 本章冒烟断言
```typescript
describe('数据库架构冒烟测试', () => {
  it('SQLite数据库应能正常连接', async () => {
    const connection = await createDBConnection()
    expect(connection.isConnected).toBe(true)
    await connection.close()
  })
  
  it('基础CRUD操作应能正常执行', async () => {
    const repo = getRepository(Guild)
    const guild = await repo.save({ name: 'Test Guild' })
    expect(guild.id).toBeTruthy()
    
    const found = await repo.findOne(guild.id)
    expect(found.name).toBe('Test Guild')
  })
})
```

#### 12.4.3 覆盖率与门禁引用
- 数据访问层覆盖率：依照 **3.3.2条** 基线标准
- 数据完整性测试：依照 **3.3.2条** critical_modules.data_integrity要求

---

## 🔒 **第六阶段：系统完善（第16-18周）**

## 13. 安全设计（完整版）
### 13.1 数据安全
#### 13.1.1 存档文件加密
#### 13.1.2 数据完整性校验
#### 13.1.3 防篡改机制
#### 13.1.4 敏感数据保护

### 13.2 代码安全
#### 13.2.1 代码混淆策略
#### 13.2.2 资源加密方案
#### 13.2.3 反调试机制
#### 13.2.4 源码保护

### 13.3 Electron安全深化
#### 13.3.1 高级安全配置
#### 13.3.2 运行时安全检查
#### 13.3.3 更新安全机制
#### 13.3.4 安全审计工具

### 13.4 插件沙箱安全
#### 13.4.1 权限管理系统
#### 13.4.2 API访问控制
#### 13.4.3 资源隔离机制
#### 13.4.4 恶意代码检测

### 13.5 **第13章测试执行清单**
#### 13.5.1 本章测试映射
- **单元测试**：加密算法验证、权限检查器、安全工具类
- **集成测试**：安全机制集成验证、权限系统集成测试
- **E2E测试**：完整安全防护流程验证
- **专项测试**：安全漏洞扫描、渗透测试、合规性检查

#### 13.5.2 本章冒烟断言
```typescript
describe('安全设计冒烟测试', () => {
  it('存档文件应被正确加密', async () => {
    const saveData = { guild: 'test', level: 10 }
    const encrypted = await encryptSaveFile(saveData)
    expect(encrypted.startsWith('ENC:')).toBe(true)
    
    const decrypted = await decryptSaveFile(encrypted)
    expect(decrypted).toEqual(saveData)
  })
  
  it('未授权API访问应被阻止', async () => {
    const result = await attemptUnauthorizedAccess()
    expect(result.success).toBe(false)
    expect(result.error).toContain('unauthorized')
  })
})
```

#### 13.5.3 覆盖率与门禁引用
- 安全模块覆盖率：依照 **3.3.2条** critical_modules.security要求(90%)
- 安全合规检查：依照 **3.3.4条** 发布门禁安全验证

## 14. 性能优化方案
### 14.1 前端性能优化
#### 14.1.1 React 19 渲染优化
#### 14.1.2 内存优化策略
#### 14.1.3 资源加载优化
#### 14.1.4 代码分割策略

### 14.2 游戏性能优化
#### 14.2.1 Phaser游戏循环优化
#### 14.2.2 对象池设计
#### 14.2.3 碰撞检测优化
#### 14.2.4 渲染批处理
#### 14.2.5 多线程渲染预研（ADR文档化，后期备选）
- **Offscreen渲染评估**：Electron Offscreen Canvas API可行性分析
- **多线程架构设计**：主线程UI + Worker线程游戏渲染分离
- **性能瓶颈触发条件**：帧率<30fps或内存>2GB时启用
- **参考实现**：Electron官方Offscreen渲染教程和最佳实践
- 🚧 **实施状态**：仅作为ADR预研，暂不开发实现

### 14.3 AI性能优化
#### 14.3.1 决策缓存机制
#### 14.3.2 Web Worker线程优化
#### 14.3.3 批量处理策略
#### 14.3.4 LOD（细节层次）系统

### 14.4 **第14章测试执行清单**
#### 14.4.1 本章测试映射
- **单元测试**：性能优化算法、缓存机制、对象池管理
- **集成测试**：优化后系统集成验证、性能回归测试
- **E2E测试**：优化后用户体验验证
- **专项测试**：性能基准测试、压力测试、内存泄漏测试

#### 14.4.2 本章冒烟断言
```typescript
describe('性能优化冒烟测试', () => {
  it('对象池应能有效复用对象', async () => {
    const pool = new ObjectPool(() => new GameEntity())
    const obj1 = pool.acquire()
    const initialSize = pool.size
    
    pool.release(obj1)
    const obj2 = pool.acquire()
    
    expect(obj1).toBe(obj2) // 同一对象被复用
    expect(pool.size).toBe(initialSize) // 池大小不变
  })
  
  it('渲染帧率应保持在目标值', async () => {
    const game = await startPerformanceTest()
    const fps = await measureFPS(3000) // 测试3秒
    expect(fps).toBeGreaterThanOrEqual(55) // 至少55fps
  })
})
```

#### 14.4.3 覆盖率与门禁引用
- 性能优化模块覆盖率：依照 **3.3.2条** 基线标准
- 性能回归检测：依照 **3.3.3条** 主干分支性能基线验证

---

## 🚀 **第七阶段：部署与集成（第19-21周）**

## 15. 部署与运维
### 15.1 构建流程设计
#### 15.1.1 Vite 构建配置
#### 15.1.2 Electron 打包优化
#### 15.1.3 多平台构建（Windows/macOS/Linux）
#### 15.1.4 CI/CD自动化构建

### 15.2 版本管理策略
#### 15.2.1 版本号规范（Semantic Versioning）
#### 15.2.2 更新策略（electron-updater）
#### 15.2.3 兼容性保证
#### 15.2.4 降级方案

### 15.3 发布流程
#### 15.3.1 代码签名（Windows/macOS）
#### 15.3.2 分发渠道
#### 15.3.3 自动更新机制
#### 15.3.4 灰度发布
#### 15.3.5 发布流程验收标准（避免最后关头失败）
##### 15.3.5.1 代码签名验收项
- ✅ **Windows代码签名**：Authenticode签名成功，信任链完整
- ✅ **macOS代码签名**：Developer ID Application证书有效
- ✅ **公证验证**：macOS公证流程通过，无安全警告
- 🧪 **签名测试**：各平台安装包签名验证通过

##### 15.3.5.2 自动更新流程验收
- ✅ **staging环境验证**：staging channel自动更新流程完整测试
- ✅ **增量更新测试**：版本间增量更新机制正常工作  
- ✅ **回滚机制验证**：更新失败自动回滚功能测试
- 📋 **参考文档**：electron-builder官方代码签名指引

### 15.4 **第15章测试执行清单**
#### 15.4.1 本章测试映射
- **单元测试**：构建脚本逻辑、版本管理工具、打包配置验证
- **集成测试**：CI/CD流程集成、多平台构建验证
- **E2E测试**：完整发布流程（构建→签名→分发→安装→更新）
- **专项测试**：兼容性测试、性能回归测试、安全验证

#### 15.4.2 本章冒烟断言
```typescript
describe('部署流程冒烟测试', () => {
  it('应能成功构建所有平台包', async () => {
    const builds = await buildAllPlatforms()
    expect(builds.windows.success).toBe(true)
    expect(builds.macos.success).toBe(true)
    expect(builds.linux.success).toBe(true)
  })
  
  it('构建包应通过签名验证', async () => {
    const signature = await verifySignature('dist/app-setup.exe')
    expect(signature.valid).toBe(true)
    expect(signature.trusted).toBe(true)
  })
})
```

#### 15.4.3 覆盖率与门禁引用
- 部署脚本覆盖率：依照 **3.3.2条** 基线要求
- 发布验收标准：依照 **3.3.4条** 发布门禁全部要求

## 16. API架构系列（网络扩展）
### 16.1 API架构基础与RESTful设计原则
### 16.2 API路由设计基础与智能匹配
### 16.3 API资源管理与生命周期
### 16.4 API数据格式与序列化
### 16.5 API安全与认证授权体系
### 16.6 API网关与流量管理
### 16.7 API版本管理与向后兼容
### 16.8 API监控与性能优化
### 16.9 API文档与开发者体验

### 16.10 **第16章测试执行清单**
#### 16.10.1 本章测试映射
- **单元测试**：API路由逻辑、认证授权算法、数据序列化器
- **集成测试**：API网关集成、认证系统集成验证
- **E2E测试**：完整API调用流程（认证→请求→响应→日志）
- **专项测试**：API性能测试、安全测试、负载测试

#### 16.10.2 本章冒烟断言
```typescript
describe('API架构冒烟测试', () => {
  it('API网关应能正常路由请求', async () => {
    const response = await apiClient.get('/api/guilds')
    expect(response.status).toBe(200)
    expect(response.data).toBeTruthy()
  })
  
  it('API认证应能正确验证token', async () => {
    const invalidResponse = await apiClient.get('/api/protected', {
      headers: { Authorization: 'Bearer invalid-token' }
    })
    expect(invalidResponse.status).toBe(401)
  })
})
```

#### 16.10.3 覆盖率与门禁引用
- API模块覆盖率：依照 **3.3.2条** 基线标准
- API安全测试：依照 **13章** 安全设计标准

---

## 🌍 **第八阶段：扩展功能（MVP后）**

## 17. 国际化支持（i18n）
### 17.1 i18n架构设计
#### 17.1.1 本地化框架选择（i18next）
#### 17.1.2 多语言资源组织
#### 17.1.3 动态语言切换机制
#### 17.1.4 回退语言策略

### 17.2 文本资源管理
#### 17.2.1 界面文案提取
#### 17.2.2 游戏剧情文本
#### 17.2.3 事件描述文本
#### 17.2.4 系统提示文本

### 17.3 本地化适配
#### 17.3.1 UI布局自适应
#### 17.3.2 字体系统管理
#### 17.3.3 日期/货币格式化
#### 17.3.4 文化内容适配

### 17.4 **第17章测试执行清单**
#### 17.4.1 本章测试映射
- **单元测试**：i18n工具类、语言切换逻辑、文本格式化器
- **集成测试**：多语言资源加载、UI适配集成验证
- **E2E测试**：完整多语言用户体验测试
- **专项测试**：字符集兼容性、文化适配验证

#### 17.4.2 本章冒烟断言
```typescript
describe('国际化支持冒烟测试', () => {
  it('应能正确加载语言资源', async () => {
    await i18n.changeLanguage('zh-CN')
    expect(i18n.t('common.hello')).toBe('你好')
    
    await i18n.changeLanguage('en-US')
    expect(i18n.t('common.hello')).toBe('Hello')
  })
  
  it('UI布局应能适配不同语言', async () => {
    const { render } = await import('react-testing-library')
    const { rerender } = render(<TestComponent />)
    
    await i18n.changeLanguage('zh-CN')
    rerender(<TestComponent />)
    // 验证中文布局正常
    
    await i18n.changeLanguage('en-US')  
    rerender(<TestComponent />)
    // 验证英文布局正常
  })
})
```

#### 17.4.3 覆盖率与门禁引用
- i18n模块覆盖率：依照 **3.3.2条** 基线标准
- 多语言测试：依照 **3.1.2条** 集成测试定义

## 18. 维护策略
### 18.1 代码维护
#### 18.1.1 技术债务管理
#### 18.1.2 重构策略
#### 18.1.3 依赖更新策略
#### 18.1.4 代码审查机制

### 18.2 文档维护
#### 18.2.1 文档更新流程
#### 18.2.2 事件字典同步
#### 18.2.3 API变更记录
#### 18.2.4 知识库管理

### 18.3 团队协作
#### 18.3.1 新人入职指南
#### 18.3.2 知识传递机制
#### 18.3.3 技术分享制度
#### 18.3.4 问题解决流程

### 18.4 **第18章测试执行清单**
#### 18.4.1 本章测试映射
- **单元测试**：代码质量检查工具、文档同步工具、知识库搜索
- **集成测试**：维护流程集成验证、团队协作工具集成
- **E2E测试**：完整维护流程验证
- **专项测试**：文档一致性检查、知识库准确性验证

#### 18.4.2 本章冒烟断言
```typescript
describe('维护策略冒烟测试', () => {
  it('技术债务检查应能识别问题代码', async () => {
    const issues = await runTechnicalDebtAnalysis()
    expect(issues.length).toBeGreaterThan(0)
    expect(issues[0]).toHaveProperty('severity')
    expect(issues[0]).toHaveProperty('location')
  })
  
  it('文档应与代码保持同步', async () => {
    const apiDocs = await loadApiDocumentation()
    const actualApi = await introspectApi()
    expect(apiDocs.endpoints.length).toBe(actualApi.endpoints.length)
  })
})
```

#### 18.4.3 覆盖率与门禁引用
- 维护工具覆盖率：依照 **3.3.2条** 基线标准
- 文档同步验证：依照 **4.3章** 文档规范要求

## 19. 风险评估与应对
### 19.1 技术风险
#### 19.1.1 架构复杂度风险
#### 19.1.2 性能瓶颈风险
#### 19.1.3 兼容性风险
#### 19.1.4 技术选型风险

### 19.2 项目风险
#### 19.2.1 进度风险
#### 19.2.2 质量风险
#### 19.2.3 资源风险
#### 19.2.4 变更风险

### 19.3 应对策略
#### 19.3.1 风险预防措施
#### 19.3.2 应急预案
#### 19.3.3 风险监控机制
#### 19.3.4 持续改进流程

### 19.4 **第19章测试执行清单**
#### 19.4.1 本章测试映射
- **单元测试**：风险评估算法、应对策略触发器、监控工具
- **集成测试**：风险监控系统集成、应急预案流程验证
- **E2E测试**：风险场景模拟与应对验证
- **专项测试**：故障注入测试、灾难恢复测试

#### 19.4.2 本章冒烟断言
```typescript
describe('风险评估冒烟测试', () => {
  it('风险监控应能检测异常指标', async () => {
    const monitor = new RiskMonitor()
    await monitor.start()
    
    // 模拟异常情况
    await simulatePerformanceDegradation()
    
    const alerts = await monitor.getAlerts()
    expect(alerts.length).toBeGreaterThan(0)
    expect(alerts[0].severity).toBe('high')
  })
  
  it('应急预案应能正确触发', async () => {
    const contingencyPlan = new ContingencyPlan()
    const result = await contingencyPlan.execute('performance_critical')
    expect(result.success).toBe(true)
    expect(result.actions).toContain('scale_resources')
  })
})
```

#### 19.4.3 覆盖率与门禁引用
- 风险管理模块覆盖率：依照 **3.3.2条** 基线标准
- 应急预案测试：依照 **3.1.4条** 专项测试要求

---

## 附录

### A. 术语表
### B. 技术决策记录（ADR）
### C. 接口文档链接
### D. 工具与资源列表
### E. 参考资料

---

## 🎯 **AI代码生成导向的实施计划**

### **第1-2周（基础设施锁定）**
- ✅ 调试监控环境（Playwright + Sentry）
- ✅ **核心护栏前置部署**：
  - Playwright Electron冒烟模板（启动→主窗口→事件→断言）
  - Sentry Event Loop Block检测（主/渲染进程ANR预警）
- ✅ 测试策略法规确立（第3章4分节体系）
- ✅ Electron安全基线锁定（不可回退地基）

### **第3-6周（可运行基础）**
- ✅ 事件系统建立（类型安全通信）+ 就地验证清单
- ✅ React+Phaser基础框架 + 就地验证清单
- 🎯 **里程碑**：基础框架可运行并通过所有就地冒烟测试

### **第7-15周（核心功能）**
- ✅ 游戏核心系统 + 就地验证清单
- ✅ 业务逻辑完整 + 就地验证清单
- ✅ AI引擎实现 + 就地验证清单
- ✅ 数据持久化 + 就地验证清单
- 🎯 **里程碑**：完整游戏玩法可运行并通过全部就地测试

### **第16-24周（系统完善）**
- ✅ 安全加固 + 就地验证清单
- ✅ 性能优化 + 就地验证清单
- ✅ 部署打包 + 就地验证清单
- 🎯 **里程碑**：MVP交付就绪，通过全部质量门禁

### **⚡ 关键成功因素**
1. **第1-2周决定后续6个月质量**：调试工具、测试法规、安全配置、核心护栏不可回退
2. **每章都有可运行验证**：AI生成代码后立即用就地断言验证，短反馈循环
3. **严格遵循测试金字塔**：70%单元+20%集成+10%E2E，确保AI生成代码质量
4. **策略集中+执行分散**：统一标准避免漂移，就地验证减少认知负担

### **🚨 风险控制**
1. **测试法规优先建立**：第3章作为不可变更的质量"宪法"
2. **护栏前置部署**：Playwright+Sentry在第1-2周就生效
3. **就地验证强制执行**：每章测试清单必须100%通过才能进入下一章
4. **质量门禁红线**：PR/主干/发布三级门禁绝不妥协
5. **标准统一引用**：所有章节通过条款编号引用第3章法规，避免标准冲突

### **🎨 混合方案优势**
1. **策略一致性**：第3章统一制定标准，避免各章节标准漂移
2. **执行即时性**：每章就地验证，AI生成后立即反馈
3. **认知负担最小**：无需跨文档查找，本章内即有完整执行指南
4. **质量可追溯**：通过条款编号清晰追溯到统一标准
5. **AI友好设计**：最大化Claude Code按章节生成+即时验证的工作模式