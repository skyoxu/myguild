# 《公会经理》技术架构文档（AI代码生成优化版）

## 1. 项目概述

### 1.1 项目背景与目标

### 1.2 架构设计原则与理念

### 1.3 技术栈选型说明

### 1.4 开发阶段规划（MVP优先）

---

## 📋 **第一阶段：基础设施锁定（第1-2周）** 🚨 **AI代码生成必备**

## 2. 调试与监控系统（基础设施优先）

### 2.1 开发调试工具

#### 2.1.1 Playwright (Electron) E2E测试环境

#### 2.1.2 Sentry (Electron) 错误监控集成

##### 2.1.2.1 Releases & Health 追踪配置

- 版本发布关联：每次构建自动创建Release记录
- 健康度监控：Session健康状态实时追踪
- 部署追踪：版本部署状态和回滚监控
- 用户影响评估：版本质量和稳定性分析

##### 2.1.2.2 采样率配置策略

- 错误采样率：100%（生产环境全量错误收集）
- 性能采样率：10%（避免过度性能数据收集）
- 调试采样率：50%（开发环境适中采样）
- 动态采样：基于错误频率自动调整

##### 2.1.2.3 Event Loop Block Detection（Electron专用）

- 主进程监控：threshold 500ms，检测主线程阻塞
- 渲染进程ANR：captureStackTrace启用，5秒阈值
- 配置示例：@sentry/electron + @sentry/node-native集成
- 监控范围：覆盖Phaser游戏循环和React渲染

#### 2.1.3 开发者工具集成 (DevTools Extensions)

#### 2.1.4 热重载与实时调试

### 2.2 日志系统

#### 2.2.1 分级日志架构

#### 2.2.2 日志收集策略

#### 2.2.3 日志持久化方案 (logs/ 目录)

#### 2.2.4 日志分析工具

### 2.3 监控面板

#### 2.3.1 实时性能监控

#### 2.3.2 内存泄漏检测

#### 2.3.3 事件流可视化 (开发期必需)

#### 2.3.4 AI状态监控面板

### 2.4 诊断工具

#### 2.4.1 崩溃报告系统

#### 2.4.2 性能采样工具

#### 2.4.3 用户行为追踪

#### 2.4.4 自动化测试报告

## 3. 测试策略与质量保证（集中化TDD基础）

### 3.1 测试金字塔架构

#### 3.1.1 单元测试层（Jest + TypeScript）

- 测试覆盖率要求：>90%
- 测试驱动开发流程（TDD）
- 快速反馈机制（<2秒执行）
- Mock策略与依赖隔离

#### 3.1.2 集成测试层（React Testing Library）

- 组件协作测试
- 状态管理集成验证
- API契约测试
- 数据流完整性测试

#### 3.1.3 端到端测试层（Playwright for Electron）

##### 3.1.3.1 冒烟用例模板（第1-2周必须完成）

- **基础冒烟流程**：应用启动 → 主窗口加载 → 事件触发 → UI/日志断言
- **测试覆盖范围**：Electron安全配置、React组件渲染、Phaser场景初始化
- **CI集成要求**：每次commit自动执行，失败阻止合并
- **参考实现**：基于Playwright Electron官方示例改造

##### 3.1.3.2 Electron特定测试场景

- 主进程-渲染进程IPC通信测试
- 窗口生命周期管理测试
- 安全策略验证（CSP、contextIsolation）
- 文件系统访问权限测试

#### 3.1.4 游戏逻辑测试（Phaser Test Utils）

- 场景切换测试
- 游戏对象生命周期验证
- 物理引擎行为测试
- AI决策逻辑验证

### 3.2 性能测试体系

#### 3.2.1 前端性能监控

- React 19渲染性能测试
- 内存泄漏检测与预防
- 资源加载优化验证
- 代码分割效果测试

#### 3.2.2 游戏性能测试

- Phaser游戏循环性能测试
- 帧率稳定性测试
- 碰撞检测性能验证
- 大规模对象管理测试

#### 3.2.3 AI性能测试

- 决策算法性能基准测试
- Web Worker多线程性能验证
- 批量处理效率测试
- 内存使用优化验证

### 3.3 安全测试框架

#### 3.3.1 Electron安全测试

- 进程隔离验证测试
- CSP策略遵循测试
- IPC通信安全验证
- 代码注入防护测试

#### 3.3.2 数据安全测试

- 存档文件加密验证
- 数据完整性校验测试
- 敏感数据保护测试
- 防篡改机制验证

#### 3.3.3 代码安全测试

- 依赖漏洞扫描
- 源码保护验证
- 反调试机制测试
- 运行时安全检查

### 3.4 AI行为测试策略

#### 3.4.1 决策验证测试

- FSM状态转换正确性验证
- 行为树执行路径测试
- 决策边界条件测试
- 人格影响因子验证

#### 3.4.2 AI系统集成测试

- 多AI实体交互测试
- 关系网络影响验证
- 情绪系统触发测试
- 场景感知能力测试

#### 3.4.3 AI性能压力测试

- 大量AI实体并发处理
- 复杂决策场景压力测试
- 内存使用监控
- CPU占用优化验证

### 3.5 测试自动化与CI/CD

#### 3.5.1 GitHub Actions配置

- 自动化测试管道
- 多平台测试矩阵
- 代码覆盖率报告
- 性能回归检测

#### 3.5.2 测试报告与分析

- 统一测试报告格式
- 趋势分析与预警
- 测试结果可视化
- 质量指标追踪

#### 3.5.3 测试数据管理

- 测试数据生成策略
- 测试环境数据隔离
- 测试场景数据版本控制
- 性能基准数据管理

### 3.6 代码质量保证

#### 3.6.1 静态代码分析

- ESLint规则配置
- TypeScript严格模式
- 代码复杂度监控
- 技术债务追踪

#### 3.6.2 代码审查流程

- Pull Request检查清单
- 自动化代码审查工具
- 安全审查要求
- 性能影响评估

## 4. 开发规范与最佳实践（代码生成标准）

### 4.1 代码规范

#### 4.1.1 TypeScript 编码规范（严格模式）

#### 4.1.2 React 组件规范（函数式 + Hooks）

#### 4.1.3 Phaser 开发规范（Scene架构）

#### 4.1.4 事件命名规范（强类型）

### 4.2 架构规范

#### 4.2.1 模块划分原则（SOLID原则）

#### 4.2.2 依赖管理规范（ESM模块）

#### 4.2.3 接口设计原则（契约优先）

#### 4.2.4 错误处理规范（统一异常）

### 4.3 文档规范

#### 4.3.1 代码注释规范（TSDoc）

#### 4.3.2 API文档规范

#### 4.3.3 架构文档维护

#### 4.3.4 变更记录要求

### 4.4 AI代码生成约束

#### 4.4.1 代码一致性保证

#### 4.4.2 命名规范统一

#### 4.4.3 架构模式固定

#### 4.4.4 重构安全策略

## 5. Electron安全基线与构建工具链（不可回退基座）

### 5.1 Electron安全配置

#### 5.1.1 进程隔离策略（contextIsolation: true）

#### 5.1.2 Node集成禁用（nodeIntegration: false）

#### 5.1.3 预加载脚本安全（安全API桥接）

#### 5.1.4 远程内容限制（webSecurity: true）

### 5.2 CSP策略配置

#### 5.2.1 内容安全策略定义

#### 5.2.2 脚本源控制

#### 5.2.3 样式源限制

#### 5.2.4 资源加载控制

### 5.3 构建工具链

#### 5.3.1 electron-vite 配置（HMR + 构建优化）

#### 5.3.2 electron-builder 配置（多平台打包）

#### 5.3.3 代码签名策略

#### 5.3.4 自动更新安全机制

---

## 🏗️ **第二阶段：架构基础建立（第3-4周）**

## 6. 系统总体架构

### 6.1 架构概览图

### 6.2 模块职责划分

### 6.3 技术栈集成方案

#### 6.3.1 Electron + React 19 + Phaser 3 集成架构

##### 6.3.1.1 React 19 特性配置清单（AI代码生成必读）

- ✅ **React Compiler**：启用自动优化，无需手动memoization
- ✅ **新JSX Transform**：mandatory requirement，旧语法不兼容
- ⚠️ **Concurrent Rendering**：默认启用，检查render副作用
- ✅ **Actions API**：异步状态管理，pending/error自动处理
- ⚠️ **Breaking Changes**：useReducer类型参数变更，ref转发规则更严格

##### 6.3.1.2 升级指导与兼容性

- 📋 **官方升级指南**：https://react.dev/blog/2024/04/25/react-19-upgrade-guide
- 🔧 **迁移工具**：先升级到React 18.3过渡版本
- 🧪 **特性开关**：生产环境逐步启用新特性
- ⚠️ **依赖检查**：确保第三方库React 19兼容性

#### 6.3.2 进程间通信机制（IPC安全设计）

#### 6.3.3 双引擎协同策略

### 6.4 开发环境配置

## 7. 事件架构与管理（通信基础）

### 7.1 事件总线设计

#### 7.1.1 EventBus架构（类型安全）

#### 7.1.2 强类型事件定义（TypeScript）

#### 7.1.3 事件命名规范

#### 7.1.4 事件优先级机制

### 7.2 事件字典文档

#### 7.2.1 系统事件清单

#### 7.2.2 游戏事件清单

#### 7.2.3 UI事件清单

#### 7.2.4 AI事件清单

### 7.3 跨模块通信契约

#### 7.3.1 Electron ↔ React通信协议

#### 7.3.2 React ↔ Phaser通信机制

#### 7.3.3 事件流控制

#### 7.3.4 契约版本管理

### 7.4 事件调试工具

#### 7.4.1 事件追踪面板

#### 7.4.2 事件性能分析

#### 7.4.3 事件异常处理

#### 7.4.4 实时事件监控

---

## 🛠️ **第三阶段：前端基础（第5-6周）**

## 8. 前端架构设计

### 8.1 Electron 主进程架构

#### 8.1.1 窗口管理（安全窗口配置）

#### 8.1.2 菜单系统

#### 8.1.3 文件系统访问（受限权限）

#### 8.1.4 系统集成（安全边界）

### 8.2 React 19 渲染进程架构

#### 8.2.1 应用结构设计

##### 8.2.1.1 React 19 应用架构模式

- **函数式组件优先**：全面使用React 19函数式组件+Hooks
- **自动优化机制**：React Compiler自动处理性能优化
- **并发安全渲染**：确保组件在并发模式下正确工作
- **新状态管理**：利用Actions API简化异步状态处理

##### 8.2.1.2 组件开发约束（AI代码生成规范）

- 🚫 **禁用模式**：class组件、手动memo、componentDidUpdate
- ✅ **推荐模式**：useCallback自动优化、Suspense边界、Error boundaries
- 🔧 **迁移策略**：逐步替换旧模式组件
- 📋 **类型安全**：TypeScript严格模式，React 19类型定义

#### 8.2.2 组件设计规范（函数式组件）

#### 8.2.3 状态管理方案（Zustand）

#### 8.2.4 路由设计

### 8.3 Phaser 3 游戏引擎集成

#### 8.3.1 场景管理架构

#### 8.3.2 游戏对象体系

#### 8.3.3 物理引擎配置

#### 8.3.4 资源加载策略

### 8.4 UI与游戏引擎交互

#### 8.4.1 React-Phaser 通信机制

#### 8.4.2 数据同步方案

#### 8.4.3 性能优化策略

#### 8.4.4 内存管理

---

## 🎮 **第四阶段：游戏核心开发（第7-12周）**

## 9. 游戏核心系统

### 9.1 游戏循环设计

#### 9.1.1 主循环架构

#### 9.1.2 时间管理系统

#### 9.1.3 帧率控制

#### 9.1.4 暂停/恢复机制

### 9.2 资源管理系统（增强版）

#### 9.2.1 资源加载器设计

#### 9.2.2 美术资源组织结构

#### 9.2.3 音频引擎集成（Web Audio API）

#### 9.2.4 资源缓存策略

#### 9.2.5 内存管理与优化

### 9.3 输入处理系统

#### 9.3.1 键盘事件处理

#### 9.3.2 鼠标/触摸事件

#### 9.3.3 输入映射配置

#### 9.3.4 输入状态管理

## 10. 业务逻辑架构

### 10.1 游戏数据模型

#### 10.1.1 公会实体设计

#### 10.1.2 成员属性系统

#### 10.1.3 任务系统模型

#### 10.1.4 经济系统设计

### 10.2 游戏逻辑层

#### 10.2.1 业务规则引擎

#### 10.2.2 事件驱动架构

#### 10.2.3 状态机设计

#### 10.2.4 数据校验机制

### 10.3 数据持久化

#### 10.3.1 SQLite本地存储方案

#### 10.3.2 存档系统设计

#### 10.3.3 数据版本控制

#### 10.3.4 存档迁移策略

## 11. AI行为引擎架构（核心复杂度）

### 11.1 AI架构总体设计

#### 11.1.1 三层AI架构概述

#### 11.1.2 FSM与行为树协同机制

#### 11.1.3 决策优先级系统

#### 11.1.4 AI性能优化策略

### 11.2 有限状态机(FSM)设计

#### 11.2.1 状态定义与转换规则

#### 11.2.2 宏观状态控制（日常行为）

#### 11.2.3 状态持久化与恢复

#### 11.2.4 状态调试工具

### 11.3 行为树(BT)系统

#### 11.3.1 行为树节点设计

#### 11.3.2 复杂决策序列（战斗、谈判）

#### 11.3.3 条件评估与动作执行

#### 11.3.4 行为树可视化编辑器

### 11.4 AI人格与关系系统

#### 11.4.1 人格模板定义

#### 11.4.2 关系网络影响机制

#### 11.4.3 情绪系统与触发器

#### 11.4.4 人格演化与成长

### 11.5 AI场景与事件系统

#### 11.5.1 具体场景实例

#### 11.5.2 事件触发概率算法

#### 11.5.3 事件链与连锁反应

#### 11.5.4 AI决策日志系统

---

## 💾 **第五阶段：数据与持久化（第13-15周）**

## 12. 数据库设计架构

### 12.1 SQLite数据库架构

#### 12.1.1 数据库选型和配置

#### 12.1.2 表结构设计

#### 12.1.3 索引优化策略

#### 12.1.4 查询性能优化

### 12.2 数据模型设计

#### 12.2.1 游戏实体关系设计

#### 12.2.2 数据完整性约束

#### 12.2.3 数据版本控制

#### 12.2.4 迁移脚本管理

### 12.3 ORM与数据访问层

#### 12.3.1 TypeORM集成

#### 12.3.2 Repository模式

#### 12.3.3 事务管理

#### 12.3.4 连接池配置

---

## 🔒 **第六阶段：系统完善（第16-18周）**

## 13. 安全设计（完整版）

### 13.1 数据安全

#### 13.1.1 存档文件加密

#### 13.1.2 数据完整性校验

#### 13.1.3 防篡改机制

#### 13.1.4 敏感数据保护

### 13.2 代码安全

#### 13.2.1 代码混淆策略

#### 13.2.2 资源加密方案

#### 13.2.3 反调试机制

#### 13.2.4 源码保护

### 13.3 Electron安全深化

#### 13.3.1 高级安全配置

#### 13.3.2 运行时安全检查

#### 13.3.3 更新安全机制

#### 13.3.4 安全审计工具

### 13.4 插件沙箱安全

#### 13.4.1 权限管理系统

#### 13.4.2 API访问控制

#### 13.4.3 资源隔离机制

#### 13.4.4 恶意代码检测

## 14. 性能优化方案

### 14.1 前端性能优化

#### 14.1.1 React 19 渲染优化

#### 14.1.2 内存优化策略

#### 14.1.3 资源加载优化

#### 14.1.4 代码分割策略

### 14.2 游戏性能优化

#### 14.2.1 Phaser游戏循环优化

#### 14.2.2 对象池设计

#### 14.2.3 碰撞检测优化

#### 14.2.4 渲染批处理

#### 14.2.5 多线程渲染预研（ADR文档化，后期备选）

- **Offscreen渲染评估**：Electron Offscreen Canvas API可行性分析
- **多线程架构设计**：主线程UI + Worker线程游戏渲染分离
- **性能瓶颈触发条件**：帧率<30fps或内存>2GB时启用
- **参考实现**：Electron官方Offscreen渲染教程和最佳实践
- 🚧 **实施状态**：仅作为ADR预研，暂不开发实现

### 14.3 AI性能优化

#### 14.3.1 决策缓存机制

#### 14.3.2 Web Worker线程优化

#### 14.3.3 批量处理策略

#### 14.3.4 LOD（细节层次）系统

---

## 🚀 **第七阶段：部署与集成（第19-21周）**

## 15. 部署与运维

### 15.1 构建流程设计

#### 15.1.1 Vite 构建配置

#### 15.1.2 Electron 打包优化

#### 15.1.3 多平台构建（Windows/macOS/Linux）

#### 15.1.4 CI/CD自动化构建

### 15.2 版本管理策略

#### 15.2.1 版本号规范（Semantic Versioning）

#### 15.2.2 更新策略（electron-updater）

#### 15.2.3 兼容性保证

#### 15.2.4 降级方案

### 15.3 发布流程

#### 15.3.1 代码签名（Windows/macOS）

#### 15.3.2 分发渠道

#### 15.3.3 自动更新机制

#### 15.3.4 灰度发布

#### 15.3.5 发布流程验收标准（避免最后关头失败）

##### 15.3.5.1 代码签名验收项

- ✅ **Windows代码签名**：Authenticode签名成功，信任链完整
- ✅ **macOS代码签名**：Developer ID Application证书有效
- ✅ **公证验证**：macOS公证流程通过，无安全警告
- 🧪 **签名测试**：各平台安装包签名验证通过

##### 15.3.5.2 自动更新流程验收

- ✅ **staging环境验证**：staging channel自动更新流程完整测试
- ✅ **增量更新测试**：版本间增量更新机制正常工作
- ✅ **回滚机制验证**：更新失败自动回滚功能测试
- 📋 **参考文档**：electron-builder官方代码签名指引

## 16. API架构系列（网络扩展）

### 16.1 API架构基础与RESTful设计原则

### 16.2 API路由设计基础与智能匹配

### 16.3 API资源管理与生命周期

### 16.4 API数据格式与序列化

### 16.5 API安全与认证授权体系

### 16.6 API网关与流量管理

### 16.7 API版本管理与向后兼容

### 16.8 API监控与性能优化

### 16.9 API文档与开发者体验

---

## 🌍 **第八阶段：扩展功能（MVP后）**

## 17. 国际化支持（i18n）

### 17.1 i18n架构设计

#### 17.1.1 本地化框架选择（i18next）

#### 17.1.2 多语言资源组织

#### 17.1.3 动态语言切换机制

#### 17.1.4 回退语言策略

### 17.2 文本资源管理

#### 17.2.1 界面文案提取

#### 17.2.2 游戏剧情文本

#### 17.2.3 事件描述文本

#### 17.2.4 系统提示文本

### 17.3 本地化适配

#### 17.3.1 UI布局自适应

#### 17.3.2 字体系统管理

#### 17.3.3 日期/货币格式化

#### 17.3.4 文化内容适配

## 18. 维护策略

### 18.1 代码维护

#### 18.1.1 技术债务管理

#### 18.1.2 重构策略

#### 18.1.3 依赖更新策略

#### 18.1.4 代码审查机制

### 18.2 文档维护

#### 18.2.1 文档更新流程

#### 18.2.2 事件字典同步

#### 18.2.3 API变更记录

#### 18.2.4 知识库管理

### 18.3 团队协作

#### 18.3.1 新人入职指南

#### 18.3.2 知识传递机制

#### 18.3.3 技术分享制度

#### 18.3.4 问题解决流程

## 19. 风险评估与应对

### 19.1 技术风险

#### 19.1.1 架构复杂度风险

#### 19.1.2 性能瓶颈风险

#### 19.1.3 兼容性风险

#### 19.1.4 技术选型风险

### 19.2 项目风险

#### 19.2.1 进度风险

#### 19.2.2 质量风险

#### 19.2.3 资源风险

#### 19.2.4 变更风险

### 19.3 应对策略

#### 19.3.1 风险预防措施

#### 19.3.2 应急预案

#### 19.3.3 风险监控机制

#### 19.3.4 持续改进流程

---

## 附录

### A. 术语表

### B. 技术决策记录（ADR）

### C. 接口文档链接

### D. 工具与资源列表

### E. 参考资料

---

## 🎯 **AI代码生成导向的实施计划**

### **第1-2周（基础设施锁定）**

- ✅ 调试监控环境（Playwright + Sentry）
- ✅ 集中化TDD测试环境（Jest + Testing Library + 完整测试策略）
- ✅ 开发规范确定（TypeScript严格模式）
- ✅ Electron安全基线锁定（不可回退）

### **第3-6周（可运行基础）**

- ✅ 事件系统建立（类型安全通信）
- ✅ React+Phaser基础框架
- 🎯 **里程碑**：基础框架可运行并可测试

### **第7-15周（核心功能）**

- ✅ 游戏核心系统
- ✅ 业务逻辑完整
- ✅ AI引擎实现
- ✅ 数据持久化
- 🎯 **里程碑**：完整游戏玩法可运行

### **第16-24周（系统完善）**

- ✅ 安全加固
- ✅ 性能优化
- ✅ 部署打包
- 🎯 **里程碑**：MVP交付就绪

### **⚡ 关键成功因素**

1. **第1-2周决定后续6个月质量**：调试工具、集中化测试策略、安全配置不可回退
2. **每周都有可运行系统**：便于AI代码生成的迭代验证
3. **严格遵循TDD**：确保AI生成代码的质量和可维护性
4. **事件架构先行**：避免后期模块间通信重构
5. **测试策略集中化**：减少AI实施时的认知负担，提高实施效率

### **🚨 风险控制**

1. **安全配置早期锁定**：避免后期安全架构调整
2. **调试工具优先建立**：支持AI代码生成的快速验证
3. **测试环境同步建立**：集中化测试策略确保代码质量和重构安全
4. **架构决策前置**：避免开发中期的架构调整
5. **认知负担最小化**：测试相关内容集中在第3章，避免跨章节查找

### **🎨 AI实施优化点**

1. **单一职责测试章节**：所有测试策略集中在第3章，避免分散查找
2. **渐进复杂度设计**：从基础设施→架构→核心功能→完善优化的递进路径
3. **里程碑可验证**：每个阶段都有明确的可运行验证点
4. **工具链优先**：优先建立支撑AI代码生成的工具和规范
5. **测试驱动架构**：TDD原则贯穿整个开发流程，确保AI生成代码的可靠性
