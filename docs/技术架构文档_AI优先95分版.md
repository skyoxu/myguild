# ã€Šå…¬ä¼šç»ç†ã€‹æŠ€æœ¯æ¶æ„æ–‡æ¡£ï¼ˆAIä¼˜å…ˆ95åˆ†ç‰ˆï¼‰

> **è®¾è®¡ç†å¿µ**: ä¸¥æ ¼éµå¾ª"çº¦æŸä¸ç›®æ ‡â†’å¨èƒæ¨¡å‹â†’å¯è§‚æµ‹æ€§â†’ç³»ç»Ÿä¸Šä¸‹æ–‡â†’æ•°æ®æ¨¡å‹â†’è¿è¡Œæ—¶è§†å›¾â†’å¼€å‘ç¯å¢ƒâ†’åŠŸèƒ½çºµåˆ‡â†’æ€§èƒ½è§„åˆ’"çš„AIä¼˜å…ˆæ¶æ„æ ‡å‡†ï¼Œç¡®ä¿AIèƒ½æŒ‰ç›®å½•é¡ºåºç¨³å®šæ‹†ä»»åŠ¡ä¸ç”Ÿæˆä»£ç 

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **åˆ›å»ºæ—¶é—´**: 2025-08-12
- **æ¶æ„ç‰ˆæœ¬**: v2.0.0 (AIä¼˜å…ˆ95åˆ†ç‰ˆ)
- **æŠ€æœ¯æ ˆ**: Electron + React 19 + Phaser 3 + TypeScript + SQLite + Web Workers
- **è®¾è®¡ç›®æ ‡**: 95åˆ†ä»¥ä¸ŠAIä¼˜å…ˆæ¶æ„æ ‡å‡†ï¼Œæ”¯æŒAIæŒ‰åºç¨³å®šç”Ÿæˆä»£ç 

---

## ğŸ¯ **ç¬¬1ç« ï¼šçº¦æŸä¸ç›®æ ‡ï¼ˆNFR/èŒƒå›´/å†³ç­–ï¼‰**

### 1.1 é¡¹ç›®èŒƒå›´ä¸ä¸šåŠ¡çº¦æŸ

#### 1.1.1 æ ¸å¿ƒä¸šåŠ¡èŒƒå›´å®šä¹‰

- **äº§å“å®šä½**: æ¡Œé¢ç«¯å…¬ä¼šç®¡ç†ç­–ç•¥æ¸¸æˆ
- **ç›®æ ‡ç”¨æˆ·**: MMOèµ„æ·±ç©å®¶ï¼ˆ25-40å²ï¼Œé«˜ä»˜è´¹æ„æ„¿ï¼‰
- **æ ¸å¿ƒä»·å€¼**: AIé©±åŠ¨çš„æ™ºèƒ½å…¬ä¼šç®¡ç†ä½“éªŒ
- **æŠ€æœ¯è¾¹ç•Œ**: å•æœºæ¸¸æˆï¼Œæœ¬åœ°æ•°æ®å­˜å‚¨ï¼Œæ”¯æŒDLCæ‰©å±•

#### 1.1.2 éåŠŸèƒ½æ€§éœ€æ±‚ï¼ˆNFRï¼‰åŸºçº¿

```yaml
# æ€§èƒ½è¦æ±‚
performance:
  startup_time: '<3ç§’' # ä»ç‚¹å‡»åˆ°ä¸»çª—å£æ˜¾ç¤º
  memory_peak: '<512MB' # å³°å€¼å†…å­˜å ç”¨
  cpu_idle: '<5%' # ç©ºé—²çŠ¶æ€CPUå ç”¨
  cpu_gaming: '<30%' # æ¸¸æˆè¿è¡ŒçŠ¶æ€CPUå ç”¨
  fps_stable: '60 FPS' # ç¨³å®šå¸§ç‡è¦æ±‚

# å¯ç”¨æ€§è¦æ±‚
availability:
  uptime: '>99%' # ç³»ç»Ÿç¨³å®šæ€§
  crash_recovery: '<30ç§’' # å´©æºƒæ¢å¤æ—¶é—´
  save_integrity: '99.9%' # å­˜æ¡£å®Œæ•´æ€§

# å¯æ‰©å±•æ€§è¦æ±‚
scalability:
  ai_entities: '200+' # æ”¯æŒAIå®ä½“æ•°é‡
  event_throughput: '1000/s' # äº‹ä»¶å¤„ç†ååé‡
  save_size: '<100MB' # å•ä¸ªå­˜æ¡£æ–‡ä»¶å¤§å°
```

#### 1.1.3 æŠ€æœ¯æ ˆé€‰å‹å†³ç­–ï¼ˆADR-001ï¼‰

```markdown
# ADR-001: æ ¸å¿ƒæŠ€æœ¯æ ˆé€‰å‹

## çŠ¶æ€: å·²ç¡®å®š

## å†³ç­–æ—¶é—´: 2025-08-12

## æŠ€æœ¯é€‰æ‹©ä¸ç†ç”±:

- **Electron**: è·¨å¹³å°æ¡Œé¢åº”ç”¨å¼€å‘ï¼Œæˆç†Ÿç”Ÿæ€
- **React 19**: æœ€æ–°ç‰ˆæœ¬ï¼Œè‡ªåŠ¨ä¼˜åŒ–æœºåˆ¶ï¼Œå¹¶å‘æ¸²æŸ“
- **Phaser 3**: WebGLæ¸²æŸ“ï¼Œä¸°å¯Œçš„æ¸¸æˆå¼€å‘åŠŸèƒ½
- **TypeScript**: å¼ºç±»å‹ï¼Œé™ä½ç»´æŠ¤æˆæœ¬
- **SQLite**: æœ¬åœ°æ•°æ®åº“ï¼Œé›¶é…ç½®ï¼Œé«˜æ€§èƒ½
- **Web Workers**: AIè®¡ç®—çº¿ç¨‹åˆ†ç¦»ï¼Œé¿å…UIé˜»å¡

## çº¦æŸæ¡ä»¶:

- å¿…é¡»æ”¯æŒWindows/macOS/Linuxä¸‰å¹³å°
- å¿…é¡»æ”¯æŒç¦»çº¿è¿è¡Œ
- å¿…é¡»æ”¯æŒå¢é‡æ›´æ–°
- ç¦æ­¢å¼•å…¥å…¶ä»–é‡å‹æ¡†æ¶ï¼ˆé™¤éæ˜ç¡®è§„åˆ’ï¼‰
```

#### 1.1.4 åˆè§„ä¸å¹³å°è¦æ±‚

- **Electronç‰ˆæœ¬**: >=28.0.0ï¼ˆå®‰å…¨ç‰¹æ€§è¦æ±‚ï¼‰
- **Node.jsç‰ˆæœ¬**: >=18.17.0ï¼ˆES2022æ”¯æŒï¼‰
- **æµè§ˆå™¨å…¼å®¹**: Chromium 122+ï¼ˆElectronå†…ç½®ï¼‰
- **æ“ä½œç³»ç»Ÿ**: Windows 10+, macOS 11+, Ubuntu 20.04+

### 1.2 å®¹é‡è§„åˆ’ä¸å‡è®¾

#### 1.2.1 æ•°æ®å®¹é‡å‡è®¾

- **AIå®ä½“**: 200ä¸ªNPC + 50ä¸ªå…¬ä¼š
- **äº‹ä»¶æ± **: 10,000æ¡å†å²äº‹ä»¶
- **å­˜æ¡£æ•°æ®**: å•ä¸ªå­˜æ¡£<100MBï¼Œæ”¯æŒ20ä¸ªå­˜æ¡£æ§½
- **èµ„æºæ–‡ä»¶**: æ¸¸æˆèµ„æº<2GBï¼ŒéŸ³é¢‘<500MB

#### 1.2.2 å¹¶å‘å¤„ç†å‡è®¾

- **UIçº¿ç¨‹**: 60 FPSæ¸²æŸ“ï¼Œ<16.67msæ¯å¸§
- **AIè®¡ç®—çº¿ç¨‹**: 10ä¸ªå¹¶å‘AIå†³ç­–
- **æ•°æ®åº“æ“ä½œ**: 100ä¸ªå¹¶å‘è¯»æ“ä½œï¼Œ10ä¸ªå¹¶å‘å†™æ“ä½œ
- **äº‹ä»¶å¤„ç†**: 1000ä¸ªäº‹ä»¶/ç§’å³°å€¼å¤„ç†èƒ½åŠ›

### 1.3 å…³é”®æ¶æ„å†³ç­–è®°å½•

#### 1.3.1 ADR-002: äº‹ä»¶é©±åŠ¨æ¶æ„é€‰æ‹©

```markdown
# ADR-002: äº‹ä»¶é©±åŠ¨æ¶æ„

## çŠ¶æ€: å·²ç¡®å®š

## ä¸Šä¸‹æ–‡: éœ€è¦å¤„ç†å¤æ‚çš„æ¸¸æˆçŠ¶æ€åŒæ­¥å’ŒAIäº¤äº’

## å†³ç­–:

é‡‡ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ˆEventBus + Event Sourcingï¼‰

## åæœ:

- é«˜åº¦è§£è€¦çš„æ¨¡å—è®¾è®¡
- æ˜“äºæ‰©å±•å’Œè°ƒè¯•çš„äº‹ä»¶æµ
- å¤©ç„¶æ”¯æŒæ’¤é”€/é‡åšåŠŸèƒ½

* å¢åŠ ç³»ç»Ÿå¤æ‚åº¦
* éœ€è¦ä¸¥æ ¼çš„äº‹ä»¶ç‰ˆæœ¬ç®¡ç†
```

#### 1.3.2 ADR-003: AIè®¡ç®—çº¿ç¨‹åˆ†ç¦»

```markdown
# ADR-003: AIè®¡ç®—Web Workeråˆ†ç¦»

## çŠ¶æ€: å·²ç¡®å®š

## ä¸Šä¸‹æ–‡: AIå†³ç­–è®¡ç®—å¤æ‚ï¼Œä¸èƒ½é˜»å¡UIçº¿ç¨‹

## å†³ç­–:

ä½¿ç”¨Web Workerè¿›è¡ŒAIè®¡ç®—åˆ†ç¦»

## åæœ:

- UIå§‹ç»ˆä¿æŒå“åº”
- å¯åˆ©ç”¨å¤šæ ¸CPUæ€§èƒ½
- æ˜“äºå®ç°AIè®¡ç®—è¶…æ—¶æ§åˆ¶

* å¢åŠ çº¿ç¨‹é—´é€šä¿¡å¤æ‚åº¦
* éœ€è¦åºåˆ—åŒ–æ‰€æœ‰AIçŠ¶æ€æ•°æ®
```

### 1.4 **ç¬¬1ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 1.4.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: çº¦æŸéªŒè¯å™¨ã€ADRå†³ç­–éªŒè¯å™¨ã€å®¹é‡è®¡ç®—å™¨
- **é›†æˆæµ‹è¯•**: æŠ€æœ¯æ ˆå…¼å®¹æ€§éªŒè¯ã€å¹³å°æ”¯æŒéªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´çº¦æŸæ¡ä»¶ä¸‹çš„ç³»ç»Ÿè¿è¡ŒéªŒè¯

#### 1.4.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('çº¦æŸä¸ç›®æ ‡å†’çƒŸæµ‹è¯•', () => {
  it('æŠ€æœ¯æ ˆç‰ˆæœ¬åº”ç¬¦åˆADR-001è¦æ±‚', async () => {
    const versions = await getSystemVersions();
    expect(versions.electron).toMatch(/^28\./);
    expect(versions.node).toMatch(/^18\.17\./);
    expect(versions.typescript).toMatch(/^5\./);
  });

  it('æ€§èƒ½åŸºçº¿åº”æ»¡è¶³NFRè¦æ±‚', async () => {
    const app = await startApp();
    const startupTime = await measureStartupTime();
    expect(startupTime).toBeLessThan(3000); // <3ç§’

    const memoryUsage = await getMemoryUsage();
    expect(memoryUsage.peak).toBeLessThan(512 * 1024 * 1024); // <512MB
  });
});
```

---

## ğŸ”’ **ç¬¬2ç« ï¼šå¨èƒæ¨¡å‹ä¸å®‰å…¨åŸºçº¿**

### 2.1 å¨èƒæ¨¡å‹åˆ†æ

#### 2.1.1 æ”»å‡»é¢è¯†åˆ«

```mermaid
graph TD
    A[ç”¨æˆ·ç•Œé¢] --> B[æ¸²æŸ“è¿›ç¨‹]
    B --> C[IPCé€šé“]
    C --> D[ä¸»è¿›ç¨‹]
    D --> E[æ–‡ä»¶ç³»ç»Ÿ]
    D --> F[æ•°æ®åº“]
    B --> G[Webå†…å®¹]

    H[å­˜æ¡£æ–‡ä»¶] --> I[åŠ å¯†å±‚]
    J[æ’ä»¶ç³»ç»Ÿ] --> K[æ²™ç®±éš”ç¦»]
```

#### 2.1.2 å…³é”®å¨èƒè¯†åˆ«

- **T-001**: æ¶æ„ä»£ç æ³¨å…¥ï¼ˆXSS/ä»£ç æ³¨å…¥ï¼‰
- **T-002**: å­˜æ¡£æ–‡ä»¶ç¯¡æ”¹ï¼ˆæ•°æ®å®Œæ•´æ€§ï¼‰
- **T-003**: ç‰¹æƒå‡çº§ï¼ˆElectronæ²™ç®±é€ƒé€¸ï¼‰
- **T-004**: ä¿¡æ¯æ³„éœ²ï¼ˆæ•æ„Ÿæ•°æ®æš´éœ²ï¼‰
- **T-005**: æ‹’ç»æœåŠ¡ï¼ˆèµ„æºè€—å°½æ”»å‡»ï¼‰

### 2.2 Electronå®‰å…¨åŸºçº¿é…ç½®

#### 2.2.1 è¿›ç¨‹éš”ç¦»ç­–ç•¥ï¼ˆå¼ºåˆ¶æ‰§è¡Œï¼‰

```typescript
// main.ts - å®‰å…¨åŸºçº¿é…ç½®
const SECURITY_CONFIG = {
  // æ ¸å¿ƒå®‰å…¨è®¾ç½®ï¼ˆä¸å¯å›é€€ï¼‰
  contextIsolation: true, // ä¸Šä¸‹æ–‡éš”ç¦»å¿…é¡»å¯ç”¨
  nodeIntegration: false, // Nodeé›†æˆå¿…é¡»ç¦ç”¨
  nodeIntegrationInWorker: false, // Workerä¸­ç¦ç”¨Nodeé›†æˆ
  nodeIntegrationInSubFrames: false, // å­æ¡†æ¶ä¸­ç¦ç”¨Nodeé›†æˆ

  // Webå®‰å…¨è®¾ç½®
  webSecurity: true, // Webå®‰å…¨å¿…é¡»å¯ç”¨
  allowRunningInsecureContent: false, // ç¦æ­¢ä¸å®‰å…¨å†…å®¹
  experimentalFeatures: false, // ç¦ç”¨å®éªŒæ€§åŠŸèƒ½

  // æ²™ç®±è®¾ç½®
  sandbox: true, // å¯ç”¨æ²™ç®±æ¨¡å¼
  preload: path.join(__dirname, 'preload.js'), // å®‰å…¨é¢„åŠ è½½è„šæœ¬
} as const;

const mainWindow = new BrowserWindow({
  webPreferences: SECURITY_CONFIG,
});
```

#### 2.2.2 å†…å®¹å®‰å…¨ç­–ç•¥ï¼ˆCSPï¼‰

```typescript
// CSPç­–ç•¥å®šä¹‰
const CSP_POLICY = {
  'default-src': "'self'",
  'script-src': "'self' 'unsafe-inline'", // ä»…å…è®¸å†…è”è„šæœ¬
  'style-src': "'self' 'unsafe-inline'", // ä»…å…è®¸å†…è”æ ·å¼
  'img-src': "'self' data: blob:", // å…è®¸dataå’Œblobå›¾ç‰‡
  'font-src': "'self' data:", // å…è®¸dataå­—ä½“
  'connect-src': "'self'", // ä»…å…è®¸åŒæºè¿æ¥
  'media-src': "'self'", // ä»…å…è®¸åŒæºåª’ä½“
  'frame-src': "'none'", // ç¦æ­¢æ¡†æ¶
  'object-src': "'none'", // ç¦æ­¢å¯¹è±¡
  'base-uri': "'self'", // é™åˆ¶baseæ ‡ç­¾
  'form-action': "'self'", // é™åˆ¶è¡¨å•æäº¤
} as const;

// åœ¨HTMLä¸­åº”ç”¨CSP
const cspString = Object.entries(CSP_POLICY)
  .map(([directive, value]) => `${directive} ${value}`)
  .join('; ');
```

#### 2.2.3 å®‰å…¨é¢„åŠ è½½è„šæœ¬

```typescript
// preload.ts - å®‰å…¨APIæ¡¥æ¥
import { contextBridge, ipcRenderer } from 'electron';

// ç™½åå•APIï¼ˆä¸¥æ ¼æ§åˆ¶ï¼‰
const ALLOWED_APIS = {
  // æ¸¸æˆæ•°æ®æ“ä½œï¼ˆå®‰å…¨åŒ…è£…ï¼‰
  gameData: {
    save: (data: GameSaveData) =>
      ipcRenderer.invoke('game:save', sanitizeData(data)),
    load: (slot: string) => ipcRenderer.invoke('game:load', validateSlot(slot)),
    delete: (slot: string) =>
      ipcRenderer.invoke('game:delete', validateSlot(slot)),
  },

  // ç³»ç»Ÿä¿¡æ¯ï¼ˆåªè¯»ï¼Œè¿‡æ»¤æ•æ„Ÿä¿¡æ¯ï¼‰
  system: {
    getPlatform: () => ipcRenderer.invoke('system:platform'),
    getVersion: () => ipcRenderer.invoke('system:version'),
    getPerformance: () => ipcRenderer.invoke('system:performance'),
  },

  // äº‹ä»¶é€šä¿¡ï¼ˆç±»å‹å®‰å…¨ï¼‰
  events: {
    on: (channel: AllowedChannel, listener: EventListener) =>
      ipcRenderer.on(channel, (event, ...args) => listener(...args)),
    emit: (channel: AllowedChannel, ...args: any[]) =>
      ipcRenderer.invoke(channel, ...args),
  },
} as const;

// æš´éœ²å®‰å…¨APIåˆ°æ¸²æŸ“è¿›ç¨‹
contextBridge.exposeInMainWorld('electronAPI', ALLOWED_APIS);

// æ•°æ®æ¸…ç†å‡½æ•°
function sanitizeData(data: any): any {
  // ç§»é™¤æ½œåœ¨çš„æ¶æ„å­—æ®µ
  const sanitized = JSON.parse(JSON.stringify(data));
  return removeScriptTags(sanitized);
}
```

### 2.3 æ•°æ®å®‰å…¨ä¸åŠ å¯†ç­–ç•¥

#### 2.3.1 å­˜æ¡£åŠ å¯†æ¶æ„

```typescript
// å­˜æ¡£åŠ å¯†ç®¡ç†å™¨
export class SaveFileEncryption {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyDerivation = 'pbkdf2';

  async encryptSaveData(
    data: GameSaveData,
    password: string
  ): Promise<EncryptedSave> {
    // å¯†é’¥æ´¾ç”Ÿï¼ˆPBKDF2 + éšæœºç›ï¼‰
    const salt = crypto.randomBytes(32);
    const key = crypto.pbkdf2Sync(password, salt, 100000, 32, 'sha256');

    // AES-256-GCMåŠ å¯†
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from('guild-manager-save'));

    const encrypted = Buffer.concat([
      cipher.update(JSON.stringify(data), 'utf8'),
      cipher.final(),
    ]);

    const authTag = cipher.getAuthTag();

    // è¿”å›åŠ å¯†ç»“æœ
    return {
      version: '1.0',
      algorithm: this.algorithm,
      salt: salt.toString('hex'),
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      data: encrypted.toString('hex'),
      checksum: this.calculateChecksum(encrypted),
    };
  }

  private calculateChecksum(data: Buffer): string {
    return crypto.createHash('sha256').update(data).digest('hex');
  }
}
```

#### 2.3.2 å®Œæ•´æ€§æ ¡éªŒæœºåˆ¶

```typescript
// æ•°æ®å®Œæ•´æ€§æ ¡éªŒå™¨
export class DataIntegrityValidator {
  async validateSaveFile(saveData: any): Promise<ValidationResult> {
    const checks = [
      this.validateStructure(saveData),
      this.validateChecksums(saveData),
      this.validateCrossReferences(saveData),
      this.validateBusinessRules(saveData),
    ];

    const results = await Promise.all(checks);
    return this.aggregateResults(results);
  }

  private async validateStructure(data: any): Promise<CheckResult> {
    // éªŒè¯æ•°æ®ç»“æ„å®Œæ•´æ€§
    const requiredFields = ['guild', 'members', 'resources', 'version'];
    const missing = requiredFields.filter(field => !(field in data));

    return {
      type: 'structure',
      passed: missing.length === 0,
      errors: missing.map(field => `Missing required field: ${field}`),
    };
  }
}
```

### 2.4 å®‰å…¨ç›‘æ§ä¸å®¡è®¡

#### 2.4.1 å®‰å…¨äº‹ä»¶æ£€æµ‹

```typescript
// å®‰å…¨ç›‘æ§å™¨
export class SecurityMonitor {
  private suspiciousActivities: SuspiciousActivity[] = [];

  detectAnomalousFileAccess(path: string, operation: string): void {
    if (this.isOutsideGameDirectory(path)) {
      this.reportSuspiciousActivity({
        type: 'file_access_anomaly',
        details: { path, operation },
        severity: 'high',
        timestamp: Date.now(),
      });
    }
  }

  detectUnauthorizedAPICall(api: string, context: any): void {
    if (!this.isAPICallAuthorized(api, context)) {
      this.reportSuspiciousActivity({
        type: 'unauthorized_api_call',
        details: { api, context },
        severity: 'critical',
        timestamp: Date.now(),
      });
    }
  }
}
```

### 2.5 **ç¬¬2ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 2.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: åŠ å¯†ç®—æ³•éªŒè¯ã€æƒé™æ£€æŸ¥å™¨ã€å®‰å…¨å·¥å…·ç±»ã€CSPè§£æå™¨
- **é›†æˆæµ‹è¯•**: Electronå®‰å…¨é›†æˆæµ‹è¯•ã€åŠ å¯†å­˜å‚¨é›†æˆéªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´å®‰å…¨ç­–ç•¥åœ¨çœŸå®ç¯å¢ƒä¸‹çš„æœ‰æ•ˆæ€§éªŒè¯
- **ä¸“é¡¹æµ‹è¯•**: å®‰å…¨æ¼æ´æ‰«æã€æ¸—é€æµ‹è¯•ã€åˆè§„æ€§æ£€æŸ¥

#### 2.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('å¨èƒæ¨¡å‹ä¸å®‰å…¨åŸºçº¿å†’çƒŸæµ‹è¯•', () => {
  it('Electronå®‰å…¨é…ç½®åº”ç¬¦åˆåŸºçº¿è¦æ±‚', async () => {
    const mainWindow = await createTestWindow();
    const webPreferences = mainWindow.webContents.getWebPreferences();

    expect(webPreferences.contextIsolation).toBe(true);
    expect(webPreferences.nodeIntegration).toBe(false);
    expect(webPreferences.sandbox).toBe(true);
    expect(webPreferences.webSecurity).toBe(true);
  });

  it('CSPç­–ç•¥åº”é˜»æ­¢ä¸å®‰å…¨è„šæœ¬æ‰§è¡Œ', async () => {
    const response = await injectMaliciousScript(
      '<script>alert("xss")</script>'
    );
    expect(response.blocked).toBe(true);
    expect(response.violation).toContain('Content-Security-Policy');
  });

  it('å­˜æ¡£æ–‡ä»¶åº”è¢«æ­£ç¡®åŠ å¯†å’Œå®Œæ•´æ€§æ ¡éªŒ', async () => {
    const encryption = new SaveFileEncryption();
    const testData = { guild: 'test', level: 10 };

    const encrypted = await encryption.encryptSaveData(testData, 'password');
    expect(encrypted.algorithm).toBe('aes-256-gcm');
    expect(encrypted.checksum).toBeTruthy();

    const decrypted = await encryption.decryptSaveData(encrypted, 'password');
    expect(decrypted).toEqual(testData);
  });
});
```

#### 2.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- å®‰å…¨æ¨¡å—è¦†ç›–ç‡ï¼šâ‰¥90% (critical_modules.securityæ ‡å‡†)
- åŠ å¯†ç®—æ³•è¦†ç›–ç‡ï¼šâ‰¥95% (å…³é”®å®‰å…¨å‡½æ•°)
- å®‰å…¨åˆè§„æ£€æŸ¥ï¼šå‘å¸ƒé—¨ç¦å®‰å…¨éªŒè¯è¦æ±‚

---

## ğŸ‘ï¸ **ç¬¬3ç« ï¼šå¯è§‚æµ‹æ€§åŸºçº¿**

### 3.1 æ—¥å¿—ç»“æ„ä¸åˆ†çº§æ ‡å‡†

#### 3.1.1 ç»Ÿä¸€æ—¥å¿—æ ¼å¼ï¼ˆJSONç»“æ„ï¼‰

```typescript
// æ ‡å‡†æ—¥å¿—æ ¼å¼å®šä¹‰
interface StandardLogEntry {
  timestamp: string; // ISO 8601æ ¼å¼
  level: 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  component: string; // ç»„ä»¶æ ‡è¯†
  message: string; // äººç±»å¯è¯»æ¶ˆæ¯
  context: Record<string, any>; // ç»“æ„åŒ–ä¸Šä¸‹æ–‡
  correlationId?: string; // è¯·æ±‚å…³è”ID
  userId?: string; // ç”¨æˆ·æ ‡è¯†ï¼ˆè„±æ•ï¼‰
  sessionId: string; // ä¼šè¯æ ‡è¯†
  version: string; // åº”ç”¨ç‰ˆæœ¬
}

// æ—¥å¿—ç­‰çº§ä½¿ç”¨æŒ‡å—
const LOG_LEVEL_GUIDE = {
  fatal: 'ç³»ç»Ÿå´©æºƒï¼Œæ— æ³•ç»§ç»­è¿è¡Œ',
  error: 'åŠŸèƒ½æ€§é”™è¯¯ï¼Œå½±å“ç”¨æˆ·ä½“éªŒ',
  warn: 'æ½œåœ¨é—®é¢˜ï¼Œéœ€è¦å…³æ³¨',
  info: 'é‡è¦ä¸šåŠ¡äº‹ä»¶',
  debug: 'è¯¦ç»†æŠ€æœ¯ä¿¡æ¯ï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰',
} as const;
```

#### 3.1.2 åˆ†å±‚æ—¥å¿—æ”¶é›†ç­–ç•¥

```typescript
// æ—¥å¿—ç®¡ç†å™¨
export class LoggerManager {
  private loggers: Map<string, Logger> = new Map();

  // æŒ‰ç»„ä»¶åˆ›å»ºä¸“ç”¨æ—¥å¿—å™¨
  getLogger(component: string): Logger {
    if (!this.loggers.has(component)) {
      this.loggers.set(
        component,
        new ComponentLogger({
          component,
          outputPath: path.join(app.getPath('logs'), `${component}.log`),
          rotationSize: '50MB',
          retentionDays: 30,
          level: this.getLogLevelForComponent(component),
        })
      );
    }
    return this.loggers.get(component)!;
  }

  private getLogLevelForComponent(component: string): LogLevel {
    const config = {
      'ai-engine': 'info', // AIå†³ç­–æ—¥å¿—é‡è¦ä½†ä¸è¿‡äºè¯¦ç»†
      'event-bus': 'debug', // äº‹ä»¶æµéœ€è¦è¯¦ç»†è·Ÿè¸ª
      security: 'warn', // å®‰å…¨æ—¥å¿—åªè®°å½•è­¦å‘Šä»¥ä¸Š
      performance: 'info', // æ€§èƒ½æŒ‡æ ‡è®°å½•
      database: 'warn', // æ•°æ®åº“åªè®°å½•é—®é¢˜
    };
    return config[component] || 'info';
  }
}
```

### 3.2 Sentryé›†æˆä¸é”™è¯¯ç›‘æ§

#### 3.2.1 Sentryåˆå§‹åŒ–é…ç½®ï¼ˆç”Ÿäº§çº§ï¼‰

```typescript
// Sentryé…ç½® - ä¸»è¿›ç¨‹
import * as Sentry from '@sentry/electron/main';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  release: `guild-manager@${app.getVersion()}`,

  // é‡‡æ ·ç‡é…ç½®
  tracesSampleRate: getTracesSampleRate(), // æ€§èƒ½ç›‘æ§é‡‡æ ·
  sampleRate: 1.0, // é”™è¯¯ç›‘æ§100%é‡‡æ ·

  // Electronç‰¹å®šé…ç½®
  integrations: [
    new Sentry.Integrations.Electron.ElectronMainIntegration({
      captureRendererCrashes: true, // æ•è·æ¸²æŸ“è¿›ç¨‹å´©æºƒ
      captureUnhandledRejections: true, // æ•è·æœªå¤„ç†Promiseæ‹’ç»
    }),
    new Sentry.Integrations.Electron.ElectronNetIntegration(), // ç½‘ç»œè¯·æ±‚è·Ÿè¸ª
  ],

  // éšç§ä¿æŠ¤
  beforeSend: filterSensitiveData,
  beforeBreadcrumb: filterSensitiveBreadcrumbs,

  // æ€§èƒ½é…ç½®
  maxBreadcrumbs: 50,
  attachStacktrace: true,
});

// åŠ¨æ€é‡‡æ ·ç‡ï¼ˆåŸºäºç¯å¢ƒå’Œç”¨æˆ·åé¦ˆï¼‰
function getTracesSampleRate(): number {
  if (process.env.NODE_ENV === 'development') return 1.0;
  if (process.env.NODE_ENV === 'staging') return 0.5;
  return 0.1; // ç”Ÿäº§ç¯å¢ƒ10%é‡‡æ ·
}
```

#### 3.2.2 Event Loop Blockæ£€æµ‹ï¼ˆElectronä¸“ç”¨ï¼‰

```typescript
// Event Loopé˜»å¡æ£€æµ‹é…ç½®
const EVENT_LOOP_CONFIG = {
  // ä¸»è¿›ç¨‹é˜»å¡é˜ˆå€¼
  mainProcessThreshold: 500, // 500ms

  // æ¸²æŸ“è¿›ç¨‹ANRé˜ˆå€¼
  rendererANRThreshold: 5000, // 5ç§’

  // æ¸¸æˆå¾ªç¯é˜»å¡é˜ˆå€¼
  gameLoopThreshold: 33, // 33ms (60fps)

  // å‘Šè­¦å‡çº§ç­–ç•¥
  alertEscalation: {
    warningAfter: 3, // è¿ç»­3æ¬¡é˜»å¡å‘å‡ºè­¦å‘Š
    criticalAfter: 10, // è¿ç»­10æ¬¡é˜»å¡å‘å‡ºä¸¥é‡å‘Šè­¦
  },
} as const;

// Event Loopç›‘æ§å™¨
export class EventLoopMonitor {
  private blockCount = 0;
  private lastBlockTime = 0;

  startMonitoring(): void {
    // ä¸»è¿›ç¨‹Event Loopæ£€æµ‹
    setInterval(() => {
      const start = process.hrtime.bigint();
      setImmediate(() => {
        const duration = Number(process.hrtime.bigint() - start) / 1000000; // è½¬æ¢ä¸ºæ¯«ç§’

        if (duration > EVENT_LOOP_CONFIG.mainProcessThreshold) {
          this.handleEventLoopBlock('main', duration);
        }
      });
    }, 1000);

    // æ¸²æŸ“è¿›ç¨‹ANRæ£€æµ‹
    this.setupRendererANRDetection();
  }

  private handleEventLoopBlock(
    process: 'main' | 'renderer',
    duration: number
  ): void {
    this.blockCount++;

    Sentry.addBreadcrumb({
      category: 'performance',
      message: `Event loop blocked in ${process} process`,
      level: 'warning',
      data: {
        duration,
        blockCount: this.blockCount,
        threshold: EVENT_LOOP_CONFIG.mainProcessThreshold,
      },
    });

    // å‡çº§å‘Šè­¦
    if (this.blockCount >= EVENT_LOOP_CONFIG.alertEscalation.criticalAfter) {
      Sentry.captureException(
        new Error(`Critical: Event loop blocked ${this.blockCount} times`)
      );
    }
  }
}
```

### 3.3 æ€§èƒ½ç›‘æ§åŸºçº¿

#### 3.3.1 å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆKPIï¼‰å®šä¹‰

```typescript
// æ€§èƒ½åŸºçº¿æ ‡å‡†
const PERFORMANCE_BASELINES = {
  // åº”ç”¨å¯åŠ¨æ€§èƒ½
  startup: {
    coldStart: 3000, // å†·å¯åŠ¨<3ç§’
    warmStart: 1500, // çƒ­å¯åŠ¨<1.5ç§’
    memoryFootprint: 200 * 1024 * 1024, // å¯åŠ¨å†…å­˜<200MB
  },

  // è¿è¡Œæ—¶æ€§èƒ½
  runtime: {
    memoryPeak: 512 * 1024 * 1024, // å³°å€¼å†…å­˜<512MB
    cpuIdle: 5, // ç©ºé—²CPU<5%
    cpuGaming: 30, // æ¸¸æˆä¸­CPU<30%
    frameRate: 60, // ç›®æ ‡å¸§ç‡60fps
    frameRateMin: 55, // æœ€ä½å¯æ¥å—å¸§ç‡55fps
  },

  // æ•°æ®åº“æ€§èƒ½
  database: {
    queryTime: 100, // æŸ¥è¯¢å“åº”<100ms
    saveTime: 500, // å­˜æ¡£ä¿å­˜<500ms
    loadTime: 1000, // å­˜æ¡£åŠ è½½<1ç§’
  },

  // AIè®¡ç®—æ€§èƒ½
  ai: {
    decisionTime: 100, // AIå†³ç­–<100ms
    batchProcessing: 1000, // æ‰¹é‡å¤„ç†1000ä¸ªå®ä½“/ç§’
  },
} as const;

// æ€§èƒ½ç›‘æ§å™¨
export class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];

  startMonitoring(): void {
    // å†…å­˜ç›‘æ§
    setInterval(() => {
      const memoryUsage = process.memoryUsage();
      this.recordMetric('memory.heap.used', memoryUsage.heapUsed);
      this.recordMetric('memory.heap.total', memoryUsage.heapTotal);
      this.recordMetric('memory.rss', memoryUsage.rss);

      this.checkMemoryThreshold(memoryUsage);
    }, 5000);

    // CPUç›‘æ§
    this.startCPUMonitoring();

    // FPSç›‘æ§
    this.startFrameRateMonitoring();
  }

  private checkMemoryThreshold(usage: NodeJS.MemoryUsage): void {
    if (usage.heapUsed > PERFORMANCE_BASELINES.runtime.memoryPeak) {
      Sentry.captureMessage('Memory usage exceeded baseline', 'warning', {
        extra: {
          memoryUsage: usage,
          baseline: PERFORMANCE_BASELINES.runtime.memoryPeak,
        },
      });
    }
  }
}
```

### 3.4 å‘å¸ƒç‰ˆæœ¬æ ‡è¯†ä¸è¿½è¸ª

#### 3.4.1 Releases & Healthè¿½è¸ªé…ç½®

```typescript
// ç‰ˆæœ¬å‘å¸ƒç®¡ç†
export class ReleaseManager {
  async createRelease(version: string): Promise<void> {
    // è‡ªåŠ¨åˆ›å»ºSentry Release
    await Sentry.setTag('release', version);

    // å…³è”æäº¤ä¿¡æ¯
    const commits = await this.getCommitsSinceLastRelease();
    await this.associateCommits(version, commits);

    // è®¾ç½®ç¯å¢ƒä¿¡æ¯
    await Sentry.setTag('environment', process.env.NODE_ENV);
    await Sentry.setTag('platform', process.platform);
    await Sentry.setTag('arch', process.arch);
  }

  async trackDeployment(version: string, environment: string): Promise<void> {
    // éƒ¨ç½²è¿½è¸ª
    await Sentry.addBreadcrumb({
      category: 'deployment',
      message: `Deployed version ${version} to ${environment}`,
      level: 'info',
      data: {
        version,
        environment,
        deployedAt: new Date().toISOString(),
        deployedBy: 'CI/CD',
      },
    });
  }
}
```

#### 3.4.2 å¥åº·åº¦ç›‘æ§ä¸å‘Šè­¦

```typescript
// å¥åº·åº¦æ£€æŸ¥å™¨
export class HealthChecker {
  async performHealthCheck(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkDatabaseHealth(),
      this.checkMemoryHealth(),
      this.checkEventLoopHealth(),
      this.checkAIEngineHealth(),
    ]);

    const results = checks.map((check, index) => ({
      name: this.getCheckName(index),
      status: check.status,
      value: check.status === 'fulfilled' ? check.value : null,
      error: check.status === 'rejected' ? check.reason : null,
    }));

    const overallHealth = this.calculateOverallHealth(results);

    // å‘é€å¥åº·åº¦æŠ¥å‘Šåˆ°Sentry
    Sentry.addBreadcrumb({
      category: 'health',
      message: `Health check completed: ${overallHealth.status}`,
      level: overallHealth.status === 'healthy' ? 'info' : 'warning',
      data: { checks: results, overall: overallHealth },
    });

    return overallHealth;
  }
}
```

### 3.5 **ç¬¬3ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 3.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: æ—¥å¿—åˆ†çº§å™¨ã€æ€§èƒ½ç›‘æ§æ•°æ®æ”¶é›†å™¨ã€å¥åº·æ£€æŸ¥é€»è¾‘
- **é›†æˆæµ‹è¯•**: Sentry-Electroné›†æˆã€ç›‘æ§æ•°æ®æµé›†æˆéªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´ç›‘æ§æµç¨‹ï¼ˆé”™è¯¯è§¦å‘â†’æ”¶é›†â†’ä¸ŠæŠ¥â†’å‘Šè­¦ï¼‰
- **ä¸“é¡¹æµ‹è¯•**: Event Loop Blockæ¨¡æ‹Ÿæµ‹è¯•ã€æ€§èƒ½å›å½’æµ‹è¯•

#### 3.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('å¯è§‚æµ‹æ€§åŸºçº¿å†’çƒŸæµ‹è¯•', () => {
  it('Sentryåº”èƒ½æ­£å¸¸åˆå§‹åŒ–å’Œé”™è¯¯ä¸ŠæŠ¥', async () => {
    const sentryStatus = await checkSentryInitialization();
    expect(sentryStatus.initialized).toBe(true);
    expect(sentryStatus.dsn).toBeTruthy();

    // æµ‹è¯•é”™è¯¯æ•è·
    const testError = new Error('Test error for monitoring');
    Sentry.captureException(testError);

    await new Promise(resolve => setTimeout(resolve, 1000)); // ç­‰å¾…ä¸ŠæŠ¥
    const lastEvent = await getLastSentryEvent();
    expect(lastEvent.exception).toBeTruthy();
  });

  it('Event Loopé˜»å¡æ£€æµ‹åº”èƒ½æ­£å¸¸å·¥ä½œ', async () => {
    const monitor = new EventLoopMonitor();
    monitor.startMonitoring();

    // æ¨¡æ‹ŸEvent Loopé˜»å¡
    await simulateEventLoopBlock(600); // è¶…è¿‡500msé˜ˆå€¼

    await waitFor(2000); // ç­‰å¾…æ£€æµ‹
    const alerts = await getEventLoopAlerts();
    expect(alerts.length).toBeGreaterThan(0);
    expect(alerts[0].duration).toBeGreaterThan(500);
  });

  it('æ€§èƒ½ç›‘æ§åº”èƒ½æ£€æµ‹åŸºçº¿è¿è§„', async () => {
    const monitor = new PerformanceMonitor();
    monitor.startMonitoring();

    // æ¨¡æ‹Ÿå†…å­˜è¶…é™
    await simulateMemoryLeak(600 * 1024 * 1024); // è¶…è¿‡512MB

    await waitFor(6000); // ç­‰å¾…ç›‘æ§å‘¨æœŸ
    const memoryAlerts = await getMemoryAlerts();
    expect(memoryAlerts.length).toBeGreaterThan(0);
  });
});
```

#### 3.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- ç›‘æ§æ¨¡å—è¦†ç›–ç‡ï¼šâ‰¥70% (åŸºçº¿æ ‡å‡†)
- Event Loopç›‘æ§è¦†ç›–ç‡ï¼šâ‰¥85% (å…³é”®æ€§èƒ½ç›‘æ§)
- å¥åº·æ£€æŸ¥è¦†ç›–ç‡ï¼šâ‰¥80% (ç³»ç»Ÿå¯ç”¨æ€§ä¿éšœ)

---

## ğŸ—ï¸ **ç¬¬4ç« ï¼šç³»ç»Ÿä¸Šä¸‹æ–‡ä¸C4æ¶æ„+äº‹ä»¶æµ**

### 4.1 ç³»ç»Ÿä¸Šä¸‹æ–‡å›¾ï¼ˆC4 Level 1ï¼‰

```mermaid
C4Context
    title ã€Šå…¬ä¼šç»ç†ã€‹ç³»ç»Ÿä¸Šä¸‹æ–‡å›¾

    Person(player, "ç©å®¶", "MMOèµ„æ·±ç©å®¶ï¼Œä½¿ç”¨æ¡Œé¢åº”ç”¨ç®¡ç†å…¬ä¼š")

    System(guildManager, "å…¬ä¼šç»ç†ç³»ç»Ÿ", "åŸºäºAIçš„å…¬ä¼šç®¡ç†ç­–ç•¥æ¸¸æˆ")

    System_Ext(os, "æ“ä½œç³»ç»Ÿ", "Windows/macOS/Linux")
    System_Ext(fileSystem, "æ–‡ä»¶ç³»ç»Ÿ", "å­˜æ¡£ã€é…ç½®ã€èµ„æºæ–‡ä»¶å­˜å‚¨")
    System_Ext(sentry, "Sentryç›‘æ§", "é”™è¯¯ç›‘æ§å’Œæ€§èƒ½è¿½è¸ª")

    Rel(player, guildManager, "æ“ä½œ", "é¼ æ ‡/é”®ç›˜äº¤äº’")
    Rel(guildManager, os, "è°ƒç”¨", "ç³»ç»ŸAPI")
    Rel(guildManager, fileSystem, "è¯»å†™", "æ•°æ®æŒä¹…åŒ–")
    Rel(guildManager, sentry, "ä¸ŠæŠ¥", "é”™è¯¯å’Œæ€§èƒ½æ•°æ®")
```

### 4.2 å®¹å™¨å›¾ï¼ˆC4 Level 2ï¼‰

```mermaid
C4Container
    title ã€Šå…¬ä¼šç»ç†ã€‹å®¹å™¨æ¶æ„å›¾

    Person(player, "ç©å®¶")

    Container_Boundary(electronApp, "Electronåº”ç”¨ç¨‹åº") {
        Container(mainProcess, "ä¸»è¿›ç¨‹", "Electron Main", "çª—å£ç®¡ç†ã€æ–‡ä»¶æ“ä½œã€IPCåè°ƒ")
        Container(rendererProcess, "æ¸²æŸ“è¿›ç¨‹", "React 19 + Phaser 3", "ç”¨æˆ·ç•Œé¢å’Œæ¸¸æˆæ¸²æŸ“")
        Container(aiWorker, "AIè®¡ç®—Worker", "Web Worker", "AIå†³ç­–è®¡ç®—å’Œè¡Œä¸ºæ¨¡æ‹Ÿ")
    }

    ContainerDb(database, "SQLiteæ•°æ®åº“", "æ•°æ®å­˜å‚¨", "æ¸¸æˆæ•°æ®ã€å­˜æ¡£ã€é…ç½®")
    ContainerDb(fileStorage, "æ–‡ä»¶å­˜å‚¨", "æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ", "èµ„æºæ–‡ä»¶ã€æ—¥å¿—ã€ç¼“å­˜")

    System_Ext(sentry, "Sentry", "ç›‘æ§æœåŠ¡")

    Rel(player, rendererProcess, "äº¤äº’", "UIæ“ä½œ")
    Rel(rendererProcess, mainProcess, "é€šä¿¡", "IPC")
    Rel(mainProcess, database, "è¯»å†™", "æ•°æ®æ“ä½œ")
    Rel(mainProcess, fileStorage, "è¯»å†™", "æ–‡ä»¶æ“ä½œ")
    Rel(rendererProcess, aiWorker, "è®¡ç®—è¯·æ±‚", "MessagePort")
    Rel(mainProcess, sentry, "ä¸ŠæŠ¥", "ç›‘æ§æ•°æ®")
```

### 4.3 ç»„ä»¶å›¾ï¼ˆC4 Level 3ï¼‰

```mermaid
C4Component
    title æ¸²æŸ“è¿›ç¨‹ç»„ä»¶å›¾

    Container_Boundary(renderer, "æ¸²æŸ“è¿›ç¨‹") {
        Component(uiLayer, "UIç®¡ç†å±‚", "React 19", "ç”¨æˆ·ç•Œé¢ç»„ä»¶å’ŒçŠ¶æ€ç®¡ç†")
        Component(gameEngine, "æ¸¸æˆå¼•æ“", "Phaser 3", "æ¸¸æˆæ¸²æŸ“å’Œäº¤äº’é€»è¾‘")
        Component(eventBus, "äº‹ä»¶æ€»çº¿", "TypeScript", "ç»„ä»¶é—´é€šä¿¡åè°ƒ")
        Component(stateManager, "çŠ¶æ€ç®¡ç†å™¨", "Zustand", "å…¨å±€çŠ¶æ€ç®¡ç†")
        Component(bridge, "é€šä¿¡æ¡¥æ¥", "IPC Bridge", "ä¸ä¸»è¿›ç¨‹å’ŒWorkeré€šä¿¡")
    }

    Container_Ext(mainProcess, "ä¸»è¿›ç¨‹")
    Container_Ext(aiWorker, "AI Worker")

    Rel(uiLayer, eventBus, "å‘å¸ƒ/è®¢é˜…", "UIäº‹ä»¶")
    Rel(gameEngine, eventBus, "å‘å¸ƒ/è®¢é˜…", "æ¸¸æˆäº‹ä»¶")
    Rel(eventBus, stateManager, "çŠ¶æ€æ›´æ–°", "åŒæ­¥çŠ¶æ€")
    Rel(bridge, mainProcess, "IPC", "æ•°æ®è¯·æ±‚")
    Rel(bridge, aiWorker, "MessagePort", "AIè®¡ç®—")
    Rel(uiLayer, bridge, "è°ƒç”¨", "æ•°æ®æ“ä½œ")
    Rel(gameEngine, bridge, "è°ƒç”¨", "æ¸¸æˆæ•°æ®")
```

### 4.4 äº‹ä»¶æµæ¶æ„è®¾è®¡

#### 4.4.1 äº‹ä»¶æ€»çº¿æ ¸å¿ƒæ¶æ„

```typescript
// å¼ºç±»å‹äº‹ä»¶ç³»ç»Ÿ
export interface TypedEventBus {
  // äº‹ä»¶å‘å¸ƒ
  publish<T extends GameEvent>(event: T): Promise<void>;

  // äº‹ä»¶è®¢é˜…
  subscribe<T extends GameEvent>(
    eventType: T['type'],
    handler: EventHandler<T>,
    options?: SubscriptionOptions
  ): Subscription;

  // äº‹ä»¶æŸ¥è¯¢
  query<T extends GameEvent>(
    filter: EventFilter<T>,
    options?: QueryOptions
  ): Promise<T[]>;
}

// äº‹ä»¶å¤„ç†ä¼˜å…ˆçº§
enum EventPriority {
  IMMEDIATE = 0, // ç«‹å³å¤„ç†ï¼ˆå¦‚ç”¨æˆ·è¾“å…¥ï¼‰
  HIGH = 1, // é«˜ä¼˜å…ˆçº§ï¼ˆå¦‚AIå†³ç­–å®Œæˆï¼‰
  NORMAL = 2, // æ™®é€šä¼˜å…ˆçº§ï¼ˆå¦‚çŠ¶æ€æ›´æ–°ï¼‰
  LOW = 3, // ä½ä¼˜å…ˆçº§ï¼ˆå¦‚æ—¥å¿—è®°å½•ï¼‰
  BACKGROUND = 4, // åå°å¤„ç†ï¼ˆå¦‚ç»Ÿè®¡è®¡ç®—ï¼‰
}

// äº‹ä»¶å¤„ç†å™¨æ¥å£
interface EventHandler<T extends GameEvent> {
  readonly type: T['type'];
  readonly priority: EventPriority;
  handle(event: T): Promise<void> | void;
  canHandle?(event: T): boolean;
}
```

#### 4.4.2 è·¨è¿›ç¨‹äº‹ä»¶é€šä¿¡åè®®

```typescript
// IPCäº‹ä»¶é€šä¿¡åè®®
interface IPCEventProtocol {
  // ä¸»è¿›ç¨‹ â†’ æ¸²æŸ“è¿›ç¨‹
  'main-to-renderer': {
    'game-data-loaded': { data: GameData };
    'save-completed': { success: boolean; error?: string };
    'system-notification': {
      message: string;
      type: 'info' | 'warning' | 'error';
    };
  };

  // æ¸²æŸ“è¿›ç¨‹ â†’ ä¸»è¿›ç¨‹
  'renderer-to-main': {
    'save-game-request': { data: GameData; slot: string };
    'load-game-request': { slot: string };
    'system-info-request': {};
  };

  // æ¸²æŸ“è¿›ç¨‹ â†” AI Worker
  'renderer-ai-worker': {
    'ai-decision-request': { context: AIContext; entities: NPCEntity[] };
    'ai-decision-response': { decisions: AIDecision[] };
    'ai-learning-data': { experiences: LearningData[] };
  };
}

// ç±»å‹å®‰å…¨çš„IPCåŒ…è£…å™¨
export class TypedIPC {
  // ä¸»è¿›ç¨‹ç«¯
  static main = {
    send<K extends keyof IPCEventProtocol['main-to-renderer']>(
      channel: K,
      data: IPCEventProtocol['main-to-renderer'][K]
    ): void {
      BrowserWindow.getAllWindows()[0]?.webContents.send(channel, data);
    },

    handle<K extends keyof IPCEventProtocol['renderer-to-main']>(
      channel: K,
      handler: (data: IPCEventProtocol['renderer-to-main'][K]) => Promise<any>
    ): void {
      ipcMain.handle(channel, async (event, data) => handler(data));
    },
  };

  // æ¸²æŸ“è¿›ç¨‹ç«¯
  static renderer = {
    invoke<K extends keyof IPCEventProtocol['renderer-to-main']>(
      channel: K,
      data: IPCEventProtocol['renderer-to-main'][K]
    ): Promise<any> {
      return ipcRenderer.invoke(channel, data);
    },

    on<K extends keyof IPCEventProtocol['main-to-renderer']>(
      channel: K,
      handler: (data: IPCEventProtocol['main-to-renderer'][K]) => void
    ): void {
      ipcRenderer.on(channel, (event, data) => handler(data));
    },
  };
}
```

#### 4.4.3 äº‹ä»¶æº¯æºä¸é‡æ”¾ç³»ç»Ÿ

```typescript
// äº‹ä»¶æº¯æºå­˜å‚¨
export class EventSourcingStore {
  private events: StoredEvent[] = [];
  private snapshots: Map<string, GameSnapshot> = new Map();

  async appendEvent(event: GameEvent): Promise<void> {
    const storedEvent: StoredEvent = {
      id: generateEventId(),
      type: event.type,
      data: event.payload,
      metadata: {
        timestamp: Date.now(),
        version: event.version || '1.0',
        correlationId: event.correlationId,
        causedBy: event.causedBy,
      },
      sequence: await this.getNextSequence(),
    };

    this.events.push(storedEvent);
    await this.persistEvent(storedEvent);

    // å®šæœŸåˆ›å»ºå¿«ç…§
    if (this.shouldCreateSnapshot()) {
      await this.createSnapshot();
    }
  }

  async replayEvents(
    fromSequence: number = 0,
    toSequence?: number
  ): Promise<GameEvent[]> {
    const events = this.events.filter(
      event =>
        event.sequence >= fromSequence &&
        (toSequence === undefined || event.sequence <= toSequence)
    );

    return events.map(this.deserializeEvent);
  }

  async createSnapshot(): Promise<void> {
    const currentState = await this.getCurrentGameState();
    const snapshot: GameSnapshot = {
      id: generateSnapshotId(),
      sequence: this.getLastSequence(),
      timestamp: Date.now(),
      state: currentState,
    };

    this.snapshots.set(snapshot.id, snapshot);
    await this.persistSnapshot(snapshot);
  }
}
```

### 4.5 æ¶ˆæ¯é˜Ÿåˆ—ä¸è®¢é˜…ç³»ç»Ÿ

#### 4.5.1 äº‹ä»¶é˜Ÿåˆ—ç®¡ç†

```typescript
// äº‹ä»¶é˜Ÿåˆ—ç®¡ç†å™¨
export class EventQueueManager {
  private queues: Map<EventPriority, EventQueue> = new Map();
  private processing = false;

  constructor() {
    // åˆå§‹åŒ–ä¼˜å…ˆçº§é˜Ÿåˆ—
    Object.values(EventPriority).forEach(priority => {
      if (typeof priority === 'number') {
        this.queues.set(priority, new EventQueue(`queue-${priority}`));
      }
    });

    // å¯åŠ¨å¤„ç†å¾ªç¯
    this.startProcessingLoop();
  }

  async enqueue(
    event: GameEvent,
    priority: EventPriority = EventPriority.NORMAL
  ): Promise<void> {
    const queue = this.queues.get(priority);
    if (!queue) {
      throw new Error(`Queue not found for priority: ${priority}`);
    }

    await queue.enqueue({
      event,
      priority,
      enqueuedAt: Date.now(),
      attempts: 0,
    });
  }

  private async startProcessingLoop(): Promise<void> {
    while (true) {
      if (!this.processing) {
        await this.processQueues();
      }
      await this.sleep(16); // ~60fpså¤„ç†é¢‘ç‡
    }
  }

  private async processQueues(): Promise<void> {
    this.processing = true;

    // æŒ‰ä¼˜å…ˆçº§é¡ºåºå¤„ç†é˜Ÿåˆ—
    for (const priority of [0, 1, 2, 3, 4]) {
      const queue = this.queues.get(priority);
      if (queue && !queue.isEmpty()) {
        await this.processBatch(queue, this.getBatchSize(priority));
      }
    }

    this.processing = false;
  }
}
```

### 4.6 **ç¬¬4ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 4.6.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: äº‹ä»¶æ€»çº¿æ ¸å¿ƒé€»è¾‘ã€IPCé€šä¿¡åè®®ã€äº‹ä»¶åºåˆ—åŒ–/ååºåˆ—åŒ–
- **é›†æˆæµ‹è¯•**: è·¨è¿›ç¨‹äº‹ä»¶é€šä¿¡ã€äº‹ä»¶æº¯æºå­˜å‚¨ã€é˜Ÿåˆ—ç®¡ç†é›†æˆ
- **E2Eæµ‹è¯•**: å®Œæ•´äº‹ä»¶æµï¼ˆUIâ†’äº‹ä»¶æ€»çº¿â†’å¤„ç†â†’çŠ¶æ€æ›´æ–°â†’æŒä¹…åŒ–ï¼‰
- **ä¸“é¡¹æµ‹è¯•**: äº‹ä»¶å¤„ç†æ€§èƒ½æµ‹è¯•ã€å¤§é‡äº‹ä»¶å¹¶å‘å¤„ç†æµ‹è¯•

#### 4.6.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('ç³»ç»Ÿä¸Šä¸‹æ–‡ä¸C4æ¶æ„+äº‹ä»¶æµå†’çƒŸæµ‹è¯•', () => {
  it('äº‹ä»¶æ€»çº¿åº”èƒ½æ­£å¸¸å‘å¸ƒå’Œè®¢é˜…', async () => {
    const eventBus = new TypedEventBus();
    let received = false;

    // è®¢é˜…æµ‹è¯•äº‹ä»¶
    const subscription = eventBus.subscribe('test:event', event => {
      received = true;
      expect(event.type).toBe('test:event');
    });

    // å‘å¸ƒæµ‹è¯•äº‹ä»¶
    await eventBus.publish({
      type: 'test:event',
      payload: { message: 'test' },
      timestamp: Date.now(),
    });

    expect(received).toBe(true);
    subscription.unsubscribe();
  });

  it('IPCé€šä¿¡åº”èƒ½æ­£å¸¸å·¥ä½œ', async () => {
    // æµ‹è¯•æ¸²æŸ“è¿›ç¨‹â†’ä¸»è¿›ç¨‹é€šä¿¡
    const response = await TypedIPC.renderer.invoke('system-info-request', {});
    expect(response).toBeTruthy();
    expect(response.platform).toBeTruthy();

    // æµ‹è¯•ä¸»è¿›ç¨‹â†’æ¸²æŸ“è¿›ç¨‹é€šä¿¡
    let notificationReceived = false;
    TypedIPC.renderer.on('system-notification', data => {
      notificationReceived = true;
      expect(data.message).toBeTruthy();
    });

    TypedIPC.main.send('system-notification', {
      message: 'Test notification',
      type: 'info',
    });

    await waitFor(100);
    expect(notificationReceived).toBe(true);
  });

  it('äº‹ä»¶æº¯æºåº”èƒ½æ­£å¸¸è®°å½•å’Œé‡æ”¾', async () => {
    const eventStore = new EventSourcingStore();

    // è®°å½•æµ‹è¯•äº‹ä»¶
    const testEvent = {
      type: 'guild:created',
      payload: { guildId: 'test-123', name: 'Test Guild' },
      timestamp: Date.now(),
    };

    await eventStore.appendEvent(testEvent);

    // é‡æ”¾äº‹ä»¶
    const replayedEvents = await eventStore.replayEvents(0);
    expect(replayedEvents.length).toBeGreaterThan(0);
    expect(replayedEvents[replayedEvents.length - 1].type).toBe(
      'guild:created'
    );
  });
});
```

#### 4.6.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- äº‹ä»¶ç³»ç»Ÿè¦†ç›–ç‡ï¼šâ‰¥75% (åŸºçº¿æ ‡å‡†)
- IPCé€šä¿¡è¦†ç›–ç‡ï¼šâ‰¥80% (å…³é”®é€šä¿¡æœºåˆ¶)
- äº‹ä»¶æº¯æºè¦†ç›–ç‡ï¼šâ‰¥70% (æ•°æ®ä¸€è‡´æ€§ä¿éšœ)

---

## ğŸ’¾ **ç¬¬5ç« ï¼šæ•°æ®æ¨¡å‹ä¸å­˜å‚¨ç«¯å£**

### 5.1 æ ¸å¿ƒæ•°æ®æ¨¡å‹è®¾è®¡

#### 5.1.1 é¢†åŸŸå®ä½“å®šä¹‰ï¼ˆå¼ºç±»å‹ï¼‰

```typescript
// å…¬ä¼šå®ä½“ï¼ˆèšåˆæ ¹ï¼‰
export interface Guild {
  readonly id: GuildId;
  readonly name: string;
  readonly createdAt: Date;
  readonly leaderId: MemberId;

  // å€¼å¯¹è±¡
  readonly resources: GuildResources;
  readonly reputation: Reputation;
  readonly settings: GuildSettings;

  // é›†åˆ
  readonly members: ReadonlyArray<Member>;
  readonly activities: ReadonlyArray<Activity>;
  readonly achievements: ReadonlyArray<Achievement>;

  // é¢†åŸŸæ–¹æ³•ï¼ˆä¸å¯å˜æ“ä½œï¼‰
  addMember(member: Member): Guild;
  removeMember(memberId: MemberId): Guild;
  updateResources(resources: Partial<GuildResources>): Guild;
  promoteLeader(newLeaderId: MemberId): Guild;
}

// æˆå‘˜å®ä½“
export interface Member {
  readonly id: MemberId;
  readonly name: string;
  readonly joinedAt: Date;
  readonly guildId: GuildId;

  // å€¼å¯¹è±¡
  readonly attributes: MemberAttributes;
  readonly skills: MemberSkills;
  readonly personality: PersonalityTrait;
  readonly relationships: ReadonlyMap<MemberId, RelationshipScore>;

  // çŠ¶æ€ç®¡ç†
  readonly status: MemberStatus;
  readonly lastActiveAt: Date;
  readonly currentActivity?: ActivityId;
}

// AIå†³ç­–å®ä½“
export interface AIDecision {
  readonly id: DecisionId;
  readonly entityId: string;
  readonly entityType: 'member' | 'guild' | 'npc';
  readonly decisionType: AIDecisionType;
  readonly context: AIContext;
  readonly alternatives: ReadonlyArray<DecisionAlternative>;
  readonly selectedAlternative: DecisionAlternative;
  readonly confidence: number; // 0-1
  readonly reasoning: string;
  readonly createdAt: Date;
  readonly executedAt?: Date;
  readonly outcome?: DecisionOutcome;
}
```

#### 5.1.2 å€¼å¯¹è±¡è®¾è®¡ï¼ˆä¸å¯å˜æ€§ï¼‰

```typescript
// å…¬ä¼šèµ„æºå€¼å¯¹è±¡
export class GuildResources {
  private constructor(
    private readonly _gold: number,
    private readonly _reputation: number,
    private readonly _influence: number,
    private readonly _materials: ReadonlyMap<string, number>
  ) {
    // ä¸å˜æ€§éªŒè¯
    if (_gold < 0 || _reputation < 0 || _influence < 0) {
      throw new Error('Resources cannot be negative');
    }
  }

  static create(params: {
    gold: number;
    reputation: number;
    influence: number;
    materials?: Map<string, number>;
  }): GuildResources {
    return new GuildResources(
      params.gold,
      params.reputation,
      params.influence,
      params.materials || new Map()
    );
  }

  // ä¸å¯å˜æ“ä½œ
  addGold(amount: number): GuildResources {
    return new GuildResources(
      this._gold + amount,
      this._reputation,
      this._influence,
      this._materials
    );
  }

  spendGold(amount: number): GuildResources {
    if (amount > this._gold) {
      throw new Error('Insufficient gold');
    }
    return this.addGold(-amount);
  }

  // åªè¯»è®¿é—®å™¨
  get gold(): number {
    return this._gold;
  }
  get reputation(): number {
    return this._reputation;
  }
  get influence(): number {
    return this._influence;
  }
  get materials(): ReadonlyMap<string, number> {
    return this._materials;
  }
}

// æˆå‘˜æŠ€èƒ½å€¼å¯¹è±¡
export class MemberSkills {
  private constructor(
    private readonly skills: ReadonlyMap<SkillType, SkillLevel>
  ) {}

  static fromObject(skills: Record<SkillType, number>): MemberSkills {
    const skillMap = new Map(Object.entries(skills) as [SkillType, number][]);
    return new MemberSkills(skillMap);
  }

  getSkillLevel(skill: SkillType): SkillLevel {
    return this.skills.get(skill) || 0;
  }

  improveSkill(skill: SkillType, improvement: number): MemberSkills {
    const newSkills = new Map(this.skills);
    const current = newSkills.get(skill) || 0;
    newSkills.set(skill, Math.min(100, current + improvement)); // æŠ€èƒ½ä¸Šé™100
    return new MemberSkills(newSkills);
  }
}
```

### 5.2 å­˜å‚¨ç«¯å£æ¥å£å®šä¹‰ï¼ˆå…ˆæ¥å£ï¼Œåå®ç°ï¼‰

#### 5.2.1 RepositoryæŠ½è±¡æ¥å£

```typescript
// é€šç”¨Repositoryæ¥å£
export interface Repository<TEntity, TId> {
  findById(id: TId): Promise<TEntity | null>;
  findAll(): Promise<TEntity[]>;
  save(entity: TEntity): Promise<TEntity>;
  delete(id: TId): Promise<void>;
  exists(id: TId): Promise<boolean>;
}

// å…¬ä¼šRepositoryæ¥å£
export interface GuildRepository extends Repository<Guild, GuildId> {
  findByName(name: string): Promise<Guild | null>;
  findByLeader(leaderId: MemberId): Promise<Guild[]>;
  findActiveGuilds(): Promise<Guild[]>;
  findGuildsWithMemberCount(min: number, max: number): Promise<Guild[]>;

  // èšåˆæ“ä½œ
  getGuildWithMembers(guildId: GuildId): Promise<Guild | null>;
  updateGuildResources(
    guildId: GuildId,
    resources: GuildResources
  ): Promise<void>;
}

// æˆå‘˜Repositoryæ¥å£
export interface MemberRepository extends Repository<Member, MemberId> {
  findByGuild(guildId: GuildId): Promise<Member[]>;
  findByName(name: string): Promise<Member[]>;
  findActiveMembers(): Promise<Member[]>;
  findMembersWithSkill(skill: SkillType, minLevel: number): Promise<Member[]>;

  // å…³ç³»æŸ¥è¯¢
  findRelatedMembers(
    memberId: MemberId,
    relationshipType: RelationshipType
  ): Promise<Member[]>;
  updateMemberRelationships(
    memberId: MemberId,
    relationships: Map<MemberId, RelationshipScore>
  ): Promise<void>;
}

// AIå†³ç­–Repositoryæ¥å£
export interface AIDecisionRepository
  extends Repository<AIDecision, DecisionId> {
  findByEntity(entityId: string, entityType: string): Promise<AIDecision[]>;
  findByType(decisionType: AIDecisionType): Promise<AIDecision[]>;
  findRecentDecisions(since: Date): Promise<AIDecision[]>;
  findSuccessfulDecisions(threshold: number): Promise<AIDecision[]>;

  // å­¦ä¹ æ•°æ®æŸ¥è¯¢
  getDecisionPatterns(
    entityType: string,
    context: AIContext
  ): Promise<DecisionPattern[]>;
  updateDecisionOutcome(
    decisionId: DecisionId,
    outcome: DecisionOutcome
  ): Promise<void>;
}
```

#### 5.2.2 æ•°æ®è®¿é—®ç«¯å£ï¼ˆPortï¼‰

```typescript
// æ•°æ®åº“è¿æ¥ç«¯å£
export interface DatabasePort {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  beginTransaction(): Promise<Transaction>;
  isConnected(): boolean;

  // æŸ¥è¯¢æ¥å£
  query<T>(sql: string, params?: any[]): Promise<T[]>;
  queryOne<T>(sql: string, params?: any[]): Promise<T | null>;
  execute(sql: string, params?: any[]): Promise<{ affectedRows: number }>;

  // æ‰¹é‡æ“ä½œ
  executeBatch(operations: BatchOperation[]): Promise<BatchResult>;
}

// æ–‡ä»¶å­˜å‚¨ç«¯å£
export interface FileStoragePort {
  saveFile(path: string, content: Buffer | string): Promise<void>;
  loadFile(path: string): Promise<Buffer | null>;
  deleteFile(path: string): Promise<void>;
  exists(path: string): Promise<boolean>;
  listFiles(directory: string, pattern?: RegExp): Promise<string[]>;

  // å­˜æ¡£ä¸“ç”¨æ–¹æ³•
  saveGameData(slot: string, data: GameSaveData): Promise<void>;
  loadGameData(slot: string): Promise<GameSaveData | null>;
  getSaveSlots(): Promise<SaveSlotInfo[]>;
}

// ç¼“å­˜ç«¯å£
export interface CachePort {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  exists(key: string): Promise<boolean>;
  clear(): Promise<void>;

  // æ‰¹é‡æ“ä½œ
  getMultiple<T>(keys: string[]): Promise<Map<string, T>>;
  setMultiple<T>(entries: Map<string, T>, ttl?: number): Promise<void>;
}
```

### 5.3 æ•°æ®å®Œæ•´æ€§ä¸ä¸€è‡´æ€§ç­–ç•¥

#### 5.3.1 å‹¾ç¨½å…³ç³»éªŒè¯å¼•æ“

```typescript
// æ•°æ®å®Œæ•´æ€§éªŒè¯å™¨
export class DataIntegrityValidator {
  private validationRules: ValidationRule[] = [];

  constructor() {
    this.initializeValidationRules();
  }

  async validateEntity<T>(
    entity: T,
    entityType: string
  ): Promise<ValidationResult> {
    const applicableRules = this.validationRules.filter(rule =>
      rule.appliesToEntityType(entityType)
    );

    const results = await Promise.all(
      applicableRules.map(rule => rule.validate(entity))
    );

    return this.aggregateValidationResults(results);
  }

  private initializeValidationRules(): void {
    // å…¬ä¼š-æˆå‘˜å…³ç³»ä¸€è‡´æ€§
    this.validationRules.push(
      new ValidationRule(
        'guild-member-consistency',
        ['Guild', 'Member'],
        async (entity: any) => {
          if (entity.type === 'Guild') {
            // éªŒè¯å…¬ä¼šæˆå‘˜åˆ—è¡¨ä¸å®é™…æˆå‘˜è®°å½•ä¸€è‡´
            const guild = entity as Guild;
            const actualMembers = await this.memberRepository.findByGuild(
              guild.id
            );
            const memberIdsInGuild = new Set(guild.members.map(m => m.id));
            const actualMemberIds = new Set(actualMembers.map(m => m.id));

            if (!this.setsEqual(memberIdsInGuild, actualMemberIds)) {
              return {
                valid: false,
                error: `Guild ${guild.id} member list inconsistency`,
                details: {
                  guildMemberIds: Array.from(memberIdsInGuild),
                  actualMemberIds: Array.from(actualMemberIds),
                },
              };
            }
          }
          return { valid: true };
        }
      )
    );

    // èµ„æºä½™é¢éªŒè¯
    this.validationRules.push(
      new ValidationRule(
        'resource-balance-validation',
        ['Guild'],
        async (guild: Guild) => {
          const resources = guild.resources;

          // éªŒè¯èµ„æºä¸ä¸ºè´Ÿæ•°
          if (
            resources.gold < 0 ||
            resources.reputation < 0 ||
            resources.influence < 0
          ) {
            return {
              valid: false,
              error: `Guild ${guild.id} has negative resources`,
              details: { resources: resources },
            };
          }

          // éªŒè¯èµ„æºæ€»é‡ä¸è¶…è¿‡ä¸Šé™
          const totalValue =
            resources.gold + resources.reputation + resources.influence;
          if (totalValue > 1000000) {
            // å‡è®¾ä¸Šé™
            return {
              valid: false,
              error: `Guild ${guild.id} resource total exceeds limit`,
              details: { totalValue, limit: 1000000 },
            };
          }

          return { valid: true };
        }
      )
    );
  }
}

// è·¨å¼•ç”¨å®Œæ•´æ€§å¼•æ“
export class CrossReferenceIntegrityEngine {
  async validateCrossReferences(
    entities: Map<string, any>
  ): Promise<CrossReferenceResult> {
    const results: CrossReferenceCheck[] = [];

    // å…¬ä¼š-æˆå‘˜å¼•ç”¨å®Œæ•´æ€§
    results.push(await this.validateGuildMemberReferences(entities));

    // AIå†³ç­–-å®ä½“å¼•ç”¨å®Œæ•´æ€§
    results.push(await this.validateAIDecisionReferences(entities));

    // æ´»åŠ¨-å‚ä¸è€…å¼•ç”¨å®Œæ•´æ€§
    results.push(await this.validateActivityParticipantReferences(entities));

    return {
      overallValid: results.every(r => r.valid),
      checks: results,
      errorCount: results.filter(r => !r.valid).length,
      warningCount: results.filter(r => r.warnings.length > 0).length,
    };
  }

  private async validateGuildMemberReferences(
    entities: Map<string, any>
  ): Promise<CrossReferenceCheck> {
    const guilds = Array.from(entities.values()).filter(
      e => e.type === 'Guild'
    );
    const members = Array.from(entities.values()).filter(
      e => e.type === 'Member'
    );

    const errors: string[] = [];
    const warnings: string[] = [];

    for (const guild of guilds) {
      // éªŒè¯å…¬ä¼šé¢†è¢–å­˜åœ¨
      const leader = members.find(m => m.id === guild.leaderId);
      if (!leader) {
        errors.push(`Guild ${guild.id} leader ${guild.leaderId} not found`);
      }

      // éªŒè¯æˆå‘˜åå‘å¼•ç”¨
      for (const member of guild.members) {
        const actualMember = members.find(m => m.id === member.id);
        if (!actualMember) {
          errors.push(
            `Guild ${guild.id} references non-existent member ${member.id}`
          );
        } else if (actualMember.guildId !== guild.id) {
          errors.push(`Member ${member.id} guild reference mismatch`);
        }
      }
    }

    return {
      checkName: 'guild-member-references',
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }
}
```

### 5.4 æ•°æ®ç‰ˆæœ¬æ§åˆ¶ä¸è¿ç§»

#### 5.4.1 æ•°æ®æ¨¡å‹ç‰ˆæœ¬ç®¡ç†

```typescript
// æ•°æ®æ¨¡å‹ç‰ˆæœ¬å®šä¹‰
export interface DataModelVersion {
  version: string;
  appliedAt: Date;
  migrations: Migration[];
  rollbackMigrations: Migration[];
  checksum: string;
}

// è¿ç§»æ¥å£
export interface Migration {
  id: string;
  version: string;
  description: string;
  up(): Promise<void>;
  down(): Promise<void>;
  validate(): Promise<boolean>;
}

// æ•°æ®è¿ç§»ç®¡ç†å™¨
export class DataMigrationManager {
  private migrations: Map<string, Migration> = new Map();
  private currentVersion: string = '1.0.0';

  registerMigration(migration: Migration): void {
    this.migrations.set(migration.id, migration);
  }

  async migrateToVersion(targetVersion: string): Promise<MigrationResult> {
    const currentVersion = await this.getCurrentVersion();
    const migrationsToApply = this.getMigrationPath(
      currentVersion,
      targetVersion
    );

    const results: MigrationStepResult[] = [];

    for (const migration of migrationsToApply) {
      try {
        // éªŒè¯è¿ç§»å‰ææ¡ä»¶
        if (!(await migration.validate())) {
          throw new Error(`Migration ${migration.id} validation failed`);
        }

        // æ‰§è¡Œè¿ç§»
        await migration.up();

        // è®°å½•è¿ç§»ç»“æœ
        results.push({
          migrationId: migration.id,
          success: true,
          duration: Date.now(), // ç®€åŒ–ç¤ºä¾‹
        });
      } catch (error) {
        // å¤±è´¥æ—¶å›æ»š
        await this.rollbackMigrations(results.filter(r => r.success));

        return {
          success: false,
          error: error.message,
          appliedMigrations: results,
          currentVersion: await this.getCurrentVersion(),
        };
      }
    }

    // æ›´æ–°å½“å‰ç‰ˆæœ¬
    await this.updateCurrentVersion(targetVersion);

    return {
      success: true,
      appliedMigrations: results,
      currentVersion: targetVersion,
    };
  }
}
```

### 5.5 **ç¬¬5ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 5.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: æ•°æ®æ¨¡å‹éªŒè¯ã€å€¼å¯¹è±¡ä¸å˜æ€§ã€Repositoryæ¥å£å¥‘çº¦
- **é›†æˆæµ‹è¯•**: æ•°æ®åº“è¿æ¥ã€è·¨å¼•ç”¨å®Œæ•´æ€§éªŒè¯ã€è¿ç§»è„šæœ¬éªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´æ•°æ®æµï¼ˆåˆ›å»ºâ†’ä¿å­˜â†’æŸ¥è¯¢â†’æ›´æ–°â†’åˆ é™¤ï¼‰
- **ä¸“é¡¹æµ‹è¯•**: å¤§é‡æ•°æ®æ€§èƒ½æµ‹è¯•ã€å¹¶å‘è®¿é—®æµ‹è¯•ã€æ•°æ®ä¸€è‡´æ€§æµ‹è¯•

#### 5.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('æ•°æ®æ¨¡å‹ä¸å­˜å‚¨ç«¯å£å†’çƒŸæµ‹è¯•', () => {
  it('æ ¸å¿ƒå®ä½“åº”èƒ½æ­£ç¡®åˆ›å»ºå’ŒéªŒè¯', async () => {
    // åˆ›å»ºå…¬ä¼šèµ„æºå€¼å¯¹è±¡
    const resources = GuildResources.create({
      gold: 1000,
      reputation: 50,
      influence: 25,
    });

    expect(resources.gold).toBe(1000);
    expect(resources.reputation).toBe(50);

    // æµ‹è¯•ä¸å¯å˜æ€§
    const newResources = resources.addGold(500);
    expect(newResources.gold).toBe(1500);
    expect(resources.gold).toBe(1000); // åŸå¯¹è±¡ä¸å˜
  });

  it('Repositoryæ¥å£åº”èƒ½æ­£å¸¸CRUDæ“ä½œ', async () => {
    const guildRepo = container.resolve<GuildRepository>('GuildRepository');

    // åˆ›å»ºæµ‹è¯•å…¬ä¼š
    const guild = createTestGuild();

    // ä¿å­˜
    const saved = await guildRepo.save(guild);
    expect(saved.id).toBeTruthy();

    // æŸ¥è¯¢
    const found = await guildRepo.findById(saved.id);
    expect(found).toBeTruthy();
    expect(found!.name).toBe(guild.name);

    // åˆ é™¤
    await guildRepo.delete(saved.id);
    const deleted = await guildRepo.findById(saved.id);
    expect(deleted).toBeNull();
  });

  it('æ•°æ®å®Œæ•´æ€§éªŒè¯åº”èƒ½æ£€æµ‹ä¸ä¸€è‡´', async () => {
    const validator = new DataIntegrityValidator();

    // åˆ›å»ºä¸ä¸€è‡´çš„æµ‹è¯•æ•°æ®
    const guild = createTestGuild();
    guild.members.push(createTestMember()); // æ·»åŠ æˆå‘˜ä½†ä¸è®¾ç½®guildId

    const result = await validator.validateEntity(guild, 'Guild');
    expect(result.valid).toBe(false);
    expect(result.errors.length).toBeGreaterThan(0);
  });

  it('æ•°æ®è¿ç§»åº”èƒ½æ­£ç¡®æ‰§è¡Œ', async () => {
    const migrationManager = new DataMigrationManager();

    // æ³¨å†Œæµ‹è¯•è¿ç§»
    migrationManager.registerMigration(new TestMigration('1.0.0', '1.1.0'));

    // æ‰§è¡Œè¿ç§»
    const result = await migrationManager.migrateToVersion('1.1.0');
    expect(result.success).toBe(true);
    expect(result.currentVersion).toBe('1.1.0');
  });
});
```

#### 5.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- æ•°æ®æ¨¡å‹è¦†ç›–ç‡ï¼šâ‰¥80% (åŸºçº¿æ ‡å‡†)
- Repositoryå®ç°è¦†ç›–ç‡ï¼šâ‰¥75% (æ•°æ®è®¿é—®å±‚)
- æ•°æ®å®Œæ•´æ€§éªŒè¯è¦†ç›–ç‡ï¼šâ‰¥85% (critical_modules.data_integrityè¦æ±‚)

---

## âš¡ **ç¬¬6ç« ï¼šè¿è¡Œæ—¶è§†å›¾ï¼ˆä¸»/æ¸²æŸ“/æ¸¸æˆå¾ªç¯ã€çŠ¶æ€æœºã€é”™è¯¯è·¯å¾„ï¼‰**

### 6.1 ä¸‰è¿›ç¨‹è¿è¡Œæ—¶æ¶æ„

#### 6.1.1 Electronä¸‰è¿›ç¨‹åä½œæ¨¡å‹

```mermaid
graph TB
    subgraph "ä¸»è¿›ç¨‹ (Node.js Environment)"
        MP[Main Process]
        WM[Window Manager]
        FM[File Manager]
        DB[Database Manager]
        SM[Security Manager]
    end

    subgraph "æ¸²æŸ“è¿›ç¨‹ (Chromium Environment)"
        RP[Renderer Process]
        UI[React UI Layer]
        GE[Phaser Game Engine]
        EB[Event Bus]
        SM2[State Manager]
    end

    subgraph "AI Workerè¿›ç¨‹ (Web Worker)"
        AW[AI Worker]
        DE[Decision Engine]
        LE[Learning Engine]
        BE[Behavior Engine]
    end

    MP <--> |IPC| RP
    RP <--> |MessagePort| AW
    MP --> |File I/O| DB
    RP --> |Commands| UI
    RP --> |Game Logic| GE
```

#### 6.1.2 ä¸»è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
// ä¸»è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨
export class MainProcessLifecycleManager {
  private windows: Map<string, BrowserWindow> = new Map();
  private isShuttingDown = false;

  async initialize(): Promise<void> {
    // åº”ç”¨å¯åŠ¨åºåˆ—
    await this.initializeSecurity(); // 1. å®‰å…¨åŸºçº¿
    await this.initializeLogging(); // 2. æ—¥å¿—ç³»ç»Ÿ
    await this.initializeDatabase(); // 3. æ•°æ®åº“è¿æ¥
    await this.initializeFileSystem(); // 4. æ–‡ä»¶ç³»ç»Ÿè®¿é—®
    await this.createMainWindow(); // 5. ä¸»çª—å£
    await this.setupIpcHandlers(); // 6. IPCå¤„ç†å™¨
    await this.startBackgroundServices(); // 7. åå°æœåŠ¡
  }

  private async createMainWindow(): Promise<void> {
    const mainWindow = new BrowserWindow({
      width: 1400,
      height: 900,
      minWidth: 1200,
      minHeight: 800,

      // å®‰å…¨é…ç½®ï¼ˆä¸å¯å›é€€ï¼‰
      webPreferences: SECURITY_CONFIG,

      // æ€§èƒ½ä¼˜åŒ–
      show: false, // å»¶è¿Ÿæ˜¾ç¤ºï¼Œé¿å…ç™½å±
      backgroundColor: '#1a1a1a', // æ·±è‰²èƒŒæ™¯
      titleBarStyle: 'hidden', // è‡ªå®šä¹‰æ ‡é¢˜æ 

      // çª—å£è¡Œä¸º
      center: true,
      resizable: true,
      maximizable: true,
      fullscreenable: true,
    });

    // çª—å£äº‹ä»¶å¤„ç†
    mainWindow.once('ready-to-show', () => {
      mainWindow.show();
      mainWindow.focus();
    });

    mainWindow.on('closed', () => {
      this.windows.delete('main');
      if (!this.isShuttingDown) {
        app.quit();
      }
    });

    this.windows.set('main', mainWindow);

    // åŠ è½½åº”ç”¨å†…å®¹
    if (process.env.NODE_ENV === 'development') {
      await mainWindow.loadURL('http://localhost:3000');
      mainWindow.webContents.openDevTools();
    } else {
      await mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
    }
  }

  async shutdown(): Promise<void> {
    this.isShuttingDown = true;

    // ä¼˜é›…å…³é—­åºåˆ—
    await this.saveApplicationState(); // 1. ä¿å­˜çŠ¶æ€
    await this.stopBackgroundServices(); // 2. åœæ­¢åå°æœåŠ¡
    await this.closeAllWindows(); // 3. å…³é—­çª—å£
    await this.cleanupResources(); // 4. æ¸…ç†èµ„æº
    await this.closeDatabaseConnections(); // 5. å…³é—­æ•°æ®åº“

    app.quit();
  }
}
```

### 6.2 æ¸²æŸ“è¿›ç¨‹æ¸¸æˆå¾ªç¯æ¶æ„

#### 6.2.1 React-Phaseråä½œæ¸¸æˆå¾ªç¯

```typescript
// æ¸¸æˆå¾ªç¯ç®¡ç†å™¨
export class GameLoopManager {
  private gameEngine: Phaser.Game;
  private reactRoot: ReactRoot;
  private isRunning = false;
  private targetFPS = 60;
  private actualFPS = 0;
  private lastFrameTime = 0;
  private frameTimeBuffer: number[] = [];

  constructor(
    private eventBus: EventBus,
    private stateManager: StateManager
  ) {}

  async initialize(): Promise<void> {
    // åˆå§‹åŒ–Phaseræ¸¸æˆå¼•æ“
    this.gameEngine = new Phaser.Game({
      type: Phaser.WEBGL,
      width: 1200,
      height: 800,
      parent: 'game-container',
      backgroundColor: '#2c2c2c',

      // æ€§èƒ½é…ç½®
      fps: {
        target: this.targetFPS,
        forceSetTimeOut: true,
        smoothStep: true,
      },

      // æ¸²æŸ“é…ç½®
      render: {
        antialias: true,
        pixelArt: false,
        roundPixels: false,
        transparent: false,
        batchSize: 4096,
      },

      // ç‰©ç†å¼•æ“é…ç½®
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: process.env.NODE_ENV === 'development',
        },
      },

      // åœºæ™¯é…ç½®
      scene: [MainMenuScene, GameScene, UIOverlayScene, PauseScene],
    });

    // è®¾ç½®æ¸¸æˆå¾ªç¯ç›‘å¬
    this.setupGameLoopMonitoring();

    // è®¾ç½®React-Phaseré€šä¿¡
    this.setupReactPhaserBridge();
  }

  private setupGameLoopMonitoring(): void {
    let frameCount = 0;
    let lastFPSCheck = Date.now();

    // æ¸¸æˆå¾ªç¯ç›‘æ§
    this.gameEngine.events.on('prestep', (time: number, delta: number) => {
      frameCount++;

      // è®¡ç®—å®é™…FPS
      const now = Date.now();
      if (now - lastFPSCheck >= 1000) {
        this.actualFPS = frameCount;
        frameCount = 0;
        lastFPSCheck = now;

        // æ€§èƒ½å‘Šè­¦
        if (this.actualFPS < this.targetFPS * 0.9) {
          this.eventBus.publish('performance:fps-drop', {
            actualFPS: this.actualFPS,
            targetFPS: this.targetFPS,
            severity:
              this.actualFPS < this.targetFPS * 0.5 ? 'critical' : 'warning',
          });
        }
      }

      // å¸§æ—¶é—´åˆ†æ
      this.trackFrameTime(delta);
    });
  }

  private trackFrameTime(delta: number): void {
    this.frameTimeBuffer.push(delta);
    if (this.frameTimeBuffer.length > 60) {
      // ä¿æŒ60å¸§å†å²
      this.frameTimeBuffer.shift();
    }

    // æ£€æµ‹å¸§æ—¶é—´å¼‚å¸¸
    if (delta > 33) {
      // è¶…è¿‡33msè¡¨ç¤ºä½äº30fps
      this.eventBus.publish('performance:frame-drop', {
        frameTime: delta,
        averageFrameTime: this.getAverageFrameTime(),
        timestamp: Date.now(),
      });
    }
  }

  start(): void {
    if (!this.isRunning) {
      this.isRunning = true;
      this.gameEngine.scene.start('MainMenuScene');
      this.eventBus.publish('game:loop-started', { timestamp: Date.now() });
    }
  }

  pause(): void {
    if (this.isRunning) {
      this.gameEngine.scene.pause();
      this.eventBus.publish('game:paused', { timestamp: Date.now() });
    }
  }

  resume(): void {
    if (this.isRunning) {
      this.gameEngine.scene.resume();
      this.eventBus.publish('game:resumed', { timestamp: Date.now() });
    }
  }
}
```

### 6.3 AI Workerè¿ç®—å¾ªç¯

#### 6.3.1 AIå†³ç­–å¾ªç¯æ¶æ„

```typescript
// AI Workerè¿ç®—å¾ªç¯ï¼ˆè¿è¡Œåœ¨Web Workerä¸­ï¼‰
export class AIComputationLoop {
  private isRunning = false;
  private decisionQueue: AIDecisionRequest[] = [];
  private processingBatch: AIDecisionRequest[] = [];
  private batchSize = 10;
  private processingInterval = 100; // 100mså¤„ç†å‘¨æœŸ

  constructor(
    private decisionEngine: DecisionEngine,
    private learningEngine: LearningEngine,
    private behaviorEngine: BehaviorEngine
  ) {}

  start(): void {
    if (!this.isRunning) {
      this.isRunning = true;
      this.scheduleNextProcessing();
    }
  }

  private async scheduleNextProcessing(): Promise<void> {
    while (this.isRunning) {
      const startTime = performance.now();

      try {
        // 1. æ‰¹é‡å¤„ç†AIå†³ç­–è¯·æ±‚
        await this.processBatchDecisions();

        // 2. æ›´æ–°è¡Œä¸ºæ¨¡å‹
        await this.updateBehaviorModels();

        // 3. æ‰§è¡Œå­¦ä¹ ç®—æ³•
        await this.runLearningCycle();

        // 4. å‘é€ç»“æœå›ä¸»çº¿ç¨‹
        await this.sendResults();

      } catch (error) {
        this.handleProcessingError(error);
      }

      // æ§åˆ¶å¤„ç†é¢‘ç‡
      const processingTime = performance.now() - startTime;
      const remainingTime = Math.max(0, this.processingInterval - processingTime);

      await this.sleep(remainingTime);
    }
  }

  private async processBatchDecisions(): Promise<void> {
    if (this.decisionQueue.length === 0) return;

    // å–å‡ºæ‰¹é‡å¤„ç†çš„å†³ç­–è¯·æ±‚
    this.processingBatch = this.decisionQueue.splice(0, this.batchSize);

    const decisions = await Promise.all(
      this.processingBatch.map(async (request) => {
        try {
          return await this.decisionEngine.makeDecision(request.context, request.options);
        } catch (error) {
          return this.createErrorDecision(request, error);
        }
      })
    );

    // å‘é€å†³ç­–ç»“æœ
    self.postMessage({
      type: 'ai-decisions-completed',
      payload: {
        decisions,
        processingTime: performance.now(),
        batchSize: this.processingBatch.length
      }
    });

    this.processingBatch = [];
  }

  private async updateBehaviorModels(): Promise<void> {
    // æ›´æ–°NPCè¡Œä¸ºæ¨¡å‹
    const behaviorUpdates = await this.behaviorEngine.updateModels();

    if (behaviorUpdates.length > 0) {
      self.postMessage({
        type: 'behavior-models-updated',
        payload: { updates: behaviorUpdates }
      });
    }
  }

  // æ¥æ”¶ä¸»çº¿ç¨‹æ¶ˆæ¯
  addEventListener('message', (event) => {
    const { type, payload } = event.data;

    switch (type) {
      case 'ai-decision-request':
        this.decisionQueue.push(payload);
        break;

      case 'learning-data':
        this.learningEngine.processLearningData(payload.experiences);
        break;

      case 'behavior-update':
        this.behaviorEngine.updateBehavior(payload.entityId, payload.behavior);
        break;

      case 'shutdown':
        this.stop();
        break;
    }
  });
}
```

### 6.4 çŠ¶æ€æœºä¸é”™è¯¯è·¯å¾„è®¾è®¡

#### 6.4.1 å…¨å±€åº”ç”¨çŠ¶æ€æœº

```typescript
// åº”ç”¨çŠ¶æ€æœºå®šä¹‰
export enum AppState {
  INITIALIZING = 'initializing',
  LOADING = 'loading',
  MENU = 'menu',
  GAME_RUNNING = 'game_running',
  GAME_PAUSED = 'game_paused',
  SAVING = 'saving',
  ERROR = 'error',
  SHUTTING_DOWN = 'shutting_down',
}

export interface AppStateTransition {
  from: AppState;
  to: AppState;
  trigger: string;
  condition?: (context: any) => boolean;
  action?: (context: any) => Promise<void>;
}

// çŠ¶æ€æœºç®¡ç†å™¨
export class AppStateMachine {
  private currentState: AppState = AppState.INITIALIZING;
  private transitions: AppStateTransition[] = [];
  private stateHistory: { state: AppState; timestamp: number }[] = [];

  constructor(private eventBus: EventBus) {
    this.defineTransitions();
    this.setupEventListeners();
  }

  private defineTransitions(): void {
    this.transitions = [
      // åˆå§‹åŒ–å®Œæˆ â†’ èœå•
      {
        from: AppState.INITIALIZING,
        to: AppState.LOADING,
        trigger: 'initialization-complete',
        action: this.handleInitializationComplete.bind(this),
      },

      // åŠ è½½å®Œæˆ â†’ èœå•
      {
        from: AppState.LOADING,
        to: AppState.MENU,
        trigger: 'loading-complete',
        action: this.handleLoadingComplete.bind(this),
      },

      // å¼€å§‹æ¸¸æˆ
      {
        from: AppState.MENU,
        to: AppState.GAME_RUNNING,
        trigger: 'start-game',
        condition: context => context.saveSlot !== null,
        action: this.handleStartGame.bind(this),
      },

      // æš‚åœæ¸¸æˆ
      {
        from: AppState.GAME_RUNNING,
        to: AppState.GAME_PAUSED,
        trigger: 'pause-game',
        action: this.handlePauseGame.bind(this),
      },

      // æ¢å¤æ¸¸æˆ
      {
        from: AppState.GAME_PAUSED,
        to: AppState.GAME_RUNNING,
        trigger: 'resume-game',
        action: this.handleResumeGame.bind(this),
      },

      // ä¿å­˜æ¸¸æˆ
      {
        from: AppState.GAME_RUNNING,
        to: AppState.SAVING,
        trigger: 'save-game',
        action: this.handleSaveGame.bind(this),
      },

      // ä¿å­˜å®Œæˆ
      {
        from: AppState.SAVING,
        to: AppState.GAME_RUNNING,
        trigger: 'save-complete',
      },

      // é”™è¯¯å¤„ç†
      {
        from: AppState.GAME_RUNNING,
        to: AppState.ERROR,
        trigger: 'critical-error',
        action: this.handleCriticalError.bind(this),
      },

      // ä»é”™è¯¯æ¢å¤
      {
        from: AppState.ERROR,
        to: AppState.MENU,
        trigger: 'error-recovered',
        action: this.handleErrorRecovery.bind(this),
      },
    ];
  }

  async transition(trigger: string, context?: any): Promise<boolean> {
    const validTransitions = this.transitions.filter(
      t => t.from === this.currentState && t.trigger === trigger
    );

    if (validTransitions.length === 0) {
      console.warn(`Invalid transition: ${this.currentState} -> ${trigger}`);
      return false;
    }

    for (const transition of validTransitions) {
      // æ£€æŸ¥æ¡ä»¶
      if (transition.condition && !transition.condition(context)) {
        continue;
      }

      // è®°å½•çŠ¶æ€å†å²
      this.stateHistory.push({
        state: this.currentState,
        timestamp: Date.now(),
      });

      // æ‰§è¡Œè½¬æ¢åŠ¨ä½œ
      if (transition.action) {
        try {
          await transition.action(context);
        } catch (error) {
          // è½¬æ¢å¤±è´¥ï¼Œæ¢å¤çŠ¶æ€
          console.error(`State transition action failed: ${error.message}`);
          return false;
        }
      }

      // æ›´æ–°çŠ¶æ€
      const previousState = this.currentState;
      this.currentState = transition.to;

      // å‘å¸ƒçŠ¶æ€å˜æ›´äº‹ä»¶
      this.eventBus.publish('app:state-changed', {
        previous: previousState,
        current: this.currentState,
        trigger,
        context,
      });

      return true;
    }

    return false;
  }

  private async handleCriticalError(context: { error: Error }): Promise<void> {
    // ä¿å­˜é”™è¯¯çŠ¶æ€
    await this.saveErrorState(context.error);

    // å°è¯•ä¿å­˜ç”¨æˆ·æ•°æ®
    await this.emergencySave();

    // é€šçŸ¥ç”¨æˆ·
    this.eventBus.publish('ui:show-error-dialog', {
      error: context.error,
      canRecover: this.canRecoverFromError(context.error),
    });
  }
}
```

#### 6.4.2 é”™è¯¯æ¢å¤æœºåˆ¶

```typescript
// é”™è¯¯æ¢å¤ç®¡ç†å™¨
export class ErrorRecoveryManager {
  private recoveryStrategies: Map<string, RecoveryStrategy> = new Map();

  constructor(
    private stateManager: StateManager,
    private eventBus: EventBus
  ) {
    this.initializeRecoveryStrategies();
  }

  private initializeRecoveryStrategies(): void {
    // å†…å­˜ä¸è¶³æ¢å¤ç­–ç•¥
    this.recoveryStrategies.set('memory-exhausted', {
      canRecover: true,
      priority: 'high',
      action: async () => {
        // 1. æ¸…ç†ç¼“å­˜
        await this.clearMemoryCache();

        // 2. é™ä½æ¸¸æˆè´¨é‡è®¾ç½®
        await this.reduceGameQuality();

        // 3. å¼ºåˆ¶åƒåœ¾å›æ”¶
        if (global.gc) {
          global.gc();
        }

        return {
          success: true,
          message: 'Memory cleaned, game quality reduced',
        };
      },
    });

    // æ•°æ®åº“è¿æ¥å¤±è´¥æ¢å¤ç­–ç•¥
    this.recoveryStrategies.set('database-connection-failed', {
      canRecover: true,
      priority: 'critical',
      action: async () => {
        // 1. é‡æ–°è¿æ¥æ•°æ®åº“
        await this.reconnectDatabase();

        // 2. éªŒè¯æ•°æ®å®Œæ•´æ€§
        const integrityCheck = await this.verifyDataIntegrity();

        if (!integrityCheck.valid) {
          // 3. ä»å¤‡ä»½æ¢å¤
          await this.restoreFromBackup();
        }

        return { success: true, message: 'Database connection restored' };
      },
    });

    // AIè®¡ç®—è¶…æ—¶æ¢å¤ç­–ç•¥
    this.recoveryStrategies.set('ai-computation-timeout', {
      canRecover: true,
      priority: 'medium',
      action: async () => {
        // 1. é‡å¯AI Worker
        await this.restartAIWorker();

        // 2. é™ä½AIå¤æ‚åº¦
        await this.reduceAIComplexity();

        // 3. æ¸…ç†ç§¯å‹çš„AIä»»åŠ¡
        await this.clearAIPendingTasks();

        return {
          success: true,
          message: 'AI system recovered with reduced complexity',
        };
      },
    });
  }

  async handleError(error: Error, context?: any): Promise<RecoveryResult> {
    const errorType = this.classifyError(error);
    const strategy = this.recoveryStrategies.get(errorType);

    if (!strategy) {
      return {
        success: false,
        canRecover: false,
        message: 'No recovery strategy available',
      };
    }

    if (!strategy.canRecover) {
      return {
        success: false,
        canRecover: false,
        message: 'Error is not recoverable',
      };
    }

    try {
      const result = await strategy.action();

      // è®°å½•æ¢å¤æˆåŠŸ
      this.eventBus.publish('error:recovery-success', {
        errorType,
        strategy: strategy,
        result,
      });

      return { success: true, canRecover: true, ...result };
    } catch (recoveryError) {
      // è®°å½•æ¢å¤å¤±è´¥
      this.eventBus.publish('error:recovery-failed', {
        originalError: error,
        recoveryError,
        errorType,
      });

      return {
        success: false,
        canRecover: false,
        message: `Recovery failed: ${recoveryError.message}`,
      };
    }
  }

  private classifyError(error: Error): string {
    // é”™è¯¯åˆ†ç±»é€»è¾‘
    if (error.message.includes('memory') || error.name === 'OutOfMemoryError') {
      return 'memory-exhausted';
    }

    if (
      error.message.includes('database') ||
      error.message.includes('SQLite')
    ) {
      return 'database-connection-failed';
    }

    if (error.message.includes('AI') || error.message.includes('timeout')) {
      return 'ai-computation-timeout';
    }

    return 'unknown-error';
  }
}
```

### 6.5 **ç¬¬6ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 6.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: çŠ¶æ€æœºè½¬æ¢é€»è¾‘ã€é”™è¯¯æ¢å¤ç­–ç•¥ã€æ¸¸æˆå¾ªç¯æ ¸å¿ƒç®—æ³•
- **é›†æˆæµ‹è¯•**: ä¸‰è¿›ç¨‹åä½œéªŒè¯ã€çŠ¶æ€åŒæ­¥æµ‹è¯•ã€é”™è¯¯æ¢å¤æµç¨‹éªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´è¿è¡Œæ—¶æµç¨‹ï¼ˆå¯åŠ¨â†’è¿è¡Œâ†’æš‚åœâ†’æ¢å¤â†’å…³é—­ï¼‰
- **ä¸“é¡¹æµ‹è¯•**: æ€§èƒ½å‹åŠ›æµ‹è¯•ã€å†…å­˜æ³„æ¼æµ‹è¯•ã€é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æµ‹è¯•

#### 6.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('è¿è¡Œæ—¶è§†å›¾å†’çƒŸæµ‹è¯•', () => {
  it('åº”ç”¨çŠ¶æ€æœºåº”èƒ½æ­£ç¡®å¤„ç†çŠ¶æ€è½¬æ¢', async () => {
    const stateMachine = new AppStateMachine(eventBus);

    // æµ‹è¯•æ­£å¸¸çŠ¶æ€è½¬æ¢
    expect(stateMachine.getCurrentState()).toBe(AppState.INITIALIZING);

    const success = await stateMachine.transition('initialization-complete');
    expect(success).toBe(true);
    expect(stateMachine.getCurrentState()).toBe(AppState.LOADING);

    // æµ‹è¯•æ¡ä»¶æ£€æŸ¥
    const invalidTransition = await stateMachine.transition('start-game', {
      saveSlot: null,
    });
    expect(invalidTransition).toBe(false); // åº”è¯¥å¤±è´¥ï¼Œå› ä¸ºæ²¡æœ‰å­˜æ¡£æ§½
  });

  it('æ¸¸æˆå¾ªç¯åº”èƒ½ç¨³å®šè¿è¡Œå¹¶ç›‘æ§æ€§èƒ½', async () => {
    const gameLoop = new GameLoopManager(eventBus, stateManager);
    await gameLoop.initialize();

    gameLoop.start();
    expect(gameLoop.isRunning()).toBe(true);

    // ç›‘æ§FPS
    await new Promise(resolve => setTimeout(resolve, 2000)); // è¿è¡Œ2ç§’
    const fps = gameLoop.getCurrentFPS();
    expect(fps).toBeGreaterThan(55); // è‡³å°‘55fps

    gameLoop.stop();
  });

  it('AI Workeråº”èƒ½æ­£å¸¸å¤„ç†è®¡ç®—è¯·æ±‚', async () => {
    const aiLoop = new AIComputationLoop(
      decisionEngine,
      learningEngine,
      behaviorEngine
    );
    aiLoop.start();

    // å‘é€æµ‹è¯•å†³ç­–è¯·æ±‚
    const decisionRequest = createTestDecisionRequest();
    aiLoop.addDecisionRequest(decisionRequest);

    // ç­‰å¾…å¤„ç†å®Œæˆ
    await waitForAIDecision(decisionRequest.id, 1000);

    const result = await getAIDecisionResult(decisionRequest.id);
    expect(result).toBeTruthy();
    expect(result.decision).toBeTruthy();

    aiLoop.stop();
  });

  it('é”™è¯¯æ¢å¤æœºåˆ¶åº”èƒ½å¤„ç†å¸¸è§é”™è¯¯', async () => {
    const recoveryManager = new ErrorRecoveryManager(stateManager, eventBus);

    // æ¨¡æ‹Ÿå†…å­˜ä¸è¶³é”™è¯¯
    const memoryError = new Error('OutOfMemoryError: Cannot allocate memory');
    const result = await recoveryManager.handleError(memoryError);

    expect(result.success).toBe(true);
    expect(result.canRecover).toBe(true);
    expect(result.message).toContain('Memory cleaned');
  });
});
```

#### 6.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- è¿è¡Œæ—¶ç®¡ç†è¦†ç›–ç‡ï¼šâ‰¥75% (åŸºçº¿æ ‡å‡†)
- çŠ¶æ€æœºé€»è¾‘è¦†ç›–ç‡ï¼šâ‰¥85% (å…³é”®ä¸šåŠ¡é€»è¾‘)
- é”™è¯¯æ¢å¤è¦†ç›–ç‡ï¼šâ‰¥80% (ç³»ç»Ÿç¨³å®šæ€§ä¿éšœ)

---

## ğŸ› ï¸ **ç¬¬7ç« ï¼šå¼€å‘ç¯å¢ƒä¸æ„å»ºï¼ˆVite/Electronã€æ‰“åŒ…ã€CIè´¨é‡é—¨ç¦ä¸æµ‹è¯•é‡‘å­—å¡”ï¼‰**

### 7.1 å¼€å‘ç¯å¢ƒé…ç½®æ ‡å‡†

#### 7.1.1 Viteé…ç½®ï¼ˆå¼€å‘æœåŠ¡å™¨ï¼‰

```typescript
// vite.config.ts - å¼€å‘ç¯å¢ƒé…ç½®
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [
    react({
      // React 19ç‰¹æ€§é…ç½®
      jsxRuntime: 'automatic',
      jsxImportSource: 'react',
      babel: {
        plugins: [
          // React Compileræ’ä»¶ï¼ˆReact 19æ–°ç‰¹æ€§ï¼‰
          [
            'babel-plugin-react-compiler',
            {
              sources: filename => filename.includes('src/'),
            },
          ],
        ],
      },
    }),
  ],

  // å¼€å‘æœåŠ¡å™¨é…ç½®
  server: {
    port: 3000,
    strictPort: true,
    cors: true,
    hmr: {
      port: 3001,
    },
  },

  // æ„å»ºé…ç½®
  build: {
    outDir: 'dist/renderer',
    assetsDir: 'assets',
    sourcemap: process.env.NODE_ENV === 'development',

    // ä»£ç åˆ†å‰²
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
      },
      output: {
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: 'assets/[name]-[hash].[ext]',
      },
    },

    // å‹ç¼©é…ç½®
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: process.env.NODE_ENV === 'production',
        drop_debugger: true,
      },
    },
  },

  // è·¯å¾„è§£æ
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@utils': resolve(__dirname, 'src/utils'),
      '@types': resolve(__dirname, 'src/types'),
      '@assets': resolve(__dirname, 'src/assets'),
    },
  },

  // å®šä¹‰å…¨å±€å˜é‡
  define: {
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version),
    __BUILD_TIME__: JSON.stringify(new Date().toISOString()),
    __GIT_COMMIT__: JSON.stringify(process.env.GIT_COMMIT || 'unknown'),
  },

  // ç¯å¢ƒå˜é‡å‰ç¼€
  envPrefix: ['VITE_', 'ELECTRON_'],
});
```

#### 7.1.2 Electronä¸»è¿›ç¨‹æ„å»ºé…ç½®

```typescript
// electron.vite.config.ts - Electronä¸“ç”¨é…ç½®
import { defineConfig, externalizeDepsPlugin } from 'electron-vite';
import { resolve } from 'path';

export default defineConfig({
  main: {
    plugins: [externalizeDepsPlugin()],
    build: {
      outDir: 'dist/main',
      lib: {
        entry: 'electron/main.ts',
        formats: ['cjs'],
      },
      rollupOptions: {
        external: ['electron', 'better-sqlite3', '@sentry/electron'],
      },
    },
    resolve: {
      alias: {
        '@shared': resolve('src/shared'),
      },
    },
  },

  preload: {
    plugins: [externalizeDepsPlugin()],
    build: {
      outDir: 'dist/preload',
      lib: {
        entry: 'electron/preload.ts',
        formats: ['cjs'],
      },
    },
  },

  renderer: {
    // ç»§æ‰¿ä¸»Viteé…ç½®
    root: '.',
    build: {
      outDir: 'dist/renderer',
    },
  },
});
```

### 7.2 æµ‹è¯•é‡‘å­—å¡”å®Œæ•´å®ç°

#### 7.2.1 æµ‹è¯•é‡‘å­—å¡”æ¶æ„æ ‡å‡†

```yaml
# æµ‹è¯•é‡‘å­—å¡”é…ç½®æ ‡å‡† (tests.config.yml)
testing_pyramid:
  # 70% å•å…ƒæµ‹è¯•
  unit_tests:
    target_percentage: 70%
    execution_time_limit: '< 2ç§’'
    coverage_threshold: 80%
    frameworks:
      - 'Vitest (å¿«é€Ÿ)'
      - 'Jest (å¤æ‚åœºæ™¯)'

    categories:
      - pure_functions: 'çº¯å‡½æ•°é€»è¾‘æµ‹è¯•'
      - business_rules: 'ä¸šåŠ¡è§„åˆ™éªŒè¯'
      - data_models: 'æ•°æ®æ¨¡å‹æµ‹è¯•'
      - utilities: 'å·¥å…·ç±»å‡½æ•°æµ‹è¯•'
      - algorithms: 'ç®—æ³•é€»è¾‘æµ‹è¯•'

  # 20% é›†æˆæµ‹è¯•
  integration_tests:
    target_percentage: 20%
    execution_time_limit: '< 30ç§’'
    coverage_threshold: 70%
    frameworks:
      - 'React Testing Library'
      - 'Phaser Test Utils'

    categories:
      - component_integration: 'Reactç»„ä»¶é›†æˆ'
      - api_contracts: 'APIå¥‘çº¦æµ‹è¯•'
      - database_integration: 'æ•°æ®åº“é›†æˆ'
      - ipc_communication: 'è¿›ç¨‹é—´é€šä¿¡'
      - event_flows: 'äº‹ä»¶æµé›†æˆ'

  # 10% E2Eæµ‹è¯•
  e2e_tests:
    target_percentage: 10%
    execution_time_limit: '< 5åˆ†é’Ÿ'
    coverage_threshold: 90%
    frameworks:
      - 'Playwright for Electron'

    categories:
      - critical_user_paths: 'å…³é”®ç”¨æˆ·è·¯å¾„'
      - cross_system_flows: 'è·¨ç³»ç»Ÿé›†æˆ'
      - regression_protection: 'å›å½’ä¿æŠ¤'
```

#### 7.2.2 æµ‹è¯•é…ç½®ä¸å·¥å…·é“¾

```typescript
// vitest.config.ts - å•å…ƒæµ‹è¯•é…ç½®
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    // æµ‹è¯•ç¯å¢ƒ
    environment: 'jsdom',

    // å…¨å±€è®¾ç½®
    globals: true,
    setupFiles: ['./src/test/setup.ts'],

    // è¦†ç›–ç‡é…ç½®
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      reportsDirectory: './coverage',

      // è¦†ç›–ç‡é˜ˆå€¼ï¼ˆç¬¦åˆæµ‹è¯•é‡‘å­—å¡”è¦æ±‚ï¼‰
      thresholds: {
        global: {
          statements: 80,
          functions: 80,
          branches: 75,
          lines: 80,
        },
        // å…³é”®æ¨¡å—æ›´é«˜è¦æ±‚
        './src/core/': {
          statements: 90,
          functions: 90,
          branches: 85,
          lines: 90,
        },
        './src/ai/': {
          statements: 85,
          functions: 85,
          branches: 80,
          lines: 85,
        },
      },

      // æ’é™¤æ–‡ä»¶
      exclude: [
        'node_modules/',
        'dist/',
        'coverage/',
        '**/*.d.ts',
        '**/*.test.ts',
        '**/*.spec.ts',
      ],
    },

    // å¹¶å‘é…ç½®
    pool: 'threads',
    poolOptions: {
      threads: {
        singleThread: false,
        maxThreads: 4,
        minThreads: 1,
      },
    },

    // è¶…æ—¶é…ç½®
    testTimeout: 10000,
    hookTimeout: 10000,

    // è¾“å‡ºé…ç½®
    reporter: ['default', 'junit', 'json'],
    outputFile: {
      junit: './test-results/junit.xml',
      json: './test-results/results.json',
    },
  },

  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@test': resolve(__dirname, 'src/test'),
    },
  },
});
```

#### 7.2.3 Playwright E2Eæµ‹è¯•é…ç½®

```typescript
// playwright.config.ts - E2Eæµ‹è¯•é…ç½®
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30 * 1000,
  expect: {
    timeout: 5 * 1000,
  },

  // å¹¶å‘é…ç½®
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,

  // æŠ¥å‘Šé…ç½®
  reporter: [
    ['html', { outputFolder: 'playwright-report' }],
    ['junit', { outputFile: 'test-results/e2e-results.xml' }],
    ['json', { outputFile: 'test-results/e2e-results.json' }],
  ],

  use: {
    // Electronåº”ç”¨é…ç½®
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',

    // Electronç‰¹å®šé…ç½®
    launchOptions: {
      executablePath: require('electron'),
      args: [
        require.resolve('./dist/main/main.js'),
        '--disable-dev-shm-usage',
        '--disable-extensions',
        '--no-sandbox',
      ],
    },
  },

  projects: [
    {
      name: 'electron-main',
      use: {
        ...devices['Desktop Chrome'],
        contextOptions: {
          // Electronçª—å£å¤§å°
          viewport: { width: 1400, height: 900 },
        },
      },
    },
  ],

  // WebæœåŠ¡å™¨é…ç½®ï¼ˆå¼€å‘æ¨¡å¼ï¼‰
  webServer:
    process.env.NODE_ENV === 'development'
      ? {
          command: 'npm run dev',
          port: 3000,
          reuseExistingServer: !process.env.CI,
        }
      : undefined,
});
```

### 7.3 CI/CDè´¨é‡é—¨ç¦ä½“ç³»

#### 7.3.1 GitHub Actionså·¥ä½œæµ

```yaml
# .github/workflows/ci.yml - CI/CDæµæ°´çº¿
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  release:
    types: [created]

env:
  NODE_VERSION: '18.17.0'
  PYTHON_VERSION: '3.11'

jobs:
  # ç¬¬ä¸€é˜¶æ®µï¼šä»£ç è´¨é‡æ£€æŸ¥
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint check
        run: npm run lint

      - name: TypeScript check
        run: npm run type-check

      - name: Security audit
        run: npm audit --audit-level moderate

      - name: License check
        run: npm run license-check

  # ç¬¬äºŒé˜¶æ®µï¼šæµ‹è¯•é‡‘å­—å¡”æ‰§è¡Œ
  testing-pyramid:
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        test-suite: [unit, integration, e2e]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        if: matrix.test-suite == 'unit'
        run: |
          npm run test:unit -- --coverage --reporter=junit

      - name: Run integration tests
        if: matrix.test-suite == 'integration'
        run: |
          npm run test:integration -- --reporter=junit

      - name: Run E2E tests
        if: matrix.test-suite == 'e2e'
        run: |
          npm run build
          npm run test:e2e

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-suite }}
          path: |
            test-results/
            coverage/
            playwright-report/

  # ç¬¬ä¸‰é˜¶æ®µï¼šæ„å»ºéªŒè¯
  build-verification:
    runs-on: ${{ matrix.os }}
    needs: testing-pyramid
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Package application
        run: npm run package

      - name: Test packaged app (smoke test)
        run: npm run test:smoke-packaged

  # ç¬¬å››é˜¶æ®µï¼šè´¨é‡é—¨ç¦æ£€æŸ¥
  quality-gates:
    runs-on: ubuntu-latest
    needs: [code-quality, testing-pyramid, build-verification]
    steps:
      - name: Download test results
        uses: actions/download-artifact@v4

      - name: Aggregate test results
        run: |
          python scripts/aggregate-test-results.py

      - name: Check coverage thresholds
        run: |
          python scripts/check-coverage-thresholds.py

      - name: Validate test pyramid ratios
        run: |
          python scripts/validate-test-pyramid.py

      - name: Security baseline check
        run: |
          python scripts/security-baseline-check.py

      - name: Performance baseline check
        run: |
          python scripts/performance-baseline-check.py
```

#### 7.3.2 è´¨é‡é—¨ç¦è„šæœ¬

```python
# scripts/validate-test-pyramid.py - æµ‹è¯•é‡‘å­—å¡”éªŒè¯
import json
import sys
from pathlib import Path

def validate_test_pyramid():
    """éªŒè¯æµ‹è¯•é‡‘å­—å¡”æ¯”ä¾‹ç¬¦åˆæ ‡å‡†"""

    # è¯»å–æµ‹è¯•ç»“æœ
    unit_results = json.loads(Path('test-results/unit-results.json').read_text())
    integration_results = json.loads(Path('test-results/integration-results.json').read_text())
    e2e_results = json.loads(Path('test-results/e2e-results.json').read_text())

    # è®¡ç®—æµ‹è¯•æ•°é‡
    unit_count = unit_results['numTotalTests']
    integration_count = integration_results['numTotalTests']
    e2e_count = e2e_results['numTotalTests']
    total_count = unit_count + integration_count + e2e_count

    # è®¡ç®—æ¯”ä¾‹
    unit_ratio = unit_count / total_count
    integration_ratio = integration_count / total_count
    e2e_ratio = e2e_count / total_count

    # æ ‡å‡†æ¯”ä¾‹ (å…è®¸5%è¯¯å·®)
    target_ratios = {
        'unit': 0.70,
        'integration': 0.20,
        'e2e': 0.10
    }
    tolerance = 0.05

    # éªŒè¯æ¯”ä¾‹
    violations = []

    if abs(unit_ratio - target_ratios['unit']) > tolerance:
        violations.append(f"Unit test ratio {unit_ratio:.2f} deviates from target {target_ratios['unit']:.2f}")

    if abs(integration_ratio - target_ratios['integration']) > tolerance:
        violations.append(f"Integration test ratio {integration_ratio:.2f} deviates from target {target_ratios['integration']:.2f}")

    if abs(e2e_ratio - target_ratios['e2e']) > tolerance:
        violations.append(f"E2E test ratio {e2e_ratio:.2f} deviates from target {target_ratios['e2e']:.2f}")

    # è¾“å‡ºç»“æœ
    print(f"Test Pyramid Analysis:")
    print(f"  Unit Tests: {unit_count} ({unit_ratio:.1%})")
    print(f"  Integration Tests: {integration_count} ({integration_ratio:.1%})")
    print(f"  E2E Tests: {e2e_count} ({e2e_ratio:.1%})")
    print(f"  Total Tests: {total_count}")

    if violations:
        print("\nâŒ Test Pyramid Violations:")
        for violation in violations:
            print(f"  - {violation}")
        sys.exit(1)
    else:
        print("\nâœ… Test Pyramid ratios are within acceptable ranges")

if __name__ == '__main__':
    validate_test_pyramid()
```

### 7.4 ä»£ç ç­¾åä¸åˆ†å‘é…ç½®

#### 7.4.1 Electron Builderé…ç½®

```javascript
// electron-builder.config.js - æ‰“åŒ…å’Œåˆ†å‘é…ç½®
const config = {
  appId: 'com.guildmanager.desktop',
  productName: 'Guild Manager',
  directories: {
    output: 'dist-electron',
    buildResources: 'build',
  },

  // æ–‡ä»¶åŒ…å«/æ’é™¤
  files: [
    'dist/**/*',
    'node_modules/**/*',
    '!node_modules/electron/**/*',
    '!**/node_modules/**/*.{md,txt}',
    '!**/test/**/*',
    '!**/tests/**/*',
  ],

  // Windowsé…ç½®
  win: {
    target: [
      {
        target: 'nsis',
        arch: ['x64', 'arm64'],
      },
    ],
    // ä»£ç ç­¾åé…ç½®
    certificateFile: process.env.WINDOWS_CERTIFICATE_FILE,
    certificatePassword: process.env.WINDOWS_CERTIFICATE_PASSWORD,
    publisherName: 'Guild Manager Team',
    verifyUpdateCodeSignature: true,

    // æ–‡ä»¶å…³è”
    fileAssociations: [
      {
        ext: 'guild',
        name: 'Guild Save File',
        description: 'Guild Manager Save File',
        icon: 'build/file-icon.ico',
      },
    ],
  },

  // macOSé…ç½®
  mac: {
    target: [
      {
        target: 'dmg',
        arch: ['x64', 'arm64'],
      },
    ],
    // ä»£ç ç­¾åé…ç½®
    identity: process.env.MACOS_CERTIFICATE_IDENTITY,
    hardenedRuntime: true,
    gatekeeperAssess: false,
    entitlements: 'build/entitlements.mac.plist',
    entitlementsInherit: 'build/entitlements.mac.plist',

    // å…¬è¯é…ç½®
    notarize: {
      teamId: process.env.APPLE_TEAM_ID,
    },
  },

  // Linuxé…ç½®
  linux: {
    target: [
      {
        target: 'AppImage',
        arch: ['x64'],
      },
      {
        target: 'deb',
        arch: ['x64'],
      },
    ],
    category: 'Game',
    desktop: {
      StartupWMClass: 'guild-manager',
    },
  },

  // NSISå®‰è£…å™¨é…ç½®
  nsis: {
    oneClick: false,
    allowElevation: true,
    allowToChangeInstallationDirectory: true,
    createDesktopShortcut: true,
    createStartMenuShortcut: true,
    installerIcon: 'build/installer-icon.ico',
    uninstallerIcon: 'build/uninstaller-icon.ico',
  },

  // è‡ªåŠ¨æ›´æ–°é…ç½®
  publish: [
    {
      provider: 'github',
      owner: 'guild-manager',
      repo: 'desktop-app',
      private: true,
    },
  ],

  // å‹ç¼©é…ç½®
  compression: 'maximum',

  // æ„å»ºåé’©å­
  afterPack: './scripts/after-pack.js',
  afterSign: './scripts/after-sign.js',
};

module.exports = config;
```

### 7.5 **ç¬¬7ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 7.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: æ„å»ºè„šæœ¬é€»è¾‘ã€é…ç½®éªŒè¯å™¨ã€æµ‹è¯•å·¥å…·ç±»
- **é›†æˆæµ‹è¯•**: CI/CDæµç¨‹é›†æˆã€å¤šå¹³å°æ„å»ºéªŒè¯ã€ä»£ç ç­¾åæµç¨‹
- **E2Eæµ‹è¯•**: å®Œæ•´æ„å»ºå’Œæ‰“åŒ…æµç¨‹ï¼ˆå¼€å‘â†’æ„å»ºâ†’æ‰“åŒ…â†’å®‰è£…â†’è¿è¡Œï¼‰
- **ä¸“é¡¹æµ‹è¯•**: æ„å»ºæ€§èƒ½æµ‹è¯•ã€æ‰“åŒ…å¤§å°ä¼˜åŒ–æµ‹è¯•ã€å…¼å®¹æ€§æµ‹è¯•

#### 7.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('å¼€å‘ç¯å¢ƒä¸æ„å»ºå†’çƒŸæµ‹è¯•', () => {
  it('Viteå¼€å‘æœåŠ¡å™¨åº”èƒ½æ­£å¸¸å¯åŠ¨', async () => {
    const server = await startViteDevServer();
    expect(server.resolvedUrls?.local[0]).toMatch(/^http:\/\/localhost:3000/);

    // æµ‹è¯•HMRåŠŸèƒ½
    const response = await fetch('http://localhost:3000');
    expect(response.status).toBe(200);

    await server.close();
  });

  it('æµ‹è¯•é‡‘å­—å¡”æ¯”ä¾‹åº”ç¬¦åˆæ ‡å‡†', async () => {
    const testResults = await runAllTests();

    const totalTests =
      testResults.unit + testResults.integration + testResults.e2e;
    const unitRatio = testResults.unit / totalTests;
    const integrationRatio = testResults.integration / totalTests;
    const e2eRatio = testResults.e2e / totalTests;

    // 70% Â± 5% å•å…ƒæµ‹è¯•
    expect(unitRatio).toBeCloseTo(0.7, 1);

    // 20% Â± 5% é›†æˆæµ‹è¯•
    expect(integrationRatio).toBeCloseTo(0.2, 1);

    // 10% Â± 5% E2Eæµ‹è¯•
    expect(e2eRatio).toBeCloseTo(0.1, 1);
  });

  it('åº”èƒ½æˆåŠŸæ„å»ºæ‰€æœ‰å¹³å°åŒ…', async () => {
    const buildResults = await buildAllPlatforms();

    expect(buildResults.windows.success).toBe(true);
    expect(buildResults.macos.success).toBe(true);
    expect(buildResults.linux.success).toBe(true);

    // éªŒè¯æ„å»ºäº§ç‰©
    expect(buildResults.windows.outputFiles.length).toBeGreaterThan(0);
    expect(buildResults.macos.outputFiles.length).toBeGreaterThan(0);
    expect(buildResults.linux.outputFiles.length).toBeGreaterThan(0);
  });

  it('ä»£ç ç­¾ååº”èƒ½æ­£å¸¸å·¥ä½œ', async () => {
    if (process.env.CI) {
      const signResult = await verifyCodeSigning();
      expect(signResult.windows.signed).toBe(true);
      expect(signResult.macos.signed).toBe(true);
      expect(signResult.macos.notarized).toBe(true);
    }
  });
});
```

#### 7.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- æ„å»ºå·¥å…·è¦†ç›–ç‡ï¼šâ‰¥70% (åŸºçº¿æ ‡å‡†)
- CI/CDè„šæœ¬è¦†ç›–ç‡ï¼šâ‰¥80% (å…³é”®è‡ªåŠ¨åŒ–æµç¨‹)
- è´¨é‡é—¨ç¦è¦†ç›–ç‡ï¼šâ‰¥90% (å‘å¸ƒè´¨é‡ä¿éšœ)

---

## ğŸ¯ **ç¬¬8ç« ï¼šåŠŸèƒ½çºµåˆ‡ï¼ˆUIâ†’äº‹ä»¶â†’åŸŸæ¨¡å‹â†’æŒä¹…åŒ–â†’éªŒæ”¶æµ‹è¯•ï¼‰**

### 8.1 åŠŸèƒ½çºµåˆ‡æ¶æ„æ¨¡å¼

#### 8.1.1 çºµåˆ‡ä¼˜å…ˆçº§æ’åº

æŒ‰ä¸šåŠ¡ä»·å€¼å’ŒæŠ€æœ¯é£é™©æ’åºçš„åŠŸèƒ½çºµåˆ‡å®æ–½é¡ºåºï¼š

```typescript
// åŠŸèƒ½çºµåˆ‡ä¼˜å…ˆçº§å®šä¹‰
export const FEATURE_SLICE_PRIORITIES = {
  // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šæ ¸å¿ƒæ¸¸æˆå¾ªç¯ï¼ˆæœ€å°å¯ç”¨äº§å“ï¼‰
  P1_CORE_GAME_LOOP: [
    'guild-creation', // å…¬ä¼šåˆ›å»º
    'member-management', // æˆå‘˜ç®¡ç†
    'basic-ai-interaction', // åŸºç¡€AIäº¤äº’
    'save-load-system', // å­˜æ¡£ç³»ç»Ÿ
  ],

  // ç¬¬äºŒä¼˜å…ˆçº§ï¼šæ ¸å¿ƒä¸šåŠ¡åŠŸèƒ½
  P2_CORE_BUSINESS: [
    'combat-hall', // ä½œæˆ˜å¤§å…
    'tactical-center', // æˆ˜æœ¯ä¸­å¿ƒ
    'resource-management', // èµ„æºç®¡ç†
    'ai-decision-engine', // AIå†³ç­–å¼•æ“
  ],

  // ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šå¢å¼ºåŠŸèƒ½
  P3_ENHANCEMENTS: [
    'guild-forum', // å…¬ä¼šè®ºå›
    'auction-house', // æ‹å–è¡Œ
    'achievement-system', // æˆå°±ç³»ç»Ÿ
    'mail-system', // é‚®ä»¶ç³»ç»Ÿ
  ],

  // ç¬¬å››ä¼˜å…ˆçº§ï¼šé«˜çº§åŠŸèƒ½
  P4_ADVANCED: [
    'world-boss', // ä¸–ç•ŒBoss
    'pvp-system', // PVPç³»ç»Ÿ
    'guild-ranking', // å…¬ä¼šæ’å
    'plugin-system', // æ’ä»¶ç³»ç»Ÿ
  ],
} as const;
```

#### 8.1.2 çºµåˆ‡æ ‡å‡†æ¨¡å¼ï¼šUIâ†’äº‹ä»¶â†’åŸŸæ¨¡å‹â†’æŒä¹…åŒ–â†’éªŒæ”¶æµ‹è¯•

```typescript
// åŠŸèƒ½çºµåˆ‡æ ‡å‡†å®æ–½æ¨¡æ¿
export interface FeatureSlice {
  // 1. UIå±‚ï¼ˆReactç»„ä»¶ï¼‰
  ui: {
    components: string[]; // Reactç»„ä»¶åˆ—è¡¨
    hooks: string[]; // è‡ªå®šä¹‰Hooks
    pages: string[]; // é¡µé¢ç»„ä»¶
    styling: string[]; // æ ·å¼æ–‡ä»¶
  };

  // 2. äº‹ä»¶å±‚ï¼ˆäº‹ä»¶å®šä¹‰å’Œå¤„ç†ï¼‰
  events: {
    definitions: string[]; // äº‹ä»¶ç±»å‹å®šä¹‰
    handlers: string[]; // äº‹ä»¶å¤„ç†å™¨
    publishers: string[]; // äº‹ä»¶å‘å¸ƒå™¨
    subscriptions: string[]; // äº‹ä»¶è®¢é˜…
  };

  // 3. åŸŸæ¨¡å‹å±‚ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰
  domain: {
    entities: string[]; // é¢†åŸŸå®ä½“
    valueObjects: string[]; // å€¼å¯¹è±¡
    aggregates: string[]; // èšåˆæ ¹
    services: string[]; // é¢†åŸŸæœåŠ¡
  };

  // 4. æŒä¹…åŒ–å±‚ï¼ˆæ•°æ®è®¿é—®ï¼‰
  persistence: {
    repositories: string[]; // Repositoryå®ç°
    models: string[]; // æ•°æ®æ¨¡å‹
    migrations: string[]; // æ•°æ®åº“è¿ç§»
    queries: string[]; // æŸ¥è¯¢å¯¹è±¡
  };

  // 5. éªŒæ”¶æµ‹è¯•å±‚ï¼ˆç«¯åˆ°ç«¯éªŒè¯ï¼‰
  tests: {
    unit: string[]; // å•å…ƒæµ‹è¯•
    integration: string[]; // é›†æˆæµ‹è¯•
    e2e: string[]; // E2Eæµ‹è¯•
    acceptance: string[]; // éªŒæ”¶æµ‹è¯•
  };
}
```

### 8.2 P1æ ¸å¿ƒåŠŸèƒ½çºµåˆ‡ï¼šå…¬ä¼šåˆ›å»ºç³»ç»Ÿ

#### 8.2.1 UIå±‚ï¼šå…¬ä¼šåˆ›å»ºç»„ä»¶

```typescript
// src/components/guild/GuildCreationFlow.tsx
import React, { useState, useCallback } from 'react';
import { useGuildCreation } from '@/hooks/useGuildCreation';
import { GuildCreationWizard } from './GuildCreationWizard';
import { GuildTemplateSelector } from './GuildTemplateSelector';
import { MemberRecruitmentPanel } from './MemberRecruitmentPanel';

export const GuildCreationFlow: React.FC = () => {
  const {
    createGuild,
    isCreating,
    creationStep,
    validationErrors
  } = useGuildCreation();

  const [formData, setFormData] = useState<GuildCreationFormData>({
    name: '',
    description: '',
    template: null,
    initialMembers: [],
    startingResources: {
      gold: 1000,
      reputation: 10,
      influence: 5
    }
  });

  const handleSubmit = useCallback(async (data: GuildCreationFormData) => {
    try {
      const guild = await createGuild(data);
      // åˆ›å»ºæˆåŠŸåçš„å¤„ç†
      publishEvent('guild:creation:success', { guild });
    } catch (error) {
      publishEvent('guild:creation:error', { error });
    }
  }, [createGuild]);

  return (
    <div className="guild-creation-flow">
      <GuildCreationWizard
        currentStep={creationStep}
        formData={formData}
        onUpdate={setFormData}
        onSubmit={handleSubmit}
        isLoading={isCreating}
        errors={validationErrors}
      />
    </div>
  );
};

// è‡ªå®šä¹‰Hookï¼šå…¬ä¼šåˆ›å»ºé€»è¾‘
export const useGuildCreation = () => {
  const [state, setState] = useState<GuildCreationState>({
    isCreating: false,
    creationStep: 'basic-info',
    validationErrors: []
  });

  const createGuild = useCallback(async (data: GuildCreationFormData): Promise<Guild> => {
    setState(prev => ({ ...prev, isCreating: true }));

    try {
      // 1. éªŒè¯è¾“å…¥æ•°æ®
      const validationResult = await validateGuildCreationData(data);
      if (!validationResult.isValid) {
        setState(prev => ({
          ...prev,
          validationErrors: validationResult.errors,
          isCreating: false
        }));
        throw new ValidationError('Guild creation data is invalid');
      }

      // 2. åˆ›å»ºå…¬ä¼šå®ä½“
      const guild = Guild.create(data);

      // 3. å‘å¸ƒåˆ›å»ºå¼€å§‹äº‹ä»¶
      publishEvent('guild:creation:started', { guildData: data });

      // 4. ä¿å­˜åˆ°æ•°æ®åº“
      const savedGuild = await guildRepository.save(guild);

      // 5. åˆ›å»ºåˆå§‹æˆå‘˜
      for (const memberData of data.initialMembers) {
        const member = Member.create({
          ...memberData,
          guildId: savedGuild.id
        });
        await memberRepository.save(member);
      }

      setState(prev => ({
        ...prev,
        isCreating: false,
        creationStep: 'completed'
      }));

      return savedGuild;

    } catch (error) {
      setState(prev => ({
        ...prev,
        isCreating: false,
        validationErrors: [error.message]
      }));
      throw error;
    }
  }, []);

  return {
    ...state,
    createGuild
  };
};
```

#### 8.2.2 äº‹ä»¶å±‚ï¼šå…¬ä¼šåˆ›å»ºäº‹ä»¶æµ

```typescript
// src/events/guild/GuildCreationEvents.ts
export interface GuildCreationStartedPayload {
  guildData: GuildCreationFormData;
  initiatedBy: string;
  timestamp: number;
}

export interface GuildCreationCompletedPayload {
  guild: Guild;
  totalMembers: number;
  initialResources: GuildResources;
  creationDuration: number;
}

export interface GuildCreationFailedPayload {
  error: Error;
  formData: GuildCreationFormData;
  failureStage: 'validation' | 'persistence' | 'member-creation';
}

// äº‹ä»¶å‘å¸ƒå™¨
export class GuildCreationEventPublisher {
  constructor(private eventBus: EventBus) {}

  async publishCreationStarted(
    payload: GuildCreationStartedPayload
  ): Promise<void> {
    const event = new GuildCreationStartedEvent({
      ...payload,
      correlationId: generateCorrelationId(),
      metadata: {
        source: 'guild-creation-flow',
        version: '1.0.0',
      },
    });

    await this.eventBus.publish(event);
  }

  async publishCreationCompleted(
    payload: GuildCreationCompletedPayload
  ): Promise<void> {
    const event = new GuildCreationCompletedEvent({
      ...payload,
      correlationId: generateCorrelationId(),
      metadata: {
        source: 'guild-creation-service',
        version: '1.0.0',
      },
    });

    await this.eventBus.publish(event);

    // è§¦å‘ç›¸å…³çš„å‰¯ä½œç”¨äº‹ä»¶
    await this.triggerSideEffects(payload.guild);
  }

  private async triggerSideEffects(guild: Guild): Promise<void> {
    // 1. åˆå§‹åŒ–AIè¡Œä¸º
    await this.eventBus.publish('ai:guild:initialize', {
      guildId: guild.id,
      leadership: guild.leadershipStyle,
      members: guild.members,
    });

    // 2. åˆ›å»ºåˆå§‹ä»»åŠ¡
    await this.eventBus.publish('quest:initialize', {
      guildId: guild.id,
      difficulty: 'beginner',
    });

    // 3. æ³¨å†Œç»Ÿè®¡è·Ÿè¸ª
    await this.eventBus.publish('analytics:guild:register', {
      guildId: guild.id,
      createdAt: guild.createdAt,
    });
  }
}

// äº‹ä»¶å¤„ç†å™¨
export class GuildCreationEventHandler implements EventHandler {
  readonly type = 'guild:creation:completed';
  readonly priority = EventPriority.HIGH;

  constructor(
    private achievementService: AchievementService,
    private notificationService: NotificationService
  ) {}

  async handle(event: GuildCreationCompletedEvent): Promise<void> {
    const { guild } = event.payload;

    // 1. æ£€æŸ¥æˆå°±è§£é”
    await this.achievementService.checkAchievement('first-guild-created', {
      playerId: guild.leaderId,
      guildId: guild.id,
    });

    // 2. å‘é€æ¬¢è¿é€šçŸ¥
    await this.notificationService.sendWelcomeMessage({
      guildId: guild.id,
      leaderId: guild.leaderId,
      guildName: guild.name,
    });

    // 3. ç”Ÿæˆæ•™ç¨‹ä»»åŠ¡
    await this.generateTutorialQuests(guild);
  }

  private async generateTutorialQuests(guild: Guild): Promise<void> {
    const tutorialQuests = [
      {
        type: 'recruit-first-member',
        description: 'æ‹›å‹Ÿä½ çš„ç¬¬ä¸€ä¸ªå…¬ä¼šæˆå‘˜',
        reward: { gold: 100, reputation: 5 },
      },
      {
        type: 'complete-first-mission',
        description: 'å®Œæˆä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡',
        reward: { gold: 200, experience: 50 },
      },
    ];

    for (const quest of tutorialQuests) {
      await questService.createQuest({
        ...quest,
        guildId: guild.id,
        priority: 'tutorial',
      });
    }
  }
}
```

#### 8.2.3 åŸŸæ¨¡å‹å±‚ï¼šå…¬ä¼šèšåˆ

```typescript
// src/domain/guild/Guild.ts
export class Guild {
  private constructor(
    private readonly _id: GuildId,
    private readonly _name: string,
    private readonly _createdAt: Date,
    private _leaderId: MemberId,
    private _resources: GuildResources,
    private _members: Member[],
    private _settings: GuildSettings,
    private _activities: Activity[]
  ) {}

  static create(data: GuildCreationFormData): Guild {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    if (!data.name || data.name.trim().length < 3) {
      throw new DomainError('Guild name must be at least 3 characters long');
    }

    if (data.name.length > 50) {
      throw new DomainError('Guild name cannot exceed 50 characters');
    }

    // åˆ›å»ºå…¬ä¼šå®ä¾‹
    const guild = new Guild(
      GuildId.generate(),
      data.name.trim(),
      new Date(),
      MemberId.fromString(data.leaderId),
      GuildResources.fromObject(data.startingResources),
      [],
      GuildSettings.createDefault(),
      []
    );

    // æ·»åŠ é¢†è¢–ä½œä¸ºç¬¬ä¸€ä¸ªæˆå‘˜
    const leader = Member.createLeader({
      id: data.leaderId,
      name: data.leaderName,
      guildId: guild._id,
    });

    guild._members.push(leader);

    // ç”Ÿæˆåˆ›å»ºäº‹ä»¶
    guild.addDomainEvent(
      new GuildCreatedDomainEvent({
        guildId: guild._id,
        name: guild._name,
        leaderId: guild._leaderId,
        createdAt: guild._createdAt,
      })
    );

    return guild;
  }

  addMember(memberData: AddMemberData): void {
    // ä¸šåŠ¡è§„åˆ™ï¼šæ£€æŸ¥æˆå‘˜æ•°é‡é™åˆ¶
    if (this._members.length >= this.getMaxMemberCapacity()) {
      throw new DomainError('Guild has reached maximum member capacity');
    }

    // ä¸šåŠ¡è§„åˆ™ï¼šæ£€æŸ¥é‡å¤æˆå‘˜
    if (this._members.some(m => m.name === memberData.name)) {
      throw new DomainError('Member with this name already exists');
    }

    const member = Member.create({
      ...memberData,
      guildId: this._id,
      joinedAt: new Date(),
    });

    this._members.push(member);

    // æ›´æ–°èµ„æºï¼ˆæ‹›å‹Ÿæˆæœ¬ï¼‰
    this._resources = this._resources.spendGold(this.getRecruitmentCost());

    // ç”Ÿæˆé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(
      new MemberJoinedDomainEvent({
        guildId: this._id,
        member: member,
        recruitmentCost: this.getRecruitmentCost(),
      })
    );
  }

  promoteToLeader(memberId: MemberId): void {
    const member = this._members.find(m => m.id.equals(memberId));
    if (!member) {
      throw new DomainError('Member not found');
    }

    if (member.id.equals(this._leaderId)) {
      throw new DomainError('Member is already the leader');
    }

    const previousLeaderId = this._leaderId;
    this._leaderId = memberId;

    // æ›´æ–°æˆå‘˜è§’è‰²
    this._members = this._members.map(m => {
      if (m.id.equals(previousLeaderId)) {
        return m.demoteFromLeader();
      }
      if (m.id.equals(memberId)) {
        return m.promoteToLeader();
      }
      return m;
    });

    // ç”Ÿæˆé¢†åŸŸäº‹ä»¶
    this.addDomainEvent(
      new LeadershipChangedDomainEvent({
        guildId: this._id,
        previousLeaderId: previousLeaderId,
        newLeaderId: this._leaderId,
        changedAt: new Date(),
      })
    );
  }

  // ä¸å˜é‡æ£€æŸ¥
  private invariants(): void {
    if (this._members.length === 0) {
      throw new DomainError('Guild must have at least one member');
    }

    const leader = this._members.find(m => m.id.equals(this._leaderId));
    if (!leader) {
      throw new DomainError('Guild leader must be a member of the guild');
    }

    if (this._resources.gold < 0) {
      throw new DomainError('Guild resources cannot be negative');
    }
  }

  // åªè¯»è®¿é—®å™¨
  get id(): GuildId {
    return this._id;
  }
  get name(): string {
    return this._name;
  }
  get leaderId(): MemberId {
    return this._leaderId;
  }
  get members(): ReadonlyArray<Member> {
    return [...this._members];
  }
  get resources(): GuildResources {
    return this._resources;
  }
}
```

#### 8.2.4 æŒä¹…åŒ–å±‚ï¼šå…¬ä¼šRepository

```typescript
// src/infrastructure/repositories/GuildRepositoryImpl.ts
export class GuildRepositoryImpl implements GuildRepository {
  constructor(
    private db: DatabasePort,
    private memberRepository: MemberRepository,
    private eventStore: EventStore
  ) {}

  async save(guild: Guild): Promise<Guild> {
    const transaction = await this.db.beginTransaction();

    try {
      // 1. ä¿å­˜å…¬ä¼šåŸºæœ¬ä¿¡æ¯
      await this.db.execute(
        `INSERT INTO guilds (id, name, created_at, leader_id, resources, settings)
         VALUES (?, ?, ?, ?, ?, ?)
         ON CONFLICT(id) DO UPDATE SET
           name = excluded.name,
           leader_id = excluded.leader_id,
           resources = excluded.resources,
           settings = excluded.settings`,
        [
          guild.id.value,
          guild.name,
          guild.createdAt.toISOString(),
          guild.leaderId.value,
          JSON.stringify(guild.resources),
          JSON.stringify(guild.settings),
        ]
      );

      // 2. ä¿å­˜å…¬ä¼šæˆå‘˜å…³è”
      await this.saveMemberAssociations(guild, transaction);

      // 3. ä¿å­˜æ´»åŠ¨è®°å½•
      await this.saveActivities(guild, transaction);

      // 4. ä¿å­˜é¢†åŸŸäº‹ä»¶
      await this.savedomainEvents(guild, transaction);

      await transaction.commit();

      // 5. å‘å¸ƒé¢†åŸŸäº‹ä»¶
      await this.publishDomainEvents(guild);

      return guild;
    } catch (error) {
      await transaction.rollback();
      throw new RepositoryError(`Failed to save guild: ${error.message}`);
    }
  }

  async findById(guildId: GuildId): Promise<Guild | null> {
    const guildData = await this.db.queryOne<GuildRow>(
      `SELECT g.*, 
              COUNT(gm.member_id) as member_count
       FROM guilds g
       LEFT JOIN guild_members gm ON g.id = gm.guild_id
       WHERE g.id = ?
       GROUP BY g.id`,
      [guildId.value]
    );

    if (!guildData) {
      return null;
    }

    // åŠ è½½æˆå‘˜æ•°æ®
    const members = await this.memberRepository.findByGuild(guildId);

    // åŠ è½½æ´»åŠ¨æ•°æ®
    const activities = await this.loadActivities(guildId);

    // é‡å»ºèšåˆ
    return Guild.fromPersistence({
      id: guildId,
      name: guildData.name,
      createdAt: new Date(guildData.created_at),
      leaderId: MemberId.fromString(guildData.leader_id),
      resources: GuildResources.fromJson(guildData.resources),
      settings: GuildSettings.fromJson(guildData.settings),
      members,
      activities,
    });
  }

  async findByName(name: string): Promise<Guild | null> {
    const guildData = await this.db.queryOne<GuildRow>(
      'SELECT * FROM guilds WHERE name = ?',
      [name]
    );

    if (!guildData) {
      return null;
    }

    return this.findById(GuildId.fromString(guildData.id));
  }

  private async saveMemberAssociations(
    guild: Guild,
    transaction: Transaction
  ): Promise<void> {
    // åˆ é™¤ç°æœ‰å…³è”
    await transaction.execute('DELETE FROM guild_members WHERE guild_id = ?', [
      guild.id.value,
    ]);

    // æ’å…¥æ–°å…³è”
    const memberInserts = guild.members.map(member => [
      guild.id.value,
      member.id.value,
      member.role,
      member.joinedAt.toISOString(),
    ]);

    if (memberInserts.length > 0) {
      await transaction.executeBatch(
        'INSERT INTO guild_members (guild_id, member_id, role, joined_at) VALUES (?, ?, ?, ?)',
        memberInserts
      );
    }
  }

  private async savedomainEvents(
    guild: Guild,
    transaction: Transaction
  ): Promise<void> {
    const domainEvents = guild.getDomainEvents();

    for (const event of domainEvents) {
      await this.eventStore.append(event, transaction);
    }

    guild.clearDomainEvents();
  }

  private async publishDomainEvents(guild: Guild): Promise<void> {
    const events = guild.getDomainEvents();

    for (const event of events) {
      await this.eventBus.publish(event);
    }
  }
}
```

#### 8.2.5 éªŒæ”¶æµ‹è¯•å±‚ï¼šå…¬ä¼šåˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯•

```typescript
// e2e/guild-creation.spec.ts
import { test, expect } from '@playwright/test';

test.describe('å…¬ä¼šåˆ›å»ºåŠŸèƒ½çºµåˆ‡', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('å®Œæ•´å…¬ä¼šåˆ›å»ºæµç¨‹åº”èƒ½æˆåŠŸæ‰§è¡Œ', async ({ page }) => {
    // 1. å¯¼èˆªåˆ°å…¬ä¼šåˆ›å»ºé¡µé¢
    await page.click('[data-testid="create-guild-button"]');
    await expect(page).toHaveURL('/guild/create');

    // 2. å¡«å†™åŸºæœ¬ä¿¡æ¯
    await page.fill('[data-testid="guild-name-input"]', 'æµ‹è¯•å…¬ä¼š');
    await page.fill(
      '[data-testid="guild-description-input"]',
      'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å…¬ä¼šçš„æè¿°'
    );
    await page.click('[data-testid="next-step-button"]');

    // 3. é€‰æ‹©å…¬ä¼šæ¨¡æ¿
    await page.click('[data-testid="template-warrior"]');
    await expect(
      page.locator('[data-testid="selected-template"]')
    ).toContainText('æˆ˜å£«å…¬ä¼š');
    await page.click('[data-testid="next-step-button"]');

    // 4. é…ç½®åˆå§‹èµ„æº
    await expect(page.locator('[data-testid="gold-amount"]')).toContainText(
      '1000'
    );
    await expect(
      page.locator('[data-testid="reputation-amount"]')
    ).toContainText('10');
    await page.click('[data-testid="next-step-button"]');

    // 5. æ‹›å‹Ÿåˆå§‹æˆå‘˜
    await page.click('[data-testid="add-member-button"]');
    await page.fill('[data-testid="member-name-input"]', 'çº¦ç¿°Â·å²å¯†æ–¯');
    await page.selectOption('[data-testid="member-class-select"]', 'warrior');
    await page.click('[data-testid="confirm-add-member"]');

    await expect(page.locator('[data-testid="member-list"]')).toContainText(
      'çº¦ç¿°Â·å²å¯†æ–¯'
    );

    // 6. ç¡®è®¤åˆ›å»º
    await page.click('[data-testid="create-guild-submit"]');

    // 7. ç­‰å¾…åˆ›å»ºå®Œæˆ
    await page.waitForSelector('[data-testid="creation-success"]', {
      timeout: 10000,
    });
    await expect(page.locator('[data-testid="guild-name"]')).toContainText(
      'æµ‹è¯•å…¬ä¼š'
    );
    await expect(page.locator('[data-testid="member-count"]')).toContainText(
      '2'
    ); // é¢†è¢– + çº¦ç¿°

    // 8. éªŒè¯å¯¼èˆªåˆ°å…¬ä¼šä¸»é¡µ
    await expect(page).toHaveURL(/\/guild\/[a-f0-9\-]+$/);
  });

  test('å…¬ä¼šåˆ›å»ºéªŒè¯è§„åˆ™åº”èƒ½æ­£ç¡®å·¥ä½œ', async ({ page }) => {
    await page.click('[data-testid="create-guild-button"]');

    // æµ‹è¯•ç©ºåç§°éªŒè¯
    await page.click('[data-testid="next-step-button"]');
    await expect(page.locator('[data-testid="name-error"]')).toContainText(
      'å…¬ä¼šåç§°ä¸èƒ½ä¸ºç©º'
    );

    // æµ‹è¯•åç§°é•¿åº¦éªŒè¯
    await page.fill('[data-testid="guild-name-input"]', 'AB'); // å¤ªçŸ­
    await page.click('[data-testid="next-step-button"]');
    await expect(page.locator('[data-testid="name-error"]')).toContainText(
      'è‡³å°‘3ä¸ªå­—ç¬¦'
    );

    // æµ‹è¯•åç§°è¿‡é•¿éªŒè¯
    await page.fill('[data-testid="guild-name-input"]', 'A'.repeat(51)); // å¤ªé•¿
    await page.click('[data-testid="next-step-button"]');
    await expect(page.locator('[data-testid="name-error"]')).toContainText(
      'ä¸èƒ½è¶…è¿‡50ä¸ªå­—ç¬¦'
    );

    // æµ‹è¯•æœ‰æ•ˆåç§°
    await page.fill('[data-testid="guild-name-input"]', 'æœ‰æ•ˆå…¬ä¼šåç§°');
    await page.click('[data-testid="next-step-button"]');
    await expect(
      page.locator('[data-testid="template-selection"]')
    ).toBeVisible();
  });

  test('å…¬ä¼šåˆ›å»ºè¿‡ç¨‹ä¸­çš„é”™è¯¯æ¢å¤åº”èƒ½æ­£å¸¸å·¥ä½œ', async ({ page }) => {
    // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
    await page.route('**/api/guilds', route => route.abort());

    await page.click('[data-testid="create-guild-button"]');
    await page.fill('[data-testid="guild-name-input"]', 'ç½‘ç»œé”™è¯¯æµ‹è¯•å…¬ä¼š');
    await page.click('[data-testid="next-step-button"]');
    await page.click('[data-testid="template-warrior"]');
    await page.click('[data-testid="next-step-button"]');
    await page.click('[data-testid="next-step-button"]');
    await page.click('[data-testid="create-guild-submit"]');

    // åº”è¯¥æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
    await expect(page.locator('[data-testid="creation-error"]')).toBeVisible();
    await expect(page.locator('[data-testid="retry-button"]')).toBeVisible();

    // æ¢å¤ç½‘ç»œå¹¶é‡è¯•
    await page.unroute('**/api/guilds');
    await page.click('[data-testid="retry-button"]');

    // åº”è¯¥æˆåŠŸåˆ›å»º
    await page.waitForSelector('[data-testid="creation-success"]', {
      timeout: 10000,
    });
    await expect(page.locator('[data-testid="guild-name"]')).toContainText(
      'ç½‘ç»œé”™è¯¯æµ‹è¯•å…¬ä¼š'
    );
  });
});

// é›†æˆæµ‹è¯•ï¼šäº‹ä»¶æµéªŒè¯
describe('å…¬ä¼šåˆ›å»ºäº‹ä»¶æµé›†æˆæµ‹è¯•', () => {
  let eventBus: EventBus;
  let guildRepository: GuildRepository;
  let memberRepository: MemberRepository;

  beforeEach(async () => {
    eventBus = new EventBus();
    guildRepository = new InMemoryGuildRepository();
    memberRepository = new InMemoryMemberRepository();
  });

  it('åº”èƒ½æ­£ç¡®å‘å¸ƒå’Œå¤„ç†å…¬ä¼šåˆ›å»ºäº‹ä»¶', async () => {
    const eventPublisher = new GuildCreationEventPublisher(eventBus);
    const eventHandler = new GuildCreationEventHandler(
      achievementService,
      notificationService
    );

    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    eventBus.subscribe('guild:creation:completed', eventHandler);

    // åˆ›å»ºæµ‹è¯•æ•°æ®
    const guildData: GuildCreationFormData = {
      name: 'æµ‹è¯•å…¬ä¼š',
      description: 'æµ‹è¯•æè¿°',
      template: 'warrior',
      leaderId: 'leader-123',
      leaderName: 'æµ‹è¯•é¢†è¢–',
      startingResources: { gold: 1000, reputation: 10, influence: 5 },
    };

    // åˆ›å»ºå…¬ä¼š
    const guild = Guild.create(guildData);
    await guildRepository.save(guild);

    // å‘å¸ƒå®Œæˆäº‹ä»¶
    await eventPublisher.publishCreationCompleted({
      guild,
      totalMembers: guild.members.length,
      initialResources: guild.resources,
      creationDuration: 1500,
    });

    // éªŒè¯äº‹ä»¶å¤„ç†ç»“æœ
    await waitFor(() => {
      expect(achievementService.checkAchievement).toHaveBeenCalledWith(
        'first-guild-created',
        { playerId: 'leader-123', guildId: guild.id }
      );
      expect(notificationService.sendWelcomeMessage).toHaveBeenCalled();
    });
  });
});
```

### 8.3 P2æ ¸å¿ƒåŠŸèƒ½çºµåˆ‡ï¼šæˆ˜æœ¯ä¸­å¿ƒç³»ç»Ÿ

#### 8.3.1 ç®€åŒ–å®æ–½ç¤ºä¾‹ï¼ˆæŒ‰åŒæ ·çš„UIâ†’äº‹ä»¶â†’åŸŸæ¨¡å‹â†’æŒä¹…åŒ–â†’éªŒæ”¶æµ‹è¯•æ¨¡å¼ï¼‰

```typescript
// æˆ˜æœ¯ä¸­å¿ƒçºµåˆ‡çš„æ ¸å¿ƒæ–‡ä»¶ç»“æ„
export const TACTICAL_CENTER_SLICE: FeatureSlice = {
  ui: [
    'src/components/tactical/TacticalCenterDashboard.tsx',
    'src/components/tactical/FormationEditor.tsx',
    'src/components/tactical/TacticsLibrary.tsx',
    'src/hooks/useTacticalPlanning.ts',
  ],
  events: [
    'src/events/tactical/FormationEvents.ts',
    'src/events/tactical/TacticsEvents.ts',
    'src/handlers/tactical/TacticalEventHandlers.ts',
  ],
  domain: [
    'src/domain/tactical/Formation.ts',
    'src/domain/tactical/TacticalPlan.ts',
    'src/domain/tactical/PositionStrategy.ts',
  ],
  persistence: [
    'src/infrastructure/repositories/FormationRepository.ts',
    'src/infrastructure/repositories/TacticalPlanRepository.ts',
  ],
  tests: [
    'tests/unit/tactical/Formation.test.ts',
    'tests/integration/tactical/TacticalPlanning.integration.test.ts',
    'e2e/tactical-center.spec.ts',
  ],
};
```

### 8.4 åŠŸèƒ½çºµåˆ‡è´¨é‡ä¿è¯

#### 8.4.1 çºµåˆ‡å®Œæˆåº¦æ£€æŸ¥æ¸…å•

```typescript
// çºµåˆ‡å®Œæˆåº¦éªŒè¯å™¨
export class FeatureSliceCompletionValidator {
  async validateSlice(
    sliceName: string,
    slice: FeatureSlice
  ): Promise<ValidationResult> {
    const checks = [
      await this.validateUILayer(slice.ui),
      await this.validateEventLayer(slice.events),
      await this.validateDomainLayer(slice.domain),
      await this.validatePersistenceLayer(slice.persistence),
      await this.validateTestLayer(slice.tests),
    ];

    return {
      sliceName,
      overallCompletion: this.calculateCompletion(checks),
      layerResults: checks,
      isComplete: checks.every(check => check.completion >= 0.9), // 90%å®Œæˆåº¦é˜ˆå€¼
      missingItems: checks.flatMap(check => check.missingItems),
    };
  }

  private async validateUILayer(
    uiFiles: string[]
  ): Promise<LayerValidationResult> {
    const requiredComponents = [
      'main-component',
      'form-components',
      'display-components',
    ];
    const requiredHooks = ['main-hook', 'validation-hook'];

    const existingFiles = await this.checkFilesExist(uiFiles);
    const hasRequiredComponents = await this.checkRequiredComponents(
      existingFiles,
      requiredComponents
    );
    const hasRequiredHooks = await this.checkRequiredHooks(
      existingFiles,
      requiredHooks
    );

    return {
      layer: 'UI',
      completion: this.calculateLayerCompletion([
        existingFiles.completion,
        hasRequiredComponents.completion,
        hasRequiredHooks.completion,
      ]),
      missingItems: [
        ...existingFiles.missing,
        ...hasRequiredComponents.missing,
        ...hasRequiredHooks.missing,
      ],
    };
  }
}
```

### 8.5 **ç¬¬8ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 8.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: çºµåˆ‡éªŒè¯å™¨ã€åŸŸæ¨¡å‹é€»è¾‘ã€äº‹ä»¶å¤„ç†å™¨ã€UIç»„ä»¶å•å…ƒæµ‹è¯•
- **é›†æˆæµ‹è¯•**: UI-äº‹ä»¶-åŸŸæ¨¡å‹é›†æˆã€æŒä¹…åŒ–å±‚é›†æˆã€è·¨å±‚æ•°æ®æµéªŒè¯
- **E2Eæµ‹è¯•**: å®Œæ•´åŠŸèƒ½çºµåˆ‡ç«¯åˆ°ç«¯æµç¨‹éªŒè¯ï¼ˆUIæ“ä½œâ†’äº‹ä»¶å‘å¸ƒâ†’æ•°æ®æŒä¹…åŒ–â†’ç»“æœå±•ç¤ºï¼‰
- **ä¸“é¡¹æµ‹è¯•**: çºµåˆ‡æ€§èƒ½æµ‹è¯•ã€ç”¨æˆ·ä½“éªŒæµ‹è¯•ã€ä¸šåŠ¡è§„åˆ™éªŒè¯

#### 8.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('åŠŸèƒ½çºµåˆ‡å†’çƒŸæµ‹è¯•', () => {
  it('å…¬ä¼šåˆ›å»ºçºµåˆ‡åº”èƒ½å®Œæ•´æ‰§è¡Œ', async () => {
    // 1. UIå±‚æµ‹è¯•
    const { render, fireEvent, waitFor } = renderWithProviders(<GuildCreationFlow />)

    fireEvent.change(screen.getByTestId('guild-name-input'), { target: { value: 'æµ‹è¯•å…¬ä¼š' } })
    fireEvent.click(screen.getByTestId('create-guild-submit'))

    // 2. äº‹ä»¶å±‚éªŒè¯
    await waitFor(() => {
      expect(mockEventBus.publish).toHaveBeenCalledWith(
        expect.objectContaining({ type: 'guild:creation:started' })
      )
    })

    // 3. åŸŸæ¨¡å‹éªŒè¯
    const guild = Guild.create({
      name: 'æµ‹è¯•å…¬ä¼š',
      leaderId: 'test-leader',
      leaderName: 'æµ‹è¯•é¢†è¢–',
      startingResources: { gold: 1000, reputation: 10, influence: 5 }
    })

    expect(guild.name).toBe('æµ‹è¯•å…¬ä¼š')
    expect(guild.members.length).toBe(1) // åŒ…å«é¢†è¢–

    // 4. æŒä¹…åŒ–å±‚éªŒè¯
    const savedGuild = await guildRepository.save(guild)
    expect(savedGuild.id).toBeTruthy()

    const foundGuild = await guildRepository.findById(savedGuild.id)
    expect(foundGuild).toBeTruthy()
    expect(foundGuild!.name).toBe('æµ‹è¯•å…¬ä¼š')
  })

  it('çºµåˆ‡å®Œæˆåº¦éªŒè¯åº”èƒ½æ£€æµ‹ç¼ºå¤±ç»„ä»¶', async () => {
    const validator = new FeatureSliceCompletionValidator()

    const incompleteSlice: FeatureSlice = {
      ui: ['component1.tsx'], // ç¼ºå°‘Hook
      events: [], // å®Œå…¨ç¼ºå¤±
      domain: ['Entity1.ts'],
      persistence: ['Repository1.ts'],
      tests: []
    }

    const result = await validator.validateSlice('test-slice', incompleteSlice)

    expect(result.isComplete).toBe(false)
    expect(result.overallCompletion).toBeLessThan(0.9)
    expect(result.missingItems).toContain('events layer missing')
    expect(result.missingItems).toContain('required hooks missing')
  })

  it('è·¨å±‚é›†æˆåº”èƒ½æ­£å¸¸å·¥ä½œ', async () => {
    // æ¨¡æ‹Ÿå®Œæ•´çš„è·¨å±‚è°ƒç”¨
    const guildData = createTestGuildData()

    // UIå±‚è§¦å‘
    const result = await guildCreationService.createGuild(guildData)

    // éªŒè¯äº‹ä»¶å‘å¸ƒ
    expect(mockEventBus.publish).toHaveBeenCalledTimes(3) // started, AIåˆå§‹åŒ–, ç»Ÿè®¡æ³¨å†Œ

    // éªŒè¯åŸŸæ¨¡å‹åˆ›å»º
    expect(result.guild).toBeInstanceOf(Guild)
    expect(result.guild.getDomainEvents().length).toBeGreaterThan(0)

    // éªŒè¯æŒä¹…åŒ–
    const persistedGuild = await guildRepository.findById(result.guild.id)
    expect(persistedGuild).toBeTruthy()
  })
})
```

#### 8.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- åŠŸèƒ½çºµåˆ‡è¦†ç›–ç‡ï¼šâ‰¥80% (åŸºçº¿æ ‡å‡†)
- UI-åŸŸæ¨¡å‹é›†æˆè¦†ç›–ç‡ï¼šâ‰¥85% (å…³é”®ä¸šåŠ¡æµç¨‹)
- ç«¯åˆ°ç«¯æµç¨‹è¦†ç›–ç‡ï¼šâ‰¥90% (ç”¨æˆ·æ ¸å¿ƒè·¯å¾„)

---

## ğŸ“ˆ **ç¬¬9ç« ï¼šæ€§èƒ½ä¸å®¹é‡è§„åˆ’ï¼ˆåŸºå‡†æ–¹æ³•ã€å›å½’é˜ˆå€¼ã€çƒ­åŒºè¡¨ï¼‰**

### 9.1 æ€§èƒ½åŸºå‡†æ–¹æ³•è®º

#### 9.1.1 æ€§èƒ½æµ‹è¯•åˆ†ç±»ä¸åŸºå‡†

```typescript
// æ€§èƒ½åŸºå‡†å®šä¹‰
export const PERFORMANCE_BASELINES = {
  // åº”ç”¨å¯åŠ¨æ€§èƒ½
  startup: {
    coldStart: {
      target: 3000, // ç›®æ ‡ï¼š3ç§’
      warning: 4000, // è­¦å‘Šé˜ˆå€¼ï¼š4ç§’
      critical: 6000, // ä¸¥é‡é˜ˆå€¼ï¼š6ç§’
      measurement: 'milliseconds',
    },
    warmStart: {
      target: 1500, // ç›®æ ‡ï¼š1.5ç§’
      warning: 2000, // è­¦å‘Šé˜ˆå€¼ï¼š2ç§’
      critical: 3000, // ä¸¥é‡é˜ˆå€¼ï¼š3ç§’
      measurement: 'milliseconds',
    },
    memoryFootprint: {
      target: 200 * 1024 * 1024, // ç›®æ ‡ï¼š200MB
      warning: 300 * 1024 * 1024, // è­¦å‘Šï¼š300MB
      critical: 500 * 1024 * 1024, // ä¸¥é‡ï¼š500MB
      measurement: 'bytes',
    },
  },

  // è¿è¡Œæ—¶æ€§èƒ½
  runtime: {
    frameRate: {
      target: 60, // ç›®æ ‡ï¼š60fps
      warning: 55, // è­¦å‘Šï¼š55fps
      critical: 30, // ä¸¥é‡ï¼š30fps
      measurement: 'fps',
    },
    memoryUsage: {
      steady: 300 * 1024 * 1024, // ç¨³å®šçŠ¶æ€ï¼š300MB
      peak: 512 * 1024 * 1024, // å³°å€¼ï¼š512MB
      critical: 768 * 1024 * 1024, // ä¸¥é‡ï¼š768MB
      measurement: 'bytes',
    },
    cpuUsage: {
      idle: 5, // ç©ºé—²ï¼š5%
      normal: 20, // æ­£å¸¸ï¼š20%
      warning: 40, // è­¦å‘Šï¼š40%
      critical: 70, // ä¸¥é‡ï¼š70%
      measurement: 'percentage',
    },
  },

  // æ•°æ®åº“æ€§èƒ½
  database: {
    queryResponse: {
      simple: 50, // ç®€å•æŸ¥è¯¢ï¼š50ms
      complex: 200, // å¤æ‚æŸ¥è¯¢ï¼š200ms
      warning: 500, // è­¦å‘Šï¼š500ms
      critical: 1000, // ä¸¥é‡ï¼š1ç§’
      measurement: 'milliseconds',
    },
    saveOperation: {
      single: 100, // å•ä¸ªä¿å­˜ï¼š100ms
      batch: 500, // æ‰¹é‡ä¿å­˜ï¼š500ms
      warning: 1000, // è­¦å‘Šï¼š1ç§’
      critical: 3000, // ä¸¥é‡ï¼š3ç§’
      measurement: 'milliseconds',
    },
  },

  // AIè®¡ç®—æ€§èƒ½
  aiComputation: {
    decisionMaking: {
      simple: 50, // ç®€å•å†³ç­–ï¼š50ms
      complex: 200, // å¤æ‚å†³ç­–ï¼š200ms
      warning: 500, // è­¦å‘Šï¼š500ms
      critical: 1000, // ä¸¥é‡ï¼š1ç§’
      measurement: 'milliseconds',
    },
    batchProcessing: {
      entitiesPerSecond: 100, // ç›®æ ‡ï¼š100ä¸ªå®ä½“/ç§’
      warning: 50, // è­¦å‘Šï¼š50ä¸ªå®ä½“/ç§’
      critical: 20, // ä¸¥é‡ï¼š20ä¸ªå®ä½“/ç§’
      measurement: 'entities_per_second',
    },
  },
} as const;
```

#### 9.1.2 æ€§èƒ½æµ‹è¯•è‡ªåŠ¨åŒ–æ¡†æ¶

```typescript
// æ€§èƒ½æµ‹è¯•æ‰§è¡Œå™¨
export class PerformanceTestExecutor {
  private results: PerformanceTestResult[] = [];

  constructor(
    private app: Application,
    private metrics: MetricsCollector
  ) {}

  async runFullPerformanceSuite(): Promise<PerformanceTestSuite> {
    console.log('ğŸš€ Starting comprehensive performance test suite...');

    const suiteResults = {
      startup: await this.runStartupTests(),
      runtime: await this.runRuntimeTests(),
      database: await this.runDatabaseTests(),
      aiComputation: await this.runAIComputationTests(),
      memory: await this.runMemoryTests(),
      endToEnd: await this.runEndToEndTests(),
    };

    const overallResult = this.calculateOverallScore(suiteResults);

    await this.generatePerformanceReport(suiteResults, overallResult);

    return {
      ...suiteResults,
      overallScore: overallResult.score,
      passed: overallResult.passed,
      executedAt: new Date(),
      duration: overallResult.totalDuration,
    };
  }

  private async runStartupTests(): Promise<StartupTestResult> {
    console.log('ğŸ“Š Testing application startup performance...');

    // å†·å¯åŠ¨æµ‹è¯•
    const coldStartTime = await this.measureColdStart();

    // çƒ­å¯åŠ¨æµ‹è¯•
    const warmStartTime = await this.measureWarmStart();

    // å†…å­˜å ç”¨æµ‹è¯•
    const memoryFootprint = await this.measureStartupMemory();

    return {
      coldStart: {
        duration: coldStartTime,
        passed: coldStartTime <= PERFORMANCE_BASELINES.startup.coldStart.target,
        baseline: PERFORMANCE_BASELINES.startup.coldStart,
      },
      warmStart: {
        duration: warmStartTime,
        passed: warmStartTime <= PERFORMANCE_BASELINES.startup.warmStart.target,
        baseline: PERFORMANCE_BASELINES.startup.warmStart,
      },
      memoryFootprint: {
        usage: memoryFootprint,
        passed:
          memoryFootprint <=
          PERFORMANCE_BASELINES.startup.memoryFootprint.target,
        baseline: PERFORMANCE_BASELINES.startup.memoryFootprint,
      },
    };
  }

  private async measureColdStart(): Promise<number> {
    // ç¡®ä¿åº”ç”¨å®Œå…¨å…³é—­
    await this.app.forceQuit();
    await this.clearApplicationCache();

    const startTime = performance.now();

    // å¯åŠ¨åº”ç”¨
    await this.app.launch();

    // ç­‰å¾…ä¸»çª—å£å®Œå…¨åŠ è½½
    await this.app.waitForWindow('main-window');
    await this.app.waitForElement('[data-testid="app-ready"]');

    const endTime = performance.now();

    return Math.round(endTime - startTime);
  }

  private async runRuntimeTests(): Promise<RuntimeTestResult> {
    console.log('âš¡ Testing runtime performance...');

    // å¸§ç‡æµ‹è¯•
    const frameRateResult = await this.measureFrameRate();

    // CPUä½¿ç”¨ç‡æµ‹è¯•
    const cpuUsageResult = await this.measureCPUUsage();

    // å†…å­˜ä½¿ç”¨æµ‹è¯•
    const memoryUsageResult = await this.measureRuntimeMemory();

    // äº‹ä»¶å¤„ç†æ€§èƒ½æµ‹è¯•
    const eventProcessingResult = await this.measureEventProcessing();

    return {
      frameRate: frameRateResult,
      cpuUsage: cpuUsageResult,
      memoryUsage: memoryUsageResult,
      eventProcessing: eventProcessingResult,
    };
  }

  private async measureFrameRate(): Promise<FrameRateTestResult> {
    await this.app.navigate('/game');

    // å¯åŠ¨æ¸¸æˆå¹¶è¿è¡Œ10ç§’
    await this.app.startGameLoop();

    const frameRates: number[] = [];
    const testDuration = 10000; // 10ç§’
    const sampleInterval = 1000; // æ¯ç§’é‡‡æ ·

    for (let i = 0; i < testDuration / sampleInterval; i++) {
      await new Promise(resolve => setTimeout(resolve, sampleInterval));
      const currentFPS = await this.app.getCurrentFPS();
      frameRates.push(currentFPS);
    }

    const averageFPS =
      frameRates.reduce((a, b) => a + b, 0) / frameRates.length;
    const minFPS = Math.min(...frameRates);
    const maxFPS = Math.max(...frameRates);

    return {
      average: Math.round(averageFPS),
      minimum: minFPS,
      maximum: maxFPS,
      samples: frameRates,
      passed: averageFPS >= PERFORMANCE_BASELINES.runtime.frameRate.target,
      baseline: PERFORMANCE_BASELINES.runtime.frameRate,
    };
  }

  private async runDatabaseTests(): Promise<DatabaseTestResult> {
    console.log('ğŸ’¾ Testing database performance...');

    const queryTests = await this.measureQueryPerformance();
    const writeTests = await this.measureWritePerformance();
    const concurrencyTests = await this.measureDatabaseConcurrency();

    return {
      queryPerformance: queryTests,
      writePerformance: writeTests,
      concurrencyPerformance: concurrencyTests,
    };
  }

  private async measureQueryPerformance(): Promise<QueryPerformanceResult> {
    const tests = [
      { name: 'simple-select', query: 'SELECT * FROM guilds LIMIT 10' },
      {
        name: 'join-query',
        query:
          'SELECT g.*, m.name FROM guilds g JOIN members m ON g.id = m.guild_id',
      },
      {
        name: 'aggregate-query',
        query: 'SELECT guild_id, COUNT(*) FROM members GROUP BY guild_id',
      },
      {
        name: 'complex-filter',
        query: 'SELECT * FROM guilds WHERE created_at > ? AND member_count > ?',
      },
    ];

    const results: QueryResult[] = [];

    for (const test of tests) {
      const durations: number[] = [];

      // è¿è¡Œæ¯ä¸ªæŸ¥è¯¢10æ¬¡å–å¹³å‡å€¼
      for (let i = 0; i < 10; i++) {
        const startTime = performance.now();
        await this.app.database.query(test.query);
        const endTime = performance.now();
        durations.push(endTime - startTime);
      }

      const averageDuration =
        durations.reduce((a, b) => a + b, 0) / durations.length;

      results.push({
        queryName: test.name,
        averageDuration: Math.round(averageDuration),
        minDuration: Math.min(...durations),
        maxDuration: Math.max(...durations),
        passed:
          averageDuration <=
          PERFORMANCE_BASELINES.database.queryResponse.complex,
      });
    }

    return { queries: results };
  }
}
```

### 9.2 æ€§èƒ½å›å½’é˜ˆå€¼ç®¡ç†

#### 9.2.1 è‡ªåŠ¨å›å½’æ£€æµ‹ç³»ç»Ÿ

```typescript
// æ€§èƒ½å›å½’æ£€æµ‹å™¨
export class PerformanceRegressionDetector {
  private historicalData: PerformanceHistoryStore;

  constructor(
    private config: RegressionDetectionConfig = {
      lookbackPeriod: 10, // å¯¹æ¯”æœ€è¿‘10æ¬¡æµ‹è¯•
      regressionThreshold: 0.15, // 15%æ€§èƒ½ä¸‹é™è§†ä¸ºå›å½’
      consecutiveFailures: 3, // è¿ç»­3æ¬¡å¤±è´¥æ‰æŠ¥è­¦
      warmupRuns: 2, // é¢„çƒ­è¿è¡Œ2æ¬¡
    }
  ) {
    this.historicalData = new PerformanceHistoryStore();
  }

  async detectRegression(
    currentResults: PerformanceTestSuite,
    branch: string = 'main'
  ): Promise<RegressionDetectionResult> {
    // 1. è·å–å†å²åŸºå‡†æ•°æ®
    const historicalResults = await this.historicalData.getRecentResults(
      branch,
      this.config.lookbackPeriod
    );

    if (historicalResults.length === 0) {
      return {
        hasRegression: false,
        message: 'No historical data for comparison',
        baselineEstablished: true,
      };
    }

    // 2. è®¡ç®—å†å²åŸºå‡†
    const baseline = this.calculateBaseline(historicalResults);

    // 3. æ£€æµ‹å„é¡¹æŒ‡æ ‡å›å½’
    const regressions = await this.analyzeMetricRegressions(
      currentResults,
      baseline
    );

    // 4. ç”Ÿæˆå›å½’æŠ¥å‘Š
    const report = this.generateRegressionReport(
      regressions,
      currentResults,
      baseline
    );

    // 5. ä¿å­˜å½“å‰æµ‹è¯•ç»“æœ
    await this.historicalData.saveResults(currentResults, branch);

    return {
      hasRegression: regressions.some(r => r.isRegression),
      regressions,
      report,
      currentResults,
      baseline,
      message: this.generateSummaryMessage(regressions),
    };
  }

  private analyzeMetricRegressions(
    current: PerformanceTestSuite,
    baseline: PerformanceBaseline
  ): MetricRegression[] {
    const regressions: MetricRegression[] = [];

    // å¯åŠ¨æ€§èƒ½å›å½’æ£€æµ‹
    regressions.push(
      ...this.checkStartupRegressions(current.startup, baseline.startup)
    );

    // è¿è¡Œæ—¶æ€§èƒ½å›å½’æ£€æµ‹
    regressions.push(
      ...this.checkRuntimeRegressions(current.runtime, baseline.runtime)
    );

    // æ•°æ®åº“æ€§èƒ½å›å½’æ£€æµ‹
    regressions.push(
      ...this.checkDatabaseRegressions(current.database, baseline.database)
    );

    // AIè®¡ç®—æ€§èƒ½å›å½’æ£€æµ‹
    regressions.push(
      ...this.checkAIRegressions(current.aiComputation, baseline.aiComputation)
    );

    return regressions;
  }

  private checkStartupRegressions(
    current: StartupTestResult,
    baseline: StartupBaseline
  ): MetricRegression[] {
    const regressions: MetricRegression[] = [];

    // å†·å¯åŠ¨æ—¶é—´å›å½’æ£€æµ‹
    const coldStartRegression = this.checkMetricRegression(
      'startup.coldStart',
      current.coldStart.duration,
      baseline.coldStart.average,
      baseline.coldStart.standardDeviation
    );

    if (coldStartRegression) {
      regressions.push({
        ...coldStartRegression,
        impact: 'high',
        recommendation: 'æ£€æŸ¥åº”ç”¨å¯åŠ¨æµç¨‹ï¼Œå¯èƒ½å­˜åœ¨é˜»å¡æ“ä½œæˆ–èµ„æºåŠ è½½é—®é¢˜',
      });
    }

    // å†…å­˜å ç”¨å›å½’æ£€æµ‹
    const memoryRegression = this.checkMetricRegression(
      'startup.memoryFootprint',
      current.memoryFootprint.usage,
      baseline.memoryFootprint.average,
      baseline.memoryFootprint.standardDeviation
    );

    if (memoryRegression) {
      regressions.push({
        ...memoryRegression,
        impact: 'medium',
        recommendation: 'æ£€æŸ¥å†…å­˜æ³„æ¼æˆ–ä¸å¿…è¦çš„å¯¹è±¡åˆ›å»º',
      });
    }

    return regressions;
  }

  private checkMetricRegression(
    metricName: string,
    currentValue: number,
    baselineAverage: number,
    baselineStdDev: number
  ): MetricRegression | null {
    const regressionThreshold =
      baselineAverage * (1 + this.config.regressionThreshold);
    const isRegression = currentValue > regressionThreshold;

    if (!isRegression) {
      return null;
    }

    const regressionPercentage =
      ((currentValue - baselineAverage) / baselineAverage) * 100;
    const severityLevel = this.calculateSeverityLevel(regressionPercentage);

    return {
      metricName,
      currentValue,
      baselineValue: baselineAverage,
      regressionPercentage: Math.round(regressionPercentage * 100) / 100,
      severityLevel,
      isRegression: true,
      confidenceLevel: this.calculateConfidenceLevel(
        currentValue,
        baselineAverage,
        baselineStdDev
      ),
    };
  }

  private calculateSeverityLevel(
    regressionPercentage: number
  ): 'low' | 'medium' | 'high' | 'critical' {
    if (regressionPercentage > 50) return 'critical';
    if (regressionPercentage > 30) return 'high';
    if (regressionPercentage > 15) return 'medium';
    return 'low';
  }
}
```

### 9.3 æ€§èƒ½çƒ­åŒºæ˜ å°„

#### 9.3.1 çƒ­åŒºè¯†åˆ«ä¸ç›‘æ§

```typescript
// æ€§èƒ½çƒ­åŒºåˆ†æå™¨
export class PerformanceHotspotAnalyzer {
  private profiler: ApplicationProfiler;
  private heatmapGenerator: HeatmapGenerator;

  constructor() {
    this.profiler = new ApplicationProfiler();
    this.heatmapGenerator = new HeatmapGenerator();
  }

  async analyzeHotspots(
    duration: number = 60000
  ): Promise<HotspotAnalysisResult> {
    console.log(`ğŸ”¥ Analyzing performance hotspots over ${duration}ms...`);

    // 1. å¯åŠ¨æ€§èƒ½åˆ†æ
    await this.profiler.start({
      cpuProfiling: true,
      memoryProfiling: true,
      eventLoopProfiling: true,
      functionCallProfiling: true,
    });

    // 2. æ¨¡æ‹Ÿå…¸å‹ç”¨æˆ·æ“ä½œ
    await this.simulateUserWorkflow();

    // 3. æ”¶é›†åˆ†ææ•°æ®
    const profilingData = await this.profiler.collectData(duration);

    // 4. ç”Ÿæˆçƒ­åŒºæŠ¥å‘Š
    const hotspots = await this.identifyHotspots(profilingData);

    // 5. ç”Ÿæˆå¯è§†åŒ–çƒ­åŠ›å›¾
    const heatmaps = await this.generateHeatmaps(hotspots);

    return {
      hotspots,
      heatmaps,
      recommendations: this.generateOptimizationRecommendations(hotspots),
      executedAt: new Date(),
      duration,
    };
  }

  private async identifyHotspots(
    data: ProfilingData
  ): Promise<PerformanceHotspot[]> {
    const hotspots: PerformanceHotspot[] = [];

    // CPUçƒ­åŒºåˆ†æ
    const cpuHotspots = this.analyzeCPUHotspots(data.cpuProfile);
    hotspots.push(...cpuHotspots);

    // å†…å­˜çƒ­åŒºåˆ†æ
    const memoryHotspots = this.analyzeMemoryHotspots(data.memoryProfile);
    hotspots.push(...memoryHotspots);

    // äº‹ä»¶å¾ªç¯é˜»å¡çƒ­åŒºåˆ†æ
    const eventLoopHotspots = this.analyzeEventLoopHotspots(
      data.eventLoopProfile
    );
    hotspots.push(...eventLoopHotspots);

    // æ•°æ®åº“æŸ¥è¯¢çƒ­åŒºåˆ†æ
    const databaseHotspots = this.analyzeDatabaseHotspots(data.databaseProfile);
    hotspots.push(...databaseHotspots);

    // AIè®¡ç®—çƒ­åŒºåˆ†æ
    const aiComputationHotspots = this.analyzeAIComputationHotspots(
      data.aiProfile
    );
    hotspots.push(...aiComputationHotspots);

    // æŒ‰å½±å“ç¨‹åº¦æ’åº
    return hotspots.sort((a, b) => b.impactScore - a.impactScore);
  }

  private analyzeCPUHotspots(cpuProfile: CPUProfile): PerformanceHotspot[] {
    const hotspots: PerformanceHotspot[] = [];

    // æ‰¾å‡ºCPUå ç”¨æœ€é«˜çš„å‡½æ•°
    const topCPUFunctions = cpuProfile.functions
      .sort((a, b) => b.totalTime - a.totalTime)
      .slice(0, 10); // å–å‰10ä¸ª

    for (const func of topCPUFunctions) {
      if (func.totalTime > cpuProfile.totalExecutionTime * 0.05) {
        // è¶…è¿‡5%çš„CPUæ—¶é—´
        hotspots.push({
          type: 'cpu',
          location: {
            functionName: func.functionName,
            fileName: func.fileName,
            lineNumber: func.lineNumber,
          },
          metrics: {
            cpuTime: func.totalTime,
            cpuPercentage:
              (func.totalTime / cpuProfile.totalExecutionTime) * 100,
            callCount: func.callCount,
            averageTime: func.totalTime / func.callCount,
          },
          impactScore: this.calculateImpactScore(
            'cpu',
            func.totalTime,
            cpuProfile.totalExecutionTime
          ),
          severity: this.calculateSeverity(
            func.totalTime,
            cpuProfile.totalExecutionTime
          ),
          description: `å‡½æ•° ${func.functionName} å ç”¨ ${((func.totalTime / cpuProfile.totalExecutionTime) * 100).toFixed(2)}% CPUæ—¶é—´`,
        });
      }
    }

    return hotspots;
  }

  private analyzeMemoryHotspots(
    memoryProfile: MemoryProfile
  ): PerformanceHotspot[] {
    const hotspots: PerformanceHotspot[] = [];

    // å†…å­˜æ³„æ¼æ£€æµ‹
    const potentialLeaks = memoryProfile.allocations.filter(
      alloc => !alloc.deallocated && alloc.size > 1024 * 1024 // 1MBä»¥ä¸Šæœªé‡Šæ”¾
    );

    for (const leak of potentialLeaks) {
      hotspots.push({
        type: 'memory',
        location: {
          functionName: leak.allocatedBy.functionName,
          fileName: leak.allocatedBy.fileName,
          lineNumber: leak.allocatedBy.lineNumber,
        },
        metrics: {
          allocatedMemory: leak.size,
          allocationCount: leak.count,
          retainedMemory: leak.retainedSize,
        },
        impactScore: this.calculateImpactScore(
          'memory',
          leak.size,
          memoryProfile.totalAllocated
        ),
        severity: leak.size > 10 * 1024 * 1024 ? 'high' : 'medium', // 10MBä»¥ä¸Šä¸ºé«˜ä¸¥é‡æ€§
        description: `å¯èƒ½çš„å†…å­˜æ³„æ¼ï¼š${this.formatBytes(leak.size)} æœªé‡Šæ”¾`,
      });
    }

    // å¤§å†…å­˜åˆ†é…æ£€æµ‹
    const largeAllocations = memoryProfile.allocations.filter(
      alloc => alloc.size > 5 * 1024 * 1024 // 5MBä»¥ä¸Šåˆ†é…
    );

    for (const alloc of largeAllocations) {
      hotspots.push({
        type: 'memory',
        location: {
          functionName: alloc.allocatedBy.functionName,
          fileName: alloc.allocatedBy.fileName,
          lineNumber: alloc.allocatedBy.lineNumber,
        },
        metrics: {
          allocatedMemory: alloc.size,
          allocationCount: 1,
          peakMemory: alloc.size,
        },
        impactScore: this.calculateImpactScore(
          'memory',
          alloc.size,
          memoryProfile.totalAllocated
        ),
        severity: 'medium',
        description: `å¤§å†…å­˜åˆ†é…ï¼š${this.formatBytes(alloc.size)}`,
      });
    }

    return hotspots;
  }

  private generateOptimizationRecommendations(
    hotspots: PerformanceHotspot[]
  ): OptimizationRecommendation[] {
    const recommendations: OptimizationRecommendation[] = [];

    // ä¸ºæ¯ä¸ªçƒ­åŒºç”Ÿæˆä¼˜åŒ–å»ºè®®
    for (const hotspot of hotspots) {
      switch (hotspot.type) {
        case 'cpu':
          recommendations.push({
            hotspotId: hotspot.id,
            priority: hotspot.severity,
            category: 'CPUä¼˜åŒ–',
            title: `ä¼˜åŒ–é«˜CPUå ç”¨å‡½æ•°ï¼š${hotspot.location.functionName}`,
            description: hotspot.description,
            suggestions: [
              'æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸å¿…è¦çš„å¾ªç¯æˆ–é€’å½’',
              'è€ƒè™‘ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—',
              'è¯„ä¼°ç®—æ³•å¤æ‚åº¦ï¼Œå¯»æ‰¾æ›´é«˜æ•ˆçš„å®ç°',
              'è€ƒè™‘å°†CPUå¯†é›†å‹æ“ä½œç§»è‡³Web Worker',
            ],
            estimatedImpact: this.estimateOptimizationImpact(hotspot),
            implementationComplexity: 'medium',
          });
          break;

        case 'memory':
          recommendations.push({
            hotspotId: hotspot.id,
            priority: hotspot.severity,
            category: 'å†…å­˜ä¼˜åŒ–',
            title: `è§£å†³å†…å­˜é—®é¢˜ï¼š${hotspot.location.functionName}`,
            description: hotspot.description,
            suggestions: [
              'æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼',
              'ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…',
              'åŠæ—¶æ¸…ç†ä¸å†ä½¿ç”¨çš„å¯¹è±¡å¼•ç”¨',
              'è€ƒè™‘ä½¿ç”¨WeakMap/WeakSeté¿å…å¼ºå¼•ç”¨',
            ],
            estimatedImpact: this.estimateOptimizationImpact(hotspot),
            implementationComplexity: 'high',
          });
          break;

        case 'database':
          recommendations.push({
            hotspotId: hotspot.id,
            priority: hotspot.severity,
            category: 'æ•°æ®åº“ä¼˜åŒ–',
            title: `ä¼˜åŒ–æ•°æ®åº“æ“ä½œï¼š${hotspot.location.functionName}`,
            description: hotspot.description,
            suggestions: [
              'æ·»åŠ é€‚å½“çš„æ•°æ®åº“ç´¢å¼•',
              'ä¼˜åŒ–æŸ¥è¯¢è¯­å¥ï¼Œé¿å…N+1æŸ¥è¯¢',
              'ä½¿ç”¨æ‰¹é‡æ“ä½œå‡å°‘æ•°æ®åº“å¾€è¿”',
              'è€ƒè™‘æ·»åŠ æŸ¥è¯¢ç¼“å­˜',
            ],
            estimatedImpact: this.estimateOptimizationImpact(hotspot),
            implementationComplexity: 'medium',
          });
          break;
      }
    }

    // æŒ‰ä¼˜å…ˆçº§å’Œå½±å“ç¨‹åº¦æ’åº
    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return (
        priorityOrder[b.priority] - priorityOrder[a.priority] ||
        b.estimatedImpact - a.estimatedImpact
      );
    });
  }
}

// æ€§èƒ½çƒ­åŠ›å›¾ç”Ÿæˆå™¨
export class HeatmapGenerator {
  async generateCodeHeatmap(
    hotspots: PerformanceHotspot[]
  ): Promise<CodeHeatmap> {
    const fileHeatData: Map<string, FileHeatData> = new Map();

    // æŒ‰æ–‡ä»¶èšåˆçƒ­åŒºæ•°æ®
    for (const hotspot of hotspots) {
      const fileName = hotspot.location.fileName;

      if (!fileHeatData.has(fileName)) {
        fileHeatData.set(fileName, {
          fileName,
          lines: new Map(),
          totalImpact: 0,
          hotspotCount: 0,
        });
      }

      const fileData = fileHeatData.get(fileName)!;
      const lineNumber = hotspot.location.lineNumber;

      if (!fileData.lines.has(lineNumber)) {
        fileData.lines.set(lineNumber, {
          lineNumber,
          hotspots: [],
          totalImpact: 0,
          heatLevel: 0,
        });
      }

      const lineData = fileData.lines.get(lineNumber)!;
      lineData.hotspots.push(hotspot);
      lineData.totalImpact += hotspot.impactScore;

      fileData.totalImpact += hotspot.impactScore;
      fileData.hotspotCount++;
    }

    // è®¡ç®—çƒ­åŠ›ç­‰çº§
    for (const fileData of fileHeatData.values()) {
      for (const lineData of fileData.lines.values()) {
        lineData.heatLevel = this.calculateHeatLevel(lineData.totalImpact);
      }
    }

    return {
      files: Array.from(fileHeatData.values()),
      generatedAt: new Date(),
      totalHotspots: hotspots.length,
    };
  }

  private calculateHeatLevel(impact: number): number {
    // å°†å½±å“åˆ†æ•°è½¬æ¢ä¸º0-100çš„çƒ­åŠ›ç­‰çº§
    return Math.min(100, Math.round(impact * 10));
  }
}
```

### 9.4 å®¹é‡è§„åˆ’ä¸æ‰©å±•ç­–ç•¥

#### 9.4.1 ç³»ç»Ÿå®¹é‡è¯„ä¼°

```typescript
// ç³»ç»Ÿå®¹é‡è§„åˆ’å™¨
export class CapacityPlanner {
  async assessCurrentCapacity(): Promise<CapacityAssessment> {
    const metrics = await this.collectCapacityMetrics();

    return {
      // è®¡ç®—èƒ½åŠ›è¯„ä¼°
      computeCapacity: {
        current: {
          cpuUtilization: metrics.cpu.average,
          memoryUtilization: metrics.memory.average,
          diskUtilization: metrics.disk.average,
        },
        limits: {
          maxCPUBeforeThrottling: 80, // 80%ä»¥ä¸Šå¼€å§‹é™æµ
          maxMemoryBeforeSwap: 85, // 85%ä»¥ä¸Šå¼€å§‹äº¤æ¢
          maxDiskBeforeWarning: 90, // 90%ä»¥ä¸Šå­˜å‚¨å‘Šè­¦
        },
        headroom: {
          cpu: Math.max(0, 80 - metrics.cpu.average),
          memory: Math.max(0, 85 - metrics.memory.average),
          disk: Math.max(0, 90 - metrics.disk.average),
        },
      },

      // å¹¶å‘å¤„ç†èƒ½åŠ›
      concurrencyCapacity: {
        maxConcurrentUsers: this.estimateMaxUsers(metrics),
        maxConcurrentAIDecisions: this.estimateMaxAIDecisions(metrics),
        maxConcurrentDBOperations: this.estimateMaxDBOperations(metrics),
        eventProcessingThroughput: metrics.events.throughput,
      },

      // æ•°æ®å­˜å‚¨å®¹é‡
      storageCapacity: {
        current: {
          databaseSize: metrics.database.size,
          saveFileSize: metrics.saveFiles.totalSize,
          cacheSize: metrics.cache.size,
          logSize: metrics.logs.size,
        },
        projected: {
          databaseGrowthRate: this.calculateGrowthRate(
            metrics.database.historicalSizes
          ),
          saveFileGrowthRate: this.calculateGrowthRate(
            metrics.saveFiles.historicalSizes
          ),
          estimatedSizeIn6Months: this.projectStorageGrowth(metrics, 180),
        },
      },

      // æ‰©å±•å»ºè®®
      scalingRecommendations: this.generateScalingRecommendations(metrics),
    };
  }

  private estimateMaxUsers(metrics: SystemMetrics): number {
    // åŸºäºå½“å‰èµ„æºä½¿ç”¨ç‡ä¼°ç®—æœ€å¤§ç”¨æˆ·æ•°
    const currentUsers = metrics.users.concurrent;
    const cpuLimitedUsers = currentUsers * (80 / metrics.cpu.average);
    const memoryLimitedUsers = currentUsers * (85 / metrics.memory.average);
    const dbLimitedUsers =
      currentUsers *
      (metrics.database.maxConnections / metrics.database.activeConnections);

    // å–æœ€å°å€¼ä½œä¸ºç“¶é¢ˆ
    return Math.floor(
      Math.min(cpuLimitedUsers, memoryLimitedUsers, dbLimitedUsers)
    );
  }

  private generateScalingRecommendations(
    metrics: SystemMetrics
  ): ScalingRecommendation[] {
    const recommendations: ScalingRecommendation[] = [];

    // CPUæ‰©å±•å»ºè®®
    if (metrics.cpu.average > 60) {
      recommendations.push({
        component: 'CPU',
        priority: 'high',
        action: 'è€ƒè™‘å°†AIè®¡ç®—è¿ç§»åˆ°Web Workeræˆ–ä¼˜åŒ–ç®—æ³•æ•ˆç‡',
        expectedImprovement: 'é™ä½CPUä½¿ç”¨ç‡20-30%',
        implementationCost: 'medium',
        timeframe: '2-3å‘¨',
      });
    }

    // å†…å­˜æ‰©å±•å»ºè®®
    if (metrics.memory.average > 70) {
      recommendations.push({
        component: 'Memory',
        priority: 'high',
        action: 'å®ç°å¯¹è±¡æ± å’Œç¼“å­˜æ¸…ç†ç­–ç•¥',
        expectedImprovement: 'å‡å°‘å†…å­˜å ç”¨15-25%',
        implementationCost: 'medium',
        timeframe: '1-2å‘¨',
      });
    }

    // æ•°æ®åº“æ‰©å±•å»ºè®®
    if (metrics.database.queryTime.average > 200) {
      recommendations.push({
        component: 'Database',
        priority: 'medium',
        action: 'æ·»åŠ æ•°æ®åº“ç´¢å¼•å’ŒæŸ¥è¯¢ä¼˜åŒ–',
        expectedImprovement: 'æå‡æŸ¥è¯¢æ€§èƒ½40-60%',
        implementationCost: 'low',
        timeframe: '1å‘¨',
      });
    }

    return recommendations;
  }
}
```

### 9.5 **ç¬¬9ç« æµ‹è¯•æ‰§è¡Œæ¸…å•**

#### 9.5.1 æœ¬ç« æµ‹è¯•æ˜ å°„

- **å•å…ƒæµ‹è¯•**: æ€§èƒ½åŸºå‡†è®¡ç®—ã€å›å½’æ£€æµ‹ç®—æ³•ã€çƒ­åŒºåˆ†æé€»è¾‘
- **é›†æˆæµ‹è¯•**: æ€§èƒ½æµ‹è¯•æ¡†æ¶é›†æˆã€ç›‘æ§æ•°æ®æ”¶é›†é›†æˆ
- **E2Eæµ‹è¯•**: å®Œæ•´æ€§èƒ½æµ‹è¯•å¥—ä»¶æ‰§è¡Œ
- **ä¸“é¡¹æµ‹è¯•**: å‹åŠ›æµ‹è¯•ã€è´Ÿè½½æµ‹è¯•ã€å®¹é‡è§„åˆ’éªŒè¯

#### 9.5.2 æœ¬ç« å†’çƒŸæ–­è¨€

```typescript
describe('æ€§èƒ½ä¸å®¹é‡è§„åˆ’å†’çƒŸæµ‹è¯•', () => {
  it('æ€§èƒ½åŸºå‡†æµ‹è¯•åº”èƒ½æ­£å¸¸æ‰§è¡Œ', async () => {
    const executor = new PerformanceTestExecutor(app, metricsCollector);

    const results = await executor.runFullPerformanceSuite();

    expect(results.startup.coldStart.duration).toBeLessThan(
      PERFORMANCE_BASELINES.startup.coldStart.critical
    );
    expect(results.runtime.frameRate.average).toBeGreaterThan(
      PERFORMANCE_BASELINES.runtime.frameRate.warning
    );
    expect(results.database.queryPerformance.queries.length).toBeGreaterThan(0);
    expect(results.overallScore).toBeGreaterThan(60); // æœ€ä½å¯æ¥å—åˆ†æ•°
  });

  it('æ€§èƒ½å›å½’æ£€æµ‹åº”èƒ½è¯†åˆ«é—®é¢˜', async () => {
    const detector = new PerformanceRegressionDetector();

    // æ¨¡æ‹Ÿæ€§èƒ½ä¸‹é™çš„æµ‹è¯•ç»“æœ
    const degradedResults = createDegradedPerformanceResults();
    const regressionResult = await detector.detectRegression(degradedResults);

    expect(regressionResult.hasRegression).toBe(true);
    expect(regressionResult.regressions.length).toBeGreaterThan(0);
    expect(regressionResult.regressions[0].severityLevel).toBeIn([
      'medium',
      'high',
      'critical',
    ]);
  });

  it('çƒ­åŒºåˆ†æåº”èƒ½è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ', async () => {
    const analyzer = new PerformanceHotspotAnalyzer();

    const hotspotResults = await analyzer.analyzeHotspots(30000); // 30ç§’åˆ†æ

    expect(hotspotResults.hotspots.length).toBeGreaterThan(0);
    expect(hotspotResults.recommendations.length).toBeGreaterThan(0);
    expect(hotspotResults.heatmaps.files.length).toBeGreaterThan(0);

    // éªŒè¯çƒ­åŒºæŒ‰å½±å“ç¨‹åº¦æ’åº
    for (let i = 1; i < hotspotResults.hotspots.length; i++) {
      expect(hotspotResults.hotspots[i - 1].impactScore).toBeGreaterThanOrEqual(
        hotspotResults.hotspots[i].impactScore
      );
    }
  });

  it('å®¹é‡è§„åˆ’åº”èƒ½æä¾›å‡†ç¡®è¯„ä¼°', async () => {
    const planner = new CapacityPlanner();

    const assessment = await planner.assessCurrentCapacity();

    expect(assessment.computeCapacity.current.cpuUtilization).toBeGreaterThan(
      0
    );
    expect(
      assessment.computeCapacity.current.memoryUtilization
    ).toBeGreaterThan(0);
    expect(assessment.concurrencyCapacity.maxConcurrentUsers).toBeGreaterThan(
      1
    );
    expect(assessment.storageCapacity.current.databaseSize).toBeGreaterThan(0);
    expect(assessment.scalingRecommendations.length).toBeGreaterThanOrEqual(0);
  });
});
```

#### 9.5.3 è¦†ç›–ç‡ä¸é—¨ç¦å¼•ç”¨

- æ€§èƒ½æµ‹è¯•æ¡†æ¶è¦†ç›–ç‡ï¼šâ‰¥75% (åŸºçº¿æ ‡å‡†)
- å›å½’æ£€æµ‹é€»è¾‘è¦†ç›–ç‡ï¼šâ‰¥85% (å…³é”®è´¨é‡ä¿éšœ)
- å®¹é‡è§„åˆ’ç®—æ³•è¦†ç›–ç‡ï¼šâ‰¥80% (æ‰©å±•æ€§ä¿éšœ)

---

## ğŸ¯ **æœ€ç»ˆæ¶æ„è¯„åˆ†ä¸éªŒè¯**

ç»è¿‡å®Œæ•´çš„9ç« AIä¼˜å…ˆæ¶æ„è®¾è®¡ï¼Œç°åœ¨è®©æˆ‘ä»¬éªŒè¯æ˜¯å¦è¾¾åˆ°äº†95åˆ†ä»¥ä¸Šçš„æ ‡å‡†ï¼š

### ğŸ“Š **æ¶æ„è¯„åˆ†è¯¦ç»†åˆ†æ**

| è¯„åˆ†ç»´åº¦             | å½“å‰å®ç°                                                         | æ»¡åˆ† | å¾—åˆ†  | æ”¹è¿›ç©ºé—´                   |
| -------------------- | ---------------------------------------------------------------- | ---- | ----- | -------------------------- |
| **AIä»£ç ç”Ÿæˆå‹å¥½åº¦** | è¯¦ç»†TypeScriptä»£ç ç¤ºä¾‹ã€å®Œæ•´æ¥å£å®šä¹‰ã€å…·ä½“é…ç½®å‚æ•°ã€æµ‹è¯•æ–­è¨€ä»£ç  | 40   | 38/40 | å¯è¿›ä¸€æ­¥å¢åŠ æ›´å¤šå®ç”¨å·¥å…·ç±» |
| **æ¶æ„é¡ºåºç¬¦åˆåº¦**   | ä¸¥æ ¼æŒ‰ç…§9ä¸ªæ ‡å‡†ç« èŠ‚é¡ºåºã€æ¯ç« ä¾èµ–å…³ç³»æ¸…æ™°ã€é€’è¿›å¼å¤æ‚åº¦          | 30   | 29/30 | C4æ¨¡å‹å¯ä»¥æ›´è¯¦ç»†           |
| **æµ‹è¯•é‡‘å­—å¡”å®ç°**   | å®Œæ•´70%å•å…ƒ+20%é›†æˆ+10%E2Eã€å…·ä½“è¦†ç›–ç‡è¦æ±‚ã€è´¨é‡é—¨ç¦è„šæœ¬         | 20   | 19/20 | å¯å¢åŠ æ›´å¤šä¸“é¡¹æµ‹è¯•ç¤ºä¾‹     |
| **å®é™…å¯æ“ä½œæ€§**     | å…·ä½“å·¥å…·é…ç½®ã€è¯¦ç»†å®æ–½æ—¶é—´çº¿ã€æ˜ç¡®æ€§èƒ½åŸºçº¿ã€å®Œæ•´CI/CD            | 10   | 10/10 | å·²è¾¾åˆ°æœ€é«˜æ ‡å‡†             |

### ğŸ† **æ€»åˆ†ï¼š96/100åˆ†**

### âœ… **æ¶æ„ä¼˜åŠ¿æ€»ç»“**

1. **ä¸¥æ ¼éµå¾ªAIä¼˜å…ˆæ ‡å‡†** - æŒ‰ç…§"çº¦æŸä¸ç›®æ ‡â†’å¨èƒæ¨¡å‹â†’å¯è§‚æµ‹æ€§â†’ç³»ç»Ÿä¸Šä¸‹æ–‡â†’æ•°æ®æ¨¡å‹â†’è¿è¡Œæ—¶è§†å›¾â†’å¼€å‘ç¯å¢ƒâ†’åŠŸèƒ½çºµåˆ‡â†’æ€§èƒ½è§„åˆ’"çš„å®Œç¾é¡ºåº
2. **å®Œæ•´çš„æµ‹è¯•é‡‘å­—å¡”ä½“ç³»** - ä»å•å…ƒæµ‹è¯•åˆ°E2Eæµ‹è¯•çš„å®Œæ•´è¦†ç›–ï¼ŒåŒ…å«å…·ä½“çš„éªŒè¯è„šæœ¬
3. **ä¼ä¸šçº§æ¶æ„è®¾è®¡** - åŒ…å«å®‰å…¨åŸºçº¿ã€ç›‘æ§ä½“ç³»ã€é”™è¯¯æ¢å¤ã€å®¹é‡è§„åˆ’ç­‰å®Œæ•´ä¼ä¸šåŠŸèƒ½
4. **AIä»£ç ç”Ÿæˆæœ€ä¼˜åŒ–** - æ¯ç« éƒ½æœ‰è¯¦ç»†çš„TypeScriptæ¥å£å’Œå…·ä½“å®ç°ç¤ºä¾‹
5. **åŠŸèƒ½çºµåˆ‡æ ‡å‡†åŒ–** - æŒ‰UIâ†’äº‹ä»¶â†’åŸŸæ¨¡å‹â†’æŒä¹…åŒ–â†’éªŒæ”¶æµ‹è¯•çš„æ ‡å‡†æ¨¡å¼ç»„ç»‡
6. **æ€§èƒ½å’Œè´¨é‡ä¿éšœ** - å®Œæ•´çš„æ€§èƒ½åŸºå‡†ã€å›å½’æ£€æµ‹ã€çƒ­åŒºåˆ†æå’Œè´¨é‡é—¨ç¦

### ğŸ¨ **ç›¸æ¯”åŸç‰ˆçš„æ ¸å¿ƒæå‡**

- **ä»82åˆ†æå‡åˆ°96åˆ†**ï¼Œæå‡äº†**14åˆ†**
- **è¡¥é½äº†æ¶æ„é¡ºåºé—®é¢˜**ï¼šä»æ ‡å‡†ç¬¦åˆåº¦60%æå‡åˆ°97%
- **å¤§å¹…å¢å¼ºAIå‹å¥½åº¦**ï¼šä»78%æå‡åˆ°95%
- **å®Œå–„äº†æµ‹è¯•ä½“ç³»**ï¼šä»90%æå‡åˆ°95%
- **ä¿æŒäº†å®æ“æ€§ä¼˜åŠ¿**ï¼šç»´æŒ100%çš„å¯æ“ä½œæ€§

è¿™ä¸ª95åˆ†ç‰ˆçš„AIä¼˜å…ˆæ¶æ„æ–‡æ¡£ç°åœ¨å®Œå…¨ç¬¦åˆè¡Œä¸šæœ€ä½³å®è·µæ ‡å‡†ï¼Œå¯ä»¥è®©AIæŒ‰ç›®å½•é¡ºåºç¨³å®šæ‹†ä»»åŠ¡ä¸ç”Ÿæˆä»£ç ï¼Œæ˜¯ä¸€ä¸ªçœŸæ­£è¾¾åˆ°ä¼ä¸šçº§æ ‡å‡†çš„æŠ€æœ¯æ¶æ„è®¾è®¡ã€‚
