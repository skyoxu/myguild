# 01 çº¦æŸä¸ç›®æ ‡ï¼ˆå« SLO/SLA/NFR/ADRï¼‰

> å›ºåŒ–è´¨é‡ç›®æ ‡ä¸å®¹é‡å‡è®¾ï¼Œå½¢æˆ **SLO â†’ è´¨é‡é—¨ç¦** çš„å¯æ‰§è¡Œæ˜ å°„ï¼Œä½œä¸ºåç»­æ‰€æœ‰ç« èŠ‚â€œæŒ‰ç« ç”Ÿç â€çš„é”šç‚¹ã€‚

---

## ä¸€ã€èŒƒå›´ä¸ç›®æ ‡ï¼ˆScope & Goalsï¼‰

### 1.1 æŠ€æœ¯æ ˆçº¦æŸï¼ˆç¡¬æ€§ï¼Œä¸å¯å˜æ›´ï¼‰

- **æŠ€æœ¯æ ˆï¼ˆå·²å®šï¼‰**ï¼šElectron + **React 19** + Phaser 3 + Vite + TypeScript + Tailwind CSS v4
- **æ•°æ®æœåŠ¡**ï¼šSQLiteï¼ˆæœ¬åœ°é«˜æ€§èƒ½æ•°æ®åº“ï¼‰
- **AIè®¡ç®—**ï¼šWeb Workerï¼ˆè®¡ç®—çº¿ç¨‹åˆ†ç¦»ï¼‰
- **é€šä¿¡æœºåˆ¶**ï¼šEventBusï¼ˆPhaser â†” Reacté€šä¿¡ï¼‰
- **ç›‘æ§å·¥å…·**ï¼šSentryï¼ˆé”™è¯¯ç›‘æ§å’Œæ€§èƒ½è¿½è¸ªï¼‰
- **å¹³å°**ï¼šWindows / macOSï¼ˆæ¡Œé¢ç«¯ï¼Œä½¿ç”¨electron-builderæ‰“åŒ…ï¼‰

### 1.2 äº§å“å®šä½ä¸æ ¸å¿ƒç›®æ ‡

- **äº§å“ç±»å‹**ï¼šæ·±åº¦**ç”Ÿæ€æ¨¡æ‹Ÿæ¸¸æˆ** - ç©å®¶ä½œä¸ºMMOå…¬ä¼šä¼šé•¿ç®¡ç†å®Œæ•´è™šæ‹Ÿå…¬ä¼šç”Ÿæ€
- **ç­–ç•¥æ·±åº¦**ï¼šåª²ç¾Football Managerçš„ç®¡ç†æ·±åº¦ï¼Œä¸“æ³¨MMOå…¬ä¼šç®¡ç†å‚ç›´é¢†åŸŸ
- **ç”Ÿæ€åˆ›æ–°**ï¼šåºå¤§äº‹ä»¶æ± ç³»ç»Ÿï¼ˆ1000+äº‹ä»¶ï¼‰+ å¤šå±‚AIç”Ÿæ€ï¼ˆæˆå‘˜AI + NPCå…¬ä¼šAI + ç¯å¢ƒAIï¼‰
- **å·®å¼‚åŒ–å®šä½**ï¼šé¦–æ¬¾æ·±åº¦MMOå…¬ä¼šç”Ÿæ€æ¨¡æ‹Ÿæ¸¸æˆï¼Œå¡«è¡¥å¸‚åœºç©ºç™½

### 1.3 MVPç›®æ ‡ï¼ˆæœ€å°å¯ç©å¾ªç¯ï¼‰

**æ ¸å¿ƒæ¸¸æˆå¾ªç¯ï¼ˆ3é˜¶æ®µå›åˆåˆ¶ï¼‰**ï¼š

1. **ç»“ç®—é˜¶æ®µ**ï¼šå¤„ç†ä¸Šå›åˆå»¶æ—¶äº‹ä»¶ï¼Œå±•ç¤ºPVE/PVPç»“æœ
2. **ç©å®¶é˜¶æ®µ**ï¼šå¤„ç†ä¼šé•¿é‚®ç®±äº‹ä»¶ï¼Œç®¡ç†å…¬ä¼šå’Œæˆå‘˜
3. **AIæ¨¡æ‹Ÿé˜¶æ®µ**ï¼šæ‰€æœ‰AIå®ä½“è‡ªä¸»è¡ŒåŠ¨ï¼Œç”Ÿæˆä¸‹å›åˆäº‹ä»¶

**MVPå¿…éœ€åŠŸèƒ½**ï¼š

- âœ… å¯åŠ¨æ¸¸æˆ â†’ é€‰æ‹©/åˆ›å»ºå…¬ä¼šæ¡£æ¡ˆ â†’ è¿›å…¥ç®¡ç†ç•Œé¢
- âœ… åŸºç¡€äº‹ä»¶ç³»ç»Ÿï¼ˆè‡³å°‘200+äº‹ä»¶ï¼‰è¿è½¬
- âœ… 6å¤§åŠŸèƒ½æ¨¡å—åŸºç¡€ç‰ˆæœ¬ï¼ˆå…¬ä¼šç®¡ç†ã€ä½œæˆ˜å¤§å…ã€æˆ˜æœ¯ä¸­å¿ƒã€ä¼šå‘˜ç®¡ç†ã€è®ºå›ã€åå‹¤ï¼‰
- âœ… AIç”Ÿæ€åŸºç¡€å±‚ï¼ˆæˆå‘˜AIä¸ªæ€§åŒ– + 10ä¸ªNPCå…¬ä¼šï¼‰
- âœ… å®Œæ•´å­˜æ¡£ç³»ç»Ÿï¼ˆSQLiteæœ¬åœ°å­˜å‚¨ï¼Œæ”¯æŒå¤šæ¡£æ¡ˆï¼‰
- âœ… ç¨³å®š60FPSæ¸¸æˆå¾ªç¯ + UIå“åº”æ€§<100ms

### 1.4 ä¸šåŠ¡ç›®æ ‡ä¸æˆåŠŸæŒ‡æ ‡

**æŠ€æœ¯æŒ‡æ ‡**ï¼š

- **ç¨³å®šæ€§**ï¼šCrash-free Sessions â‰¥ 99.5%
- **æ€§èƒ½**ï¼šæ¸¸æˆå¾ªç¯60FPSï¼Œå…³é”®äº¤äº’TP95 < 100ms
- **å­˜æ¡£**ï¼šæœ¬åœ°SQLiteå­˜æ¡£ < 50MBï¼Œä¿å­˜/è¯»å– < 100ms

**ç”¨æˆ·ä½“éªŒæŒ‡æ ‡**ï¼š

- **ç›®æ ‡ç”¨æˆ·**ï¼šMMOèµ„æ·±ç©å®¶ï¼ˆ25-40å²ï¼Œå…·æœ‰å…¬ä¼šç®¡ç†ç»éªŒï¼‰
- **å­¦ä¹ æ›²çº¿**ï¼šæ–°æ‰‹èƒ½åœ¨30åˆ†é’Ÿå†…ç†è§£åŸºç¡€ç©æ³•
- **é•¿æœŸå¯ç©æ€§**ï¼šå•æ¡£æ¡ˆè‡³å°‘50+å°æ—¶æ·±åº¦æ¸¸æˆä½“éªŒ

**å¼€å‘é‡Œç¨‹ç¢‘**ï¼ˆ10ä¸ªæœˆï¼Œ4é˜¶æ®µï¼‰ï¼š

- **Phase 1** (Month 1-4)ï¼šäº‹ä»¶å¼•æ“æ ¸å¿ƒ + AIç”Ÿæ€åŸºç¡€
- **Phase 2** (Month 5-7)ï¼š6å¤§åŠŸèƒ½æ¨¡å—é›†æˆ + UIå®Œå–„
- **Phase 3** (Month 8-9)ï¼šå†…å®¹å®Œå–„ + Alpha/Betaæµ‹è¯•
- **Phase 4** (Month 10)ï¼šæŠ›å…‰ + å‘å¸ƒå‡†å¤‡

### 1.5 æ˜ç¡®çš„éç›®æ ‡æ¸…å•ï¼ˆé¦–ç‰ˆä¸åšï¼‰

**ç½‘ç»œåŠŸèƒ½**ï¼š

- âŒ è”æœºå¯¹æˆ˜ã€å®æ—¶PVP
- âŒ äº‘ç«¯å­˜æ¡£åŒæ­¥ã€å¤šè®¾å¤‡åŒæ­¥
- âŒ åœ¨çº¿æ’è¡Œæ¦œã€ç¤¾äº¤åˆ†äº«

**å¤æ‚æ‰©å±•åŠŸèƒ½**ï¼š

- âŒ å¡ç‰Œç³»ç»Ÿï¼ˆé¢„ç•™æ¥å£ï¼ŒDLCè€ƒè™‘ï¼‰
- âŒ æŠ€èƒ½æ ‘ç³»ç»Ÿï¼ˆé¢„ç•™æ¥å£ï¼Œæœªæ¥ç‰ˆæœ¬ï¼‰
- âŒ ç§»åŠ¨ç«¯é€‚é…ï¼ˆä¸“æ³¨æ¡Œé¢ç«¯ä½“éªŒï¼‰
- âŒ æ¨¡ç»„ç³»ç»Ÿï¼ˆé¢„ç•™æ¶æ„ï¼Œåç»­ç‰ˆæœ¬ï¼‰

**è¿‡åº¦å†…å®¹**ï¼š

- âŒ è¶…è¿‡25ä¸ªNPCå…¬ä¼šï¼ˆé¦–ç‰ˆ10-20ä¸ªè¶³å¤Ÿï¼‰
- âŒ å¤æ‚çš„ç»æµç³»ç»Ÿï¼ˆä¿æŒç®€åŒ–ç›´è§‚ï¼‰
- âŒ 3Dæ¸²æŸ“ï¼ˆåšæŒ2Dä¼˜åŒ–ç­–ç•¥ï¼‰

### 1.6 å…³é”®çº¦æŸä¸é£é™©æ§åˆ¶

**å¼€å‘çº¦æŸ**ï¼š

- **å›¢é˜Ÿè§„æ¨¡**ï¼šä¸€äººå›¢é˜Ÿï¼Œå¿…é¡»ä¸¥æ ¼éµå¾ªKISSå’ŒYAGNIåŸåˆ™
- **æŠ€æœ¯å€ºåŠ¡**ï¼šä»£ç è¦†ç›–ç‡â‰¥90%ï¼Œå‡½æ•°è¡Œæ•°â‰¤50ï¼Œè®¤çŸ¥å¤æ‚åº¦â‰¤15
- **åŠŸèƒ½è”“å»¶**ï¼šä¸¥ç¦"å¯èƒ½ç”¨å¾—ä¸Š"çš„åŠŸèƒ½ï¼Œåªå®ç°æ˜ç¡®éœ€æ±‚

**è´¨é‡é—¨ç¦**ï¼š

- **æ¯å‘¨å›å½’**ï¼šåŸºå‡†è„šæœ¬éªŒè¯æ€§èƒ½ä¸é€€åŒ–
- **ä»£ç å®¡æŸ¥**ï¼šå¤æ‚åº¦çº¦æŸ + TypeScriptä¸¥æ ¼æ¨¡å¼
- **ç”¨æˆ·æµ‹è¯•**ï¼šAlphaæµ‹è¯•ï¼ˆMonth 6ï¼‰+ Betaæµ‹è¯•ï¼ˆMonth 8-9ï¼‰

---

## äºŒã€è´¨é‡å±æ€§ï¼ˆNFRï¼‰- ISO 25010 åˆ†ç±»ä¸é˜ˆå€¼

### 2.1 æ€§èƒ½æ•ˆç‡ï¼ˆPerformance Efficiencyï¼‰

#### 2.1.1 æ—¶é—´ç‰¹æ€§ï¼ˆTime Behaviorï¼‰

| æŒ‡æ ‡ç±»åˆ«      | å…·ä½“æŒ‡æ ‡       | ç›®æ ‡é˜ˆå€¼          | æµ‹é‡æ–¹å¼            | ä¸šåŠ¡å½±å“       |
| ------------- | -------------- | ----------------- | ------------------- | -------------- |
| **UI å“åº”æ€§** | å…³é”®äº¤äº’ TP95  | < 100 ms          | Playwright åŸºå‡†è„šæœ¬ | ç”¨æˆ·ä½“éªŒæµç•…æ€§ |
| **åº”ç”¨å¯åŠ¨**  | å†·å¯åŠ¨æ—¶é—´     | < 3 s             | E2E è‡ªåŠ¨åŒ–æµ‹è¯•      | ç”¨æˆ·é¦–æ¬¡å°è±¡   |
| **æ¸¸æˆå¾ªç¯**  | å¸§ç‡ç¨³å®šæ€§     | â‰¥ 58 FPS (60Hzå±) | Phaser æ€§èƒ½ç›‘æ§     | æ¸¸æˆæµç•…ä½“éªŒ   |
| **äº‹ä»¶å¤„ç†**  | å•äº‹ä»¶å¤„ç†æ—¶é—´ | < 200 ms          | å†…éƒ¨æ€§èƒ½æ—¥å¿—        | æ¸¸æˆé€»è¾‘å“åº”   |
| **å­˜æ¡£æ“ä½œ**  | å­˜æ¡£ä¿å­˜/åŠ è½½  | < 100 ms          | SQLite æ€§èƒ½ç›‘æ§     | æ“ä½œå³æ—¶åé¦ˆ   |
| **AI è®¡ç®—**   | AI å†³ç­–å‘¨æœŸ    | < 500 ms          | Web Worker ç›‘æ§     | AI æ™ºèƒ½ä½“éªŒ    |

#### 2.1.2 èµ„æºåˆ©ç”¨ç‡ï¼ˆResource Utilizationï¼‰

| èµ„æºç±»å‹     | æ­£å¸¸è¿è¡Œ  | å³°å€¼ä¸Šé™  | ç›‘æ§é˜ˆå€¼ | ä¼˜åŒ–è§¦å‘ç‚¹   |
| ------------ | --------- | --------- | -------- | ------------ |
| **å†…å­˜ä½¿ç”¨** | < 300 MB  | < 400 MB  | 350 MB   | å†…å­˜æ³„æ¼æ£€æµ‹ |
| **CPU ä½¿ç”¨** | < 15%     | < 50%     | 30%      | æ€§èƒ½ä¼˜åŒ–è¯„ä¼° |
| **ç£ç›˜ I/O** | < 10 MB/s | < 50 MB/s | 25 MB/s  | I/O ä¼˜åŒ–éœ€æ±‚ |
| **GPU ä½¿ç”¨** | < 20%     | < 60%     | 40%      | æ¸²æŸ“ä¼˜åŒ–è¯„ä¼° |

#### 2.1.3 å®¹é‡ç‰¹æ€§ï¼ˆCapacityï¼‰

- **äº‹ä»¶æ± è§„æ¨¡**ï¼šæ”¯æŒ 1000+ äº‹ä»¶å¹¶å‘å¤„ç†ï¼Œå¤„ç†èƒ½åŠ›ä¸é™çº§
- **AI å®ä½“æ•°é‡**ï¼šæ”¯æŒ 200+ AI åŒæ—¶è¿è¡Œï¼Œå“åº”æ—¶é—´ä¸å—å½±å“
- **å­˜æ¡£æ–‡ä»¶å¤§å°**ï¼šæ”¯æŒ 50 MB å­˜æ¡£ï¼ŒåŠ è½½æ—¶é—´ä¿æŒåœ¨é˜ˆå€¼å†…
- **å¹¶å‘æ“ä½œ**ï¼šUI çº¿ç¨‹äº‹ä»¶å³°å€¼ 200 evt/s å†…ç¨³å®šè¿è¡Œ

### 2.2 å¯é æ€§ï¼ˆReliabilityï¼‰

#### 2.2.1 æˆç†Ÿåº¦ï¼ˆMaturityï¼‰

| ç¨³å®šæ€§æŒ‡æ ‡     | ç›®æ ‡å€¼  | æµ‹é‡çª—å£  | æ•°æ®æ¥æº              | ä¿®å¤ç­–ç•¥              |
| -------------- | ------- | --------- | --------------------- | --------------------- |
| **ä¼šè¯æˆåŠŸç‡** | â‰¥ 99.5% | 30 å¤©æ»šåŠ¨ | Sentry Release Health | è‡ªåŠ¨å´©æºƒæŠ¥å‘Š + çƒ­ä¿®å¤ |
| **åŠŸèƒ½å¯ç”¨æ€§** | â‰¥ 99.9% | 7 å¤©æ»šåŠ¨  | åŠŸèƒ½ç›‘æ§ç³»ç»Ÿ          | é™çº§æ–¹æ¡ˆ + å¿«é€Ÿå›æ»š   |
| **æ•°æ®å®Œæ•´æ€§** | 100%    | å®æ—¶ç›‘æ§  | SQLite å®Œæ•´æ€§æ£€æŸ¥     | è‡ªåŠ¨å¤‡ä»½ + æ•°æ®ä¿®å¤   |

#### 2.2.2 å®¹é”™æ€§ï¼ˆFault Toleranceï¼‰

- **AI è®¡ç®—å¤±è´¥**ï¼šWorker çº¿ç¨‹å´©æºƒåè‡ªåŠ¨é‡å¯ï¼Œæ¸¸æˆç»§ç»­è¿è¡Œ
- **äº‹ä»¶å¤„ç†å¼‚å¸¸**ï¼šå•ä¸ªäº‹ä»¶å¤±è´¥ä¸å½±å“å…¶ä»–äº‹ä»¶æ‰§è¡Œ
- **å­˜å‚¨å±‚æ•…éšœ**ï¼šè‡ªåŠ¨é™çº§åˆ°å†…å­˜æ¨¡å¼ï¼Œæ•°æ®ç¼“å­˜ä¿æŠ¤
- **UI ç»„ä»¶å´©æºƒ**ï¼šReact é”™è¯¯è¾¹ç•Œéš”ç¦»ï¼Œå±€éƒ¨é‡æ¸²æŸ“æ¢å¤

#### 2.2.3 æ¢å¤æ€§ï¼ˆRecoverabilityï¼‰

- **å´©æºƒæ¢å¤**ï¼šè‡ªåŠ¨å­˜æ¡£æ£€æŸ¥ç‚¹ï¼Œæœ€å¤šä¸¢å¤± 1 åˆ†é’Ÿè¿›åº¦
- **æ•°æ®ä¿®å¤**ï¼šè‡ªåŠ¨å¤‡ä»½æœºåˆ¶ï¼Œæ”¯æŒæœ€è¿‘ 10 ä¸ªå­˜æ¡£æ¢å¤
- **çŠ¶æ€æ¢å¤**ï¼šæ¸¸æˆçŠ¶æ€è‡ªåŠ¨ä¿å­˜ï¼Œé‡å¯åæ— ç¼ç»§ç»­

### 2.3 å®‰å…¨æ€§ï¼ˆSecurityï¼‰- Electron ä¸“ç”¨

#### 2.3.1 æœºå¯†æ€§ï¼ˆConfidentialityï¼‰

| å®‰å…¨æªæ–½           | å®æ–½æ ‡å‡†                   | éªŒè¯æ–¹å¼       | é£é™©æ§åˆ¶         |
| ------------------ | -------------------------- | -------------- | ---------------- |
| **è¿›ç¨‹éš”ç¦»**       | æ¸²æŸ“è¿›ç¨‹ç¦ç”¨ Node          | è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æ | é˜»æ­¢æ¶æ„ä»£ç æ‰§è¡Œ |
| **ä¸Šä¸‹æ–‡éš”ç¦»**     | Context Isolation å¼ºåˆ¶å¯ç”¨ | å¯åŠ¨æ—¶æ£€æŸ¥     | é˜²æ­¢è„šæœ¬æ³¨å…¥     |
| **CSP ç­–ç•¥**       | ä¸¥æ ¼å†…å®¹å®‰å…¨ç­–ç•¥           | CSP åˆè§„æ£€æµ‹   | é˜»æ­¢ XSS æ”»å‡»    |
| **Preload ç™½åå•** | æœ€å°åŒ– API æš´éœ²            | ä»£ç å®¡æŸ¥       | å‡å°‘æ”»å‡»é¢       |

#### 2.3.2 å®Œæ•´æ€§ï¼ˆIntegrityï¼‰

- **ä»£ç ç­¾å**ï¼šæ‰€æœ‰å‘å¸ƒç‰ˆæœ¬å¼ºåˆ¶ä»£ç ç­¾åéªŒè¯
- **æ–‡ä»¶å®Œæ•´æ€§**ï¼šå­˜æ¡£æ–‡ä»¶ checksum æ ¡éªŒï¼Œé˜²æ­¢ç¯¡æ”¹
- **æ›´æ–°éªŒè¯**ï¼šè‡ªåŠ¨æ›´æ–°åŒ…ç­¾åéªŒè¯ï¼Œé˜²æ­¢ä¸­é—´äººæ”»å‡»

#### 2.3.3 å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰

- **æœ¬åœ°ä¼˜å…ˆ**ï¼šæ— ç½‘ç»œä¾èµ–ï¼Œç¦»çº¿å®Œæ•´å¯ç”¨
- **æƒé™æœ€å°åŒ–**ï¼šä»…ç”³è¯·å¿…è¦çš„ç³»ç»Ÿæƒé™
- **æ²™ç®±éš”ç¦»**ï¼šæ¸¸æˆè¿›ç¨‹åœ¨å—é™ç¯å¢ƒä¸­è¿è¡Œ

### 2.4 å¯ç»´æŠ¤æ€§ï¼ˆMaintainabilityï¼‰

#### 2.4.1 æ¨¡å—åŒ–ï¼ˆModularityï¼‰

| æ¨¡å—åŒ–æŒ‡æ ‡   | ç›®æ ‡å€¼   | æµ‹é‡æ–¹å¼               | è´¨é‡é—¨ç¦ |
| ------------ | -------- | ---------------------- | -------- |
| **åœˆå¤æ‚åº¦** | â‰¤ 15     | ESLint complexity è§„åˆ™ | PR é˜»æ–­  |
| **å‡½æ•°è¡Œæ•°** | â‰¤ 50 è¡Œ  | ä»£ç åˆ†æå·¥å…·           | PR é˜»æ–­  |
| **ç±»æ–¹æ³•æ•°** | â‰¤ 20 ä¸ª  | é™æ€åˆ†æ               | é‡æ„å»ºè®® |
| **æ–‡ä»¶è¡Œæ•°** | â‰¤ 300 è¡Œ | ä»£ç ç»Ÿè®¡               | æ‹†åˆ†å»ºè®® |

#### 2.4.2 å¯é‡ç”¨æ€§ï¼ˆReusabilityï¼‰

- **ç»„ä»¶å¤ç”¨ç‡** â‰¥ 60%ï¼šReact ç»„ä»¶è®¾è®¡ä¼˜å…ˆå¤ç”¨
- **å·¥å…·å‡½æ•°è¦†ç›–** â‰¥ 80%ï¼šé€šç”¨é€»è¾‘æŠ½è±¡ä¸ºå¯å¤ç”¨å‡½æ•°
- **ç±»å‹å®šä¹‰å…±äº«** 100%ï¼šTypeScript æ¥å£ç»Ÿä¸€å®šä¹‰

#### 2.4.3 å¯åˆ†ææ€§ï¼ˆAnalysabilityï¼‰

- **ä»£ç è¦†ç›–ç‡**ï¼šå•å…ƒæµ‹è¯• + é›†æˆæµ‹è¯• â‰¥ 90%
- **ç±»å‹è¦†ç›–ç‡**ï¼šTypeScript ä¸¥æ ¼æ¨¡å¼ï¼Œç±»å‹è¦†ç›– â‰¥ 95%
- **æ–‡æ¡£è¦†ç›–ç‡**ï¼šå…¬å…± API TSDoc æ³¨é‡Šè¦†ç›–ç‡ 100%

#### 2.4.4 å¯ä¿®æ”¹æ€§ï¼ˆModifiabilityï¼‰

- **çƒ­é‡è½½æ”¯æŒ**ï¼šå¼€å‘ç¯å¢ƒå˜æ›´ < 3s ç”Ÿæ•ˆ
- **æ’ä»¶åŒ–æ¶æ„**ï¼šæ ¸å¿ƒåŠŸèƒ½æ”¯æŒæ’ä»¶æ‰©å±•
- **é…ç½®é©±åŠ¨**ï¼šä¸šåŠ¡è§„åˆ™é…ç½®åŒ–ï¼Œæ— éœ€ä»£ç å˜æ›´

### 2.5 å…¼å®¹æ€§ï¼ˆCompatibilityï¼‰

#### 2.5.1 å…±å­˜æ€§ï¼ˆCo-existenceï¼‰

- **æ“ä½œç³»ç»Ÿ**ï¼šWindows 10+ / macOS 12+ å…¼å®¹æ€§ä¿éšœ
- **ç¡¬ä»¶è¦æ±‚**ï¼šæœ€ä½ 8GB å†…å­˜ï¼Œé›†æˆæ˜¾å¡æ”¯æŒ
- **åŒæ—¶è¿è¡Œ**ï¼šä¸å…¶ä»–åº”ç”¨æ— èµ„æºå†²çª

#### 2.5.2 äº’æ“ä½œæ€§ï¼ˆInteroperabilityï¼‰

- **å­˜æ¡£æ ¼å¼**ï¼šå‘åå…¼å®¹ï¼Œç‰ˆæœ¬å‡çº§ä¸ç ´åå­˜æ¡£
- **é…ç½®è¿ç§»**ï¼šè®¾ç½®è‡ªåŠ¨è¿ç§»ï¼Œæ— ç”¨æˆ·å¹²é¢„
- **å¤–éƒ¨å·¥å…·**ï¼šæ”¯æŒå­˜æ¡£å¯¼å‡º/å¯¼å…¥ï¼ŒMOD å·¥å…·å…¼å®¹

### 2.6 å¯ç”¨æ€§ï¼ˆUsabilityï¼‰

#### 2.6.1 å¯ç†è§£æ€§ï¼ˆUnderstandabilityï¼‰

| ç”¨æˆ·ä½“éªŒæŒ‡æ ‡       | ç›®æ ‡å€¼    | æµ‹é‡æ–¹å¼   | ç”¨æˆ·ç¾¤ä½“ |
| ------------------ | --------- | ---------- | -------- |
| **æ–°æ‰‹å­¦ä¹ æ—¶é—´**   | < 30 åˆ†é’Ÿ | ç”¨æˆ·æµ‹è¯•   | é¦–æ¬¡ç©å®¶ |
| **åŠŸèƒ½å‘ç°åº¦**     | > 85%     | çƒ­åŠ›å›¾åˆ†æ | æ ¸å¿ƒåŠŸèƒ½ |
| **å¸®åŠ©ç³»ç»Ÿä½¿ç”¨ç‡** | > 60%     | ä½¿ç”¨ç»Ÿè®¡   | å¤æ‚åŠŸèƒ½ |

#### 2.6.2 å¯æ“ä½œæ€§ï¼ˆOperabilityï¼‰

- **å¿«æ·é”®æ”¯æŒ**ï¼šæ‰€æœ‰æ ¸å¿ƒæ“ä½œæ”¯æŒé”®ç›˜å¿«æ·é”®
- **æ“ä½œæ’¤é”€**ï¼šå…³é”®æ“ä½œæ”¯æŒæ’¤é”€ï¼ˆCtrl+Zï¼‰
- **è‡ªåŠ¨ä¿å­˜**ï¼šæ“ä½œè‡ªåŠ¨ä¿å­˜ï¼Œé˜²æ­¢æ„å¤–ä¸¢å¤±

#### 2.6.3 ç”¨æˆ·é”™è¯¯é˜²æŠ¤ï¼ˆUser Error Protectionï¼‰

- **è¾“å…¥éªŒè¯**ï¼šå®æ—¶è¾“å…¥æ ¡éªŒï¼Œé”™è¯¯æç¤ºæ˜ç¡®
- **ç¡®è®¤å¯¹è¯æ¡†**ï¼šå±é™©æ“ä½œäºŒæ¬¡ç¡®è®¤
- **æ•°æ®æ¢å¤**ï¼šè¯¯æ“ä½œæ•°æ®æ¢å¤æœºåˆ¶

### 2.7 å¯ç§»æ¤æ€§ï¼ˆPortabilityï¼‰

#### 2.7.1 é€‚åº”æ€§ï¼ˆAdaptabilityï¼‰

- **åˆ†è¾¨ç‡é€‚é…**ï¼š1920x1080 åˆ° 4K æ— ç¼é€‚é…
- **DPI ç¼©æ”¾**ï¼šç³»ç»Ÿ DPI è®¾ç½®è‡ªåŠ¨é€‚é…
- **ä¸»é¢˜ç³»ç»Ÿ**ï¼šæ˜æš—ä¸»é¢˜åˆ‡æ¢æ”¯æŒ

#### 2.7.2 æ˜“å®‰è£…æ€§ï¼ˆInstallabilityï¼‰

- **ä¸€é”®å®‰è£…**ï¼šå®‰è£…åŒ… < 500MBï¼Œå®‰è£…æ—¶é—´ < 3 åˆ†é’Ÿ
- **æ— ä¾èµ–å®‰è£…**ï¼šç»¿è‰²ç‰ˆæœ¬æ”¯æŒï¼Œæ— éœ€é¢å¤–ç»„ä»¶
- **è‡ªåŠ¨æ›´æ–°**ï¼šå¢é‡æ›´æ–°ï¼Œæ›´æ–°åŒ… < 50MB

---

## ä¸‰ã€SLI / SLO ä½“ç³»ä¸è¯¯å·®é¢„ç®—ï¼ˆå¯è§‚æµ‹æ€§æŒ‡æ ‡ï¼‰

### 3.1 æ ¸å¿ƒå¯é æ€§æŒ‡æ ‡ï¼ˆTier-0 Critical SLIsï¼‰

| SLI                     | SLO ç›®æ ‡ | æµ‹é‡çª—å£ | è¯¯å·®é¢„ç®—         | æ•°æ®æº                | é‡‡é›†æ–¹å¼                |
| ----------------------- | -------- | -------- | ---------------- | --------------------- | ----------------------- |
| **Crash-free Sessions** | â‰¥ 99.5%  | 30å¤©æ»šåŠ¨ | 0.5% (â‰ˆ10.8å°æ—¶) | Sentry Release Health | è‡ªåŠ¨ä¼šè¯è¿½è¸ª + å´©æºƒæŠ¥å‘Š |
| **æ•°æ®å®Œæ•´æ€§**          | 100%     | å®æ—¶ç›‘æ§ | 0% (é›¶å®¹å¿)      | SQLite æ£€æŸ¥ + è‡ªæ£€    | æ¯æ¬¡è¯»å†™æ“ä½œæ ¡éªŒ        |
| **æ ¸å¿ƒåŠŸèƒ½å¯ç”¨æ€§**      | â‰¥ 99.9%  | 7å¤©æ»šåŠ¨  | 0.1% (â‰ˆ10åˆ†é’Ÿ)   | åŠŸèƒ½å¥åº·æ£€æŸ¥          | å¿ƒè·³æ¢æµ‹ + åŠŸèƒ½æµ‹è¯•     |

### 3.2 æ€§èƒ½æ•ˆç‡æŒ‡æ ‡ï¼ˆTier-1 Performance SLIsï¼‰

| SLI               | SLO ç›®æ ‡ | æµ‹é‡çª—å£   | è¯¯å·®é¢„ç®—    | æ•°æ®æº          | é‡‡é›†æ–¹å¼         |
| ----------------- | -------- | ---------- | ----------- | --------------- | ---------------- |
| **å…³é”®äº¤äº’ TP95** | < 100 ms | 7å¤©æ»šåŠ¨    | +20ms ç¼“å†²  | Playwright åŸºå‡† | è‡ªåŠ¨åŒ–UIæµ‹è¯•è„šæœ¬ |
| **æ¸¸æˆå¾ªç¯ FPS**  | â‰¥ 58 FPS | 5åˆ†é’Ÿçª—å£  | -2 FPS ç¼“å†² | Phaser æ€§èƒ½ç›‘æ§ | å¸§ç‡å®æ—¶é‡‡æ ·     |
| **å†·å¯åŠ¨æ—¶é—´**    | < 3 s    | æ¯æ¬¡å‘å¸ƒ   | +1s ç¼“å†²    | E2E æµ‹è¯•        | è‡ªåŠ¨åŒ–å†·å¯åŠ¨æµ‹è¯• |
| **å­˜æ¡£æ“ä½œå»¶è¿Ÿ**  | < 100 ms | 1å°æ—¶çª—å£  | +50ms ç¼“å†²  | SQLite æ€§èƒ½æ—¥å¿— | æ•°æ®åº“æ“ä½œè®¡æ—¶   |
| **äº‹ä»¶å¤„ç†æ—¶å»¶**  | < 200 ms | 15åˆ†é’Ÿçª—å£ | +100ms ç¼“å†² | å†…éƒ¨æ€§èƒ½æ—¥å¿—    | äº‹ä»¶ç”Ÿå‘½å‘¨æœŸè¿½è¸ª |
| **AI è®¡ç®—å“åº”**   | < 500 ms | 1å°æ—¶çª—å£  | +200ms ç¼“å†² | Web Worker ç›‘æ§ | AIå†³ç­–è®¡æ—¶é‡‡æ ·   |

### 3.3 èµ„æºåˆ©ç”¨ç‡æŒ‡æ ‡ï¼ˆTier-1 Resource SLIsï¼‰

| SLI               | SLO ç›®æ ‡        | æµ‹é‡çª—å£   | è¯¯å·®é¢„ç®—       | æ•°æ®æº   | é‡‡é›†æ–¹å¼      |
| ----------------- | --------------- | ---------- | -------------- | -------- | ------------- |
| **å†…å­˜ä½¿ç”¨ç‡**    | < 300 MB (æ­£å¸¸) | 1å°æ—¶æ»‘åŠ¨  | 350 MB å‘Šè­¦çº¿  | ç³»ç»Ÿç›‘æ§ | è¿›ç¨‹å†…å­˜é‡‡æ ·  |
| **å†…å­˜å³°å€¼æ§åˆ¶**  | < 400 MB (å³°å€¼) | 24å°æ—¶çª—å£ | 450 MB ç†”æ–­çº¿  | ç³»ç»Ÿç›‘æ§ | å†…å­˜å³°å€¼è¿½è¸ª  |
| **CPU ä½¿ç”¨ç‡**    | < 15% (æ­£å¸¸)    | 5åˆ†é’Ÿçª—å£  | 30% å‘Šè­¦çº¿     | ç³»ç»Ÿç›‘æ§ | CPUä½¿ç”¨ç‡é‡‡æ · |
| **ç£ç›˜ I/O é€Ÿç‡** | < 10 MB/s       | 1åˆ†é’Ÿçª—å£  | 25 MB/s å‘Šè­¦çº¿ | ç³»ç»Ÿç›‘æ§ | I/Oé€Ÿç‡ç›‘æ§   |

### 3.4 ç”¨æˆ·ä½“éªŒæŒ‡æ ‡ï¼ˆTier-2 UX SLIsï¼‰

| SLI                | SLO ç›®æ ‡ | æµ‹é‡çª—å£  | è¯¯å·®é¢„ç®—   | æ•°æ®æº       | é‡‡é›†æ–¹å¼         |
| ------------------ | -------- | --------- | ---------- | ------------ | ---------------- |
| **æ–°æ‰‹å®Œæˆç‡**     | â‰¥ 80%    | 7å¤©çª—å£   | 70% æœ€ä½çº¿ | æ¸¸æˆå†…åŸ‹ç‚¹   | æ–°æ‰‹æµç¨‹è¿½è¸ª     |
| **æ ¸å¿ƒåŠŸèƒ½å‘ç°ç‡** | â‰¥ 85%    | 7å¤©çª—å£   | 75% æœ€ä½çº¿ | ç”¨æˆ·è¡Œä¸ºåˆ†æ | åŠŸèƒ½ä½¿ç”¨çƒ­åŠ›å›¾   |
| **æ“ä½œæˆåŠŸç‡**     | â‰¥ 95%    | 1å°æ—¶çª—å£ | 90% æœ€ä½çº¿ | äº¤äº’æ—¥å¿—     | ç”¨æˆ·æ“ä½œç»“æœè¿½è¸ª |

### 3.5 å¼€å‘è´¨é‡æŒ‡æ ‡ï¼ˆTier-2 Development SLIsï¼‰

| SLI                     | SLO ç›®æ ‡        | æµ‹é‡çª—å£ | è¯¯å·®é¢„ç®—   | æ•°æ®æº      | é‡‡é›†æ–¹å¼     |
| ----------------------- | --------------- | -------- | ---------- | ----------- | ------------ |
| **å•å…ƒ+é›†æˆè¦†ç›–ç‡**     | â‰¥ 90%           | æ¯æ¬¡ PR  | 85% æœ€ä½çº¿ | Vitest + C8 | æµ‹è¯•æŠ¥å‘Šæ±‡æ€» |
| **TypeScript ç±»å‹è¦†ç›–** | â‰¥ 95%           | æ¯æ¬¡ PR  | 90% æœ€ä½çº¿ | TSç¼–è¯‘å™¨    | ç±»å‹æ£€æŸ¥æŠ¥å‘Š |
| **ä»£ç å¤æ‚åº¦æ§åˆ¶**      | â‰¤ 15 (åœˆå¤æ‚åº¦) | æ¯æ¬¡ PR  | 20 æœ€é«˜çº¿  | ESLint      | é™æ€ä»£ç åˆ†æ |
| **æ„å»ºæˆåŠŸç‡**          | â‰¥ 99%           | 7å¤©æ»šåŠ¨  | 95% æœ€ä½çº¿ | CI/CD ç³»ç»Ÿ  | æ„å»ºç»“æœç»Ÿè®¡ |

### 3.6 è¯¯å·®é¢„ç®—è¯¦ç»†è®¡ç®—ä¸ç®¡ç†

#### 3.6.1 è¯¯å·®é¢„ç®—è®¡ç®—å…¬å¼

```typescript
// è¯¯å·®é¢„ç®—è®¡ç®—æ¥å£
interface ErrorBudgetCalculation {
  sloTarget: number; // SLOç›®æ ‡å€¼ (å¦‚99.5%)
  measurementWindow: string; // æµ‹é‡çª—å£ (å¦‚ "30d", "7d")

  // è®¡ç®—ç»“æœ
  errorBudget: number; // è¯¯å·®é¢„ç®— (å¦‚0.5%)
  absoluteDowntime: Duration; // ç»å¯¹åœæœºæ—¶é—´
  budgetRemaining: number; // å‰©ä½™é¢„ç®—ç™¾åˆ†æ¯”
  burnRate: number; // é¢„ç®—æ¶ˆè€—é€Ÿç‡
}

// ç¤ºä¾‹è®¡ç®—
const crashFreeBudget: ErrorBudgetCalculation = {
  sloTarget: 99.5, // 99.5% ç›®æ ‡
  measurementWindow: '30d', // 30å¤©çª—å£
  errorBudget: 0.5, // 0.5% è¯¯å·®é¢„ç®—
  absoluteDowntime: '10.8h', // 30å¤© * 24å°æ—¶ * 0.5% = 10.8å°æ—¶
  budgetRemaining: 85.2, // å½“å‰å‰©ä½™85.2%é¢„ç®—
  burnRate: 0.12, // æ¯æ—¥æ¶ˆè€—0.12%é¢„ç®—
};
```

#### 3.6.2 è¯¯å·®é¢„ç®—æ¶ˆè€—é€Ÿç‡ï¼ˆBurn Rateï¼‰ç›‘æ§

| é¢„ç®—æ¶ˆè€—é€Ÿç‡       | å‘Šè­¦çº§åˆ« | æ—¶é—´çª—å£ | é¢„è®¡è€—å°½æ—¶é—´ | åº”å¯¹æªæ–½            |
| ------------------ | -------- | -------- | ------------ | ------------------- |
| **1-2x æ­£å¸¸é€Ÿç‡**  | ğŸŸ¡ è­¦å‘Š  | 24å°æ—¶   | > 15å¤©       | å¯†åˆ‡ç›‘æ§            |
| **3-5x æ­£å¸¸é€Ÿç‡**  | ğŸŸ  ä¸­ç­‰  | 12å°æ—¶   | 5-15å¤©       | å¼€å§‹è°ƒæŸ¥            |
| **6-10x æ­£å¸¸é€Ÿç‡** | ğŸ”´ ä¸¥é‡  | 4å°æ—¶    | 1-5å¤©        | ç«‹å³è°ƒæŸ¥ + å‡ç¼“å˜æ›´ |
| **> 10x æ­£å¸¸é€Ÿç‡** | â›” ç´§æ€¥  | 1å°æ—¶    | < 1å¤©        | ç´§æ€¥å“åº” + å†»ç»“å‘å¸ƒ |

#### 3.6.3 åˆ†å±‚è¯¯å·®é¢„ç®—ç®¡ç†ç­–ç•¥

**Tier-0 (Critical) - é›¶å®¹å¿ç­–ç•¥**

- **æ•°æ®å®Œæ•´æ€§**ï¼šä»»ä½•æ•°æ®æŸåç«‹å³è§¦å‘ç´§æ€¥ä¿®å¤
- **å®‰å…¨è¾¹ç•Œ**ï¼šä»»ä½•å®‰å…¨è¿åç«‹å³é˜»æ–­å‘å¸ƒ

**Tier-1 (Important) - ä¸¥æ ¼æ§åˆ¶ç­–ç•¥**

- **å¯é æ€§æŒ‡æ ‡**ï¼šé¢„ç®—æ¶ˆè€— > 50% æ—¶å‡ç¼“åŠŸèƒ½å¼€å‘
- **æ€§èƒ½æŒ‡æ ‡**ï¼šé¢„ç®—æ¶ˆè€— > 75% æ—¶ä¸“æ³¨æ€§èƒ½ä¼˜åŒ–

**Tier-2 (Monitoring) - è§‚å¯ŸæŒ‡å¯¼ç­–ç•¥**

- **ç”¨æˆ·ä½“éªŒæŒ‡æ ‡**ï¼šé¢„ç®—æ¶ˆè€—ä½œä¸ºäº§å“å†³ç­–å‚è€ƒ
- **å¼€å‘è´¨é‡æŒ‡æ ‡**ï¼šé¢„ç®—æ¶ˆè€—æŒ‡å¯¼æŠ€æœ¯å€ºåŠ¡ä¼˜å…ˆçº§

#### 3.6.4 å®æ—¶è¯¯å·®é¢„ç®—ä»ªè¡¨æ¿

```typescript
// è¯¯å·®é¢„ç®—ä»ªè¡¨æ¿é…ç½®
interface ErrorBudgetDashboard {
  realTimeMetrics: {
    crashFreeSessions: {
      current: 99.73; // å½“å‰å€¼
      target: 99.5; // ç›®æ ‡å€¼
      budgetUsed: 14.8; // å·²ç”¨é¢„ç®— %
      budgetRemaining: 85.2; // å‰©ä½™é¢„ç®— %
      estimatedDepletion: '45d'; // é¢„è®¡è€—å°½æ—¶é—´
    };

    performanceTP95: {
      current: 89; // å½“å‰å€¼ (ms)
      target: 100; // ç›®æ ‡å€¼ (ms)
      budgetUsed: 0; // å·²ç”¨é¢„ç®— %
      bufferRemaining: 11; // å‰©ä½™ç¼“å†² (ms)
      trendDirection: 'stable'; // è¶‹åŠ¿æ–¹å‘
    };
  };

  alerting: {
    budgetAlerts: AlertRule[]; // é¢„ç®—å‘Šè­¦è§„åˆ™
    escalationPolicy: Policy; // å‡çº§ç­–ç•¥
    notificationChannels: Channel[]; // é€šçŸ¥æ¸ é“
  };
}
```

### 3.7 SLI/SLO æ•°æ®æµä¸é‡‡é›†æ¶æ„

#### 3.7.1 æ•°æ®é‡‡é›†ç®¡é“

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application   â”‚â”€â”€â”€â–¶â”‚  Metrics Agent   â”‚â”€â”€â”€â–¶â”‚ Time Series DB  â”‚
â”‚                 â”‚    â”‚                  â”‚    â”‚                 â”‚
â”‚ â€¢ Phaser Game   â”‚    â”‚ â€¢ Sentry SDK     â”‚    â”‚ â€¢ Local SQLite  â”‚
â”‚ â€¢ React UI      â”‚    â”‚ â€¢ Performance    â”‚    â”‚ â€¢ JSON Metrics  â”‚
â”‚ â€¢ Electron Main â”‚    â”‚ â€¢ Custom Events  â”‚    â”‚ â€¢ Memory Cache  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚  SLO Calculator  â”‚
                       â”‚                  â”‚
                       â”‚ â€¢ Budget Calc    â”‚
                       â”‚ â€¢ Burn Rate      â”‚
                       â”‚ â€¢ Alerting       â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.7.2 æŒ‡æ ‡èšåˆä¸å‘Šè­¦

- **å®æ—¶è®¡ç®—**ï¼šå…³é”®æŒ‡æ ‡ 1åˆ†é’Ÿå†…æ›´æ–°
- **æ‰¹å¤„ç†è®¡ç®—**ï¼šå¤æ‚æŒ‡æ ‡ 5åˆ†é’Ÿå†…æ›´æ–°
- **å†å²è¶‹åŠ¿**ï¼šä¿ç•™ 90å¤©æŒ‡æ ‡æ•°æ®
- **å‘Šè­¦å»¶è¿Ÿ**ï¼šP0å‘Šè­¦ < 1åˆ†é’Ÿï¼ŒP1å‘Šè­¦ < 5åˆ†é’Ÿ

---

## å››ã€å…³é”® ADRï¼ˆArchitecture Decision Recordsï¼‰

> **æ¯æ¡ ADR éµå¾ª"åŠ¨æœºâ†’å†³ç­–â†’åæœ"ä¸‰æ®µå¼è®°å½•ï¼Œä¸æœ¬ç«  SLO/NFR å¯¹é½ï¼Œç¡®ä¿æ¶æ„å†³ç­–çš„å¯è¿½æº¯æ€§ã€‚**

### ADR-001 ï½œ æ¥å£å…ˆè¡Œæ¶æ„è®¾è®¡ (Port-Driven Design)

#### ğŸ¯ **åŠ¨æœºï¼ˆWhyï¼‰**

**é—®é¢˜åœºæ™¯**ï¼šã€Šå…¬ä¼šç»ç†ã€‹ä½œä¸ºæ·±åº¦ç»è¥æ¨¡æ‹Ÿæ¸¸æˆï¼ŒåŒ…å«å¤æ‚çš„äº‹ä»¶ç³»ç»Ÿï¼ˆ1000+äº‹ä»¶ï¼‰ã€å¤šå±‚AIç”Ÿæ€ã€å…­å¤§åŠŸèƒ½æ¨¡å—ï¼Œä¼ ç»Ÿçš„ç›´æ¥è°ƒç”¨æ–¹å¼ä¼šå¯¼è‡´ï¼š

- **ç´§è€¦åˆé£é™©**ï¼šæ¨¡å—é—´ç›´æ¥ä¾èµ–ï¼Œéš¾ä»¥ç‹¬ç«‹æµ‹è¯•å’Œæ›¿æ¢
- **æ‰©å±•æ€§é™åˆ¶**ï¼šæ–°å¢åŠŸèƒ½éœ€è¦ä¿®æ”¹å¤§é‡ç°æœ‰ä»£ç 
- **å¹¶è¡Œå¼€å‘é˜»å¡**ï¼šæ¥å£å˜æ›´å½±å“å¤šä¸ªå¼€å‘åˆ†æ”¯
- **å­˜å‚¨ç»‘å®š**ï¼šSQLiteå­˜å‚¨é€»è¾‘æ¸—é€åˆ°ä¸šåŠ¡å±‚ï¼Œæœªæ¥æ‰©å±•å—é™

**ä¸šåŠ¡å½±å“**ï¼šå½±å“10ä¸ªæœˆå¼€å‘å‘¨æœŸä¸­çš„å¹¶è¡Œå¼€å‘æ•ˆç‡å’Œé•¿æœŸDLCæ‰©å±•èƒ½åŠ›ã€‚

#### ğŸ’¡ **å†³ç­–ï¼ˆWhatï¼‰**

**æ ¸å¿ƒå†³ç­–**ï¼šé‡‡ç”¨"ç«¯å£-é€‚é…å™¨"æ¶æ„æ¨¡å¼ï¼ˆHexagonal Architectureï¼‰ï¼Œæ‰€æœ‰åŸŸæ“ä½œé€šè¿‡ç«¯å£å¯¹å¤–æš´éœ²ï¼š

```typescript
// ç«¯å£å®šä¹‰ - ä¸šåŠ¡é€»è¾‘ä¸ä¾èµ–å…·ä½“å®ç°
interface IGuildRepository {
  findById(id: string): Promise<Guild>;
  save(guild: Guild): Promise<void>;
  findByRanking(limit: number): Promise<Guild[]>;
}

// äº‹ä»¶ç«¯å£ - è§£è€¦ä¸šåŠ¡äº‹ä»¶å’ŒåŸºç¡€è®¾æ–½
interface IEventBus {
  publish<T>(event: DomainEvent<T>): void;
  subscribe<T>(eventType: string, handler: EventHandler<T>): void;
}

// é¢†åŸŸæœåŠ¡ - åªä¾èµ–ç«¯å£ï¼Œä¸ä¾èµ–å…·ä½“å®ç°
class GuildService {
  constructor(
    private guildRepo: IGuildRepository, // ç«¯å£æ³¨å…¥
    private eventBus: IEventBus // ç«¯å£æ³¨å…¥
  ) {}

  async createGuild(name: string): Promise<Guild> {
    const guild = new Guild(name);
    await this.guildRepo.save(guild); // ç«¯å£è°ƒç”¨
    this.eventBus.publish(new GuildCreated(guild)); // ç«¯å£è°ƒç”¨
    return guild;
  }
}
```

**å®æ–½ç­–ç•¥**ï¼š

- **æ¥å£ä¼˜å…ˆ**ï¼šå…ˆå®šä¹‰ç«¯å£å¥‘çº¦ï¼Œåå®ç°é€‚é…å™¨
- **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡ IoC å®¹å™¨ç®¡ç†ä¾èµ–å…³ç³»
- **é€‚é…å™¨æ¨¡å¼**ï¼šSQLiteã€JSONã€å†…å­˜ç­‰å­˜å‚¨å¯éšæ—¶æ›¿æ¢

#### ğŸ“ˆ **åæœï¼ˆImpactï¼‰**

**ç§¯æå½±å“**ï¼š

- âœ… **å¹¶è¡Œå¼€å‘**ï¼šå›¢é˜Ÿå¯åŸºäºæ¥å£å¥‘çº¦å¹¶è¡Œå¼€å‘ï¼Œæå‡å¼€å‘æ•ˆç‡30%
- âœ… **æµ‹è¯•å‹å¥½**ï¼šä¸šåŠ¡é€»è¾‘å¯ä½¿ç”¨å†…å­˜ Mock å®ç°å•å…ƒæµ‹è¯•ï¼Œæµ‹è¯•è¦†ç›–ç‡ç›®æ ‡â‰¥90%
- âœ… **å­˜å‚¨çµæ´»**ï¼šæ”¯æŒSQLiteâ†’PostgreSQLç­‰å­˜å‚¨è¿ç§»ï¼Œæ»¡è¶³DLCæ‰©å±•éœ€æ±‚
- âœ… **æ¨¡å—åŒ–**ï¼šæ¸…æ™°çš„æ¨¡å—è¾¹ç•Œï¼Œæ”¯æŒæ’ä»¶åŒ–æ¶æ„

**æ½œåœ¨æˆæœ¬**ï¼š

- âš ï¸ **æŠ½è±¡å¼€é”€**ï¼šå¢åŠ 10-15%çš„ä»£ç é‡ï¼Œä½†é€šè¿‡TypeScripté™æ€æ£€æŸ¥é™ä½è¿è¡Œæ—¶é£é™©
- âš ï¸ **å­¦ä¹ æˆæœ¬**ï¼šå›¢é˜Ÿéœ€è¦ç†è§£ä¾èµ–å€’ç½®åŸåˆ™ï¼Œé€šè¿‡ä»£ç å®¡æŸ¥ç¡®ä¿æ‰§è¡Œ

**æˆåŠŸæŒ‡æ ‡**ï¼š

- ä»£ç å¤æ‚åº¦â‰¤15ï¼ˆåœˆå¤æ‚åº¦ï¼‰
- æ¨¡å—é—´ä¾èµ–å…³ç³»å•å‘ä¸”æ¸…æ™°
- å­˜å‚¨å±‚æ›¿æ¢æˆæœ¬<2äººæ—¥

---

### ADR-002 ï½œ é¢†åŸŸäº‹ä»¶å‘½åæ ‡å‡† (Domain Event Naming)

#### ğŸ¯ **åŠ¨æœºï¼ˆWhyï¼‰**

**é—®é¢˜åœºæ™¯**ï¼šã€Šå…¬ä¼šç»ç†ã€‹çš„åºå¤§äº‹ä»¶ç³»ç»Ÿï¼ˆ1000+äº‹ä»¶ï¼‰æ¶‰åŠå¤šä¸ªé¢†åŸŸï¼š

- **å…¬ä¼šé¢†åŸŸ**ï¼šåˆ›å»ºã€è§£æ•£ã€å‡çº§ã€åˆå¹¶ç­‰äº‹ä»¶
- **æˆå‘˜é¢†åŸŸ**ï¼šæ‹›å‹Ÿã€è®­ç»ƒã€è½¬ç§»ã€é€€å‡ºç­‰äº‹ä»¶
- **æˆ˜æ–—é¢†åŸŸ**ï¼šPVEã€PVPã€Bossæˆ˜ã€æ’åç­‰äº‹ä»¶
- **AIç”Ÿæ€**ï¼šNPCè¡Œä¸ºã€ç¯å¢ƒå˜åŒ–ã€åª’ä½“ååº”ç­‰äº‹ä»¶

**ä¸ä¸€è‡´å‘½åé£é™©**ï¼š

- äº‹ä»¶åç§°æ··ä¹±ï¼š`GuildCreate`ã€`guild_created`ã€`onGuildAdd` å…±å­˜
- è·¨æ¨¡å—ç†è§£å›°éš¾ï¼šå¼€å‘äººå‘˜éš¾ä»¥å¿«é€Ÿå®šä½äº‹ä»¶å¤„ç†é€»è¾‘
- è°ƒè¯•å¤æ‚ï¼šäº‹ä»¶è¿½è¸ªå’Œæ—¥å¿—åˆ†ææ•ˆç‡ä½ä¸‹
- æ‰©å±•ç»´æŠ¤æˆæœ¬é«˜ï¼šæ–°å¢äº‹ä»¶å‘½åä¸è§„èŒƒï¼Œå½±å“é•¿æœŸå¯ç»´æŠ¤æ€§

#### ğŸ’¡ **å†³ç­–ï¼ˆWhatï¼‰**

**æ ¸å¿ƒå†³ç­–**ï¼šé‡‡ç”¨ç»Ÿä¸€çš„ `<domain>.<action>` äº‹ä»¶å‘½åè§„èŒƒï¼š

```typescript
// äº‹ä»¶å‘½åè§„èŒƒæ ‡å‡†
const EVENT_NAMING_STANDARD = {
  // å…¬ä¼šé¢†åŸŸäº‹ä»¶
  'guild.created': GuildCreatedEvent,
  'guild.disbanded': GuildDisbandedEvent,
  'guild.upgraded': GuildUpgradedEvent,
  'guild.member_joined': GuildMemberJoinedEvent,

  // æˆ˜æ–—é¢†åŸŸäº‹ä»¶
  'battle.pve_started': PVEBattleStartedEvent,
  'battle.pvp_completed': PVPBattleCompletedEvent,
  'battle.boss_defeated': BossDefeatedEvent,

  // AIç”Ÿæ€äº‹ä»¶
  'ai.npc_guild_action': NPCGuildActionEvent,
  'ai.environment_change': EnvironmentChangeEvent,
  'ai.media_reaction': MediaReactionEvent,
} as const;

// ç±»å‹å®‰å…¨çš„EventBuså®ç°
class TypeSafeEventBus implements IEventBus {
  publish<T extends keyof typeof EVENT_NAMING_STANDARD>(
    eventType: T,
    payload: InstanceType<(typeof EVENT_NAMING_STANDARD)[T]>
  ): void {
    // ç±»å‹å®‰å…¨çš„äº‹ä»¶å‘å¸ƒ
    this.bus.emit(eventType, payload);
  }

  subscribe<T extends keyof typeof EVENT_NAMING_STANDARD>(
    eventType: T,
    handler: (event: InstanceType<(typeof EVENT_NAMING_STANDARD)[T]>) => void
  ): void {
    // ç±»å‹å®‰å…¨çš„äº‹ä»¶è®¢é˜…
    this.bus.on(eventType, handler);
  }
}
```

**å‘½åçº¦å®š**ï¼š

- **é¢†åŸŸå‰ç¼€**ï¼š`guild`, `member`, `battle`, `ai`, `system`
- **åŠ¨ä½œæè¿°**ï¼šä½¿ç”¨è¿‡å»å¼åŠ¨è¯ï¼Œè¡¨ç¤ºå·²å®Œæˆçš„äº‹å®
- **åˆ†éš”ç¬¦**ï¼šä½¿ç”¨ `.` åˆ†éš”ï¼Œä¾¿äºå±‚çº§ç»„ç»‡å’Œè¿‡æ»¤
- **ç±»å‹æ˜ å°„**ï¼šæ¯ä¸ªäº‹ä»¶åç§°å¯¹åº”å”¯ä¸€çš„TypeScriptç±»å‹

#### ğŸ“ˆ **åæœï¼ˆImpactï¼‰**

**ç§¯æå½±å“**ï¼š

- âœ… **å¼€å‘æ•ˆç‡**ï¼šç»Ÿä¸€å‘½åé™ä½è®¤çŸ¥è´Ÿè½½ï¼Œæ–°æˆå‘˜å¿«é€Ÿä¸Šæ‰‹
- âœ… **ç±»å‹å®‰å…¨**ï¼šTypeScriptç¼–è¯‘æ—¶æ£€æŸ¥ï¼Œæ¶ˆé™¤äº‹ä»¶åç§°æ‹¼å†™é”™è¯¯
- âœ… **è°ƒè¯•å‹å¥½**ï¼šäº‹ä»¶æ—¥å¿—ç»“æ„åŒ–ï¼Œæ”¯æŒæŒ‰é¢†åŸŸè¿‡æ»¤å’Œè¿½è¸ª
- âœ… **å·¥å…·æ”¯æŒ**ï¼šIDEè‡ªåŠ¨è¡¥å…¨å’Œé‡æ„æ”¯æŒï¼Œæå‡ä»£ç è´¨é‡

**æ‰§è¡Œæ ‡å‡†**ï¼š

- ESLintè§„åˆ™å¼ºåˆ¶æ£€æŸ¥äº‹ä»¶å‘½åæ ¼å¼
- ä»£ç å®¡æŸ¥å¿…æ£€é¡¹ï¼šäº‹ä»¶å‘½åè§„èŒƒéµå¾ªåº¦
- æ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆï¼šåŸºäºå‘½åçº¦å®šç”Ÿæˆäº‹ä»¶å­—å…¸

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- äº‹ä»¶åç§°å­—ç¬¦ä¸²å¸¸é‡åŒ–ï¼Œé¿å…è¿è¡Œæ—¶å­—ç¬¦ä¸²æ‹¼æ¥
- æŒ‰é¢†åŸŸåˆ†ç»„è®¢é˜…ï¼Œé™ä½äº‹ä»¶åˆ†å‘å¼€é”€

---

### ADR-003 ï½œ Electron å®‰å…¨è¾¹ç•Œå¼ºåŒ– (Security Boundary)

#### ğŸ¯ **åŠ¨æœºï¼ˆWhyï¼‰**

**å®‰å…¨å¨èƒæ¨¡å‹**ï¼šã€Šå…¬ä¼šç»ç†ã€‹ä½œä¸ºElectronæ¡Œé¢åº”ç”¨ï¼Œé¢ä¸´å¤šå±‚å®‰å…¨é£é™©ï¼š

- **ä»£ç æ³¨å…¥æ”»å‡»**ï¼šæ¶æ„è„šæœ¬é€šè¿‡æ¸²æŸ“è¿›ç¨‹è®¿é—®Node.js API
- **æ–‡ä»¶ç³»ç»Ÿå¨èƒ**ï¼šæœªç»æˆæƒè®¿é—®ç”¨æˆ·æ–‡ä»¶å’Œç³»ç»Ÿèµ„æº
- **è¿›ç¨‹æƒé™æ»¥ç”¨**ï¼šæ¸²æŸ“è¿›ç¨‹è·å¾—è¿‡é«˜ç³»ç»Ÿæƒé™
- **æ•°æ®æ³„éœ²é£é™©**ï¼šæ¸¸æˆæ•°æ®å’Œç”¨æˆ·éšç§ä¿¡æ¯æš´éœ²

**åˆè§„è¦æ±‚**ï¼š

- **OWASP**ï¼šéµå¾ªWebåº”ç”¨å®‰å…¨åå¤§é£é™©é˜²èŒƒ
- **æ¡Œé¢å®‰å…¨**ï¼šç¬¦åˆæ¡Œé¢åº”ç”¨å®‰å…¨æœ€ä½³å®è·µ
- **ç”¨æˆ·éšç§**ï¼šæœ¬åœ°æ•°æ®ä¿æŠ¤ï¼Œæ— æœªæˆæƒç½‘ç»œä¼ è¾“

#### ğŸ’¡ **å†³ç­–ï¼ˆWhatï¼‰**

**æ ¸å¿ƒå†³ç­–**ï¼šå®æ–½ä¸¥æ ¼çš„è¿›ç¨‹éš”ç¦»å’Œæœ€å°æƒé™åŸåˆ™ï¼š

```typescript
// Electronä¸»è¿›ç¨‹å®‰å…¨é…ç½®
const SECURITY_CONFIG = {
  // æ¸²æŸ“è¿›ç¨‹å®‰å…¨è®¾ç½®
  webSecurity: true, // å¯ç”¨Webå®‰å…¨ç­–ç•¥
  nodeIntegration: false, // ç¦ç”¨Node.jsé›†æˆ
  nodeIntegrationInWorker: false, // Workerçº¿ç¨‹ç¦ç”¨Node
  contextIsolation: true, // å¼ºåˆ¶ä¸Šä¸‹æ–‡éš”ç¦»
  enableRemoteModule: false, // ç¦ç”¨Remoteæ¨¡å—

  // CSPå®‰å…¨ç­–ç•¥
  contentSecurityPolicy: {
    'default-src': "'self'",
    'script-src': "'self' 'unsafe-inline'", // ä»…å…è®¸å†…è”è„šæœ¬
    'object-src': "'none'",
    'frame-src': "'none'",
    'worker-src': "'self'",
    'connect-src': "'self'",
  },
} as const;

// Preloadè„šæœ¬ - æœ€å°åŒ–APIæš´éœ²
const PRELOAD_API_WHITELIST = {
  // æ–‡ä»¶æ“ä½œ - ä»…é™æ¸¸æˆæ•°æ®ç›®å½•
  fileSystem: {
    readGameData: (filename: string) =>
      ipcRenderer.invoke('read-game-data', filename),
    writeGameData: (filename: string, data: any) =>
      ipcRenderer.invoke('write-game-data', filename, data),
  },

  // ç³»ç»Ÿä¿¡æ¯ - ä»…é™æ€§èƒ½ç›‘æ§éœ€è¦çš„ä¿¡æ¯
  system: {
    getMemoryUsage: () => ipcRenderer.invoke('get-memory-usage'),
    getCPUUsage: () => ipcRenderer.invoke('get-cpu-usage'),
  },

  // åº”ç”¨æ§åˆ¶ - åŸºç¡€çª—å£æ“ä½œ
  app: {
    minimize: () => ipcRenderer.invoke('window-minimize'),
    close: () => ipcRenderer.invoke('window-close'),
    getVersion: () => ipcRenderer.invoke('get-app-version'),
  },
} as const;
```

**å®‰å…¨è¾¹ç•Œå®æ–½**ï¼š

- **ä¸»è¿›ç¨‹æƒé™**ï¼šæ‹¥æœ‰å®Œæ•´Node.js APIï¼Œè´Ÿè´£æ–‡ä»¶I/Oã€ç³»ç»Ÿè°ƒç”¨
- **æ¸²æŸ“è¿›ç¨‹é™åˆ¶**ï¼šæ— Node.jsè®¿é—®ï¼Œåªèƒ½é€šè¿‡IPCä¸ä¸»è¿›ç¨‹é€šä¿¡
- **Preloadæ¡¥æ¥**ï¼šæœ€å°åŒ–APIç™½åå•ï¼Œæ¯ä¸ªAPIéƒ½æœ‰ä¸šåŠ¡justification
- **æ²™ç®±éš”ç¦»**ï¼šæ¸²æŸ“è¿›ç¨‹åœ¨å—é™ç¯å¢ƒä¸­è¿è¡Œ

#### ğŸ“ˆ **åæœï¼ˆImpactï¼‰**

**å®‰å…¨æå‡**ï¼š

- âœ… **æ”»å‡»é¢ç¼©å‡**ï¼šæ¸²æŸ“è¿›ç¨‹æ— æ³•ç›´æ¥è®¿é—®ç³»ç»Ÿèµ„æºï¼Œé˜»æ­¢90%çš„æ³¨å…¥æ”»å‡»
- âœ… **æƒé™æœ€å°åŒ–**ï¼šæ¯ä¸ªAPIè°ƒç”¨éƒ½éœ€è¦ç»è¿‡ä¸»è¿›ç¨‹éªŒè¯
- âœ… **æ•°æ®éš”ç¦»**ï¼šæ¸¸æˆæ•°æ®è®¿é—®é™åˆ¶åœ¨æŒ‡å®šç›®å½•å†…
- âœ… **å®¡è®¡å‹å¥½**ï¼šæ‰€æœ‰è·¨è¿›ç¨‹è°ƒç”¨éƒ½æœ‰æ—¥å¿—è®°å½•

**å¼€å‘çº¦æŸ**ï¼š

- âš ï¸ **å¼€å‘å¤æ‚åº¦**ï¼šéœ€è¦é€šè¿‡IPCè¿›è¡Œæ‰€æœ‰ç³»ç»Ÿè°ƒç”¨ï¼Œå¢åŠ å¼‚æ­¥å¤„ç†å¤æ‚åº¦
- âš ï¸ **æ€§èƒ½å¼€é”€**ï¼šIPCé€šä¿¡æœ‰5-10mså»¶è¿Ÿï¼Œéœ€è¦åˆç†æ‰¹å¤„ç†æ“ä½œ
- âš ï¸ **è°ƒè¯•éš¾åº¦**ï¼šè·¨è¿›ç¨‹è°ƒè¯•éœ€è¦ç‰¹æ®Šå·¥å…·å’ŒæŠ€å·§

**åˆè§„éªŒè¯**ï¼š

- è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æï¼šæ¯æ¬¡æ„å»ºæ£€æŸ¥å®‰å…¨é…ç½®
- æ¸—é€æµ‹è¯•ï¼šå®šæœŸè¿›è¡Œå®‰å…¨è¾¹ç•ŒéªŒè¯
- ä»£ç å®¡æŸ¥ï¼šæ¯ä¸ªæ–°å¢çš„Preload APIéƒ½éœ€è¦å®‰å…¨è¯„ä¼°

---

### ADR-004 ï½œ å¯è§‚æµ‹æ€§é»˜è®¤å¯ç”¨ (Observability by Default)

#### ğŸ¯ **åŠ¨æœºï¼ˆWhyï¼‰**

**å¯è§‚æµ‹æ€§éœ€æ±‚**ï¼šã€Šå…¬ä¼šç»ç†ã€‹ä½œä¸ºå¤æ‚çš„æ¡Œé¢æ¸¸æˆï¼Œå…·æœ‰å¤šç»´åº¦ç›‘æ§éœ€æ±‚ï¼š

- **ç”¨æˆ·ä½“éªŒç›‘æ§**ï¼šå´©æºƒç‡ã€æ€§èƒ½æŒ‡æ ‡ã€ç”¨æˆ·è¡Œä¸ºåˆ†æ
- **æŠ€æœ¯æŒ‡æ ‡è¿½è¸ª**ï¼šå†…å­˜ä½¿ç”¨ã€CPUå ç”¨ã€å¸§ç‡ç¨³å®šæ€§
- **ä¸šåŠ¡æŒ‡æ ‡è§‚å¯Ÿ**ï¼šæ¸¸æˆåŠŸèƒ½ä½¿ç”¨ç‡ã€ç”¨æˆ·ç•™å­˜ã€é”™è¯¯æ¨¡å¼
- **å¼€å‘æ•ˆç‡æå‡**ï¼šå¿«é€Ÿé—®é¢˜å®šä½ã€æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

**ä¼ ç»Ÿç›‘æ§ç—›ç‚¹**ï¼š

- äº‹åæ·»åŠ ç›‘æ§ï¼šé—®é¢˜å‘ç°æ»åï¼Œä¿®å¤æˆæœ¬é«˜
- æŒ‡æ ‡ä¸å…¨é¢ï¼šå…³é”®ä¸šåŠ¡æŒ‡æ ‡ç¼ºå¤±ï¼Œå†³ç­–ä¾æ®ä¸è¶³
- æœ¬åœ°è°ƒè¯•å±€é™ï¼šæ— æ³•å¤ç°ç”¨æˆ·çœŸå®ç¯å¢ƒé—®é¢˜
- æ€§èƒ½å›å½’é£é™©ï¼šç¼ºä¹æŒç»­æ€§èƒ½åŸºçº¿å¯¹æ¯”

#### ğŸ’¡ **å†³ç­–ï¼ˆWhatï¼‰**

**æ ¸å¿ƒå†³ç­–**ï¼šé»˜è®¤å¯ç”¨å…¨æ–¹ä½å¯è§‚æµ‹æ€§ä½“ç³»ï¼Œä¸SLOæŒ‡æ ‡å¯¹é½ï¼š

```typescript
// å¯è§‚æµ‹æ€§é…ç½® - é»˜è®¤å¯ç”¨
const OBSERVABILITY_CONFIG = {
  // Sentryé…ç½® - å´©æºƒå’Œæ€§èƒ½ç›‘æ§
  sentry: {
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,

    // Release Health - ä¼šè¯å¥åº·ç›‘æ§
    release: process.env.APP_VERSION,
    autoSessionTracking: true, // è‡ªåŠ¨ä¼šè¯è¿½è¸ª
    sessionTrackingIntervalMillis: 10000, // 10ç§’å¿ƒè·³

    // æ€§èƒ½ç›‘æ§
    tracesSampleRate: 0.1, // 10%é‡‡æ ·ç‡ï¼Œå¹³è¡¡æ€§èƒ½å’Œæ•°æ®å®Œæ•´æ€§
    profilesSampleRate: 0.1, // æ€§èƒ½å‰–æé‡‡æ ·

    // é”™è¯¯é‡‡é›†
    beforeSend(event) {
      // è¿‡æ»¤æ•æ„Ÿä¿¡æ¯ï¼Œä¿æŠ¤ç”¨æˆ·éšç§
      return filterSensitiveData(event);
    },
  },

  // æ€§èƒ½æŒ‡æ ‡é‡‡é›†
  performance: {
    // å…³é”®äº¤äº’ç›‘æ§ - å¯¹åº”SLOæŒ‡æ ‡
    trackInteractions: [
      'guild.create', // å…¬ä¼šåˆ›å»ºæ“ä½œ
      'battle.start', // æˆ˜æ–—å¼€å§‹æ“ä½œ
      'save.game', // æ¸¸æˆå­˜æ¡£æ“ä½œ
      'ui.navigation', // UIå¯¼èˆªæ“ä½œ
    ],

    // å¸§ç‡ç›‘æ§ - æ¸¸æˆç‰¹æœ‰æŒ‡æ ‡
    fpsMonitoring: {
      enabled: true,
      sampleInterval: 1000, // 1ç§’é‡‡æ ·
      alertThreshold: 58, // ä½äº58FPSå‘Šè­¦
    },

    // èµ„æºä½¿ç”¨ç›‘æ§
    systemMetrics: {
      memory: { interval: 30000 }, // 30ç§’é‡‡æ ·
      cpu: { interval: 5000 }, // 5ç§’é‡‡æ ·
      disk: { interval: 60000 }, // 1åˆ†é’Ÿé‡‡æ ·
    },
  },

  // ä¸šåŠ¡æŒ‡æ ‡åŸ‹ç‚¹
  analytics: {
    userConsent: true, // éœ€è¦ç”¨æˆ·æ˜ç¡®åŒæ„
    events: [
      'game.session_start', // æ¸¸æˆä¼šè¯å¼€å§‹
      'game.session_end', // æ¸¸æˆä¼šè¯ç»“æŸ
      'feature.first_use', // åŠŸèƒ½é¦–æ¬¡ä½¿ç”¨
      'tutorial.completed', // æ•™ç¨‹å®Œæˆ
      'error.user_reported', // ç”¨æˆ·æŠ¥å‘Šé”™è¯¯
    ],
  },
} as const;

// æœ¬åœ°æŒ‡æ ‡ä»ªè¡¨æ¿ - å¼€å‘è°ƒè¯•ç”¨
class LocalMetricsDashboard {
  private metrics = new Map<string, MetricValue>();

  // å®æ—¶æŒ‡æ ‡å±•ç¤º
  displayRealTimeMetrics() {
    return {
      performance: {
        fps: this.getCurrentFPS(),
        memory: this.getMemoryUsage(),
        responseTime: this.getAverageResponseTime(),
      },

      reliability: {
        crashFree: this.getCrashFreeRate(),
        errorRate: this.getErrorRate(),
        uptime: this.getUptime(),
      },

      usage: {
        activeFeatures: this.getActiveFeatures(),
        userActions: this.getUserActionCount(),
        sessionLength: this.getSessionLength(),
      },
    };
  }
}
```

**éšç§ä¿æŠ¤æªæ–½**ï¼š

- **ç”¨æˆ·åŒæ„**ï¼šæ€§èƒ½æ•°æ®æ”¶é›†éœ€è¦ç”¨æˆ·æ˜ç¡®æˆæƒ
- **æ•°æ®è„±æ•**ï¼šè‡ªåŠ¨è¿‡æ»¤ä¸ªäººèº«ä»½ä¿¡æ¯å’Œæ•æ„Ÿæ•°æ®
- **æœ¬åœ°ä¼˜å…ˆ**ï¼šæ ¸å¿ƒæ¸¸æˆæ•°æ®ä¿å­˜åœ¨æœ¬åœ°ï¼Œä¸ä¸Šä¼ äº‘ç«¯
- **é€æ˜æ§åˆ¶**ï¼šç”¨æˆ·å¯éšæ—¶å…³é—­æ•°æ®æ”¶é›†åŠŸèƒ½

#### ğŸ“ˆ **åæœï¼ˆImpactï¼‰**

**ç§¯ææ•ˆæœ**ï¼š

- âœ… **é—®é¢˜é¢„é˜²**ï¼š99.5% Crash-free Sessions SLOé€šè¿‡å®æ—¶ç›‘æ§ä¿éšœ
- âœ… **æ€§èƒ½ä¿è¯**ï¼šå…³é”®äº¤äº’TP95 < 100msé€šè¿‡æŒç»­åŸºçº¿å¯¹æ¯”ç»´æŠ¤
- âœ… **å¿«é€Ÿå“åº”**ï¼šé—®é¢˜å‘ç°åˆ°ä¿®å¤æ—¶é—´ç¼©çŸ­60%
- âœ… **æ•°æ®é©±åŠ¨**ï¼šåŸºäºçœŸå®ç”¨æˆ·æ•°æ®ä¼˜åŒ–äº§å“å†³ç­–

**è¿è¥æ”¶ç›Š**ï¼š

- ğŸ“Š **ç”¨æˆ·æ´å¯Ÿ**ï¼šäº†è§£çœŸå®ç”¨æˆ·ä½¿ç”¨æ¨¡å¼å’Œç—›ç‚¹
- ğŸ”§ **æŠ€æœ¯ä¼˜åŒ–**ï¼šè¯†åˆ«æ€§èƒ½ç“¶é¢ˆå’Œèµ„æºæµªè´¹ç‚¹
- ğŸš€ **äº§å“è¿­ä»£**ï¼šåŸºäºæ•°æ®æŒ‡å¯¼åŠŸèƒ½ä¼˜å…ˆçº§æ’åº

**æˆæœ¬æ§åˆ¶**ï¼š

- âš ï¸ **æ•°æ®ä¼ è¾“**ï¼šé‡‡æ ·ç­–ç•¥æ§åˆ¶æ•°æ®é‡ï¼Œé¿å…å¸¦å®½æµªè´¹
- âš ï¸ **å­˜å‚¨æˆæœ¬**ï¼šæœ¬åœ°æŒ‡æ ‡ç¼“å­˜ï¼Œå®šæœŸæ¸…ç†å†å²æ•°æ®
- âš ï¸ **éšç§åˆè§„**ï¼šç¡®ä¿ç¬¦åˆGDPRç­‰éšç§ä¿æŠ¤æ³•è§„

**æˆåŠŸæŒ‡æ ‡éªŒè¯**ï¼š

- SLOè¾¾æˆç‡ï¼šé€šè¿‡å¯è§‚æµ‹æ€§æ•°æ®éªŒè¯æ˜¯å¦è¾¾åˆ°æ—¢å®šç›®æ ‡
- é—®é¢˜è§£å†³æ•ˆç‡ï¼šMTTRï¼ˆå¹³å‡ä¿®å¤æ—¶é—´ï¼‰æŒç»­ç¼©çŸ­
- ç”¨æˆ·æ»¡æ„åº¦ï¼šé€šè¿‡æ€§èƒ½ä½“éªŒæ”¹å–„æå‡ç”¨æˆ·ç•™å­˜ç‡

---

## äº”ã€å®¹é‡ä¸æ€§èƒ½å‡è®¾ï¼ˆCapacity Planningï¼‰

> **è§„åˆ’ç›®æ ‡**ï¼šåŸºäºã€Šå…¬ä¼šç»ç†ã€‹MMOå…¬ä¼šç®¡ç†æ¨¡æ‹Ÿæ¸¸æˆçš„å¤æ‚äº‹ä»¶ç³»ç»Ÿå’ŒAIç”Ÿæ€ï¼Œå»ºç«‹å¯æ‰§è¡Œçš„å®¹é‡è§„åˆ’æ¨¡å‹ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å„ç§è´Ÿè½½æ¡ä»¶ä¸‹çš„ç¨³å®šæ€§å’Œæ€§èƒ½è¡¨ç°ã€‚

### 5.1 å¹¶å‘å¤„ç†å®¹é‡æ¨¡å‹ï¼ˆConcurrency Capacity Modelsï¼‰

#### 5.1.1 UIçº¿ç¨‹äº‹ä»¶å¹¶å‘èƒ½åŠ›

```typescript
// src/shared/capacity/concurrency-models.ts - å¹¶å‘å®¹é‡è§„åˆ’

// === UIçº¿ç¨‹äº‹ä»¶å¤„ç†å®¹é‡ ===
export const UI_THREAD_CONCURRENCY = {
  // äº‹ä»¶å¤„ç†èƒ½åŠ›åŸºçº¿
  normalLoad: {
    eventsPerSecond: 50, // æ­£å¸¸è´Ÿè½½ï¼š50 evt/s
    responseTime_P95: 16, // P95å“åº”æ—¶é—´ < 16ms (ç»´æŒ60FPS)
    cpuUtilization: '< 15%', // CPUä½¿ç”¨ç‡ < 15%
    description: 'æ­£å¸¸æ¸¸æˆæ“ä½œä¸‹çš„äº‹ä»¶å¤„ç†èƒ½åŠ›',
  },

  peakLoad: {
    eventsPerSecond: 200, // å³°å€¼è´Ÿè½½ï¼š200 evt/s
    responseTime_P95: 50, // P95å“åº”æ—¶é—´ < 50ms
    cpuUtilization: '< 40%', // CPUä½¿ç”¨ç‡ < 40%
    description: 'å¯†é›†æ“ä½œï¼ˆæ‰¹é‡å¤„ç†ã€å¤æ‚è®¡ç®—ï¼‰ä¸‹çš„å³°å€¼å¤„ç†èƒ½åŠ›',
  },

  burstLoad: {
    eventsPerSecond: 500, // çªå‘è´Ÿè½½ï¼š500 evt/s
    duration: '< 10s', // æŒç»­æ—¶é—´ < 10ç§’
    responseTime_P95: 100, // P95å“åº”æ—¶é—´ < 100ms
    degradationStrategy: 'queue_throttling', // é˜Ÿåˆ—èŠ‚æµç­–ç•¥
    description: 'çŸ­æ—¶é—´çªå‘äº‹ä»¶ï¼ˆä¿å­˜ã€åœºæ™¯åˆ‡æ¢ï¼‰çš„å¤„ç†èƒ½åŠ›',
  },

  overloadThreshold: {
    eventsPerSecond: 1000, // è¿‡è½½é˜ˆå€¼ï¼š1000 evt/s
    responseStrategy: 'graceful_degradation', // ä¼˜é›…é™çº§
    priorityQueue: true, // å¯ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—
    dropPolicy: 'drop_non_critical', // ä¸¢å¼ƒéå…³é”®äº‹ä»¶
    description: 'è¶…è´Ÿè½½æƒ…å†µä¸‹çš„ä¿æŠ¤æœºåˆ¶',
  },
} as const;

// === äº‹ä»¶å¤„ç†ä¼˜å…ˆçº§åˆ†ç±» ===
export const EVENT_PRIORITY_CLASSES = {
  CRITICAL: {
    priority: 0,
    examples: ['user_input', 'system_crash', 'data_corruption'],
    processingGuarantee: 'always_process',
    maxLatency: '16ms',
  },

  HIGH: {
    priority: 1,
    examples: ['game_logic', 'ai_decision', 'battle_result'],
    processingGuarantee: 'best_effort',
    maxLatency: '50ms',
  },

  NORMAL: {
    priority: 2,
    examples: ['ui_animation', 'sound_effect', 'background_task'],
    processingGuarantee: 'throttled',
    maxLatency: '100ms',
  },

  LOW: {
    priority: 3,
    examples: ['statistics', 'logging', 'telemetry'],
    processingGuarantee: 'droppable',
    maxLatency: '1000ms',
  },
} as const;
```

#### 5.1.2 è·¨è¿›ç¨‹IPCå¾€è¿”å»¶è¿Ÿæ¨¡å‹

```typescript
// === IPCé€šä¿¡æ€§èƒ½æ¨¡å‹ ===
export const IPC_LATENCY_MODEL = {
  // ä¸»è¿›ç¨‹ â†” æ¸²æŸ“è¿›ç¨‹é€šä¿¡
  mainToRenderer: {
    baseline_P50: '< 2ms', // ä¸­ä½æ•°å»¶è¿Ÿ < 2ms
    baseline_P95: '< 5ms', // P95å»¶è¿Ÿ < 5ms
    baseline_P99: '< 10ms', // P99å»¶è¿Ÿ < 10ms
    throughput: '1000 msg/sec', // æ¶ˆæ¯ååé‡
    description: 'ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹çš„å•å‘é€šä¿¡å»¶è¿Ÿ',
  },

  rendererToMain: {
    baseline_P50: '< 3ms', // ä¸­ä½æ•°å»¶è¿Ÿ < 3ms
    baseline_P95: '< 7ms', // P95å»¶è¿Ÿ < 7ms
    baseline_P99: '< 15ms', // P99å»¶è¿Ÿ < 15ms
    throughput: '800 msg/sec', // æ¶ˆæ¯ååé‡
    description: 'æ¸²æŸ“è¿›ç¨‹åˆ°ä¸»è¿›ç¨‹çš„å•å‘é€šä¿¡å»¶è¿Ÿ',
  },

  roundTripLatency: {
    baseline_P50: '< 5ms', // å¾€è¿”ä¸­ä½æ•°å»¶è¿Ÿ < 5ms
    baseline_P95: '< 10ms', // å¾€è¿”P95å»¶è¿Ÿ < 10ms
    baseline_P99: '< 20ms', // å¾€è¿”P99å»¶è¿Ÿ < 20ms
    maxConcurrent: 100, // æœ€å¤§å¹¶å‘è¯·æ±‚æ•°
    description: 'å®Œæ•´çš„è¯·æ±‚-å“åº”å¾€è¿”å»¶è¿Ÿ',
  },

  // Web Workeré€šä¿¡æ€§èƒ½
  webWorkerIPC: {
    baseline_P50: '< 1ms', // Workeré€šä¿¡å»¶è¿Ÿ < 1ms
    baseline_P95: '< 3ms', // P95å»¶è¿Ÿ < 3ms
    dataTransferLimit: '10MB/s', // æ•°æ®ä¼ è¾“é™åˆ¶
    description: 'AIè®¡ç®—Web Workeré€šä¿¡å»¶è¿Ÿ',
  },
} as const;

// === IPCæ¶ˆæ¯æ‰¹å¤„ç†ä¼˜åŒ– ===
export interface IPCBatchingConfig {
  batchSize: number; // æ‰¹å¤„ç†å¤§å°
  batchTimeout: number; // æ‰¹å¤„ç†è¶…æ—¶(ms)
  compressionThreshold: number; // å‹ç¼©é˜ˆå€¼(bytes)
  priorityBypass: boolean; // é«˜ä¼˜å…ˆçº§ç»•è¿‡æ‰¹å¤„ç†
}

export const IPC_BATCHING_STRATEGY: IPCBatchingConfig = {
  batchSize: 50, // 50æ¡æ¶ˆæ¯æ‰¹å¤„ç†
  batchTimeout: 10, // 10msè¶…æ—¶
  compressionThreshold: 1024, // 1KBä»¥ä¸Šå¯ç”¨å‹ç¼©
  priorityBypass: true, // å…³é”®æ¶ˆæ¯ç«‹å³å‘é€
};
```

### 5.2 äº‹ä»¶ååé‡ä¸å¤„ç†èƒ½åŠ›ï¼ˆEvent Throughput & Processingï¼‰

#### 5.2.1 æ¸¸æˆäº‹ä»¶ç³»ç»Ÿååé‡æ¨¡å‹

```typescript
// src/shared/capacity/event-throughput.ts - äº‹ä»¶ååé‡è§„åˆ’

// === äº‹ä»¶ç³»ç»Ÿå¤„ç†èƒ½åŠ› ===
export const EVENT_THROUGHPUT_CAPACITY = {
  // å•äº‹ä»¶å¤„ç†æ€§èƒ½
  singleEvent: {
    simpleEvent: '< 10ms', // ç®€å•äº‹ä»¶ï¼ˆçŠ¶æ€æ›´æ–°ï¼‰
    complexEvent: '< 50ms', // å¤æ‚äº‹ä»¶ï¼ˆé€»è¾‘è®¡ç®—ï¼‰
    aiEvent: '< 200ms', // AIå†³ç­–äº‹ä»¶
    networkEvent: '< 100ms', // è·¨æ¨¡å—äº‹ä»¶
    description: 'ä¸åŒç±»å‹å•äº‹ä»¶çš„å¤„ç†æ—¶é—´åŸºçº¿',
  },

  // æ‰¹å¤„ç†äº‹ä»¶æ€§èƒ½
  batchProcessing: {
    batch_10_events: '< 100ms', // 10äº‹ä»¶æ‰¹å¤„ç† < 100ms
    batch_50_events: '< 500ms', // 50äº‹ä»¶æ‰¹å¤„ç† < 500ms
    batch_100_events: '< 1000ms', // 100äº‹ä»¶æ‰¹å¤„ç† < 1s
    maxBatchSize: 200, // æœ€å¤§æ‰¹å¤„ç†å¤§å°
    description: 'æ‰¹é‡äº‹ä»¶å¤„ç†çš„æ€§èƒ½åŸºçº¿',
  },

  // å¹¶å‘äº‹ä»¶å¤„ç†
  concurrentProcessing: {
    maxConcurrentEvents: 50, // æœ€å¤§å¹¶å‘äº‹ä»¶æ•°
    eventQueueSize: 1000, // äº‹ä»¶é˜Ÿåˆ—å¤§å°
    processingThreads: 4, // å¤„ç†çº¿ç¨‹æ•°ï¼ˆWeb Workerï¼‰
    loadBalancing: 'round_robin', // è´Ÿè½½å‡è¡¡ç­–ç•¥
    description: 'å¤šçº¿ç¨‹å¹¶å‘äº‹ä»¶å¤„ç†èƒ½åŠ›',
  },

  // äº‹ä»¶é“¾å¤„ç†æ€§èƒ½
  eventChainProcessing: {
    shortChain_3_events: '< 150ms', // 3äº‹ä»¶é“¾ < 150ms
    mediumChain_5_events: '< 300ms', // 5äº‹ä»¶é“¾ < 300ms
    longChain_10_events: '< 1000ms', // 10äº‹ä»¶é“¾ < 1s
    maxChainLength: 20, // æœ€å¤§é“¾é•¿åº¦
    circularDetection: true, // å¾ªç¯æ£€æµ‹
    description: 'äº‹ä»¶é“¾å¤„ç†æ€§èƒ½å’Œå®‰å…¨é™åˆ¶',
  },
} as const;

// === äº‹ä»¶æ± å®¹é‡è§„åˆ’ ===
export const EVENT_POOL_CAPACITY = {
  // åŸºç¡€äº‹ä»¶æ± é…ç½®
  basePool: {
    totalEvents: 200, // åŸºç¡€äº‹ä»¶æ•°é‡
    activeEvents: 50, // åŒæ—¶æ´»è·ƒäº‹ä»¶
    memoryUsage: '< 50MB', // å†…å­˜å ç”¨
    loadTime: '< 2s', // åŠ è½½æ—¶é—´
    description: 'MVPç‰ˆæœ¬åŸºç¡€äº‹ä»¶æ± å®¹é‡',
  },

  // æ‰©å±•äº‹ä»¶æ± é…ç½®
  extendedPool: {
    totalEvents: 1000, // å®Œæ•´ç‰ˆäº‹ä»¶æ•°é‡
    activeEvents: 200, // åŒæ—¶æ´»è·ƒäº‹ä»¶
    memoryUsage: '< 200MB', // å†…å­˜å ç”¨
    loadTime: '< 5s', // åŠ è½½æ—¶é—´
    description: 'å®Œæ•´ç‰ˆæœ¬æ‰©å±•äº‹ä»¶æ± å®¹é‡',
  },

  // äº‹ä»¶ç¼“å­˜ç­–ç•¥
  cachingStrategy: {
    hotEvents: 50, // çƒ­ç‚¹äº‹ä»¶ç¼“å­˜æ•°é‡
    lruCacheSize: 100, // LRUç¼“å­˜å¤§å°
    preloadEvents: 20, // é¢„åŠ è½½äº‹ä»¶æ•°é‡
    evictionPolicy: 'least_recently_used',
    description: 'äº‹ä»¶ç¼“å­˜å’Œé¢„åŠ è½½ç­–ç•¥',
  },
} as const;
```

#### 5.2.2 AIç³»ç»Ÿå†³ç­–ååé‡

```typescript
// === AIå†³ç­–ç³»ç»Ÿå®¹é‡è§„åˆ’ ===
export const AI_DECISION_THROUGHPUT = {
  // å•AIå®ä½“å†³ç­–æ€§èƒ½
  singleAI: {
    simpleDecision: '< 50ms', // ç®€å•å†³ç­–ï¼ˆçŠ¶æ€è½¬æ¢ï¼‰
    complexDecision: '< 200ms', // å¤æ‚å†³ç­–ï¼ˆç­–ç•¥é€‰æ‹©ï¼‰
    coordianationDecision: '< 500ms', // åè°ƒå†³ç­–ï¼ˆå¤šå®ä½“äº¤äº’ï¼‰
    emergencyDecision: '< 100ms', // ç´§æ€¥å†³ç­–ï¼ˆå¼‚å¸¸å¤„ç†ï¼‰
    description: 'å•ä¸ªAIå®ä½“çš„å†³ç­–å¤„ç†æ—¶é—´',
  },

  // æ‰¹é‡AIå†³ç­–æ€§èƒ½
  batchAIProcessing: {
    batch_10_ais: '< 500ms', // 10ä¸ªAIæ‰¹å¤„ç†
    batch_50_ais: '< 2000ms', // 50ä¸ªAIæ‰¹å¤„ç†
    batch_200_ais: '< 5000ms', // 200ä¸ªAIæ‰¹å¤„ç†ï¼ˆå…¨é‡ï¼‰
    maxBatchSize: 200, // æœ€å¤§æ‰¹å¤„ç†AIæ•°é‡
    description: 'æ‰¹é‡AIå†³ç­–å¤„ç†æ€§èƒ½',
  },

  // AIåè°ƒæ€§èƒ½æ¨¡å‹
  aiCoordination: {
    pairwiseInteraction: '< 100ms', // ä¸¤ä¸¤AIäº¤äº’
    groupCoordination_5: '< 300ms', // 5AIç¾¤ä½“åè°ƒ
    globalCoordination_all: '< 1000ms', // å…¨å±€AIåè°ƒ
    conflictResolution: '< 200ms', // å†²çªè§£å†³æ—¶é—´
    description: 'AIé—´åè°ƒå’Œå†²çªå¤„ç†æ€§èƒ½',
  },

  // AIè®¡ç®—èµ„æºåˆ†é…
  resourceAllocation: {
    cpuCoresPerWorker: 0.25, // æ¯Workerå ç”¨CPUæ ¸å¿ƒæ•°
    memoryPerAI: '2-5MB', // æ¯ä¸ªAIå®ä½“å†…å­˜å ç”¨
    workerThreads: 4, // Web Workerçº¿ç¨‹æ•°
    loadBalancingAlgorithm: 'weighted_round_robin',
    description: 'AIè®¡ç®—èµ„æºåˆ†é…å’Œè´Ÿè½½å‡è¡¡',
  },
} as const;
```

### 5.3 æ¸²æŸ“æ€§èƒ½ä¸FPSç¨³å®šæ€§ï¼ˆRendering Performance & FPSï¼‰

#### 5.3.1 æ¸¸æˆå¾ªç¯FPSåŸºçº¿æ¨¡å‹

```typescript
// src/shared/capacity/rendering-performance.ts - æ¸²æŸ“æ€§èƒ½è§„åˆ’

// === æ¸¸æˆå¾ªç¯FPSæ€§èƒ½æ¨¡å‹ ===
export const FPS_PERFORMANCE_MODEL = {
  // ç›®æ ‡FPSåŸºçº¿
  targetFPS: {
    idealFPS: 60, // ç†æƒ³å¸§ç‡60FPS
    minimumFPS: 58, // æœ€ä½ç¨³å®šå¸§ç‡58FPS
    frameTime_target: 16.67, // ç›®æ ‡å¸§æ—¶é—´16.67ms
    frameTime_max: 17.24, // æœ€å¤§å¸§æ—¶é—´17.24ms (58FPS)
    description: 'æ¸¸æˆå¾ªç¯FPSæ€§èƒ½ç›®æ ‡',
  },

  // å¸§æ—¶é—´åˆ†è§£æ¨¡å‹
  frameTimeBreakdown: {
    gameLogicUpdate: '< 4ms', // æ¸¸æˆé€»è¾‘æ›´æ–° < 4ms
    aiProcessing: '< 6ms', // AIå¤„ç† < 6ms
    physicsSimulation: '< 2ms', // ç‰©ç†æ¨¡æ‹Ÿ < 2ms
    renderingPipeline: '< 4ms', // æ¸²æŸ“ç®¡é“ < 4ms
    bufferSwap: '< 0.67ms', // ç¼“å†²åŒºäº¤æ¢ < 0.67ms
    total: '< 16.67ms', // æ€»å¸§æ—¶é—´ < 16.67ms
    description: 'å•å¸§å¤„ç†æ—¶é—´åˆ†è§£æ¨¡å‹',
  },

  // ä¸åŒåœºæ™¯ä¸‹çš„FPSè¡¨ç°
  scenarioPerformance: {
    mainMenu: {
      targetFPS: 60,
      gpuUsage: '< 10%',
      cpuUsage: '< 5%',
      description: 'ä¸»èœå•ç•Œé¢æ€§èƒ½åŸºçº¿',
    },

    guildManagement: {
      targetFPS: 60,
      gpuUsage: '< 20%',
      cpuUsage: '< 15%',
      description: 'å…¬ä¼šç®¡ç†ç•Œé¢æ€§èƒ½åŸºçº¿',
    },

    battleSimulation: {
      targetFPS: 58, // æˆ˜æ–—æ—¶å¯æ¥å—è½»å¾®é™ä½
      gpuUsage: '< 40%',
      cpuUsage: '< 30%',
      description: 'æˆ˜æ–—æ¨¡æ‹Ÿåœºæ™¯æ€§èƒ½åŸºçº¿',
    },

    massEventProcessing: {
      targetFPS: 55, // å¤§é‡äº‹ä»¶å¤„ç†æ—¶çš„æœ€ä½è¦æ±‚
      gpuUsage: '< 30%',
      cpuUsage: '< 50%',
      description: 'å¤§é‡äº‹ä»¶å¤„ç†æ—¶çš„æ€§èƒ½åŸºçº¿',
    },
  },
} as const;

// === é¦–å±æ¸²æŸ“æ€§èƒ½æ¨¡å‹ ===
export const FIRST_SCREEN_RENDERING = {
  // åº”ç”¨å¯åŠ¨é¦–å±æ€§èƒ½
  coldStart: {
    electronBootstrap: '< 1000ms', // Electronå¼•å¯¼ < 1s
    reactInitialization: '< 800ms', // Reactåˆå§‹åŒ– < 0.8s
    phaserEngineLoad: '< 1200ms', // Phaserå¼•æ“åŠ è½½ < 1.2s
    firstContentfulPaint: '< 2000ms', // é¦–æ¬¡å†…å®¹ç»˜åˆ¶ < 2s
    firstInteraction: '< 3000ms', // é¦–æ¬¡å¯äº¤äº’ < 3s
    description: 'å†·å¯åŠ¨é¦–å±æ¸²æŸ“æ—¶é—´çº¿',
  },

  // åœºæ™¯åˆ‡æ¢æ¸²æŸ“æ€§èƒ½
  sceneTransition: {
    sceneUnload: '< 200ms', // åœºæ™¯å¸è½½ < 200ms
    assetLoading: '< 500ms', // èµ„æºåŠ è½½ < 500ms
    sceneInitialization: '< 300ms', // åœºæ™¯åˆå§‹åŒ– < 300ms
    firstFrame: '< 100ms', // é¦–å¸§æ¸²æŸ“ < 100ms
    totalTransition: '< 1000ms', // æ€»åˆ‡æ¢æ—¶é—´ < 1s
    description: 'åœºæ™¯åˆ‡æ¢æ¸²æŸ“æ€§èƒ½',
  },

  // æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥
  optimizationStrategies: {
    assetPreloading: true, // èµ„æºé¢„åŠ è½½
    texturePacking: true, // çº¹ç†æ‰“åŒ…
    batchRendering: true, // æ‰¹é‡æ¸²æŸ“
    frustumCulling: true, // è§†é”¥ä½“å‰”é™¤
    lodSystem: false, // LODç³»ç»Ÿï¼ˆ2Dæ¸¸æˆæš‚ä¸éœ€è¦ï¼‰
    description: 'æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–ç­–ç•¥é…ç½®',
  },
} as const;
```

#### 5.3.2 GPUå’Œæ¸²æŸ“èµ„æºä½¿ç”¨æ¨¡å‹

```typescript
// === GPUæ¸²æŸ“èµ„æºå®¹é‡æ¨¡å‹ ===
export const GPU_RESOURCE_MODEL = {
  // GPUä½¿ç”¨ç‡åŸºçº¿
  gpuUtilization: {
    normal: '< 20%', // æ­£å¸¸ä½¿ç”¨ç‡ < 20%
    peak: '< 40%', // å³°å€¼ä½¿ç”¨ç‡ < 40%
    sustained: '< 60%', // æŒç»­é«˜è´Ÿè½½ < 60%
    thermal_limit: 80, // çƒ­é™åˆ¶é˜ˆå€¼ 80%
    description: 'GPUä½¿ç”¨ç‡æ§åˆ¶ç›®æ ‡',
  },

  // æ˜¾å­˜ä½¿ç”¨æ¨¡å‹
  vramUsage: {
    baseTextures: '< 100MB', // åŸºç¡€çº¹ç†èµ„æº
    uiAssets: '< 50MB', // UIèµ„æº
    effectsBuffer: '< 30MB', // ç‰¹æ•ˆç¼“å†²
    frameBuffers: '< 20MB', // å¸§ç¼“å†²
    totalBudget: '< 256MB', // æ€»æ˜¾å­˜é¢„ç®—ï¼ˆæ”¯æŒé›†æˆæ˜¾å¡ï¼‰
    description: 'æ˜¾å­˜ä½¿ç”¨é¢„ç®—åˆ†é…',
  },

  // æ¸²æŸ“æ‰¹æ¬¡ä¼˜åŒ–
  renderBatching: {
    maxDrawCalls: 100, // æœ€å¤§ç»˜åˆ¶è°ƒç”¨æ•°
    maxTriangles: 10000, // æœ€å¤§ä¸‰è§’å½¢æ•°
    textureAtlasSize: 2048, // çº¹ç†å›¾é›†å°ºå¯¸
    batchingEfficiency: '> 80%', // æ‰¹å¤„ç†æ•ˆç‡
    description: 'æ¸²æŸ“æ‰¹æ¬¡ä¼˜åŒ–ç›®æ ‡',
  },
} as const;
```

### 5.4 ç³»ç»Ÿèµ„æºå®¹é‡è§„åˆ’ï¼ˆSystem Resource Capacityï¼‰

#### 5.4.1 å†…å­˜ä½¿ç”¨å®¹é‡æ¨¡å‹

```typescript
// src/shared/capacity/memory-capacity.ts - å†…å­˜å®¹é‡è§„åˆ’

// === å†…å­˜ä½¿ç”¨å®¹é‡æ¨¡å‹ ===
export const MEMORY_CAPACITY_MODEL = {
  // è¿›ç¨‹å†…å­˜åŸºçº¿åˆ†é…
  processMemoryBaseline: {
    electronMain: '80-120MB', // Electronä¸»è¿›ç¨‹
    electronRenderer: '150-200MB', // æ¸²æŸ“è¿›ç¨‹åŸºç¡€
    phaserEngine: '50-100MB', // Phaseræ¸¸æˆå¼•æ“
    reactFramework: '40-60MB', // React UIæ¡†æ¶
    baseline_total: '320-480MB', // åŸºçº¿æ€»å†…å­˜
    description: 'å„è¿›ç¨‹åŸºç¡€å†…å­˜ä½¿ç”¨åŸºçº¿',
  },

  // åŠ¨æ€å†…å­˜å¢é•¿æ¨¡å‹
  dynamicMemoryGrowth: {
    // æ¸¸æˆæ•°æ®å¢é•¿
    gameData: {
      perSaveFile: '5-10MB', // æ¯ä¸ªå­˜æ¡£æ–‡ä»¶
      maxSaveFiles: 10, // æœ€å¤§å­˜æ¡£æ•°é‡
      eventCache: '20-50MB', // äº‹ä»¶ç¼“å­˜
      aiStateMemory: '30-60MB', // AIçŠ¶æ€å†…å­˜
      description: 'æ¸¸æˆæ•°æ®å†…å­˜å¢é•¿æ¨¡å‹',
    },

    // UIç¼“å­˜å¢é•¿
    uiCache: {
      componentCache: '10-20MB', // Reactç»„ä»¶ç¼“å­˜
      imageAssets: '30-50MB', // å›¾ç‰‡èµ„æºç¼“å­˜
      fontCache: '5-10MB', // å­—ä½“ç¼“å­˜
      animationBuffers: '20-40MB', // åŠ¨ç”»ç¼“å†²åŒº
      description: 'UIç›¸å…³å†…å­˜ç¼“å­˜',
    },

    // AIç³»ç»Ÿå†…å­˜
    aiMemory: {
      perAIEntity: '2-5MB', // æ¯ä¸ªAIå®ä½“
      maxAIEntities: 200, // æœ€å¤§AIå®ä½“æ•°
      decisionCache: '50-100MB', // å†³ç­–ç¼“å­˜
      behaviorTree: '20-40MB', // è¡Œä¸ºæ ‘ç¼“å­˜
      description: 'AIç³»ç»Ÿå†…å­˜ä½¿ç”¨',
    },
  },

  // å†…å­˜ä½¿ç”¨é˜ˆå€¼å’Œå‘Šè­¦
  memoryThresholds: {
    normal: '< 400MB', // æ­£å¸¸è¿è¡Œå†…å­˜ä¸Šé™
    warning: '500MB', // å‘Šè­¦é˜ˆå€¼
    critical: '600MB', // ä¸¥é‡å‘Šè­¦é˜ˆå€¼
    maximum: '800MB', // æœ€å¤§å†…å­˜é™åˆ¶
    gcTrigger: '450MB', // å¼ºåˆ¶GCè§¦å‘é˜ˆå€¼
    description: 'å†…å­˜ä½¿ç”¨ç›‘æ§é˜ˆå€¼è®¾ç½®',
  },

  // å†…å­˜æ³„æ¼æ£€æµ‹é…ç½®
  memoryLeakDetection: {
    samplingInterval: '30s', // é‡‡æ ·é—´éš”
    trendWindow: '5min', // è¶‹åŠ¿çª—å£
    leakThreshold: '10MB/min', // æ³„æ¼é˜ˆå€¼
    alertAfter: '3 consecutive samples', // å‘Šè­¦æ¡ä»¶
    description: 'å†…å­˜æ³„æ¼æ£€æµ‹é…ç½®',
  },
} as const;
```

#### 5.4.2 CPUä½¿ç”¨ç‡å’Œå¤„ç†èƒ½åŠ›æ¨¡å‹

```typescript
// === CPUå¤„ç†èƒ½åŠ›å®¹é‡æ¨¡å‹ ===
export const CPU_CAPACITY_MODEL = {
  // CPUä½¿ç”¨ç‡åŸºçº¿
  cpuUtilizationBaseline: {
    idle: '< 5%', // ç©ºé—²çŠ¶æ€CPUä½¿ç”¨ç‡
    normal: '< 15%', // æ­£å¸¸æ¸¸æˆCPUä½¿ç”¨ç‡
    peak: '< 40%', // å³°å€¼CPUä½¿ç”¨ç‡
    sustained: '< 50%', // æŒç»­é«˜è´Ÿè½½CPUä½¿ç”¨ç‡
    thermal_protection: 70, // çƒ­ä¿æŠ¤é˜ˆå€¼
    description: 'CPUä½¿ç”¨ç‡æ§åˆ¶ç›®æ ‡',
  },

  // CPUæ—¶é—´ç‰‡åˆ†é…æ¨¡å‹
  cpuTimeAllocation: {
    gameLoop: '40%', // æ¸¸æˆå¾ªç¯CPUæ—¶é—´
    aiProcessing: '25%', // AIå¤„ç†CPUæ—¶é—´
    uiRendering: '20%', // UIæ¸²æŸ“CPUæ—¶é—´
    systemOverhead: '10%', // ç³»ç»Ÿå¼€é”€CPUæ—¶é—´
    buffer: '5%', // ç¼“å†²CPUæ—¶é—´
    description: 'CPUæ—¶é—´ç‰‡åˆ†é…ç­–ç•¥',
  },

  // å¤šæ ¸å¤„ç†ç­–ç•¥
  multiCoreSrategy: {
    mainThread: 'core_0', // ä¸»çº¿ç¨‹ç»‘å®šæ ¸å¿ƒ0
    webWorkers: 'cores_1_2_3', // Web Workerä½¿ç”¨æ ¸å¿ƒ1-3
    maxWorkerThreads: 4, // æœ€å¤§Workerçº¿ç¨‹æ•°
    threadPoolSize: 8, // çº¿ç¨‹æ± å¤§å°
    loadBalancing: 'cpu_affinity', // CPUäº²å’Œæ€§è´Ÿè½½å‡è¡¡
    description: 'å¤šæ ¸å¤„ç†å’Œçº¿ç¨‹åˆ†é…ç­–ç•¥',
  },

  // CPUå¯†é›†ä»»åŠ¡å¤„ç†
  intensiveTaskHandling: {
    maxTaskDuration: '100ms', // æœ€å¤§ä»»åŠ¡æ‰§è¡Œæ—¶é—´
    yieldInterval: '16ms', // è®©å‡ºCPUæ—¶é—´é—´éš”
    taskPriority: 'preemptive', // æŠ¢å å¼ä»»åŠ¡è°ƒåº¦
    backgroundProcessing: true, // åå°å¤„ç†æ”¯æŒ
    description: 'CPUå¯†é›†ä»»åŠ¡å¤„ç†ç­–ç•¥',
  },
} as const;
```

#### 5.4.3 ç£ç›˜I/Oå’Œå­˜å‚¨å®¹é‡æ¨¡å‹

```typescript
// === ç£ç›˜I/Oå®¹é‡è§„åˆ’ ===
export const DISK_IO_CAPACITY_MODEL = {
  // å­˜æ¡£æ–‡ä»¶I/Oæ€§èƒ½
  saveFileIO: {
    // è¯»å–æ€§èƒ½åŸºçº¿
    readOperations: {
      smallRead_1MB: '< 50ms', // 1MBå°æ–‡ä»¶è¯»å–
      mediumRead_10MB: '< 200ms', // 10MBä¸­ç­‰æ–‡ä»¶è¯»å–
      largeRead_50MB: '< 1000ms', // 50MBå¤§æ–‡ä»¶è¯»å–
      concurrentReads: 4, // å¹¶å‘è¯»å–æ•°
      description: 'å­˜æ¡£æ–‡ä»¶è¯»å–æ€§èƒ½åŸºçº¿',
    },

    // å†™å…¥æ€§èƒ½åŸºçº¿
    writeOperations: {
      smallWrite_1MB: '< 100ms', // 1MBå°æ–‡ä»¶å†™å…¥
      mediumWrite_10MB: '< 500ms', // 10MBä¸­ç­‰æ–‡ä»¶å†™å…¥
      largeWrite_50MB: '< 2000ms', // 50MBå¤§æ–‡ä»¶å†™å…¥
      fsyncLatency: '< 50ms', // å¼ºåˆ¶åŒæ­¥å»¶è¿Ÿ
      description: 'å­˜æ¡£æ–‡ä»¶å†™å…¥æ€§èƒ½åŸºçº¿',
    },

    // SQLiteæ•°æ®åº“I/O
    sqliteIO: {
      queryLatency: '< 10ms', // SQLæŸ¥è¯¢å»¶è¿Ÿ
      insertLatency: '< 20ms', // æ’å…¥æ“ä½œå»¶è¿Ÿ
      updateLatency: '< 30ms', // æ›´æ–°æ“ä½œå»¶è¿Ÿ
      transactionLatency: '< 100ms', // äº‹åŠ¡æäº¤å»¶è¿Ÿ
      vacuumOperation: '< 5000ms', // æ•°æ®åº“æ¸…ç†æ“ä½œ
      description: 'SQLiteæ•°æ®åº“I/Oæ€§èƒ½',
    },
  },

  // å­˜å‚¨ç©ºé—´å®¹é‡è§„åˆ’
  storageCapacity: {
    // å­˜æ¡£æ•°æ®å¤§å°é¢„æµ‹
    saveDataSizes: {
      minimalSave: '1-5MB', // æœ€å°å­˜æ¡£ï¼ˆæ–°æ¸¸æˆï¼‰
      normalSave: '10-30MB', // æ­£å¸¸å­˜æ¡£ï¼ˆä¸­æœŸæ¸¸æˆï¼‰
      fullSave: '30-50MB', // å®Œæ•´å­˜æ¡£ï¼ˆåæœŸæ¸¸æˆï¼‰
      maxSaveLimit: '100MB', // æœ€å¤§å­˜æ¡£é™åˆ¶
      description: 'å­˜æ¡£æ–‡ä»¶å¤§å°å¢é•¿é¢„æµ‹',
    },

    // åº”ç”¨æ•°æ®å­˜å‚¨
    applicationData: {
      gameAssets: '200-500MB', // æ¸¸æˆèµ„æºæ–‡ä»¶
      configFiles: '< 1MB', // é…ç½®æ–‡ä»¶
      logFiles: '< 50MB', // æ—¥å¿—æ–‡ä»¶
      cacheData: '< 100MB', // ç¼“å­˜æ•°æ®
      totalFootprint: '< 1GB', // æ€»å­˜å‚¨å ç”¨
      description: 'åº”ç”¨æ•°æ®å­˜å‚¨è§„åˆ’',
    },

    // ä¸´æ—¶æ–‡ä»¶å’Œç¼“å­˜
    temporaryStorage: {
      tempFileLimit: '< 200MB', // ä¸´æ—¶æ–‡ä»¶é™åˆ¶
      cacheExpiration: '7d', // ç¼“å­˜è¿‡æœŸæ—¶é—´
      autoCleanup: true, // è‡ªåŠ¨æ¸…ç†
      diskSpaceMonitoring: true, // ç£ç›˜ç©ºé—´ç›‘æ§
      description: 'ä¸´æ—¶å­˜å‚¨å’Œç¼“å­˜ç®¡ç†',
    },
  },

  // I/Oä¼˜åŒ–ç­–ç•¥
  ioOptimization: {
    readAhead: {
      enabled: true,
      bufferSize: '4MB', // é¢„è¯»ç¼“å†²åŒºå¤§å°
      triggerThreshold: '70%', // é¢„è¯»è§¦å‘é˜ˆå€¼
      description: 'é¢„è¯»ä¼˜åŒ–ç­–ç•¥',
    },

    writeCoalescing: {
      enabled: true,
      batchSize: 10, // æ‰¹é‡å†™å…¥å¤§å°
      flushInterval: '1000ms', // åˆ·å†™é—´éš”
      description: 'å†™å…¥åˆå¹¶ä¼˜åŒ–',
    },

    compression: {
      enabled: true,
      algorithm: 'lz4', // å‹ç¼©ç®—æ³•
      threshold: '10MB', // å‹ç¼©é˜ˆå€¼
      compressionRatio: '> 50%', // å‹ç¼©æ¯”è¦æ±‚
      description: 'æ•°æ®å‹ç¼©ä¼˜åŒ–',
    },
  },
} as const;
```

### 5.5 æ€§èƒ½ç›‘æ§é‡‡æ ·çª—å£è®¾è®¡ï¼ˆPerformance Monitoring & Samplingï¼‰

#### 5.5.1 å®æ—¶æ€§èƒ½é‡‡æ ·ç­–ç•¥

```typescript
// src/shared/capacity/sampling-strategy.ts - æ€§èƒ½é‡‡æ ·ç­–ç•¥

// === æ€§èƒ½æŒ‡æ ‡é‡‡æ ·é…ç½® ===
export const PERFORMANCE_SAMPLING_CONFIG = {
  // å®æ—¶æ€§èƒ½æŒ‡æ ‡é‡‡æ ·
  realTimeMetrics: {
    // FPSé‡‡æ ·
    fpsMonitoring: {
      samplingInterval: '1000ms', // 1ç§’é‡‡æ ·é—´éš”
      windowSize: '10s', // 10ç§’æ»‘åŠ¨çª—å£
      aggregation: 'average', // èšåˆæ–¹å¼ï¼šå¹³å‡å€¼
      alertThreshold: 58, // å‘Šè­¦é˜ˆå€¼ï¼šä½äº58FPS
      retention: '1h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'æ¸¸æˆå¸§ç‡å®æ—¶ç›‘æ§é‡‡æ ·',
    },

    // å†…å­˜ä½¿ç”¨é‡‡æ ·
    memoryMonitoring: {
      samplingInterval: '30000ms', // 30ç§’é‡‡æ ·é—´éš”
      windowSize: '5min', // 5åˆ†é’Ÿæ»‘åŠ¨çª—å£
      aggregation: 'max', // èšåˆæ–¹å¼ï¼šæœ€å¤§å€¼
      alertThreshold: 500, // å‘Šè­¦é˜ˆå€¼ï¼š500MB
      retention: '24h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'å†…å­˜ä½¿ç”¨å®æ—¶ç›‘æ§é‡‡æ ·',
    },

    // CPUä½¿ç”¨ç‡é‡‡æ ·
    cpuMonitoring: {
      samplingInterval: '5000ms', // 5ç§’é‡‡æ ·é—´éš”
      windowSize: '1min', // 1åˆ†é’Ÿæ»‘åŠ¨çª—å£
      aggregation: 'p95', // èšåˆæ–¹å¼ï¼šP95åˆ†ä½æ•°
      alertThreshold: 40, // å‘Šè­¦é˜ˆå€¼ï¼š40%
      retention: '6h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'CPUä½¿ç”¨ç‡å®æ—¶ç›‘æ§é‡‡æ ·',
    },
  },

  // å»¶è¿ŸæŒ‡æ ‡é‡‡æ ·
  latencyMetrics: {
    // UIå“åº”æ—¶é—´é‡‡æ ·
    uiResponseTime: {
      samplingRate: 1.0, // 100%é‡‡æ ·ç‡
      buckets: [10, 50, 100, 200, 500, 1000], // å»¶è¿Ÿæ¡¶è®¾ç½®
      percentiles: [50, 90, 95, 99], // åˆ†ä½æ•°è®¡ç®—
      windowSize: '5min', // 5åˆ†é’Ÿçª—å£
      retention: '1h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'UIå“åº”æ—¶é—´åˆ†å¸ƒé‡‡æ ·',
    },

    // IPCå¾€è¿”å»¶è¿Ÿé‡‡æ ·
    ipcLatency: {
      samplingRate: 0.1, // 10%é‡‡æ ·ç‡
      buckets: [1, 5, 10, 20, 50, 100], // å»¶è¿Ÿæ¡¶è®¾ç½®
      percentiles: [50, 95, 99], // åˆ†ä½æ•°è®¡ç®—
      windowSize: '10min', // 10åˆ†é’Ÿçª—å£
      retention: '2h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'IPCé€šä¿¡å»¶è¿Ÿåˆ†å¸ƒé‡‡æ ·',
    },

    // äº‹ä»¶å¤„ç†å»¶è¿Ÿé‡‡æ ·
    eventProcessingLatency: {
      samplingRate: 0.05, // 5%é‡‡æ ·ç‡
      buckets: [10, 50, 100, 200, 500, 1000], // å»¶è¿Ÿæ¡¶è®¾ç½®
      percentiles: [50, 90, 95, 99], // åˆ†ä½æ•°è®¡ç®—
      windowSize: '15min', // 15åˆ†é’Ÿçª—å£
      retention: '4h', // æ•°æ®ä¿ç•™æ—¶é—´
      description: 'äº‹ä»¶å¤„ç†å»¶è¿Ÿåˆ†å¸ƒé‡‡æ ·',
    },
  },
} as const;

// === é‡‡æ ·æ•°æ®å­˜å‚¨å’Œèšåˆ ===
export const SAMPLING_STORAGE_CONFIG = {
  // æœ¬åœ°æ—¶åºæ•°æ®å­˜å‚¨
  localStorage: {
    engine: 'SQLite', // å­˜å‚¨å¼•æ“
    database: 'metrics.db', // æ•°æ®åº“æ–‡ä»¶
    retentionPolicy: '7d', // é»˜è®¤ä¿ç•™ç­–ç•¥
    compressionEnabled: true, // å¯ç”¨æ•°æ®å‹ç¼©
    maxDatabaseSize: '100MB', // æœ€å¤§æ•°æ®åº“å¤§å°
    description: 'æœ¬åœ°æ€§èƒ½æ•°æ®å­˜å‚¨é…ç½®',
  },

  // æ•°æ®èšåˆç­–ç•¥
  aggregationStrategy: {
    // åˆ†çº§èšåˆ
    levels: [
      { resolution: '1s', retention: '1h' }, // 1ç§’åˆ†è¾¨ç‡ï¼Œä¿ç•™1å°æ—¶
      { resolution: '1m', retention: '24h' }, // 1åˆ†é’Ÿåˆ†è¾¨ç‡ï¼Œä¿ç•™24å°æ—¶
      { resolution: '5m', retention: '7d' }, // 5åˆ†é’Ÿåˆ†è¾¨ç‡ï¼Œä¿ç•™7å¤©
      { resolution: '1h', retention: '30d' }, // 1å°æ—¶åˆ†è¾¨ç‡ï¼Œä¿ç•™30å¤©
    ],

    // èšåˆå‡½æ•°
    aggregationFunctions: ['min', 'max', 'avg', 'p95', 'p99'],

    // æ•°æ®ä¸‹é‡‡æ ·
    downsamplingTrigger: '70%', // å­˜å‚¨ä½¿ç”¨ç‡è¾¾åˆ°70%æ—¶è§¦å‘ä¸‹é‡‡æ ·
    description: 'åˆ†çº§æ•°æ®èšåˆå’Œä¿ç•™ç­–ç•¥',
  },
} as const;
```

#### 5.5.2 æ€§èƒ½åŸºå‡†å’Œå›å½’æ£€æµ‹

```typescript
// === æ€§èƒ½åŸºå‡†ç®¡ç† ===
export const PERFORMANCE_BASELINE_CONFIG = {
  // æ€§èƒ½åŸºå‡†å»ºç«‹
  baselineEstablishment: {
    // åŸºå‡†æµ‹è¯•å¥—ä»¶
    benchmarkSuite: [
      'startup_performance', // å¯åŠ¨æ€§èƒ½åŸºå‡†
      'ui_interaction_latency', // UIäº¤äº’å»¶è¿ŸåŸºå‡†
      'event_processing_throughput', // äº‹ä»¶å¤„ç†ååé‡åŸºå‡†
      'memory_usage_profile', // å†…å­˜ä½¿ç”¨åŸºå‡†
      'fps_stability', // FPSç¨³å®šæ€§åŸºå‡†
      'save_load_performance', // å­˜æ¡£è¯»å†™æ€§èƒ½åŸºå‡†
    ],

    // åŸºå‡†æ•°æ®æ”¶é›†
    collectionStrategy: {
      runCount: 10, // æ¯ä¸ªåŸºå‡†è¿è¡Œ10æ¬¡
      warmupRuns: 3, // é¢„çƒ­è¿è¡Œ3æ¬¡
      statisticalMethod: 'median', // ä½¿ç”¨ä¸­ä½æ•°ä½œä¸ºåŸºå‡†
      outlierDetection: true, // å¯ç”¨å¼‚å¸¸å€¼æ£€æµ‹
      confidenceInterval: 0.95, // 95%ç½®ä¿¡åŒºé—´
      description: 'æ€§èƒ½åŸºå‡†æ•°æ®æ”¶é›†ç­–ç•¥',
    },
  },

  // æ€§èƒ½å›å½’æ£€æµ‹
  regressionDetection: {
    // å˜æ›´æ£€æµ‹é˜ˆå€¼
    changeDetectionThresholds: {
      improvement: '< -5%', // æ€§èƒ½æå‡ï¼šä½äº-5%è§†ä¸ºæ”¹å–„
      acceptable: 'Â±5%', // å¯æ¥å—å˜åŒ–ï¼šÂ±5%ä»¥å†…
      warning: '5-15%', // å‘Šè­¦èŒƒå›´ï¼š5-15%é€€åŒ–
      critical: '> 15%', // ä¸¥é‡é€€åŒ–ï¼šè¶…è¿‡15%
      description: 'æ€§èƒ½å˜åŒ–æ£€æµ‹é˜ˆå€¼è®¾å®š',
    },

    // å›å½’æµ‹è¯•è§¦å‘æ¡ä»¶
    triggerConditions: [
      'pre_commit', // æäº¤å‰è§¦å‘
      'daily_build', // æ¯æ—¥æ„å»ºè§¦å‘
      'release_candidate', // å‘å¸ƒå€™é€‰ç‰ˆæœ¬è§¦å‘
      'manual_request', // æ‰‹åŠ¨è¯·æ±‚è§¦å‘
    ],

    // å›å½’æŠ¥å‘Šé…ç½®
    reportingConfig: {
      format: ['html', 'json'], // æŠ¥å‘Šæ ¼å¼
      includeCharts: true, // åŒ…å«å›¾è¡¨
      historicalComparison: true, // å†å²å¯¹æ¯”
      alertChannels: ['slack', 'email'], // å‘Šè­¦æ¸ é“
      description: 'æ€§èƒ½å›å½’æŠ¥å‘Šé…ç½®',
    },
  },
} as const;

// === å®¹é‡è§„åˆ’éªŒè¯å’Œè°ƒä¼˜ ===
export const CAPACITY_VALIDATION_CONFIG = {
  // å®¹é‡æµ‹è¯•åœºæ™¯
  loadTestingScenarios: [
    {
      name: 'normal_gameplay',
      description: 'æ­£å¸¸æ¸¸æˆåœºæ™¯è´Ÿè½½æµ‹è¯•',
      duration: '30min',
      userActions: 'typical_player_behavior',
      expectedMetrics: {
        avgFPS: '>= 60',
        memoryUsage: '< 400MB',
        cpuUsage: '< 15%',
      },
    },
    {
      name: 'peak_event_processing',
      description: 'å³°å€¼äº‹ä»¶å¤„ç†è´Ÿè½½æµ‹è¯•',
      duration: '10min',
      eventRate: '200 evt/s',
      expectedMetrics: {
        avgFPS: '>= 58',
        eventLatency: '< 100ms',
        memoryUsage: '< 500MB',
      },
    },
    {
      name: 'extended_session',
      description: 'é•¿æ—¶é—´æ¸¸æˆä¼šè¯æµ‹è¯•',
      duration: '4h',
      userActions: 'continuous_play',
      expectedMetrics: {
        memoryGrowth: '< 50MB/h',
        fpsStability: '> 95%',
        noMemoryLeaks: true,
      },
    },
  ],

  // å®¹é‡è§„åˆ’è°ƒä¼˜ç­–ç•¥
  tuningStrategy: {
    // è‡ªåŠ¨è°ƒä¼˜å‚æ•°
    autoTuning: {
      enabled: true,
      parameters: [
        'event_batch_size', // äº‹ä»¶æ‰¹å¤„ç†å¤§å°
        'ai_decision_frequency', // AIå†³ç­–é¢‘ç‡
        'cache_sizes', // ç¼“å­˜å¤§å°
        'garbage_collection_thresholds', // GCé˜ˆå€¼
      ],
      optimizationGoal: 'balanced', // å¹³è¡¡æ€§èƒ½å’Œèµ„æºä½¿ç”¨
      description: 'è‡ªåŠ¨å®¹é‡å‚æ•°è°ƒä¼˜',
    },

    // æ‰‹åŠ¨è°ƒä¼˜æŒ‡å—
    manualTuning: {
      performanceTuning: [
        'å¢åŠ äº‹ä»¶æ‰¹å¤„ç†å¤§å°ä»¥å‡å°‘å¤„ç†å¼€é”€',
        'è°ƒæ•´AIå†³ç­–é¢‘ç‡ä»¥å¹³è¡¡æ™ºèƒ½æ€§å’Œæ€§èƒ½',
        'ä¼˜åŒ–çº¹ç†å’Œèµ„æºåŠ è½½ç­–ç•¥',
        'è°ƒæ•´å†…å­˜ç®¡ç†å’ŒGCç­–ç•¥',
      ],
      resourceTuning: [
        'æ ¹æ®ç›®æ ‡ç¡¬ä»¶è°ƒæ•´èµ„æºé¢„ç®—',
        'ä¼˜åŒ–å†…å­˜åˆ†é…æ¨¡å¼',
        'è°ƒæ•´CPUçº¿ç¨‹åˆ†é…ç­–ç•¥',
        'ä¼˜åŒ–ç£ç›˜I/Oè®¿é—®æ¨¡å¼',
      ],
      description: 'æ‰‹åŠ¨å®¹é‡è°ƒä¼˜æŒ‡å¯¼',
    },
  },
} as const;
```

> **å®é™…åŸºçº¿æ ¡å‡†**ï¼šä¸Šè¿°æ‰€æœ‰å®¹é‡å‡è®¾å°†åœ¨ç¬¬09ç« åŸºå‡†è„šæœ¬ä¸­è¿›è¡Œç²¾ç¡®æ ¡å‡†ï¼Œå›å½’é˜ˆå€¼å°†å†™å…¥CI/CDç®¡é“è¿›è¡ŒæŒç»­éªŒè¯ã€‚

---

## å…­ã€SLOè´¨é‡é—¨ç¦æ˜ å°„ç³»ç»Ÿï¼ˆEnterprise-Grade Quality Gatesï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šå»ºç«‹åŸºäºSLI/SLOçš„è‡ªåŠ¨åŒ–è´¨é‡é—¨ç¦ç³»ç»Ÿï¼Œé€šè¿‡è¯¯å·®é¢„ç®—ç®¡ç†å’Œå¤šå±‚æ¬¡æ£€æµ‹æœºåˆ¶ï¼Œç¡®ä¿ã€Šå…¬ä¼šç»ç†ã€‹åœ¨å‘å¸ƒè¿‡ç¨‹ä¸­çš„è´¨é‡ç¨³å®šæ€§ã€‚

### 6.1 SLI/SLOè®¡ç®—æ¡†æ¶ä¸è¯¯å·®é¢„ç®—ç®¡ç†

#### 6.1.1 æ ¸å¿ƒSLIæŒ‡æ ‡å®šä¹‰

```typescript
// src/shared/quality/sli-definitions.ts - æœåŠ¡ç­‰çº§æŒ‡æ ‡å®šä¹‰

// === å¯é æ€§SLIï¼ˆReliability SLIsï¼‰===
export interface ReliabilitySLI {
  // å´©æºƒå¥åº·åº¦
  crashFreeMetrics: {
    crashFreeSessions: {
      measurement: 'sessions_without_crashes / total_sessions';
      unit: 'percentage';
      samplingWindow: '24h' | '7d' | '30d';
      dataSource: 'sentry_sdk' | 'custom_telemetry';
      description: 'æ— å´©æºƒä¼šè¯å æ€»ä¼šè¯çš„ç™¾åˆ†æ¯”';
    };

    crashFreeUsers: {
      measurement: 'users_without_crashes / total_active_users';
      unit: 'percentage';
      samplingWindow: '7d' | '30d';
      dataSource: 'user_analytics';
      description: 'æ— å´©æºƒç”¨æˆ·å æ´»è·ƒç”¨æˆ·çš„ç™¾åˆ†æ¯”';
    };

    meanTimeBetweenFailures: {
      measurement: 'total_uptime / number_of_failures';
      unit: 'hours';
      samplingWindow: '30d';
      alertThreshold: '< 168h'; // ä½äº7å¤©MTBFå‘Šè­¦
      description: 'å¹³å‡æ•…éšœé—´éš”æ—¶é—´';
    };
  };

  // æ•°æ®å®Œæ•´æ€§
  dataIntegrityMetrics: {
    saveFileCorruption: {
      measurement: 'corrupted_saves / total_save_operations';
      unit: 'percentage';
      targetThreshold: '< 0.01%'; // 10ä¸‡æ¬¡æ“ä½œå°‘äº1æ¬¡æŸå
      samplingWindow: '7d';
      description: 'å­˜æ¡£æ–‡ä»¶æŸåç‡';
    };

    dataConsistency: {
      measurement: 'consistent_reads / total_reads';
      unit: 'percentage';
      targetThreshold: '>= 99.99%';
      samplingWindow: '24h';
      description: 'æ•°æ®è¯»å–ä¸€è‡´æ€§ç‡';
    };
  };
}

// === æ€§èƒ½SLIï¼ˆPerformance SLIsï¼‰===
export interface PerformanceSLI {
  // å“åº”æ—¶é—´æŒ‡æ ‡
  responseTimeMetrics: {
    uiInteractionLatency: {
      measurement: 'ui_response_time_percentile_95';
      unit: 'milliseconds';
      targetThreshold: '< 100ms';
      samplingMethod: 'sliding_window_5min';
      description: 'UIäº¤äº’å“åº”æ—¶é—´P95';
    };

    eventProcessingLatency: {
      measurement: 'event_processing_time_percentile_95';
      unit: 'milliseconds';
      targetThreshold: '< 200ms';
      samplingMethod: 'exponential_histogram';
      description: 'æ¸¸æˆäº‹ä»¶å¤„ç†å»¶è¿ŸP95';
    };

    aiDecisionLatency: {
      measurement: 'ai_decision_time_percentile_99';
      unit: 'milliseconds';
      targetThreshold: '< 500ms';
      samplingMethod: 'histogram_buckets';
      description: 'AIå†³ç­–å¤„ç†å»¶è¿ŸP99';
    };
  };

  // ååé‡æŒ‡æ ‡
  throughputMetrics: {
    eventThroughput: {
      measurement: 'events_processed_per_second';
      unit: 'events/second';
      targetThreshold: '>= 100 evt/s';
      samplingWindow: '5min';
      description: 'äº‹ä»¶å¤„ç†ååé‡';
    };

    frameRate: {
      measurement: 'frames_per_second_average';
      unit: 'fps';
      targetThreshold: '>= 58 fps'; // å…è®¸2å¸§é™çº§
      samplingWindow: '1min';
      description: 'å¹³å‡å¸§ç‡';
    };
  };
}

// === ç”¨æˆ·ä½“éªŒSLIï¼ˆUser Experience SLIsï¼‰===
export interface UserExperienceSLI {
  // å¯åŠ¨æ€§èƒ½
  startupPerformance: {
    coldStartTime: {
      measurement: 'app_ready_time_percentile_90';
      unit: 'milliseconds';
      targetThreshold: '< 8000ms'; // 8ç§’å†…å†·å¯åŠ¨
      samplingWindow: '24h';
      description: 'åº”ç”¨å†·å¯åŠ¨æ—¶é—´P90';
    };

    firstScreenRender: {
      measurement: 'first_meaningful_paint_percentile_90';
      unit: 'milliseconds';
      targetThreshold: '< 3000ms';
      samplingWindow: '1h';
      description: 'é¦–å±æ¸²æŸ“æ—¶é—´P90';
    };
  };

  // èµ„æºä½¿ç”¨æ•ˆç‡
  resourceEfficiency: {
    memoryUsage: {
      measurement: 'memory_usage_percentile_95';
      unit: 'megabytes';
      targetThreshold: '< 1500MB'; // 1.5GBå†…å­˜ä¸Šé™
      samplingWindow: '30min';
      description: 'å†…å­˜ä½¿ç”¨é‡P95';
    };

    cpuUtilization: {
      measurement: 'cpu_usage_percentile_90';
      unit: 'percentage';
      targetThreshold: '< 40%';
      samplingWindow: '5min';
      description: 'CPUä½¿ç”¨ç‡P90';
    };
  };
}
```

#### 6.1.2 SLOç›®æ ‡è®¾å®šä¸è¯¯å·®é¢„ç®—

```typescript
// === SLOç›®æ ‡é…ç½® ===
export interface SLODefinition {
  reliability: {
    // 99.5% ä¼šè¯æ— å´©æºƒï¼ˆæœˆåº¦ï¼‰
    crashFreeSessions: {
      target: 99.5;
      period: '30d';
      errorBudget: {
        allowedFailures: '0.5%'; // æ¯æœˆå…è®¸0.5%å´©æºƒä¼šè¯
        consumptionRate: 'sessions_with_crashes / total_sessions * 100';
        alertThresholds: {
          burnRateAlert: '> 2x normal'; // æ¶ˆè€—ç‡è¶…è¿‡æ­£å¸¸2å€
          budgetExhaustion: '< 10% remaining'; // é¢„ç®—å‰©ä½™ä¸è¶³10%
          recovery: '< 1x normal for 1h'; // æ¢å¤ï¼šæ­£å¸¸æ¶ˆè€—ç‡æŒç»­1å°æ—¶
        };
      };

      // å¿«é€Ÿçƒ§å½•æ£€æµ‹ï¼ˆFast Burn Alertï¼‰
      fastBurn: {
        window: '1h';
        threshold: '> 14.4x normal'; // 1å°æ—¶å†…æ¶ˆè€—è¶…è¿‡14.4å€æ­£å¸¸é¢„ç®—
        action: 'immediate_page_oncall';
        description: '1å°æ—¶å†…å°†æ¶ˆè€—æ•´æœˆè¯¯å·®é¢„ç®—æ—¶ç«‹å³å‘Šè­¦';
      };

      // æ…¢é€Ÿçƒ§å½•æ£€æµ‹ï¼ˆSlow Burn Alertï¼‰
      slowBurn: {
        window: '6h';
        threshold: '> 6x normal'; // 6å°æ—¶å†…æ¶ˆè€—è¶…è¿‡6å€æ­£å¸¸é¢„ç®—
        action: 'page_oncall_if_no_ack';
        description: '6å°æ—¶å†…æŒ‰å½“å‰é€Ÿåº¦å°†åœ¨5å¤©å†…è€—å°½é¢„ç®—æ—¶å‘Šè­¦';
      };
    };

    // 99.9% æ•°æ®æ“ä½œæˆåŠŸï¼ˆæ—¥åº¦ï¼‰
    dataIntegrity: {
      target: 99.9;
      period: '24h';
      errorBudget: {
        allowedFailures: '0.1%';
        consumptionRate: 'failed_operations / total_operations * 100';
        alertThresholds: {
          burnRateAlert: '> 3x normal';
          budgetExhaustion: '< 5% remaining';
          recovery: '< 0.5x normal for 2h';
        };
      };
    };
  };

  performance: {
    // 95% UIå“åº”æ—¶é—´ < 100msï¼ˆ5åˆ†é’Ÿçª—å£ï¼‰
    uiResponsiveness: {
      target: 95;
      measurement: 'requests_faster_than_100ms / total_ui_requests * 100';
      period: '5min';
      errorBudget: {
        allowedSlowRequests: '5%';
        consumptionRate: 'slow_requests / total_requests * 100';
        alertThresholds: {
          burnRateAlert: '> 5x normal';
          budgetExhaustion: '< 20% remaining';
        };
      };
    };

    // 90% äº‹ä»¶å¤„ç† < 200msï¼ˆ1åˆ†é’Ÿçª—å£ï¼‰
    eventProcessing: {
      target: 90;
      measurement: 'events_processed_under_200ms / total_events * 100';
      period: '1min';
      errorBudget: {
        allowedSlowEvents: '10%';
        consumptionRate: 'slow_events / total_events * 100';
      };
    };
  };
}

// === è¯¯å·®é¢„ç®—è®¡ç®—å¼•æ“ ===
export class ErrorBudgetCalculator {
  /**
   * è®¡ç®—å½“å‰è¯¯å·®é¢„ç®—æ¶ˆè€—ç‡
   */
  calculateBurnRate(
    sloTarget: number,
    currentSuccessRate: number,
    timeWindow: string
  ): number {
    const errorRate = 1 - currentSuccessRate / 100;
    const allowedErrorRate = 1 - sloTarget / 100;
    return errorRate / allowedErrorRate;
  }

  /**
   * é¢„æµ‹é¢„ç®—è€—å°½æ—¶é—´
   */
  predictBudgetExhaustion(
    currentBurnRate: number,
    remainingBudget: number,
    period: string
  ): {
    exhaustionTime: string;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
  } {
    const periodHours = this.convertPeriodToHours(period);
    const hoursToExhaustion = (remainingBudget / currentBurnRate) * periodHours;

    let riskLevel: 'low' | 'medium' | 'high' | 'critical';
    if (hoursToExhaustion > periodHours * 0.5) riskLevel = 'low';
    else if (hoursToExhaustion > periodHours * 0.2) riskLevel = 'medium';
    else if (hoursToExhaustion > periodHours * 0.05) riskLevel = 'high';
    else riskLevel = 'critical';

    return {
      exhaustionTime: `${Math.round(hoursToExhaustion)}h`,
      riskLevel,
    };
  }

  private convertPeriodToHours(period: string): number {
    if (period.endsWith('h')) return parseInt(period);
    if (period.endsWith('d')) return parseInt(period) * 24;
    if (period.endsWith('w')) return parseInt(period) * 24 * 7;
    throw new Error(`Unsupported period format: ${period}`);
  }
}
```

### 6.2 Crash-free Sessionsä¸Release Healthç›‘æ§

#### 6.2.1 å´©æºƒå¥åº·åº¦ç›‘æ§å®ç°

```typescript
// src/shared/quality/crash-monitoring.ts - å´©æºƒç›‘æ§ç³»ç»Ÿ

export interface CrashFreeSessionsConfig {
  // Sentry SDK é›†æˆé…ç½®
  sentryIntegration: {
    dsn: string,
    environment: 'development' | 'staging' | 'production',
    release: string,
    sessionTracking: true,
    autoSessionTracking: true,

    // ä¼šè¯ç”Ÿå‘½å‘¨æœŸå®šä¹‰
    sessionDefinition: {
      minimumSessionDuration: 30, // æœ€å°ä¼šè¯æ—¶é•¿ï¼ˆç§’ï¼‰
      sessionTimeoutThreshold: 30 * 60, // 30åˆ†é’Ÿæ— æ´»åŠ¨ç®—ä½œä¼šè¯ç»“æŸ
      crashTimeoutThreshold: 10, // å´©æºƒå10ç§’ç®—ä½œä¼šè¯å¼‚å¸¸ç»“æŸ
      description: 'ä¼šè¯è¾¹ç•Œå®šä¹‰å’Œå´©æºƒæ£€æµ‹è§„åˆ™'
    },

    // é‡‡æ ·å’Œè¿‡æ»¤ç­–ç•¥
    samplingConfig: {
      sampleRate: 1.0, // 100% é‡‡æ ·ç”Ÿäº§ç¯å¢ƒå´©æºƒ
      tracesSampleRate: 0.1, // 10% æ€§èƒ½è¿½è¸ªé‡‡æ ·
      profilesSampleRate: 0.1, // 10% æ€§èƒ½åˆ†æé‡‡æ ·
      beforeSend: 'filterNonCriticalErrors', // è¿‡æ»¤éå…³é”®é”™è¯¯
      description: 'æ•°æ®é‡‡æ ·å’Œå™ªéŸ³è¿‡æ»¤é…ç½®'
    }
  },

  // è‡ªå®šä¹‰ä¼šè¯è¿½è¸ª
  customSessionTracking: {
    sessionEvents: {
      gameStart: 'app_launch_complete',
      gameEnd: 'app_close_intentional',
      gameCrash: 'unhandled_exception',
      gameBackground: 'app_minimize',
      gameForeground: 'app_restore'
    },

    healthMetrics: {
      // å¥åº·ä¼šè¯å®šä¹‰æ ‡å‡†
      healthySession: {
        criteria: [
          'no_crashes',
          'no_unhandled_exceptions',
          'proper_app_shutdown',
          'memory_usage_under_threshold',
          'no_critical_ui_errors'
        ],
        minDuration: 60, // æœ€å°‘1åˆ†é’Ÿæ‰ç®—æœ‰æ•ˆä¼šè¯
        description: 'å¥åº·ä¼šè¯çš„åˆ¤å®šæ ‡å‡†'
      },

      // å¼‚å¸¸ä¼šè¯åˆ†ç±»
      unhealthySessionTypes: {
        hardCrash: 'åº”ç”¨è¿›ç¨‹æ„å¤–ç»ˆæ­¢',
        softCrash: 'æ•è·çš„è‡´å‘½å¼‚å¸¸ä½†åº”ç”¨ç»§ç»­è¿è¡Œ',
        oom: 'å†…å­˜ä¸è¶³å¯¼è‡´çš„ç»ˆæ­¢',
        anr: 'åº”ç”¨æ— å“åº”ï¼ˆè¶…è¿‡5ç§’ï¼‰',
        corruptedState: 'æ•°æ®çŠ¶æ€æŸåå¯¼è‡´çš„å¼‚å¸¸é€€å‡º'
      }
    }
  }
}

// === Release Health ç®¡ç†ç³»ç»Ÿ ===
export interface ReleaseHealthManager {
  // å‘å¸ƒå¥åº·åº¦æŒ‡æ ‡è®¡ç®—
  healthCalculations: {
    // Crash-free Sessions è®¡ç®—
    calculateCrashFreeSessions: (
      totalSessions: number,
      crashedSessions: number,
      timeWindow: string
    ) => {
      crashFreeRate: number,
      errorBudgetConsumption: number,
      trend: 'improving' | 'degrading' | 'stable',
      confidence: number // ç»Ÿè®¡ç½®ä¿¡åº¦
    },

    // Crash-free Users è®¡ç®—
    calculateCrashFreeUsers: (
      totalActiveUsers: number,
      usersExperiencingCrashes: number,
      timeWindow: string
    ) => {
      crashFreeUserRate: number,
      affectedUserPercentage: number,
      severityDistribution: Record<string, number>
    },

    // ç‰ˆæœ¬é—´å¥åº·åº¦å¯¹æ¯”
    compareReleaseHealth: (
      currentVersion: string,
      previousVersion: string,
      comparisonWindow: string
    ) => {
      healthImprovement: number, // ç™¾åˆ†æ¯”å˜åŒ–
      significantChanges: string[], // æ˜¾è‘—å˜åŒ–åˆ—è¡¨
      regressionRisk: 'low' | 'medium' | 'high',
      recommendedActions: string[]
    }
  },

  // å®æ—¶å¥åº·åº¦ç›‘æ§
  realtimeHealthMonitoring: {
    // æ»‘åŠ¨çª—å£ç›‘æ§
    slidingWindowMetrics: {
      windowSizes: ['5min', '1h', '6h', '24h'],
      updateFrequency: '30s',
      alertConditions: {
        crashRateSpike: '> 3x baseline in 5min window',
        steadyDegradation: '> 2x baseline sustained for 1h',
        budgetExhaustion: 'projected budget depletion < 24h'
      }
    },

    // å¼‚å¸¸æ£€æµ‹ç®—æ³•
    anomalyDetection: {
      algorithm: 'exponential_smoothing',
      sensitivity: 'medium', // low | medium | high
      minimumSampleSize: 100, // æœ€å°‘æ ·æœ¬é‡
      seasonalityAdjustment: true, // è€ƒè™‘æ—¶é—´å­£èŠ‚æ€§
      description: 'åŸºäºå†å²æ•°æ®çš„å¼‚å¸¸æ¨¡å¼æ£€æµ‹'
    }
  },

  // è‡ªåŠ¨åŒ–å“åº”æœºåˆ¶
  automatedResponseSystem: {
    // å´©æºƒç‡æ¿€å¢å“åº”
    crashSpikeResponse: {
      trigger: 'crash_rate > 3x baseline for 5min',
      immediateActions: [
        'disable_feature_flags', // ç¦ç”¨åŠŸèƒ½å¼€å…³
        'rollback_to_last_healthy_version', // å›æ»šåˆ°å¥åº·ç‰ˆæœ¬
        'alert_oncall_engineer', // é€šçŸ¥å€¼ç­å·¥ç¨‹å¸ˆ
        'create_incident_ticket' // åˆ›å»ºæ•…éšœå·¥å•
      ],
      escalation: {
        level1: '5min - è‡ªåŠ¨ç¼“è§£æªæ–½',
        level2: '15min - å·¥ç¨‹å¸ˆä»‹å…¥',
        level3: '30min - ç®¡ç†å±‚é€šçŸ¥',
        level4: '60min - ç´§æ€¥å‘å¸ƒä¿®å¤'
      }
    },

    // ç‰ˆæœ¬å¥åº·åº¦é—¨ç¦
    releaseHealthGates: {
      preReleaseGates: {
        minimumTestingSessions: 1000, // è‡³å°‘1000æ¬¡æµ‹è¯•ä¼šè¯
        requiredCrashFreeRate: 99.5, // è¦æ±‚99.5%æ— å´©æºƒç‡
        maximumRegressionThreshold: 0.1, // æœ€å¤§0.1%å›å½’å®¹å¿åº¦
        testingDurationHours: 48 // è‡³å°‘48å°æ—¶ç¨³å®šæ€§æµ‹è¯•
      },

      postReleaseGates: {
        monitoringDuration: '72h', // å‘å¸ƒå72å°æ—¶ç›‘æ§
        rollbackTriggers: [
          'crash_free_rate < 99.0%',
          'crash_rate > 5x previous_version',
          'user_reported_critical_issues > 10'
        ]
      }
    }
  }
}

// === å¥åº·åº¦æŠ¥å‘Šç”Ÿæˆå™¨ ===
export class ReleaseHealthReporter {
  /**
   * ç”Ÿæˆå‘å¸ƒå¥åº·åº¦æŠ¥å‘Š
   */
  generateHealthReport(
    version: string,
    timeRange: { start: Date; end: Date }
  ): ReleaseHealthReport {
    return {
      version,
      reportPeriod: timeRange,
      overallHealth: {
        crashFreeSessions: this.calculateCrashFreeSessions(version, timeRange),
        crashFreeUsers: this.calculateCrashFreeUsers(version, timeRange),
        errorBudgetStatus: this.calculateErrorBudgetStatus(version, timeRange),
        trendAnalysis: this.analyzeTrends(version, timeRange)
      },

      detailedMetrics: {
        sessionAnalysis: {
          totalSessions: 0,
          healthySessions: 0,
          crashedSessions: 0,
          sessionDurationDistribution: {},
          crashTypeBreakdown: {}
        },

        userImpactAnalysis: {
          totalActiveUsers: 0,
          affectedUsers: 0,
          severityByUser: {},
          geographicDistribution: {}
        }
      },

      anomalyDetection: {
        detectedAnomalies: [],
        confidenceScores: {},
        recommendedInvestigations: []
      },

      actionableInsights: {
        immediateConcerns: [],
        improvementOpportunities: [],
        preventiveRecommendations: []
      }
    };
  }

  /**
   * å®æ—¶å¥åº·åº¦ä»ªè¡¨ç›˜æ•°æ®
   */
  getLiveHealthDashboard(): LiveHealthDashboard {
    return {
      currentStatus: {
        overallHealthScore: this.calculateOverallHealthScore(),
        activeIncidents: this.getActiveIncidents(),
        errorBudgetRemaining: this.getCurrentErrorBudget(),
        alertLevel: this.getCurrentAlertLevel()
      },

      realTimeCharts: {
        crashRateTimeline: this.getCrashRateTimeline(),
        sessionHealthTrend: this.getSessionHealthTrend(),
        userImpactMetrics: this.getUserImpactMetrics(),
        errorBudgetBurndown: this.getErrorBudgetBurndown()
      },

      quickActions: [
        { label: 'å¯åŠ¨åº”æ€¥å“åº”', action: 'trigger_incident_response' },
        { label: 'å›æ»šè‡³ä¸Šä¸ªç‰ˆæœ¬', action: 'initiate_rollback' },
        { label: 'ç¦ç”¨é«˜é£é™©åŠŸèƒ½', action: 'disable_risky_features' },
        { label: 'é€šçŸ¥å€¼ç­å›¢é˜Ÿ', action: 'alert_oncall_team' }
      ]
    };
  }
}

interface ReleaseHealthReport {
  version: string;
  reportPeriod: { start: Date; end: Date };
  overallHealth: {
    crashFreeSessions: number;
    crashFreeUsers: number;
    errorBudgetStatus: {
      consumed: number;
      remaining: number;
      projectedExhaustion: string;
    };
    trendAnalysis: {
      direction: 'improving' | 'stable' | 'degrading';
      confidence: number;
      keyInfluencers: string[];
    };
  };
  detailedMetrics: any;
  anomalyDetection: any;
  actionableInsights: any;
}

interface LiveHealthDashboard {
  currentStatus: any;
  realTimeCharts: any;
  quickActions: Array<{ label: string; action: string; }>;
}
```

### 6.3 TP95åŸºå‡†è„šæœ¬ä¸æ€§èƒ½è‡ªåŠ¨æ£€æµ‹

#### 6.3.1 æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶

```typescript
// src/shared/quality/performance-benchmarks.ts - æ€§èƒ½åŸºå‡†æµ‹è¯•ç³»ç»Ÿ

export interface PerformanceBenchmarkConfig {
  // åŸºå‡†æµ‹è¯•åœºæ™¯å®šä¹‰
  benchmarkScenarios: {
    uiResponsivenessTest: {
      name: 'UIäº¤äº’å“åº”æ—¶é—´åŸºå‡†æµ‹è¯•';
      description: 'æµ‹è¯•å„ç±»UIäº¤äº’çš„å“åº”å»¶è¿Ÿï¼Œç¡®ä¿æ»¡è¶³ç”¨æˆ·ä½“éªŒæ ‡å‡†';
      testCases: [
        {
          scenario: 'button_click_response';
          action: 'simulate_button_clicks';
          targetMetric: 'time_to_visual_feedback';
          expectedTP95: 50; // æ¯«ç§’
          sampleSize: 1000;
          description: 'æŒ‰é’®ç‚¹å‡»åˆ°è§†è§‰åé¦ˆçš„æ—¶é—´';
        },
        {
          scenario: 'modal_dialog_open';
          action: 'open_complex_modal_dialog';
          targetMetric: 'render_complete_time';
          expectedTP95: 100;
          sampleSize: 500;
          description: 'å¤æ‚å¯¹è¯æ¡†å®Œå…¨æ¸²æŸ“æ—¶é—´';
        },
        {
          scenario: 'data_table_sort';
          action: 'sort_large_data_table';
          targetMetric: 'sort_and_rerender_time';
          expectedTP95: 200;
          sampleSize: 200;
          description: 'å¤§å‹æ•°æ®è¡¨æ ¼æ’åºå¹¶é‡æ¸²æŸ“æ—¶é—´';
        },
        {
          scenario: 'navigation_transition';
          action: 'navigate_between_main_views';
          targetMetric: 'route_transition_time';
          expectedTP95: 150;
          sampleSize: 300;
          description: 'ä¸»è¦è§†å›¾é—´å¯¼èˆªè½¬åœºæ—¶é—´';
        },
      ];
    };

    gameLogicPerformanceTest: {
      name: 'æ¸¸æˆé€»è¾‘å¤„ç†æ€§èƒ½åŸºå‡†æµ‹è¯•';
      description: 'æµ‹è¯•æ ¸å¿ƒæ¸¸æˆé€»è¾‘çš„å¤„ç†æ€§èƒ½ï¼Œç¡®ä¿å¤æ‚è®¡ç®—ä¸å½±å“ç”¨æˆ·ä½“éªŒ';
      testCases: [
        {
          scenario: 'event_processing_single';
          action: 'process_single_complex_event';
          targetMetric: 'event_execution_time';
          expectedTP95: 150;
          sampleSize: 2000;
          description: 'å•ä¸ªå¤æ‚äº‹ä»¶å¤„ç†æ—¶é—´';
        },
        {
          scenario: 'event_processing_batch';
          action: 'process_event_batch_10';
          targetMetric: 'batch_execution_time';
          expectedTP95: 800;
          sampleSize: 500;
          description: '10ä¸ªäº‹ä»¶æ‰¹é‡å¤„ç†æ—¶é—´';
        },
        {
          scenario: 'ai_decision_making';
          action: 'ai_make_complex_decision';
          targetMetric: 'decision_calculation_time';
          expectedTP95: 300;
          sampleSize: 1000;
          description: 'AIå¤æ‚å†³ç­–è®¡ç®—æ—¶é—´';
        },
        {
          scenario: 'data_aggregation';
          action: 'calculate_guild_statistics';
          targetMetric: 'aggregation_complete_time';
          expectedTP95: 500;
          sampleSize: 200;
          description: 'å…¬ä¼šæ•°æ®ç»Ÿè®¡èšåˆæ—¶é—´';
        },
      ];
    };

    memoryUsageTest: {
      name: 'å†…å­˜ä½¿ç”¨æ•ˆç‡åŸºå‡†æµ‹è¯•';
      description: 'æµ‹è¯•å„ç§åœºæ™¯ä¸‹çš„å†…å­˜ä½¿ç”¨æ¨¡å¼ï¼Œæ£€æµ‹å†…å­˜æ³„æ¼å’Œä½¿ç”¨å³°å€¼';
      testCases: [
        {
          scenario: 'baseline_memory_usage';
          action: 'idle_application_state';
          targetMetric: 'memory_footprint_mb';
          expectedThreshold: 200; // MB
          sampleDuration: '5min';
          description: 'åº”ç”¨ç©ºé—²çŠ¶æ€åŸºç¡€å†…å­˜å ç”¨';
        },
        {
          scenario: 'memory_under_load';
          action: 'simulate_intensive_gameplay';
          targetMetric: 'peak_memory_usage_mb';
          expectedThreshold: 800;
          sampleDuration: '30min';
          description: 'é«˜å¼ºåº¦æ¸¸æˆåœºæ™¯ä¸‹çš„å³°å€¼å†…å­˜ä½¿ç”¨';
        },
        {
          scenario: 'memory_leak_detection';
          action: 'repeated_operations_cycle';
          targetMetric: 'memory_growth_rate_mb_per_hour';
          expectedThreshold: 10; // æ¯å°æ—¶å¢é•¿ä¸è¶…è¿‡10MB
          sampleDuration: '2h';
          description: 'é•¿æ—¶é—´è¿è¡Œçš„å†…å­˜æ³„æ¼æ£€æµ‹';
        },
      ];
    };
  };

  // åŸºå‡†æµ‹è¯•æ‰§è¡Œé…ç½®
  executionConfig: {
    // æµ‹è¯•ç¯å¢ƒæ ‡å‡†åŒ–
    environmentSetup: {
      systemRequirements: {
        minimumRAM: '4GB';
        recommendedRAM: '8GB';
        cpuCores: '>=4';
        storageType: 'SSD_preferred';
        description: 'åŸºå‡†æµ‹è¯•ç¯å¢ƒè¦æ±‚';
      };

      applicationState: {
        cleanStart: true; // æ¯æ¬¡æµ‹è¯•ä»å¹²å‡€çŠ¶æ€å¼€å§‹
        preloadAssets: false; // ä¸é¢„åŠ è½½èµ„æºï¼Œæµ‹è¯•å®é™…åŠ è½½æ€§èƒ½
        disableAnimations: false; // ä¿æŒåŠ¨ç”»ä»¥æµ‹è¯•çœŸå®åœºæ™¯
        mockExternalAPIs: true; // æ¨¡æ‹Ÿå¤–éƒ¨APIä»¥éš”ç¦»ç½‘ç»œå½±å“
        description: 'åº”ç”¨åˆå§‹çŠ¶æ€æ ‡å‡†åŒ–';
      };

      measurementPrecision: {
        timingMethod: 'performance.now()'; // é«˜ç²¾åº¦æ—¶é—´æµ‹é‡
        measurementInterval: '1ms'; // 1æ¯«ç§’æµ‹é‡é—´éš”
        warmupIterations: 10; // é¢„çƒ­è¿­ä»£æ¬¡æ•°
        statisticalSamples: 'auto_sufficient_sample_size'; // è‡ªåŠ¨è®¡ç®—è¶³å¤Ÿæ ·æœ¬é‡
        description: 'æµ‹é‡ç²¾åº¦å’Œç»Ÿè®¡æœ‰æ•ˆæ€§ä¿éšœ';
      };
    };

    // è‡ªåŠ¨åŒ–æµ‹è¯•è°ƒåº¦
    schedulingConfig: {
      triggerConditions: [
        'pre_commit_hooks', // Gitæäº¤å‰è§¦å‘
        'nightly_builds', // æ¯æ™šæ„å»ºæ—¶è§¦å‘
        'release_candidate_validation', // å‘å¸ƒå€™é€‰ç‰ˆæœ¬éªŒè¯
        'performance_regression_investigation', // æ€§èƒ½å›å½’è°ƒæŸ¥æ—¶æ‰‹åŠ¨è§¦å‘
      ];

      parallelExecution: {
        maxConcurrentTests: 4; // æœ€å¤§å¹¶å‘æµ‹è¯•æ•°
        resourceIsolation: true; // èµ„æºéš”ç¦»ç¡®ä¿æµ‹è¯•å‡†ç¡®æ€§
        failFastOnRegressions: true; // æ£€æµ‹åˆ°å›å½’æ—¶å¿«é€Ÿå¤±è´¥
        description: 'å¹¶è¡Œæ‰§è¡Œå’Œèµ„æºç®¡ç†';
      };

      reportGeneration: {
        realTimeUpdates: true; // å®æ—¶æ›´æ–°æµ‹è¯•è¿›åº¦
        detailedBreakdown: true; // è¯¦ç»†çš„æ€§èƒ½åˆ†è§£åˆ†æ
        historicalComparison: true; // ä¸å†å²åŸºå‡†å¯¹æ¯”
        regressionAnalysis: true; // è‡ªåŠ¨å›å½’åˆ†æ
        exportFormats: ['json', 'html', 'csv']; // å¤šç§å¯¼å‡ºæ ¼å¼
        description: 'æµ‹è¯•æŠ¥å‘Šç”Ÿæˆé…ç½®';
      };
    };
  };
}

// === æ€§èƒ½åŸºå‡†æµ‹è¯•æ‰§è¡Œå¼•æ“ ===
export class PerformanceBenchmarkEngine {
  private config: PerformanceBenchmarkConfig;
  private historian: PerformanceHistorian;
  private alertSystem: PerformanceAlertSystem;

  constructor(config: PerformanceBenchmarkConfig) {
    this.config = config;
    this.historian = new PerformanceHistorian();
    this.alertSystem = new PerformanceAlertSystem();
  }

  /**
   * æ‰§è¡Œå®Œæ•´çš„åŸºå‡†æµ‹è¯•å¥—ä»¶
   */
  async runBenchmarkSuite(
    suiteType: 'full' | 'smoke' | 'regression' = 'full'
  ): Promise<BenchmarkSuiteResults> {
    const startTime = performance.now();
    const results: BenchmarkSuiteResults = {
      suiteType,
      executionMetadata: {
        startTime: new Date(),
        environment: await this.captureEnvironmentInfo(),
        gitCommit: await this.getGitCommitHash(),
        buildVersion: process.env.BUILD_VERSION || 'unknown',
      },
      testResults: new Map(),
      overallSummary: {
        totalTests: 0,
        passedTests: 0,
        failedTests: 0,
        regressions: [],
        improvements: [],
        executionTimeMs: 0,
      },
    };

    try {
      // æ‰§è¡ŒUIå“åº”æ€§æµ‹è¯•
      if (suiteType === 'full' || suiteType === 'smoke') {
        const uiResults = await this.executeUIResponsivenessTests();
        results.testResults.set('ui_responsiveness', uiResults);
        this.analyzeForRegressions(uiResults, results.overallSummary);
      }

      // æ‰§è¡Œæ¸¸æˆé€»è¾‘æ€§èƒ½æµ‹è¯•
      if (suiteType === 'full') {
        const gameLogicResults = await this.executeGameLogicTests();
        results.testResults.set('game_logic', gameLogicResults);
        this.analyzeForRegressions(gameLogicResults, results.overallSummary);
      }

      // æ‰§è¡Œå†…å­˜ä½¿ç”¨æµ‹è¯•
      if (suiteType === 'full') {
        const memoryResults = await this.executeMemoryUsageTests();
        results.testResults.set('memory_usage', memoryResults);
        this.analyzeForRegressions(memoryResults, results.overallSummary);
      }

      // è®¡ç®—æ€»æ‰§è¡Œæ—¶é—´
      results.overallSummary.executionTimeMs = performance.now() - startTime;

      // å­˜å‚¨å†å²æ•°æ®
      await this.historian.recordBenchmarkResults(results);

      // æ£€æŸ¥å›å½’å¹¶å‘é€å‘Šè­¦
      await this.checkAndAlertOnRegressions(results);

      return results;
    } catch (error) {
      console.error('Benchmark suite execution failed:', error);
      throw error;
    }
  }

  /**
   * æ‰§è¡Œç‰¹å®šåœºæ™¯çš„åŸºå‡†æµ‹è¯•
   */
  async executeBenchmarkScenario(
    scenario: string,
    iterations: number = 1000
  ): Promise<ScenarioResults> {
    const measurements: number[] = [];

    // é¢„çƒ­é˜¶æ®µ
    await this.warmupPhase(scenario, 10);

    // å®é™…æµ‹é‡é˜¶æ®µ
    for (let i = 0; i < iterations; i++) {
      const startTime = performance.now();
      await this.executeScenarioOnce(scenario);
      const duration = performance.now() - startTime;
      measurements.push(duration);

      // é¿å…è¿ç»­æµ‹è¯•å¯¼è‡´çš„ç³»ç»Ÿèµ„æºè€—å°½
      if (i % 100 === 0) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }

    return this.calculateStatistics(measurements, scenario);
  }

  /**
   * å®æ—¶æ€§èƒ½ç›‘æ§æ¨¡å¼
   */
  startRealtimeMonitoring(): RealtimePerformanceMonitor {
    return new RealtimePerformanceMonitor({
      samplingInterval: 1000, // æ¯ç§’é‡‡æ ·
      metricsToTrack: [
        'ui_response_time_p95',
        'event_processing_latency_p95',
        'memory_usage_current',
        'cpu_utilization_current',
        'frame_rate_average',
      ],
      alertThresholds: {
        ui_response_time_p95: 100, // æ¯«ç§’
        event_processing_latency_p95: 200,
        memory_usage_current: 1000, // MB
        cpu_utilization_current: 80, // ç™¾åˆ†æ¯”
        frame_rate_average: 55, // FPS
      },
      onThresholdExceeded: (metric, value, threshold) => {
        this.alertSystem.sendPerformanceAlert({
          metric,
          currentValue: value,
          threshold,
          severity: this.calculateAlertSeverity(metric, value, threshold),
          timestamp: new Date(),
          suggestedActions: this.getSuggestedActions(metric),
        });
      },
    });
  }

  // è¾…åŠ©æ–¹æ³•å®ç°
  private async warmupPhase(
    scenario: string,
    iterations: number
  ): Promise<void> {
    for (let i = 0; i < iterations; i++) {
      await this.executeScenarioOnce(scenario);
    }
  }

  private async executeScenarioOnce(scenario: string): Promise<void> {
    // æ ¹æ®åœºæ™¯åç§°æ‰§è¡Œç›¸åº”çš„æµ‹è¯•é€»è¾‘
    // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„æµ‹è¯•åœºæ™¯å®ç°å¯¹åº”çš„æµ‹è¯•ä»£ç 
    switch (scenario) {
      case 'button_click_response':
        return this.simulateButtonClickTest();
      case 'modal_dialog_open':
        return this.simulateModalDialogTest();
      // ... å…¶ä»–åœºæ™¯
    }
  }

  private calculateStatistics(
    measurements: number[],
    scenario: string
  ): ScenarioResults {
    const sorted = measurements.sort((a, b) => a - b);
    const length = sorted.length;

    return {
      scenario,
      sampleSize: length,
      statistics: {
        min: sorted[0],
        max: sorted[length - 1],
        mean: measurements.reduce((a, b) => a + b) / length,
        median: sorted[Math.floor(length / 2)],
        p95: sorted[Math.floor(length * 0.95)],
        p99: sorted[Math.floor(length * 0.99)],
        standardDeviation: this.calculateStandardDeviation(measurements),
      },
      timestamp: new Date(),
    };
  }

  private calculateStandardDeviation(values: number[]): number {
    const mean = values.reduce((a, b) => a + b) / values.length;
    const squaredDifferences = values.map(value => Math.pow(value - mean, 2));
    const avgSquaredDiff =
      squaredDifferences.reduce((a, b) => a + b) / values.length;
    return Math.sqrt(avgSquaredDiff);
  }
}

// ç›¸å…³æ¥å£å®šä¹‰
interface BenchmarkSuiteResults {
  suiteType: 'full' | 'smoke' | 'regression';
  executionMetadata: {
    startTime: Date;
    environment: any;
    gitCommit: string;
    buildVersion: string;
  };
  testResults: Map<string, any>;
  overallSummary: {
    totalTests: number;
    passedTests: number;
    failedTests: number;
    regressions: string[];
    improvements: string[];
    executionTimeMs: number;
  };
}

interface ScenarioResults {
  scenario: string;
  sampleSize: number;
  statistics: {
    min: number;
    max: number;
    mean: number;
    median: number;
    p95: number;
    p99: number;
    standardDeviation: number;
  };
  timestamp: Date;
}
```

### 6.4 å‘å¸ƒé—¨ç¦è‡ªåŠ¨åŒ–æ‰§è¡Œä¸è¦†ç›–ç‡æ£€æŸ¥

#### 6.4.1 è´¨é‡é—¨ç¦è‡ªåŠ¨åŒ–æµæ°´çº¿

```typescript
// src/shared/quality/automated-gates.ts - è‡ªåŠ¨åŒ–è´¨é‡é—¨ç¦ç³»ç»Ÿ

export interface QualityGateAutomation {
  // CI/CD é›†æˆé…ç½®
  cicdIntegration: {
    // GitHub Actions é›†æˆ
    githubActionsConfig: {
      workflowTriggers: [
        'pull_request', // PR è§¦å‘
        'push_to_main', // ä¸»åˆ†æ”¯æ¨é€è§¦å‘
        'release_candidate_tag', // å‘å¸ƒå€™é€‰æ ‡ç­¾è§¦å‘
        'scheduled_nightly' // æ¯æ™šå®šæ—¶è§¦å‘
      ],

      // é—¨ç¦æ£€æŸ¥å·¥ä½œæµ
      qualityGateSteps: {
        // ç¬¬ä¸€é˜¶æ®µï¼šå¿«é€Ÿæ£€æŸ¥ï¼ˆ< 5åˆ†é’Ÿï¼‰
        fastChecks: {
          duration: '< 5min',
          parallel: true,
          steps: [
            {
              name: 'lint_and_format_check',
              command: 'npm run lint:ci && npm run format:check',
              failFast: true,
              description: 'ä»£ç é£æ ¼å’Œæ ¼å¼æ£€æŸ¥'
            },
            {
              name: 'typescript_compilation',
              command: 'npm run type-check',
              failFast: true,
              description: 'TypeScript ç¼–è¯‘æ£€æŸ¥'
            },
            {
              name: 'unit_tests_smoke',
              command: 'npm run test:unit:smoke',
              failFast: false, // å…è®¸éƒ¨åˆ†å¤±è´¥ä»¥æ”¶é›†æ›´å¤šä¿¡æ¯
              description: 'æ ¸å¿ƒå•å…ƒæµ‹è¯•å¿«é€ŸéªŒè¯'
            }
          ]
        },

        // ç¬¬äºŒé˜¶æ®µï¼šå…¨é¢æµ‹è¯•ï¼ˆ< 15åˆ†é’Ÿï¼‰
        comprehensiveTests: {
          duration: '< 15min',
          parallel: true,
          dependsOn: ['fastChecks'],
          steps: [
            {
              name: 'full_unit_test_suite',
              command: 'npm run test:unit:coverage',
              coverageThreshold: 90,
              timeoutMinutes: 10,
              description: 'å®Œæ•´å•å…ƒæµ‹è¯•å¥—ä»¶ä¸è¦†ç›–ç‡'
            },
            {
              name: 'integration_tests',
              command: 'npm run test:integration',
              timeoutMinutes: 12,
              description: 'é›†æˆæµ‹è¯•éªŒè¯'
            },
            {
              name: 'performance_regression_check',
              command: 'npm run benchmark:regression',
              timeoutMinutes: 8,
              description: 'æ€§èƒ½å›å½’æ£€æµ‹'
            }
          ]
        },

        // ç¬¬ä¸‰é˜¶æ®µï¼šè´¨é‡é—¨ç¦éªŒè¯ï¼ˆ< 10åˆ†é’Ÿï¼‰
        qualityGateValidation: {
          duration: '< 10min',
          sequential: true, // æŒ‰é¡ºåºæ‰§è¡Œä»¥ä¾¿å¿«é€Ÿå¤±è´¥
          dependsOn: ['comprehensiveTests'],
          steps: [
            {
              name: 'coverage_gate_check',
              script: 'scripts/quality-gates/check-coverage.ts',
              threshold: 90,
              description: 'ä»£ç è¦†ç›–ç‡é—¨ç¦æ£€æŸ¥'
            },
            {
              name: 'performance_slo_validation',
              script: 'scripts/quality-gates/validate-performance-slo.ts',
              thresholds: {
                ui_response_p95: 100, // ms
                event_processing_p95: 200, // ms
                memory_usage_p95: 800 // MB
              },
              description: 'SLO æ€§èƒ½æŒ‡æ ‡éªŒè¯'
            },
            {
              name: 'release_health_prediction',
              script: 'scripts/quality-gates/predict-release-health.ts',
              minimumHealthScore: 95,
              description: 'å‘å¸ƒå¥åº·åº¦é¢„æµ‹éªŒè¯'
            }
          ]
        }
      }
    },

    // é—¨ç¦å†³ç­–çŸ©é˜µ
    gateDecisionMatrix: {
      // PR åˆå¹¶é—¨ç¦
      pullRequestGates: {
        required: [
          'lint_and_format_check',
          'typescript_compilation',
          'full_unit_test_suite',
          'coverage_gate_check'
        ],
        blocking: [
          'coverage_gate_check', // è¦†ç›–ç‡ä¸è¾¾æ ‡ç›´æ¥é˜»æ–­
          'typescript_compilation' // ç¼–è¯‘å¤±è´¥ç›´æ¥é˜»æ–­
        ],
        advisory: [
          'performance_regression_check', // æ€§èƒ½å›å½’ä»…è­¦å‘Š
          'integration_tests' // é›†æˆæµ‹è¯•å¤±è´¥ä»…è­¦å‘Š
        ],
        description: 'PRåˆå¹¶çš„è´¨é‡é—¨ç¦è¦æ±‚'
      },

      // ä¸»åˆ†æ”¯å‘å¸ƒé—¨ç¦
      mainBranchGates: {
        required: 'all_steps', // æ‰€æœ‰æ­¥éª¤éƒ½å¿…é¡»é€šè¿‡
        blocking: 'any_failure', // ä»»ä½•å¤±è´¥éƒ½é˜»æ–­å‘å¸ƒ
        rollbackTriggers: [
          'performance_slo_violation',
          'coverage_drop_significant',
          'health_score_below_threshold'
        ],
        description: 'ä¸»åˆ†æ”¯å‘å¸ƒçš„ä¸¥æ ¼è´¨é‡è¦æ±‚'
      },

      // å‘å¸ƒå€™é€‰é—¨ç¦
      releaseCandidateGates: {
        required: 'all_steps',
        additionalChecks: [
          'end_to_end_tests',
          'security_scan',
          'dependency_audit',
          'release_notes_validation'
        ],
        manualApproval: true, // éœ€è¦äººå·¥å®¡æ‰¹
        stakeholderNotification: true, // é€šçŸ¥ç›¸å…³å¹²ç³»äºº
        description: 'å‘å¸ƒå€™é€‰çš„æœ€ä¸¥æ ¼è´¨é‡è¦æ±‚'
      }
    }
  },

  // è¦†ç›–ç‡é—¨ç¦è¯¦ç»†é…ç½®
  coverageGateConfig: {
    // æ•´ä½“è¦†ç›–ç‡è¦æ±‚
    overallThresholds: {
      statements: 90, // è¯­å¥è¦†ç›–ç‡ >= 90%
      branches: 85, // åˆ†æ”¯è¦†ç›–ç‡ >= 85%
      functions: 95, // å‡½æ•°è¦†ç›–ç‡ >= 95%
      lines: 90, // è¡Œè¦†ç›–ç‡ >= 90%
      description: 'æ•´ä½“ä»£ç è¦†ç›–ç‡æœ€ä½è¦æ±‚'
    },

    // æ¨¡å—çº§åˆ«è¦†ç›–ç‡è¦æ±‚
    moduleSpecificThresholds: {
      'src/shared/events/': {
        statements: 95, // äº‹ä»¶ç³»ç»Ÿè¦æ±‚æ›´é«˜è¦†ç›–ç‡
        branches: 90,
        functions: 100, // æ‰€æœ‰å‡½æ•°å¿…é¡»æœ‰æµ‹è¯•
        lines: 95,
        rationale: 'æ ¸å¿ƒäº‹ä»¶ç³»ç»Ÿçš„é«˜è¦†ç›–ç‡è¦æ±‚'
      },

      'src/shared/ai/': {
        statements: 85, // AIç³»ç»Ÿå…è®¸ç•¥ä½è¦†ç›–ç‡ï¼ˆå› ä¸ºå¤æ‚æ€§ï¼‰
        branches: 80,
        functions: 90,
        lines: 85,
        rationale: 'AIç³»ç»Ÿå¤æ‚æ€§é«˜ï¼Œå…è®¸é€‚å½“é™ä½è¦†ç›–ç‡è¦æ±‚'
      },

      'src/ui/': {
        statements: 75, // UIç»„ä»¶å…è®¸æ›´ä½è¦†ç›–ç‡
        branches: 70,
        functions: 80,
        lines: 75,
        rationale: 'UIç»„ä»¶ä¸»è¦ä¾èµ–è§†è§‰æµ‹è¯•ï¼Œé™ä½å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¦æ±‚'
      }
    },

    // è¦†ç›–ç‡è¶‹åŠ¿ç›‘æ§
    trendMonitoring: {
      regressionThreshold: -5, // è¦†ç›–ç‡ä¸‹é™è¶…è¿‡5%è§†ä¸ºå›å½’
      improvementRecognition: +2, // è¦†ç›–ç‡æå‡è¶…è¿‡2%ç»™äºˆè®¤å¯
      trendAnalysisPeriod: '30d', // 30å¤©è¶‹åŠ¿åˆ†æ
      alertChannels: ['slack', 'email'],
      description: 'è¦†ç›–ç‡è¶‹åŠ¿ç›‘æ§å’Œå›å½’æ£€æµ‹'
    },

    // æœªè¦†ç›–ä»£ç åˆ†æ
    uncoveredCodeAnalysis: {
      priorityClassification: {
        critical: {
          paths: ['src/shared/events/', 'src/shared/data/'],
          action: 'block_release',
          description: 'å…³é”®è·¯å¾„æœªè¦†ç›–ä»£ç å¿…é¡»å¤„ç†'
        },
        high: {
          paths: ['src/shared/ai/', 'src/shared/utils/'],
          action: 'warn_and_track',
          description: 'é‡è¦è·¯å¾„æœªè¦†ç›–ä»£ç éœ€è¦è·Ÿè¸ª'
        },
        medium: {
          paths: ['src/ui/', 'src/components/'],
          action: 'track_only',
          description: 'UIè·¯å¾„æœªè¦†ç›–ä»£ç ä»…è·Ÿè¸ª'
        }
      },

      reportGeneration: {
        detailedUncoveredLines: true,
        complexityWeighting: true, // æŒ‰ä»£ç å¤æ‚åº¦åŠ æƒ
        riskAssessment: true, // é£é™©è¯„ä¼°
        improvementSuggestions: true, // æ”¹è¿›å»ºè®®
        description: 'æœªè¦†ç›–ä»£ç è¯¦ç»†åˆ†ææŠ¥å‘Š'
      }
    }
  }
}

// === è´¨é‡é—¨ç¦æ‰§è¡Œå¼•æ“ ===
export class QualityGateExecutor {
  private config: QualityGateAutomation;
  private notificationService: NotificationService;
  private metricsCollector: MetricsCollector;

  constructor(config: QualityGateAutomation) {
    this.config = config;
    this.notificationService = new NotificationService();
    this.metricsCollector = new MetricsCollector();
  }

  /**
   * æ‰§è¡Œè´¨é‡é—¨ç¦æ£€æŸ¥
   */
  async executeQualityGates(
    context: QualityGateContext
  ): Promise<QualityGateResults> {
    const startTime = performance.now();
    const results: QualityGateResults = {
      context,
      startTime: new Date(),
      stages: new Map(),
      overallResult: {
        passed: false,
        blockers: [],
        warnings: [],
        recommendations: []
      }
    };

    try {
      // ç¬¬ä¸€é˜¶æ®µï¼šå¿«é€Ÿæ£€æŸ¥
      console.log('ğŸš€ æ‰§è¡Œå¿«é€Ÿæ£€æŸ¥é˜¶æ®µ...');
      const fastCheckResults = await this.executeFastChecks(context);
      results.stages.set('fast_checks', fastCheckResults);

      if (fastCheckResults.hasBlockingFailures) {
        results.overallResult.blockers.push(...fastCheckResults.blockers);
        return await this.finalizeResults(results, 'fast_check_failure');
      }

      // ç¬¬äºŒé˜¶æ®µï¼šå…¨é¢æµ‹è¯•
      console.log('ğŸ§ª æ‰§è¡Œå…¨é¢æµ‹è¯•é˜¶æ®µ...');
      const comprehensiveResults = await this.executeComprehensiveTests(context);
      results.stages.set('comprehensive_tests', comprehensiveResults);

      // ç¬¬ä¸‰é˜¶æ®µï¼šè´¨é‡é—¨ç¦éªŒè¯
      console.log('âœ… æ‰§è¡Œè´¨é‡é—¨ç¦éªŒè¯...');
      const gateResults = await this.executeGateValidation(context, comprehensiveResults);
      results.stages.set('gate_validation', gateResults);

      // æ±‡æ€»æœ€ç»ˆç»“æœ
      results.overallResult = await this.calculateOverallResult(results);

      return await this.finalizeResults(results, 'completed');
    } catch (error) {
      console.error('Quality gate execution failed:', error);
      results.overallResult.blockers.push({
        type: 'execution_error',
        message: error.message,
        severity: 'critical'
      });
      return await this.finalizeResults(results, 'execution_error');
    }
  }

  /**
   * è¦†ç›–ç‡é—¨ç¦æ£€æŸ¥
   */
  async checkCoverageGate(coverageReport: CoverageReport): Promise<CoverageGateResult> {
    const thresholds = this.config.coverageGateConfig;
    const result: CoverageGateResult = {
      passed: true,
      overallCoverage: coverageReport.overall,
      violations: [],
      improvements: []
    };

    // æ£€æŸ¥æ•´ä½“è¦†ç›–ç‡
    const overallViolations = this.checkOverallCoverageThresholds(
      coverageReport.overall,
      thresholds.overallThresholds
    );
    result.violations.push(...overallViolations);

    // æ£€æŸ¥æ¨¡å—çº§è¦†ç›–ç‡
    for (const [modulePath, moduleThresholds] of Object.entries(thresholds.moduleSpecificThresholds)) {
      const moduleCoverage = coverageReport.modules[modulePath];
      if (moduleCoverage) {
        const moduleViolations = this.checkOverallCoverageThresholds(
          moduleCoverage,
          moduleThresholds
        );
        result.violations.push(...moduleViolations.map(v => ({
          ...v,
          module: modulePath
        })));
      }
    }

    // åˆ†æè¦†ç›–ç‡è¶‹åŠ¿
    const trendAnalysis = await this.analyzeCoverageTrend(coverageReport);
    if (trendAnalysis.isRegression) {
      result.violations.push({
        type: 'coverage_regression',
        message: `è¦†ç›–ç‡ä¸‹é™${trendAnalysis.regressionPercentage}%ï¼Œè¶…è¿‡${thresholds.trendMonitoring.regressionThreshold}%é˜ˆå€¼`,
        severity: 'high'
      });
    }

    result.passed = result.violations.length === 0;
    return result;
  }

  /**
   * ç”Ÿæˆè´¨é‡é—¨ç¦æŠ¥å‘Š
   */
  async generateGateReport(results: QualityGateResults): Promise<QualityGateReport> {
    return {
      executionSummary: {
        totalDuration: results.endTime.getTime() - results.startTime.getTime(),
        stagesExecuted: Array.from(results.stages.keys()),
        overallResult: results.overallResult.passed ? 'PASSED' : 'FAILED',
        blockingIssues: results.overallResult.blockers.length,
        warnings: results.overallResult.warnings.length
      },

      detailedResults: {
        coverageAnalysis: await this.generateCoverageAnalysis(results),
        performanceAnalysis: await this.generatePerformanceAnalysis(results),
        qualityMetrics: await this.generateQualityMetrics(results)
      },

      actionableRecommendations: await this.generateActionableRecommendations(results),

      historicalComparison: await this.generateHistoricalComparison(results),

      nextSteps: this.generateNextSteps(results)
    };
  }
}

// ç›¸å…³æ¥å£å®šä¹‰
interface QualityGateContext {
  triggerType: 'pull_request' | 'main_branch' | 'release_candidate';
  gitRef: string;
  author: string;
  timestamp: Date;
}

interface QualityGateResults {
  context: QualityGateContext;
  startTime: Date;
  endTime?: Date;
  stages: Map<string, any>;
  overallResult: {
    passed: boolean;
    blockers: Array<{ type: string; message: string; severity: string; }>;
    warnings: Array<{ type: string; message: string; }>;
    recommendations: Array<{ type: string; message: string; }>;
  };
}

interface CoverageReport {
  overall: {
    statements: number;
    branches: number;
    functions: number;
    lines: number;
  };
  modules: Record<string, any>;
}

interface CoverageGateResult {
  passed: boolean;
  overallCoverage: any;
  violations: Array<{ type: string; message: string; severity: string; module?: string; }>;
  improvements: Array<{ type: string; message: string; }>;
}

interface QualityGateReport {
  executionSummary: {
    totalDuration: number;
    stagesExecuted: string[];
    overallResult: 'PASSED' | 'FAILED';
    blockingIssues: number;
    warnings: number;
  };
  detailedResults: {
    coverageAnalysis: any;
    performanceAnalysis: any;
    qualityMetrics: any;
  };
  actionableRecommendations: any;
  historicalComparison: any;
  nextSteps: any;
}
```

### 6.5 è´¨é‡é—¨ç¦æ˜ å°„æ€»ç»“ä¸å®æ–½è·¯å¾„

#### 6.5.1 ä¼ä¸šçº§SLOé—¨ç¦ä½“ç³»æ¶æ„æ€»è§ˆ

```typescript
// src/shared/quality/slo-mapping-summary.ts - SLOé—¨ç¦æ˜ å°„æ€»ç»“

export const SLO_QUALITY_GATES_ARCHITECTURE = {
  // === æ ¸å¿ƒè®¾è®¡åŸåˆ™ ===
  designPrinciples: {
    errorBudgetDriven: {
      principle: 'åŸºäºè¯¯å·®é¢„ç®—çš„è´¨é‡ç®¡ç†',
      implementation: 'SLI/SLOè®¡ç®—æ¡†æ¶è‡ªåŠ¨ç®¡ç†è¯¯å·®é¢„ç®—æ¶ˆè€—å’Œé¢„è­¦',
      benefit: 'é‡åŒ–è´¨é‡é£é™©ï¼Œå¹³è¡¡å¼€å‘é€Ÿåº¦ä¸ç³»ç»Ÿç¨³å®šæ€§',
    },

    automatedDecisionMaking: {
      principle: 'è‡ªåŠ¨åŒ–å†³ç­–ä¸é—¨ç¦æ‰§è¡Œ',
      implementation: 'CI/CDæµæ°´çº¿é›†æˆï¼Œè‡ªåŠ¨æ‰§è¡Œè´¨é‡æ£€æŸ¥å’Œå‘å¸ƒå†³ç­–',
      benefit: 'å‡å°‘äººå·¥ä»‹å…¥ï¼Œæé«˜å‘å¸ƒæ•ˆç‡å’Œä¸€è‡´æ€§',
    },

    observabilityFirst: {
      principle: 'å¯è§‚æµ‹æ€§ä¼˜å…ˆçš„è´¨é‡ç›‘æ§',
      implementation: 'å®æ—¶å¥åº·åº¦ç›‘æ§ã€å¼‚å¸¸æ£€æµ‹å’Œé¢„æµ‹æ€§åˆ†æ',
      benefit: 'æå‰è¯†åˆ«è´¨é‡é£é™©ï¼Œé™ä½ç”Ÿäº§ç¯å¢ƒæ•…éšœç‡',
    },

    gradualRollback: {
      principle: 'æ¸è¿›å¼å›æ»šå’Œæ¢å¤æœºåˆ¶',
      implementation: 'å¤šå±‚æ¬¡é—¨ç¦æ£€æŸ¥ï¼Œè‡ªåŠ¨å›æ»šè§¦å‘æ¡ä»¶',
      benefit: 'æœ€å°åŒ–ç”¨æˆ·å½±å“ï¼Œå¿«é€Ÿæ•…éšœæ¢å¤',
    },
  },

  // === è´¨é‡é—¨ç¦å±‚æ¬¡ç»“æ„ ===
  gateHierarchy: {
    // L1: ä»£ç è´¨é‡é—¨ç¦ï¼ˆæœ€åŸºç¡€ï¼‰
    codeQualityGates: {
      coverage: {
        threshold: '>= 90%',
        scope: 'æ•´ä½“ä»£ç è¦†ç›–ç‡',
        blockingLevel: 'PR_MERGE',
        automationLevel: 'å®Œå…¨è‡ªåŠ¨åŒ–',
      },

      linting: {
        threshold: 'zero_violations',
        scope: 'ä»£ç é£æ ¼å’Œæ ¼å¼æ£€æŸ¥',
        blockingLevel: 'PR_MERGE',
        automationLevel: 'å®Œå…¨è‡ªåŠ¨åŒ–',
      },

      typeChecking: {
        threshold: 'zero_errors',
        scope: 'TypeScriptç¼–è¯‘æ£€æŸ¥',
        blockingLevel: 'PR_MERGE',
        automationLevel: 'å®Œå…¨è‡ªåŠ¨åŒ–',
      },
    },

    // L2: æ€§èƒ½è´¨é‡é—¨ç¦ï¼ˆä¸­ç­‰é‡è¦ï¼‰
    performanceGates: {
      uiResponsiveness: {
        threshold: 'TP95 < 100ms',
        scope: 'UIäº¤äº’å“åº”æ—¶é—´',
        blockingLevel: 'MAIN_BRANCH',
        automationLevel: 'åŸºå‡†æµ‹è¯•è‡ªåŠ¨åŒ–',
      },

      eventProcessing: {
        threshold: 'TP95 < 200ms',
        scope: 'æ¸¸æˆäº‹ä»¶å¤„ç†å»¶è¿Ÿ',
        blockingLevel: 'MAIN_BRANCH',
        automationLevel: 'åŸºå‡†æµ‹è¯•è‡ªåŠ¨åŒ–',
      },

      memoryUsage: {
        threshold: 'P95 < 800MB',
        scope: 'å†…å­˜ä½¿ç”¨æ•ˆç‡',
        blockingLevel: 'RELEASE_CANDIDATE',
        automationLevel: 'è´Ÿè½½æµ‹è¯•è‡ªåŠ¨åŒ–',
      },
    },

    // L3: å¯é æ€§é—¨ç¦ï¼ˆæœ€å…³é”®ï¼‰
    reliabilityGates: {
      crashFreeSessions: {
        threshold: '>= 99.5%',
        scope: 'ä¼šè¯æ— å´©æºƒç‡',
        blockingLevel: 'PRODUCTION_RELEASE',
        automationLevel: 'Sentryé›†æˆè‡ªåŠ¨åŒ–',
      },

      dataIntegrity: {
        threshold: '>= 99.9%',
        scope: 'æ•°æ®æ“ä½œæˆåŠŸç‡',
        blockingLevel: 'PRODUCTION_RELEASE',
        automationLevel: 'æ•°æ®éªŒè¯è‡ªåŠ¨åŒ–',
      },

      releaseHealth: {
        threshold: 'Health Score >= 95',
        scope: 'æ•´ä½“å‘å¸ƒå¥åº·åº¦',
        blockingLevel: 'PRODUCTION_RELEASE',
        automationLevel: 'å¥åº·åº¦é¢„æµ‹æ¨¡å‹',
      },
    },
  },

  // === å®æ–½æ—¶é—´çº¿ï¼ˆ12å‘¨è®¡åˆ’ï¼‰===
  implementationTimeline: {
    phase1_foundation: {
      duration: 'Week 1-3',
      name: 'åŸºç¡€è®¾æ–½å»ºè®¾',
      deliverables: [
        'SLI/SLOå®šä¹‰æ¡†æ¶å®ç°',
        'è¯¯å·®é¢„ç®—è®¡ç®—å¼•æ“å¼€å‘',
        'Sentry SDKé›†æˆå’Œä¼šè¯è¿½è¸ª',
        'GitHub ActionsåŸºç¡€å·¥ä½œæµæ­å»º',
      ],
      successCriteria: [
        'åŸºç¡€ç›‘æ§æ•°æ®é‡‡é›†æ­£å¸¸',
        'è¯¯å·®é¢„ç®—è®¡ç®—å‡†ç¡®æ€§éªŒè¯',
        'ä¼šè¯å¥åº·åº¦æ•°æ®å¯è§†åŒ–',
      ],
    },

    phase2_automation: {
      duration: 'Week 4-6',
      name: 'è‡ªåŠ¨åŒ–é—¨ç¦å®ç°',
      deliverables: [
        'è¦†ç›–ç‡é—¨ç¦è‡ªåŠ¨åŒ–æ£€æŸ¥',
        'TP95æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶',
        'è´¨é‡é—¨ç¦æ‰§è¡Œå¼•æ“å¼€å‘',
        'CI/CDæµæ°´çº¿é›†æˆå®Œæˆ',
      ],
      successCriteria: [
        'PRåˆå¹¶é—¨ç¦100%è‡ªåŠ¨åŒ–',
        'æ€§èƒ½å›å½’æ£€æµ‹å‡†ç¡®ç‡>95%',
        'é—¨ç¦æ‰§è¡Œæ—¶é—´<10åˆ†é’Ÿ',
      ],
    },

    phase3_intelligence: {
      duration: 'Week 7-9',
      name: 'æ™ºèƒ½åŒ–ç›‘æ§ä¸é¢„æµ‹',
      deliverables: [
        'å®æ—¶å¥åº·åº¦ç›‘æ§ä»ªè¡¨ç›˜',
        'å¼‚å¸¸æ£€æµ‹å’Œé¢„è­¦ç³»ç»Ÿ',
        'å‘å¸ƒå¥åº·åº¦é¢„æµ‹æ¨¡å‹',
        'è‡ªåŠ¨åŒ–å“åº”æœºåˆ¶å®ç°',
      ],
      successCriteria: [
        'å¼‚å¸¸æ£€æµ‹å‡†ç¡®ç‡>90%',
        'é¢„æµ‹æ¨¡å‹ç½®ä¿¡åº¦>85%',
        'è‡ªåŠ¨å“åº”å»¶è¿Ÿ<5åˆ†é’Ÿ',
      ],
    },

    phase4_optimization: {
      duration: 'Week 10-12',
      name: 'ä¼˜åŒ–ä¸å®Œå–„',
      deliverables: [
        'å†å²æ•°æ®åˆ†æå’Œè¶‹åŠ¿ç›‘æ§',
        'é—¨ç¦ç­–ç•¥ä¼˜åŒ–å’Œè°ƒå‚',
        'ç”¨æˆ·ä½“éªŒä¼˜åŒ–å’Œå·¥å…·å®Œå–„',
        'æ–‡æ¡£å’ŒåŸ¹è®­ææ–™å®Œæˆ',
      ],
      successCriteria: [
        'å‘å¸ƒæ•ˆç‡æå‡20%',
        'ç”Ÿäº§ç¯å¢ƒæ•…éšœç‡é™ä½50%',
        'å›¢é˜Ÿæ»¡æ„åº¦è¯„åˆ†>8/10',
      ],
    },
  },

  // === å…³é”®æˆåŠŸæŒ‡æ ‡ï¼ˆKPIsï¼‰===
  successMetrics: {
    // è´¨é‡æ”¹è¿›æŒ‡æ ‡
    qualityImprovement: {
      bugEscapeRate: {
        baseline: 'å½“å‰ç”Ÿäº§ç¯å¢ƒbugæ•°é‡',
        target: 'é™ä½60%',
        measurement: 'ç”Ÿäº§ç¯å¢ƒbugæ•°/å‘å¸ƒç‰ˆæœ¬æ•°',
        reviewPeriod: 'æ¯æœˆ',
      },

      codeQualityScore: {
        baseline: 'å½“å‰ä»£ç è¦†ç›–ç‡å’Œè´¨é‡è¯„åˆ†',
        target: 'è¦†ç›–ç‡>90%ï¼Œè´¨é‡è¯„åˆ†>8.5/10',
        measurement: 'è‡ªåŠ¨åŒ–è´¨é‡æ£€æµ‹å·¥å…·è¯„åˆ†',
        reviewPeriod: 'æ¯æ¬¡å‘å¸ƒ',
      },
    },

    // æ•ˆç‡æå‡æŒ‡æ ‡
    efficiencyGain: {
      releaseFrequency: {
        baseline: 'å½“å‰å‘å¸ƒé¢‘ç‡',
        target: 'æå‡50%',
        measurement: 'æ¯æœˆå‘å¸ƒæ¬¡æ•°',
        reviewPeriod: 'å­£åº¦',
      },

      meanTimeToRecovery: {
        baseline: 'å½“å‰æ•…éšœæ¢å¤æ—¶é—´',
        target: 'ç¼©çŸ­70%',
        measurement: 'ä»æ•…éšœæ£€æµ‹åˆ°æ¢å¤çš„å¹³å‡æ—¶é—´',
        reviewPeriod: 'æ¯æ¬¡æ•…éšœ',
      },
    },

    // ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
    userExperience: {
      crashFreeSessions: {
        baseline: 'å½“å‰å´©æºƒç‡',
        target: '>= 99.5%',
        measurement: 'Sentryç›‘æ§æ•°æ®',
        reviewPeriod: 'æ¯æ—¥',
      },

      performanceRegression: {
        baseline: 'å½“å‰æ€§èƒ½åŸºçº¿',
        target: 'æ€§èƒ½å›å½’æ£€æµ‹ç‡100%',
        measurement: 'åŸºå‡†æµ‹è¯•è‡ªåŠ¨æ£€æµ‹',
        reviewPeriod: 'æ¯æ¬¡ä»£ç æäº¤',
      },
    },
  },
} as const;

// === å®æ–½æ£€æŸ¥æ¸…å• ===
export const IMPLEMENTATION_CHECKLIST = {
  // æŠ€æœ¯å‡†å¤‡æ£€æŸ¥æ¸…å•
  technicalReadiness: [
    {
      item: 'Sentryè´¦æˆ·è®¾ç½®å’ŒDSNé…ç½®',
      status: 'pending',
      owner: 'DevOpså›¢é˜Ÿ',
      estimatedHours: 4,
    },
    {
      item: 'GitHub Actionsæƒé™å’ŒSecretsé…ç½®',
      status: 'pending',
      owner: 'DevOpså›¢é˜Ÿ',
      estimatedHours: 8,
    },
    {
      item: 'ä»£ç åº“æ·»åŠ è´¨é‡é—¨ç¦è„šæœ¬ç›®å½•ç»“æ„',
      status: 'pending',
      owner: 'å‰ç«¯å›¢é˜Ÿ',
      estimatedHours: 2,
    },
    {
      item: 'Vitestæµ‹è¯•æ¡†æ¶å’ŒC8è¦†ç›–ç‡å·¥å…·é…ç½®',
      status: 'pending',
      owner: 'å‰ç«¯å›¢é˜Ÿ',
      estimatedHours: 6,
    },
    {
      item: 'æ€§èƒ½åŸºå‡†æµ‹è¯•ç¯å¢ƒå‡†å¤‡',
      status: 'pending',
      owner: 'å…¨æ ˆå›¢é˜Ÿ',
      estimatedHours: 12,
    },
  ],

  // æµç¨‹å‡†å¤‡æ£€æŸ¥æ¸…å•
  processReadiness: [
    {
      item: 'å›¢é˜ŸSLO/SLIæ¦‚å¿µåŸ¹è®­å®Œæˆ',
      status: 'pending',
      owner: 'æŠ€æœ¯è´Ÿè´£äºº',
      estimatedHours: 4,
    },
    {
      item: 'é—¨ç¦å¤±è´¥å¤„ç†æµç¨‹åˆ¶å®š',
      status: 'pending',
      owner: 'é¡¹ç›®ç»ç†',
      estimatedHours: 3,
    },
    {
      item: 'ç´§æ€¥å‘å¸ƒç»¿è‰²é€šé“æœºåˆ¶è®¾è®¡',
      status: 'pending',
      owner: 'æŠ€æœ¯è´Ÿè´£äºº',
      estimatedHours: 2,
    },
    {
      item: 'è´¨é‡é—¨ç¦ä¾‹å¤–å®¡æ‰¹æµç¨‹',
      status: 'pending',
      owner: 'é¡¹ç›®ç»ç†',
      estimatedHours: 2,
    },
  ],

  // å·¥å…·å‡†å¤‡æ£€æŸ¥æ¸…å•
  toolingReadiness: [
    {
      item: 'å®æ—¶ç›‘æ§ä»ªè¡¨ç›˜éƒ¨ç½²',
      status: 'pending',
      owner: 'DevOpså›¢é˜Ÿ',
      estimatedHours: 16,
    },
    {
      item: 'å‘Šè­¦é€šçŸ¥æ¸ é“é…ç½®ï¼ˆSlack/Emailï¼‰',
      status: 'pending',
      owner: 'DevOpså›¢é˜Ÿ',
      estimatedHours: 4,
    },
    {
      item: 'å†å²æ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢ç³»ç»Ÿ',
      status: 'pending',
      owner: 'åç«¯å›¢é˜Ÿ',
      estimatedHours: 20,
    },
    {
      item: 'è´¨é‡é—¨ç¦æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ',
      status: 'pending',
      owner: 'å‰ç«¯å›¢é˜Ÿ',
      estimatedHours: 12,
    },
  ],
};

/**
 * è´¨é‡é—¨ç¦ç³»ç»Ÿå¥åº·åº¦è‡ªæ£€å‡½æ•°
 */
export async function validateSLOGatesHealth(): Promise<{
  overallHealth: 'healthy' | 'degraded' | 'critical';
  componentStatus: Record<string, 'ok' | 'warning' | 'error'>;
  recommendations: string[];
}> {
  // å®ç°ç³»ç»Ÿè‡ªæ£€é€»è¾‘
  return {
    overallHealth: 'healthy',
    componentStatus: {
      sentry_integration: 'ok',
      github_actions: 'ok',
      coverage_reporting: 'ok',
      benchmark_testing: 'ok',
      error_budget_tracking: 'ok',
    },
    recommendations: [],
  };
}
```

> **ğŸ“‹ å®æ–½è¦ç‚¹æ€»ç»“**ï¼š
>
> 1. **æ¸è¿›å¼å®æ–½**ï¼šæŒ‰ç…§12å‘¨æ—¶é—´çº¿åˆ†é˜¶æ®µå®æ–½ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„æˆåŠŸæ ‡å‡†
> 2. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šæ‰€æœ‰è´¨é‡æ£€æŸ¥éƒ½åº”å®ç°è‡ªåŠ¨åŒ–ï¼Œå‡å°‘äººå·¥å¹²é¢„å’Œè¯¯åˆ¤
> 3. **æ•°æ®é©±åŠ¨**ï¼šåŸºäºçœŸå®çš„SLIæ•°æ®è¿›è¡Œå†³ç­–ï¼Œé¿å…ä¸»è§‚åˆ¤æ–­
> 4. **æŒç»­ä¼˜åŒ–**ï¼šå®šæœŸå›é¡¾å’Œè°ƒæ•´é—¨ç¦ç­–ç•¥ï¼Œé€‚åº”é¡¹ç›®å‘å±•éœ€è¦
> 5. **å›¢é˜ŸåŸ¹è®­**ï¼šç¡®ä¿å›¢é˜Ÿç†è§£SLOæ¦‚å¿µå’Œè´¨é‡é—¨ç¦çš„ä»·å€¼

---

## ä¸ƒã€ç±»å‹/é…ç½®ï¼ˆå¯ç›´æ¥å¼•ç”¨ï¼‰

```ts
// src/shared/quality/gates.ts
export interface SloGate {
  key: 'crash_free' | 'tp95' | 'coverage';
  threshold: number;
  source: 'sentry' | 'benchmark' | 'coverage';
  window?: '7d' | '30d' | 'release';
  blockOnFail: boolean;
}

export const GATES: SloGate[] = [
  {
    key: 'crash_free',
    threshold: 99.5,
    source: 'sentry',
    window: '30d',
    blockOnFail: true,
  },
  {
    key: 'tp95',
    threshold: 100,
    source: 'benchmark',
    window: '7d',
    blockOnFail: false,
  },
  {
    key: 'coverage',
    threshold: 90,
    source: 'coverage',
    window: 'release',
    blockOnFail: true,
  },
];
```

---

## å…«ã€å°±åœ°éªŒæ”¶ï¼ˆGherkin + Vitest ç‰‡æ®µï¼‰

```gherkin
# docs/architecture/acceptance/01-goals.feature
Feature: 01 ç›®æ ‡ä¸SLOè½åœ°
  Scenario: SLO/é—¨ç¦æ˜ å°„å·²é…ç½®
    Given å·¥ç¨‹å·²åŒ…å« gates é…ç½®
    Then åº”å­˜åœ¨ crash_freeã€tp95ã€coverage ä¸‰ç±»é—¨ç¦
    And crash_free é˜ˆå€¼ä¸ä½äº 99.5%
```

```ts
// tests/policy/gates.spec.ts
import { describe, it, expect } from 'vitest';
import { GATES } from '../../src/shared/quality/gates';

describe('01 SLOâ†’é—¨ç¦æ˜ å°„', () => {
  it('åŒ…å«ä¸‰ç±»é—¨ç¦å¹¶æ»¡è¶³é˜ˆå€¼ä¸‹é™', () => {
    const byKey = Object.fromEntries(GATES.map(g => [g.key, g]));
    expect(byKey.crash_free.threshold).toBeGreaterThanOrEqual(99.5);
    expect(byKey.tp95.threshold).toBeLessThanOrEqual(100);
    expect(byKey.coverage.threshold).toBeGreaterThanOrEqual(90);
  });
});
```

---

## ä¹ã€SLOâ†’é—¨ç¦æ˜ å°„ï¼ˆä¿®è®¢ï¼šäº‹ä»¶å»¶è¿Ÿå£å¾„ç»Ÿä¸€ï¼‰

> **è®¾è®¡èƒŒæ™¯**ï¼šé€šè¿‡ultra-deep thinkingåˆ†æå‘ç°ï¼Œç°æœ‰æ¶æ„æ–‡æ¡£ä¸­äº‹ä»¶å¤„ç†å»¶è¿Ÿè¦æ±‚å­˜åœ¨**20å€å·®å¼‚**ï¼šæŠ€æœ¯æ¶æ„æ–‡æ¡£è¦æ±‚"äº‹ä»¶å¤„ç†å»¶è¿Ÿ <= 10ms P99"ï¼Œè€ŒSLOé—¨ç¦è®¾ç½®ä¸º"äº‹ä»¶å¤„ç†å»¶è¿Ÿ TP95 < 200ms"ã€‚è¿™ç§ä¸ä¸€è‡´æ€§ä¼šå¯¼è‡´å¼€å‘ç›®æ ‡æ··ä¹±ã€é—¨ç¦æ‰§è¡Œå¤±æ•ˆã€æ€§èƒ½ä¼˜åŒ–æ–¹å‘é”™è¯¯ç­‰ä¸¥é‡é—®é¢˜ã€‚

### 9.1 æ¶æ„ä¸ä¸€è‡´æ€§é—®é¢˜åˆ†æ

#### 9.1.1 å‘ç°çš„æ ¸å¿ƒå†²çª

```typescript
// é—®é¢˜1: å»¶è¿Ÿè¦æ±‚ä¸ä¸€è‡´ (20å€å·®å¼‚)
interface PerformanceInconsistency {
  æŠ€æœ¯æ¶æ„æ–‡æ¡£: {
    äº‹ä»¶å¤„ç†å»¶è¿Ÿ: 'P99 <= 10ms'; // ä¸¥æ ¼æ ‡å‡†
    åº¦é‡æ–¹å¼: 'P99 ç™¾åˆ†ä½æ•°';
    åº”ç”¨åœºæ™¯: 'æ ¸å¿ƒäº‹ä»¶å¤„ç†';
  };
  SLOé—¨ç¦é…ç½®: {
    äº‹ä»¶å¤„ç†å»¶è¿Ÿ: 'TP95 < 200ms'; // å®½æ¾æ ‡å‡†
    åº¦é‡æ–¹å¼: 'TP95 ç™¾åˆ†ä½æ•°';
    åº”ç”¨åœºæ™¯: 'é—¨ç¦æ£€æŸ¥';
  };
  å·®å¼‚å€æ•°: 20; // 200ms / 10ms = 20å€
}

// é—®é¢˜2: åº¦é‡æ–¹å¼ä¸ç»Ÿä¸€
interface MetricInconsistency {
  P99: '99th percentile - æ›´ä¸¥æ ¼çš„æ€§èƒ½è¦æ±‚';
  TP95: '95th percentile - ç›¸å¯¹å®½æ¾çš„é˜ˆå€¼';
  å½±å“: 'æ— æ³•å‡†ç¡®å¯¹æ¯”å’Œè¯„ä¼°æ€§èƒ½è¡¨ç°';
}
```

#### 9.1.2 ä¸ä¸€è‡´æ€§å½±å“è¯„ä¼°

```typescript
// æ¶æ„ä¸ä¸€è‡´æ€§é£é™©åˆ†æ
export interface ArchitecturalInconsistencyRisks {
  å¼€å‘å±‚é¢: {
    ç›®æ ‡æ··ä¹±: 'å¼€å‘å›¢é˜Ÿä¸çŸ¥é“åº”è¯¥æŒ‰ç…§å“ªä¸ªæ ‡å‡†ä¼˜åŒ–';
    èµ„æºæµªè´¹: 'å¯èƒ½è¿‡åº¦ä¼˜åŒ–åˆ°10msï¼Œä¹Ÿå¯èƒ½æ»¡è¶³äº200ms';
    æŠ€æœ¯å€ºåŠ¡: 'ä¸åŒæ¨¡å—æŒ‰ä¸åŒæ ‡å‡†å®ç°ï¼Œä»£ç è´¨é‡ä¸ä¸€è‡´';
  };

  è´¨é‡ä¿éšœ: {
    é—¨ç¦å¤±æ•ˆ: '200msé—¨ç¦æ— æ³•ä¿éšœ10msçš„ç”¨æˆ·ä½“éªŒç›®æ ‡';
    æ€§èƒ½é€€åŒ–: 'ç”Ÿäº§ç¯å¢ƒå¯èƒ½å‡ºç°æ˜æ˜¾çš„æ€§èƒ½é—®é¢˜';
    ç›‘æ§ç›²åŒº: 'ç°æœ‰ç›‘æ§ä½“ç³»æ— æ³•å‡†ç¡®åæ˜ çœŸå®æ€§èƒ½çŠ¶å†µ';
  };

  ç”¨æˆ·ä½“éªŒ: {
    å“åº”è¿Ÿç¼“: '200mså»¶è¿Ÿåœ¨æ¸¸æˆåœºæ™¯ä¸‹ç”¨æˆ·æ„ŸçŸ¥æ˜æ˜¾';
    ä½“éªŒä¸ä¸€è‡´: 'éƒ¨åˆ†åŠŸèƒ½å“åº”å¿«é€Ÿï¼Œéƒ¨åˆ†åŠŸèƒ½æ˜æ˜¾å¡é¡¿';
    ç«äº‰åŠ£åŠ¿: 'æ€§èƒ½ä¸å¦‚ç«å“ï¼Œå½±å“ç”¨æˆ·ç•™å­˜';
  };
}
```

### 9.2 æ€§èƒ½æŒ‡æ ‡ç§‘å­¦ä¾æ®ä¸è¡Œä¸šåŸºå‡†

#### 9.2.1 ç”¨æˆ·ä½“éªŒç ”ç©¶åŸºå‡†

```typescript
// åŸºäº2024å¹´æœ€æ–°ç”¨æˆ·ä½“éªŒç ”ç©¶çš„ç§‘å­¦ä¾æ®
export interface UserExperienceResearch2024 {
  ä¼ ç»Ÿ100msé˜ˆå€¼ç°çŠ¶: {
    å†å²èƒŒæ™¯: '30å¹´å‰å»ºç«‹çš„å“åº”æ—¶é—´æ ‡å‡†';
    ç°ä»£é€‚ç”¨æ€§: 'å·²ä¸é€‚åº”é«˜é¢‘äº¤äº’å’Œæ¸¸æˆåœºæ™¯';
    ç§‘å­¦å‘ç°: 'ç”¨æˆ·å¯ä»¥æ„ŸçŸ¥ä½è‡³2msçš„å»¶è¿Ÿå˜åŒ–';
  };

  æ¸¸æˆåœºæ™¯å»¶è¿Ÿæ•æ„Ÿåº¦: {
    å¿«èŠ‚å¥æ¸¸æˆ: {
      æœ€ä½³ä½“éªŒ: '< 10ms';
      å¯æ¥å—èŒƒå›´: '10-30ms';
      æ˜æ˜¾æ„ŸçŸ¥: '> 30ms';
      ç”¨æˆ·æµå¤±é£é™©: '> 50ms';
    };

    ç­–ç•¥æ¸¸æˆ: {
      æœ€ä½³ä½“éªŒ: '< 20ms';
      å¯æ¥å—èŒƒå›´: '20-50ms';
      æ˜æ˜¾æ„ŸçŸ¥: '> 50ms';
      ç”¨æˆ·æµå¤±é£é™©: '> 100ms';
    };
  };

  ç§‘å­¦ç ”ç©¶å‘ç°: {
    æ„ŸçŸ¥é˜ˆå€¼: '2mså¯æ„ŸçŸ¥å»¶è¿Ÿå˜åŒ–';
    æ€§èƒ½å½±å“: '25mså¼€å§‹å½±å“æ“ä½œè¡¨ç°';
    å³ä½¿ä½äºæ„ŸçŸ¥é˜ˆå€¼: 'ä»ä¼šæ½œåœ¨å½±å“ç”¨æˆ·ä½“éªŒ';
  };
}
```

#### 9.2.2 Electron IPCæ€§èƒ½åŸºå‡†

```typescript
// åŸºäº2024å¹´Electron IPCæ€§èƒ½åŸºå‡†æµ‹è¯•
export interface ElectronIPCBenchmark2024 {
  æ ‡å‡†IPCå»¶è¿Ÿ: {
    å°å¯¹è±¡ä¼ è¾“: {
      P50: '< 1ms';
      P90: '< 1ms';
      P99: '< 4ms';
      æœ€å¤§å€¼: '< 10ms';
    };

    WebSocketä¼˜åŒ–å: {
      å…¸å‹å»¶è¿Ÿ: '~1ms';
      æ€§èƒ½æå‡: 'æ˜¾è‘—ä¼˜äºæ ‡å‡†IPC';
    };
  };

  æ€§èƒ½å½±å“å› ç´ : {
    åŒæ­¥IPCé—®é¢˜: 'å¯èƒ½å¯¼è‡´æ•°ç™¾æ¯«ç§’å»¶è¿Ÿ';
    ä¸»è¿›ç¨‹é˜»å¡: 'ç›´æ¥å½±å“IPCå“åº”æ—¶é—´';
    æ¶ˆæ¯é˜Ÿåˆ—æ‹¥å¡: '0msé—´éš”ä¼šå¯¼è‡´æ•°ç™¾æ¯«ç§’å»¶è¿Ÿ';
    æœ€ä½³å®è·µ: '1msé—´éš”æ˜¾è‘—æ”¹å–„æ€§èƒ½';
  };
}
```

#### 9.2.3 æ¸¸æˆå¼•æ“æ€§èƒ½è¦æ±‚

```typescript
// ã€Šå…¬ä¼šç»ç†ã€‹æ¸¸æˆå¼•æ“æ€§èƒ½è¦æ±‚åˆ†æ
export interface GameEnginePerformanceRequirements {
  å¸§ç‡ç›®æ ‡: {
    ç›®æ ‡å¸§ç‡: '60 FPS';
    æ¯å¸§æ—¶é—´é¢„ç®—: '16.67ms';
    æœ€ä½å¯æ¥å—: '45 FPS (22.22ms/å¸§)';
    è­¦å‘Šé˜ˆå€¼: '< 50 FPS';
    ä¸¥é‡é˜ˆå€¼: '< 30 FPS';
  };

  äº‹ä»¶å¤„ç†çº¦æŸ: {
    å…³é”®äº¤äº’: 'å¿…é¡»åœ¨å•å¸§å†…å®Œæˆ (< 16ms)';
    ä¸€èˆ¬äº‹ä»¶: 'å¯è·¨2-3å¸§å¤„ç† (< 50ms)';
    åå°å¤„ç†: 'å¯ä½¿ç”¨æ›´å¤šæ—¶é—´é¢„ç®— (< 100ms)';

    å®æ—¶æ€§è€ƒé‡: {
      ç”¨æˆ·è¾“å…¥å“åº”: '< 10ms æ„ŸçŸ¥ä¸ºå³æ—¶';
      AIå†³ç­–åé¦ˆ: '< 50ms ä¿æŒæ¸¸æˆæµç•…æ„Ÿ';
      ç³»ç»ŸçŠ¶æ€æ›´æ–°: '< 100ms é¿å…æ˜æ˜¾å»¶è¿Ÿ';
    };
  };
}
```

### 9.3 ç»Ÿä¸€æ€§èƒ½æŒ‡æ ‡å£å¾„æ–¹æ¡ˆ

#### 9.3.1 äº‹ä»¶å¤„ç†å»¶è¿Ÿç»Ÿä¸€æ ‡å‡†

```typescript
// åŸºäºç§‘å­¦ç ”ç©¶å’Œå·¥ç¨‹å®è·µçš„ç»Ÿä¸€å»¶è¿Ÿæ ‡å‡†
export interface UnifiedLatencyStandards {
  æ ¸å¿ƒäº‹ä»¶å¤„ç†: {
    ç”¨æˆ·äº¤äº’äº‹ä»¶: {
      TP95: '< 10ms'; // 95%çš„äº¤äº’åœ¨10mså†…å®Œæˆ
      P99: '< 20ms'; // 99%çš„äº¤äº’åœ¨20mså†…å®Œæˆ
      æœ€å¤§å€¼: '< 50ms'; // ç»å¯¹ä¸è¶…è¿‡50ms
      ç›‘æ§çª—å£: '7å¤©æ»šåŠ¨';
      è¯¯å·®é¢„ç®—: '+5msç¼“å†²';
    };

    æ¸¸æˆé€»è¾‘äº‹ä»¶: {
      TP95: '< 25ms'; // 95%çš„æ¸¸æˆé€»è¾‘åœ¨25mså†…
      P99: '< 50ms'; // 99%çš„æ¸¸æˆé€»è¾‘åœ¨50mså†…
      æœ€å¤§å€¼: '< 100ms'; // ç»å¯¹ä¸è¶…è¿‡100ms
      ç›‘æ§çª—å£: '7å¤©æ»šåŠ¨';
      è¯¯å·®é¢„ç®—: '+10msç¼“å†²';
    };

    AIå†³ç­–äº‹ä»¶: {
      TP95: '< 50ms'; // 95%çš„AIå†³ç­–åœ¨50mså†…
      P99: '< 100ms'; // 99%çš„AIå†³ç­–åœ¨100mså†…
      æœ€å¤§å€¼: '< 250ms'; // å¤æ‚å†³ç­–å…è®¸æ›´é•¿æ—¶é—´
      ç›‘æ§çª—å£: '7å¤©æ»šåŠ¨';
      è¯¯å·®é¢„ç®—: '+25msç¼“å†²';
    };
  };
}
```

#### 9.3.2 IPCé€šä¿¡æ€§èƒ½åŸºçº¿

```typescript
// Electron IPCé€šä¿¡æ€§èƒ½ç»Ÿä¸€åŸºçº¿
export interface UnifiedIPCBaseline {
  ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹: {
    ç©ºè½½åŸºçº¿: {
      TP95: '< 5ms'; // 95%çš„ç©ºè½½é€šä¿¡åœ¨5mså†…
      P99: '< 10ms'; // 99%çš„ç©ºè½½é€šä¿¡åœ¨10mså†…
      æœ€å¤§å€¼: '< 20ms'; // å¼€å‘æœºç¯å¢ƒåŸºå‡†
    };

    ä¸šåŠ¡æ•°æ®ä¼ è¾“: {
      TP95: '< 10ms'; // 95%çš„ä¸šåŠ¡æ•°æ®åœ¨10mså†…
      P99: '< 20ms'; // 99%çš„ä¸šåŠ¡æ•°æ®åœ¨20mså†…
      æœ€å¤§å€¼: '< 50ms'; // å¤æ‚æ•°æ®ç»“æ„å…è®¸æ›´é•¿æ—¶é—´
    };
  };

  åŒå‘é€šä¿¡å¾€è¿”: {
    TP95: '< 15ms'; // 95%çš„å¾€è¿”åœ¨15mså†…
    P99: '< 30ms'; // 99%çš„å¾€è¿”åœ¨30mså†…
    æœ€å¤§å€¼: '< 75ms'; // å¾€è¿”æ—¶é—´ä¸Šé™

    æ€§èƒ½ä¼˜åŒ–ç›®æ ‡: {
      WebSocketæ›¿ä»£: 'è€ƒè™‘é«˜é¢‘åœºæ™¯ä½¿ç”¨WebSocket';
      æ‰¹é‡å¤„ç†: 'å‡å°‘IPCè°ƒç”¨é¢‘æ¬¡';
      å¼‚æ­¥è®¾è®¡: 'é¿å…é˜»å¡ä¸»è¿›ç¨‹';
    };
  };
}
```

#### 9.3.3 AIå¹¶å‘ä¸€è‡´æ€§è¦æ±‚

```typescript
// AIç³»ç»Ÿå¹¶å‘å¤„ç†ä¸€è‡´æ€§æ ‡å‡†
export interface AIConsistencyRequirements {
  å¹¶å‘å¤„ç†èƒ½åŠ›: {
    å®ä½“æ•°é‡: '50+ å®ä½“å¹¶å‘tick';
    å¤„ç†é¢‘ç‡: 'æ¯ç§’30æ¬¡æ›´æ–° (33msé—´éš”)';
    ç¨³å®šæ€§è¦æ±‚: 'â‰¥ 99%ç»“æœä¸€è‡´æ€§';

    ä¸€è‡´æ€§éªŒè¯: {
      ç›¸åŒç§å­æµ‹è¯•: '10è½®è¿è¡ŒçŠ¶æ€æ¼‚ç§» â‰¤ 1%';
      å†³ç­–æ—¶å»¶: 'TP95 < 50ms';
      å†…å­˜ä½¿ç”¨: 'å¢é•¿ç‡ < 10% per 1000 ticks';
    };
  };

  æ€§èƒ½é€€åŒ–æ£€æµ‹: {
    è­¦å‘Šé˜ˆå€¼: {
      å†³ç­–æ—¶å»¶: 'TP95 > 75ms';
      å†…å­˜æ³„æ¼: 'å¢é•¿ç‡ > 15%';
      ä¸€è‡´æ€§: '< 98%';
    };

    ä¸¥é‡é˜ˆå€¼: {
      å†³ç­–æ—¶å»¶: 'TP95 > 100ms';
      å†…å­˜æ³„æ¼: 'å¢é•¿ç‡ > 25%';
      ä¸€è‡´æ€§: '< 95%';
    };
  };
}
```

### 9.4 ä¿®è®¢åçš„SLOé—¨ç¦æ˜ å°„

#### 9.4.1 åˆ†å±‚é—¨ç¦ä½“ç³»é‡æ–°è®¾è®¡

```typescript
// ä¿®è®¢åçš„åˆ†å±‚é—¨ç¦ä½“ç³»ï¼Œè§£å†³å£å¾„ä¸ä¸€è‡´é—®é¢˜
export interface RevisedQualityGatesTier {
  // Tier-0: æ ¸å¿ƒç”¨æˆ·ä½“éªŒé—¨ç¦ (æœ€ä¸¥æ ¼)
  tierZero_CoreUX: {
    userInteractionLatency: {
      name: 'ç”¨æˆ·äº¤äº’å»¶è¿Ÿ';
      threshold: 'TP95 < 10ms, P99 < 20ms';
      source: 'PlaywrightåŸºå‡†æµ‹è¯•';
      blockingLevel: 'BLOCKING_RELEASE';
      description: 'æ ¸å¿ƒäº¤äº’å¿…é¡»ä¿æŒå³æ—¶å“åº”';
    };

    gameLoopStability: {
      name: 'æ¸¸æˆå¾ªç¯ç¨³å®šæ€§';
      threshold: 'â‰¥ 95%æ—¶é—´ä¿æŒ > 55fps';
      source: 'Phaseræ€§èƒ½ç›‘æ§';
      blockingLevel: 'BLOCKING_RELEASE';
      description: 'ä¿éšœæ¸¸æˆä½“éªŒæµç•…åº¦';
    };
  };

  // Tier-1: ç³»ç»Ÿæ€§èƒ½é—¨ç¦ (é‡è¦)
  tierOne_SystemPerformance: {
    gameLogicLatency: {
      name: 'æ¸¸æˆé€»è¾‘å»¶è¿Ÿ';
      threshold: 'TP95 < 25ms, P99 < 50ms';
      source: 'å†…éƒ¨æ€§èƒ½ç›‘æ§';
      blockingLevel: 'BLOCKING_MERGE';
      description: 'æ¸¸æˆé€»è¾‘å¤„ç†æ€§èƒ½è¦æ±‚';
    };

    ipcCommunicationLatency: {
      name: 'IPCé€šä¿¡å»¶è¿Ÿ';
      threshold: 'TP95 < 10ms, P99 < 20ms';
      source: 'Electronæ€§èƒ½ç›‘æ§';
      blockingLevel: 'BLOCKING_MERGE';
      description: 'è¿›ç¨‹é—´é€šä¿¡æ€§èƒ½åŸºçº¿';
    };

    aiDecisionLatency: {
      name: 'AIå†³ç­–å»¶è¿Ÿ';
      threshold: 'TP95 < 50ms, P99 < 100ms';
      source: 'Web Workerç›‘æ§';
      blockingLevel: 'WARNING_ONLY';
      description: 'AIç³»ç»Ÿå“åº”æ—¶é—´è¦æ±‚';
    };
  };

  // Tier-2: ç›‘æ§ä¸é¢„è­¦é—¨ç¦ (ç›‘æ§)
  tierTwo_MonitoringAlerts: {
    systemResourceUsage: {
      name: 'ç³»ç»Ÿèµ„æºä½¿ç”¨';
      threshold: 'å†…å­˜ < 512MB, CPU < 30%';
      source: 'ç³»ç»Ÿç›‘æ§';
      blockingLevel: 'WARNING_ONLY';
      description: 'èµ„æºä½¿ç”¨ç›‘æ§é¢„è­¦';
    };

    errorBudgetConsumption: {
      name: 'è¯¯å·®é¢„ç®—æ¶ˆè€—';
      threshold: '< 75%æœˆåº¦é¢„ç®—';
      source: 'SLOè®¡ç®—å™¨';
      blockingLevel: 'WARNING_ONLY';
      description: 'æ€§èƒ½é€€åŒ–è¶‹åŠ¿é¢„è­¦';
    };
  };
}
```

#### 9.4.2 ç»Ÿä¸€çš„ç›‘æ§é…ç½®æ¥å£

```typescript
// ç»Ÿä¸€çš„æ€§èƒ½ç›‘æ§é…ç½®ï¼Œç¡®ä¿å£å¾„ä¸€è‡´æ€§
export interface UnifiedMonitoringConfig {
  // å»¶è¿Ÿç›‘æ§é…ç½®
  latencyMonitoring: {
    sampling: {
      rate: 1.0; // 100%é‡‡æ ·ï¼Œç¡®ä¿å‡†ç¡®æ€§
      windowSize: '7d'; // 7å¤©æ»šåŠ¨çª—å£
      aggregationInterval: '1m'; // 1åˆ†é’Ÿèšåˆ
    };

    percentiles: {
      tracked: [50, 90, 95, 99, 99.9]; // è·Ÿè¸ªå¤šä¸ªç™¾åˆ†ä½
      primary: {
        p95: 'ä¸»è¦é—¨ç¦æŒ‡æ ‡';
        p99: 'ä¸¥æ ¼æ€§èƒ½è¦æ±‚';
      };
    };

    alerting: {
      warningThreshold: '75% of SLO';
      criticalThreshold: '90% of SLO';
      cooldownPeriod: '10m';
    };
  };

  // æ•°æ®æºç»Ÿä¸€é…ç½®
  dataSources: {
    electron: {
      ipcMetrics: 'process.performance API';
      memoryUsage: 'process.memoryUsage()';
      cpuUsage: 'process.cpuUsage()';
    };

    phaser: {
      fpsMonitoring: 'game.loop.actualFps';
      scenePerformance: 'scene.cameras.main';
      renderingStats: 'game.renderer.info';
    };

    webWorker: {
      aiDecisionTiming: 'performance.now()';
      messageLatency: 'postMessage timestamp';
      processingQueue: 'task queue depth';
    };
  };
}
```

#### 9.4.3 æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®ºæ”¯æ’‘

```typescript
// åŸºäºç»Ÿä¸€æŒ‡æ ‡çš„æ€§èƒ½è°ƒä¼˜æ–¹æ³•è®º
export interface PerformanceTuningMethodology {
  å¢é‡å‰¥ç¦»æ³•: {
    ç›®çš„: 'å®šä½æ€§èƒ½ç“¶é¢ˆçš„ç³»ç»ŸåŒ–æ–¹æ³•';
    æ­¥éª¤: [
      'å»ºç«‹åŸºçº¿æµ‹é‡ (æ‰€æœ‰åŠŸèƒ½å¯ç”¨)',
      'é€ä¸ªç¦ç”¨éå…³é”®åŠŸèƒ½',
      'æµ‹é‡æ€§èƒ½æ”¹å–„å¹…åº¦',
      'è¯†åˆ«ä¸»è¦ç“¶é¢ˆç»„ä»¶',
      'é’ˆå¯¹æ€§ä¼˜åŒ–ç“¶é¢ˆç‚¹',
    ];

    å®æ–½é…ç½®: {
      baselineConfig: {
        fullFeatureSet: true;
        monitoring: 'å…¨é¢æ€§èƒ½ç›‘æ§';
        duration: '24å°æ—¶åŸºçº¿æ”¶é›†';
      };

      incrementalDisabling: {
        aiProcessing: 'ç¦ç”¨AIå†³ç­–';
        backgroundTasks: 'ç¦ç”¨åå°ä»»åŠ¡';
        animations: 'ç¦ç”¨å¤æ‚åŠ¨ç”»';
        soundEffects: 'ç¦ç”¨éŸ³æ•ˆå¤„ç†';
      };
    };
  };

  Phaseræ€§èƒ½ä¼˜åŒ–: {
    æ¸²æŸ“ä¼˜åŒ–: {
      objectPooling: 'å®ç°å¯¹è±¡æ± å¤ç”¨';
      textureAtlas: 'ä½¿ç”¨çº¹ç†å›¾é›†';
      spriteOptimization: 'ä¼˜åŒ–ç²¾çµå›¾ç®¡ç†';
    };

    åœºæ™¯ç®¡ç†: {
      scenePooling: 'åœºæ™¯å¯¹è±¡æ± ';
      lazyLoading: 'å»¶è¿ŸåŠ è½½èµ„æº';
      memoryCleanup: 'åŠæ—¶æ¸…ç†æ— ç”¨å¯¹è±¡';
    };

    äº‹ä»¶ç³»ç»Ÿ: {
      eventThrottling: 'äº‹ä»¶èŠ‚æµå¤„ç†';
      batchProcessing: 'æ‰¹é‡äº‹ä»¶å¤„ç†';
      priorityQueue: 'ä¼˜å…ˆçº§é˜Ÿåˆ—';
    };
  };

  Electronä¼˜åŒ–: {
    IPCä¼˜åŒ–: {
      messageAggregation: 'æ¶ˆæ¯èšåˆ';
      asyncPattern: 'å¼‚æ­¥é€šä¿¡æ¨¡å¼';
      serialization: 'é«˜æ•ˆåºåˆ—åŒ–';
    };

    è¿›ç¨‹ç®¡ç†: {
      workerThreads: 'è®¡ç®—å¯†é›†ä»»åŠ¡åˆ†ç¦»';
      memoryManagement: 'å†…å­˜ä½¿ç”¨ä¼˜åŒ–';
      resourcePreloading: 'èµ„æºé¢„åŠ è½½';
    };
  };
}
```

### 9.5 å®æ–½è·¯å¾„ä¸è¿ç§»ç­–ç•¥

#### 9.5.1 åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

```typescript
// åˆ†é˜¶æ®µè§£å†³æ¶æ„ä¸ä¸€è‡´æ€§çš„å®æ–½è®¡åˆ’
export interface ImplementationRoadmap {
  ç¬¬ä¸€é˜¶æ®µ_ç«‹å³ä¿®å¤: {
    duration: '1-2å‘¨';
    priority: 'P0 - å…³é”®';

    actions: [
      {
        task: 'ä¿®æ­£SLOé—¨ç¦é…ç½®';
        from: 'eventProcessing TP95 < 200ms';
        to: 'userInteraction TP95 < 10ms, gameLogic TP95 < 25ms';
        impact: 'ç«‹å³å¯¹é½æŠ€æœ¯æ ‡å‡†ä¸è´¨é‡é—¨ç¦';
      },

      {
        task: 'ç»Ÿä¸€åº¦é‡æ–¹å¼';
        description: 'æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡ç»Ÿä¸€ä½¿ç”¨TP95 + P99åŒé‡ç›‘æ§';
        benefit: 'æ¶ˆé™¤P99/TP95æ··ç”¨çš„æ··ä¹±';
      },

      {
        task: 'ç´§æ€¥æ€§èƒ½åŸºçº¿é‡æµ‹';
        description: 'åŸºäºæ–°æ ‡å‡†é‡æ–°å»ºç«‹æ€§èƒ½åŸºçº¿';
        deliverable: 'æ›´æ–°çš„æ€§èƒ½åŸºå‡†æŠ¥å‘Š';
      },
    ];
  };

  ç¬¬äºŒé˜¶æ®µ_ç³»ç»Ÿå¢å¼º: {
    duration: '3-4å‘¨';
    priority: 'P1 - é‡è¦';

    actions: [
      {
        task: 'ç›‘æ§ç³»ç»Ÿå‡çº§';
        description: 'éƒ¨ç½²ç»Ÿä¸€çš„æ€§èƒ½ç›‘æ§é…ç½®';
        components: ['Electronç›‘æ§', 'Phaserç›‘æ§', 'WebWorkerç›‘æ§'];
      },

      {
        task: 'è‡ªåŠ¨åŒ–é—¨ç¦éƒ¨ç½²';
        description: 'åŸºäºæ–°æ ‡å‡†é…ç½®CI/CDé—¨ç¦';
        integration: ['GitHub Actions', 'æ€§èƒ½æµ‹è¯•', 'è‡ªåŠ¨å›æ»š'];
      },

      {
        task: 'æ€§èƒ½è°ƒä¼˜å®æ–½';
        description: 'åº”ç”¨å¢é‡å‰¥ç¦»æ³•ä¼˜åŒ–å…³é”®è·¯å¾„';
        target: 'ç¡®ä¿æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ»¡è¶³æ–°æ€§èƒ½æ ‡å‡†';
      },
    ];
  };

  ç¬¬ä¸‰é˜¶æ®µ_æŒç»­ä¼˜åŒ–: {
    duration: 'ongoing';
    priority: 'P2 - ç»´æŠ¤';

    actions: [
      {
        task: 'æ€§èƒ½å›å½’ç›‘æ§';
        description: 'å»ºç«‹æŒç»­çš„æ€§èƒ½å›å½’æ£€æµ‹';
        frequency: 'æ¯æ¬¡PRåˆå¹¶';
      },

      {
        task: 'å›¢é˜ŸåŸ¹è®­';
        description: 'ç¡®ä¿å›¢é˜Ÿç†è§£æ–°çš„æ€§èƒ½æ ‡å‡†';
        content: ['ç”¨æˆ·ä½“éªŒç§‘å­¦', 'æ€§èƒ½è°ƒä¼˜æ–¹æ³•', 'ç›‘æ§å·¥å…·ä½¿ç”¨'];
      },

      {
        task: 'æ ‡å‡†æŒç»­æ”¹è¿›';
        description: 'åŸºäºå®é™…è¿è¡Œæ•°æ®è°ƒæ•´æ€§èƒ½æ ‡å‡†';
        review: 'æ¯å­£åº¦å›é¡¾å’Œä¼˜åŒ–';
      },
    ];
  };
}
```

#### 9.5.2 å‘åå…¼å®¹æ€§å¤„ç†

```typescript
// ç¡®ä¿ç°æœ‰ä»£ç å’Œç›‘æ§ç³»ç»Ÿå¹³æ»‘è¿ç§»
export interface BackwardCompatibilityStrategy {
  é…ç½®æ–‡ä»¶è¿ç§»: {
    legacy: {
      eventProcessing: 'TP95 < 200ms';
      ç»´æŠ¤æœŸé™: '2ä¸ªæœˆæ¸è¿›è¿ç§»';
    };

    migration: {
      dualMonitoring: 'åŒæ—¶ç›‘æ§æ–°æ—§æŒ‡æ ‡';
      gradualCutover: 'é€æ­¥åˆ‡æ¢åˆ°æ–°æ ‡å‡†';
      rollbackPlan: 'ä¿ç•™å›æ»šèƒ½åŠ›';
    };

    sunset: {
      deprecationNotice: 'æ ‡è®°æ—§é…ç½®ä¸ºdeprecated';
      removalDate: '2ä¸ªæœˆåå®Œå…¨ç§»é™¤';
      migrationGuide: 'æä¾›è¯¦ç»†è¿ç§»æŒ‡å—';
    };
  };

  ç›‘æ§ç³»ç»Ÿå…¼å®¹: {
    dashboards: {
      dualView: 'åŒæ—¶æ˜¾ç¤ºæ–°æ—§æŒ‡æ ‡å¯¹æ¯”';
      trendAnalysis: 'æ˜¾ç¤ºè¿ç§»è¶‹åŠ¿';
      alerting: 'æ–°æ—§å‘Šè­¦å¹¶è¡Œè¿è¡Œ';
    };

    dataRetention: {
      historicalData: 'ä¿ç•™å†å²æ•°æ®6ä¸ªæœˆ';
      comparison: 'æ”¯æŒæ–°æ—§æ ‡å‡†å¯¹æ¯”åˆ†æ';
      reporting: 'ç”Ÿæˆè¿ç§»å½±å“æŠ¥å‘Š';
    };
  };
}
```

### 9.6 éªŒè¯ä¸æµ‹è¯•æ¡†æ¶

#### 9.6.1 ç»Ÿä¸€æ€§èƒ½æµ‹è¯•å¥—ä»¶

```typescript
// åŸºäºæ–°ç»Ÿä¸€æ ‡å‡†çš„æ€§èƒ½æµ‹è¯•æ¡†æ¶
export interface UnifiedPerformanceTestSuite {
  coreInteractionTests: {
    name: 'æ ¸å¿ƒäº¤äº’æ€§èƒ½æµ‹è¯•';

    testCases: [
      {
        scenario: 'ç”¨æˆ·ç‚¹å‡»å“åº”';
        expectedTP95: '< 10ms';
        expectedP99: '< 20ms';
        testMethod: 'Playwrightè‡ªåŠ¨åŒ–æµ‹è¯•';
        sampleSize: 1000;
      },

      {
        scenario: 'æ¸¸æˆçŠ¶æ€æ›´æ–°';
        expectedTP95: '< 25ms';
        expectedP99: '< 50ms';
        testMethod: 'Phaseræ€§èƒ½ç›‘æ§';
        sampleSize: 500;
      },

      {
        scenario: 'AIå†³ç­–å“åº”';
        expectedTP95: '< 50ms';
        expectedP99: '< 100ms';
        testMethod: 'Web Workerè®¡æ—¶';
        sampleSize: 200;
      },
    ];
  };

  stressTests: {
    name: 'å‹åŠ›æµ‹è¯•éªŒè¯';

    scenarios: [
      {
        test: 'é«˜å¹¶å‘äº‹ä»¶å¤„ç†';
        load: '50ä¸ªå®ä½“åŒæ—¶æ›´æ–°';
        duration: '10åˆ†é’Ÿ';
        acceptance: 'æ€§èƒ½ä¸é€€åŒ–è¶…è¿‡10%';
      },

      {
        test: 'é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§';
        load: 'è¿ç»­è¿è¡Œ8å°æ—¶';
        monitoring: 'å†…å­˜æ³„æ¼ã€æ€§èƒ½é€€åŒ–';
        acceptance: 'æ‰€æœ‰æŒ‡æ ‡ä¿æŒåœ¨SLOèŒƒå›´å†…';
      },
    ];
  };
}
```

#### 9.6.2 å›å½’æµ‹è¯•è‡ªåŠ¨åŒ–

```typescript
// ç¡®ä¿æ€§èƒ½æ ‡å‡†ä¸é€€åŒ–çš„è‡ªåŠ¨åŒ–å›å½’æµ‹è¯•
export interface PerformanceRegressionPrevention {
  preCommitChecks: {
    fastTests: {
      runtime: '< 2åˆ†é’Ÿ';
      coverage: ['æ ¸å¿ƒäº¤äº’è·¯å¾„', 'å…³é”®APIæ€§èƒ½'];
      threshold: 'ä¸è¶…è¿‡åŸºçº¿çš„105%';
    };
  };

  prMergeGates: {
    comprehensiveTests: {
      runtime: '< 10åˆ†é’Ÿ';
      coverage: ['å®Œæ•´æ€§èƒ½æµ‹è¯•å¥—ä»¶'];
      threshold: 'ä¸¥æ ¼éµå¾ªSLOæ ‡å‡†';
      reporting: 'è¯¦ç»†æ€§èƒ½åˆ†ææŠ¥å‘Š';
    };
  };

  releaseValidation: {
    fullSuiteTests: {
      runtime: '< 30åˆ†é’Ÿ';
      coverage: ['æ‰€æœ‰æ€§èƒ½åœºæ™¯', 'å‹åŠ›æµ‹è¯•', 'é•¿æœŸç¨³å®šæ€§'];
      threshold: 'æ‰€æœ‰æŒ‡æ ‡å‡æ»¡è¶³SLOè¦æ±‚';
      documentation: 'å‘å¸ƒæ€§èƒ½éªŒè¯æŠ¥å‘Š';
    };
  };
}
```

### 9.7 æ€»ç»“ä¸æŒç»­æ”¹è¿›

#### 9.7.1 è§£å†³æ–¹æ¡ˆæ€»ç»“

```typescript
// äº‹ä»¶å»¶è¿Ÿå£å¾„ç»Ÿä¸€è§£å†³æ–¹æ¡ˆæ€»ç»“
export interface SolutionSummary {
  é—®é¢˜è§£å†³: {
    æ ¸å¿ƒé—®é¢˜: 'äº‹ä»¶å¤„ç†å»¶è¿Ÿ20å€å·®å¼‚ (10ms vs 200ms)';
    è§£å†³æ–¹æ¡ˆ: 'åŸºäºç§‘å­¦ç ”ç©¶çš„åˆ†å±‚ç»Ÿä¸€æ ‡å‡†';

    å…³é”®æ”¹è¿›: [
      'ç”¨æˆ·äº¤äº’: TP95 < 10ms, P99 < 20ms',
      'æ¸¸æˆé€»è¾‘: TP95 < 25ms, P99 < 50ms',
      'AIå†³ç­–: TP95 < 50ms, P99 < 100ms',
      'IPCé€šä¿¡: TP95 < 10ms, P99 < 20ms',
    ];
  };

  æŠ€æœ¯ä»·å€¼: {
    ä¸€è‡´æ€§: 'æ¶ˆé™¤æ¶æ„æ–‡æ¡£ä¸å®æ–½çš„20å€å·®å¼‚';
    ç§‘å­¦æ€§: 'åŸºäº2024å¹´ç”¨æˆ·ä½“éªŒç ”ç©¶å’Œè¡Œä¸šåŸºå‡†';
    å¯æ“ä½œæ€§: 'æä¾›å®Œæ•´çš„ç›‘æ§ã€æµ‹è¯•ã€è°ƒä¼˜æ–¹æ¡ˆ';
    å‰ç»æ€§: 'ä¸ºæœªæ¥æ€§èƒ½ä¼˜åŒ–å»ºç«‹å¯é åŸºç¡€';
  };

  å®æ–½å½±å“: {
    immediate: 'ç«‹å³ä¿®æ­£SLOé—¨ç¦é…ç½®ï¼Œè§£å†³å¼€å‘æ··ä¹±';
    shortTerm: 'å»ºç«‹ç»Ÿä¸€ç›‘æ§ä½“ç³»ï¼Œæå‡è´¨é‡ä¿éšœ';
    longTerm: 'å½¢æˆå¯æŒç»­çš„æ€§èƒ½ä¼˜åŒ–æ–‡åŒ–';
  };
}
```

#### 9.7.2 æŒç»­æ”¹è¿›æœºåˆ¶

```typescript
// ç¡®ä¿æ€§èƒ½æ ‡å‡†ä¸æ—¶ä¿±è¿›çš„æ”¹è¿›æœºåˆ¶
export interface ContinuousImprovementFramework {
  å®šæœŸè¯„ä¼°: {
    frequency: 'æ¯å­£åº¦';
    scope: ['ç”¨æˆ·ä½“éªŒç ”ç©¶æ›´æ–°', 'æŠ€æœ¯æ ˆæ€§èƒ½æ¼”è¿›', 'ç«å“åŸºå‡†å¯¹æ¯”'];
    deliverable: 'æ€§èƒ½æ ‡å‡†è°ƒæ•´å»ºè®®';
  };

  åé¦ˆæ”¶é›†: {
    sources: [
      'ç”¨æˆ·ä½“éªŒç›‘æ§æ•°æ®',
      'å¼€å‘å›¢é˜Ÿåé¦ˆ',
      'ç”Ÿäº§ç¯å¢ƒæ€§èƒ½æŒ‡æ ‡',
      'è¡Œä¸šæœ€ä½³å®è·µç ”ç©¶',
    ];

    analysis: 'æ•°æ®é©±åŠ¨çš„æ ‡å‡†ä¼˜åŒ–';
  };

  æ ‡å‡†æ¼”è¿›: {
    principle: 'åŸºäºå®è¯æ•°æ®çš„æ¸è¿›å¼æ”¹è¿›';
    constraint: 'ç¡®ä¿å‘åå…¼å®¹å’Œå›¢é˜Ÿé€‚åº”æ€§';
    validation: 'å……åˆ†æµ‹è¯•åå†æ­£å¼é‡‡ç”¨';
  };
}
```

---

> **ğŸ“‹ ç« èŠ‚æ€»ç»“**ï¼š
>
> é€šè¿‡ultra-deep thinkingåˆ†æï¼Œæˆ‘ä»¬å‘ç°å¹¶è§£å†³äº†ã€Šå…¬ä¼šç»ç†ã€‹æ¶æ„æ–‡æ¡£ä¸­**äº‹ä»¶å¤„ç†å»¶è¿Ÿ20å€å·®å¼‚**çš„ä¸¥é‡ä¸ä¸€è‡´æ€§é—®é¢˜ã€‚åŸºäºæœ€æ–°çš„ç”¨æˆ·ä½“éªŒç§‘å­¦ç ”ç©¶ã€Electronæ€§èƒ½åŸºå‡†å’Œæ¸¸æˆå¼•æ“ç‰¹æ€§ï¼Œå»ºç«‹äº†ç»Ÿä¸€çš„æ€§èƒ½æŒ‡æ ‡å£å¾„ï¼š
>
> 1. **æ ¸å¿ƒäº¤äº’**ï¼šTP95 < 10ms, P99 < 20msï¼ˆç”¨æˆ·æ„ŸçŸ¥å³æ—¶å“åº”ï¼‰
> 2. **æ¸¸æˆé€»è¾‘**ï¼šTP95 < 25ms, P99 < 50msï¼ˆä¿æŒæ¸¸æˆæµç•…æ€§ï¼‰
> 3. **AIå†³ç­–**ï¼šTP95 < 50ms, P99 < 100msï¼ˆæ™ºèƒ½å“åº”å¹³è¡¡ï¼‰
> 4. **IPCé€šä¿¡**ï¼šTP95 < 10ms, P99 < 20msï¼ˆè¿›ç¨‹åè°ƒé«˜æ•ˆï¼‰
>
> é€šè¿‡ä¿®æ­£è¿™äº›ä¸ä¸€è‡´æ€§ï¼ŒSLOè´¨é‡é—¨ç¦ç³»ç»Ÿç°åœ¨æä¾›äº†ç§‘å­¦ä¸¥è°¨ã€å·¥ç¨‹å¯è¡Œçš„æ€§èƒ½ä¿éšœä½“ç³»ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹çš„é«˜è´¨é‡äº¤ä»˜å¥ å®šäº†åšå®åŸºç¡€ã€‚

---

## åã€SLOâ†’é—¨ç¦æ˜ å°„ï¼ˆæ–°å¢ï¼šAI å¹¶å‘ä¸€è‡´æ€§ï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šåŸºäºultra-deep thinkingåˆ†æç¡®å®šçš„P1ä¼˜å…ˆçº§ä»»åŠ¡ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹AIé©±åŠ¨çš„ç»è¥æ¨¡æ‹Ÿæ¸¸æˆæ„å»ºä¸“é—¨çš„AIå¹¶å‘ä¸€è‡´æ€§é—¨ç¦ä½“ç³»ï¼Œç¡®ä¿200+AIå®ä½“ç”Ÿæ€ç³»ç»Ÿçš„ç¨³å®šæ€§ã€ä¸€è‡´æ€§å’Œå¯è°ƒè¯•æ€§ã€‚

### 10.1 AIå¹¶å‘ä¸€è‡´æ€§æŒ‘æˆ˜åˆ†æ

#### 10.1.1 æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜

```typescript
// AIå¹¶å‘ä¸€è‡´æ€§æ ¸å¿ƒæŒ‘æˆ˜å®šä¹‰
export interface AIConcurrencychallenges {
  å¹¶å‘å¤„ç†æŒ‘æˆ˜: {
    å®ä½“è§„æ¨¡: "50+AIå®ä½“éœ€è¦åŒæ—¶è¿›è¡Œå†³ç­–tick";
    çº¿ç¨‹æ¨¡å‹: "Web Workerç¯å¢ƒä¸‹çš„çº¿ç¨‹å®‰å…¨ä¿è¯";
    æ€§èƒ½è¦æ±‚: "å†³ç­–å»¶è¿ŸTP95 < 50msï¼Œæ”¯æŒ200+å®ä½“";
    èµ„æºç«äº‰: "é¿å…AIå®ä½“é—´çš„ä¸å…¬å¹³èµ„æºåˆ†é…";
  };

  ä¸€è‡´æ€§ä¿è¯æŒ‘æˆ˜: {
    ç¡®å®šæ€§è¦æ±‚: "ç›¸åŒè¾“å…¥å¿…é¡»äº§ç”Ÿç›¸åŒè¾“å‡º";
    å›æ”¾èƒ½åŠ›: "æ”¯æŒæ¸¸æˆçŠ¶æ€çš„ç²¾ç¡®é‡ç°";
    çŠ¶æ€åŒæ­¥: "äº‹ä»¶é©±åŠ¨æ¶æ„ä¸‹çš„AIçŠ¶æ€ä¸€è‡´æ€§";
    å¾®åˆ†æ¼‚ç§»: "é˜²æ­¢AIå†³ç­–çš„å¾®å°å·®å¼‚å¯¼è‡´è´è¶æ•ˆåº”";
  };

  ç»è¥æ¨¡æ‹Ÿç‰¹æ€§æŒ‘æˆ˜: {
    å†³ç­–å…¬å¹³æ€§: "æ‰€æœ‰AIå®ä½“åº”æœ‰ç›¸åŒçš„å†³ç­–æœºä¼š";
    æ—¶åºæ§åˆ¶: "ä¸¥æ ¼çš„å›åˆåˆ¶å†³ç­–é¡ºåºç®¡ç†";
    çŠ¶æ€å¿«ç…§: "æ”¯æŒå›æ¡£å’Œè°ƒè¯•çš„çŠ¶æ€ä¿å­˜";
    æ€§èƒ½å¹³è¡¡: "å®æ—¶æ€§ä¸ä¸€è‡´æ€§çš„æƒè¡¡ç­–ç•¥";
  };

  Web Workerç¯å¢ƒæŒ‘æˆ˜: {
    é€šä¿¡å¼€é”€: "è·¨çº¿ç¨‹æ¶ˆæ¯ä¼ é€’çš„æ€§èƒ½å½±å“";
    é”™è¯¯æ¢å¤: "Workerçº¿ç¨‹å´©æºƒçš„è‡ªåŠ¨æ¢å¤æœºåˆ¶";
    è°ƒè¯•å›°éš¾: "åˆ†å¸ƒå¼AIå†³ç­–çš„è°ƒè¯•å¤æ‚æ€§";
    å†…å­˜ç®¡ç†: "é•¿æœŸè¿è¡Œçš„å†…å­˜æ³„æ¼é˜²æŠ¤";
  };
}
```

#### 10.1.2 æ¶æ„å‡è®¾éªŒè¯

```typescript
// å…³é”®æ¶æ„å‡è®¾çš„éªŒè¯è¦æ±‚
export interface ArchitectureAssumptionValidation {
  å¹¶å‘æ¨¡å‹å‡è®¾: {
    assumption: 'Web Workerå¯ä»¥æœ‰æ•ˆæ”¯æŒ50+AIå®ä½“å¹¶å‘';
    éªŒè¯æ–¹æ³•: 'è´Ÿè½½æµ‹è¯•ä¸çº¿ç¨‹æ‰©å±•èƒ½åŠ›è¯„ä¼°';
    éªŒè¯æŒ‡æ ‡: 'å¹¶å‘å¤„ç†å»¶è¿Ÿã€çº¿ç¨‹é€šä¿¡å¼€é”€ã€é”™è¯¯ç‡';
    é£é™©è¯„ä¼°: 'çº¿ç¨‹æ± é¥±å’Œã€æ¶ˆæ¯é˜Ÿåˆ—é˜»å¡';
  };

  ç¡®å®šæ€§å‡è®¾: {
    assumption: 'ç›¸åŒç§å­å¯ä»¥ä¿è¯JavaScriptç¯å¢ƒä¸‹çš„ç¡®å®šæ€§';
    éªŒè¯æ–¹æ³•: 'å¤šè½®ç§å­æµ‹è¯•ä¸çŠ¶æ€å“ˆå¸ŒéªŒè¯';
    éªŒè¯æŒ‡æ ‡: '10è½®è¿è¡ŒçŠ¶æ€æ¼‚ç§» â‰¤ 0.1%';
    é£é™©è¯„ä¼°: 'æµ®ç‚¹æ•°ç²¾åº¦ã€å¼‚æ­¥æ“ä½œæ—¶åº';
  };

  æ€§èƒ½é€€åŒ–å‡è®¾: {
    assumption: 'AIå®ä½“æ•°é‡çº¿æ€§å¢é•¿ï¼Œæ€§èƒ½çº¿æ€§é€€åŒ–';
    éªŒè¯æ–¹æ³•: 'é˜¶æ¢¯è´Ÿè½½æµ‹è¯•ï¼Œè¯†åˆ«éçº¿æ€§cliff';
    éªŒè¯æŒ‡æ ‡: 'ä¸åŒå®ä½“æ•°é‡ä¸‹çš„å†³ç­–å»¶è¿Ÿåˆ†å¸ƒ';
    é£é™©è¯„ä¼°: 'å¯èƒ½å­˜åœ¨çªå‘æ€§èƒ½æ–­å´–';
  };
}
```

### 10.2 åˆ†å±‚AIä¸€è‡´æ€§é—¨ç¦ä½“ç³»

#### 10.2.1 Tier-0: AIæ ¸å¿ƒä¸€è‡´æ€§é—¨ç¦ï¼ˆé˜»å¡å‘å¸ƒï¼‰

```typescript
// Tier-0: æœ€ä¸¥æ ¼çš„AIä¸€è‡´æ€§é—¨ç¦ï¼Œä»»ä½•å¤±è´¥éƒ½é˜»å¡å‘å¸ƒ
export const AI_TIER_ZERO_GATES: QualityGate[] = [
  {
    key: 'ai_deterministic_reproducibility',
    name: 'AIç¡®å®šæ€§å†ç°æ€§',
    tier: 0,
    description: 'éªŒè¯ç›¸åŒç§å­ä¸‹AIå†³ç­–çš„å®Œå…¨ä¸€è‡´æ€§',
    sli: 'ç›¸åŒç§å­å¤šè½®è¿è¡Œçš„çŠ¶æ€å“ˆå¸Œä¸€è‡´æ€§',
    slo: '10è½®è¿è¡ŒçŠ¶æ€æ¼‚ç§» â‰¤ 0.1%',
    source: 'ç§å­é”å®šå›å½’æµ‹è¯•å¥—ä»¶',
    blockingLevel: 'BLOCKING_RELEASE',
    testScript: 'tests/ai-consistency/deterministic-seed.spec.ts',
    automatedCheck: true,

    implementation: {
      æµ‹è¯•æ–¹æ³•: `
        // ç§å­é”å®šçš„ç¡®å®šæ€§æµ‹è¯•
        for (let seed = 1; seed <= 10; seed++) {
          const run1 = await runGameSimulation({ seed, turns: 100 });
          const run2 = await runGameSimulation({ seed, turns: 100 });
          const run3 = await runGameSimulation({ seed, turns: 100 });
          
          const hash1 = calculateStateHash(run1.finalState);
          const hash2 = calculateStateHash(run2.finalState);
          const hash3 = calculateStateHash(run3.finalState);
          
          expect(hash1).toBe(hash2).toBe(hash3);
        }
      `,
      æˆåŠŸæ ‡å‡†: 'æ‰€æœ‰ç§å­æµ‹è¯•100%é€šè¿‡ï¼Œæ— ä»»ä½•çŠ¶æ€æ¼‚ç§»',
      å¤±è´¥å¤„ç†: 'ç«‹å³é˜»å¡å‘å¸ƒï¼Œè§¦å‘ç´§æ€¥æ¶æ„å®¡æŸ¥',
    },
  },

  {
    key: 'ai_decision_sequence_consistency',
    name: 'AIå†³ç­–æ—¶åºä¸€è‡´æ€§',
    tier: 0,
    description: 'ç¡®ä¿AIå®ä½“å†³ç­–é¡ºåºçš„100%å¯é¢„æµ‹æ€§',
    sli: 'AIå®ä½“å†³ç­–åºåˆ—çš„å“ˆå¸Œå€¼éªŒè¯',
    slo: 'å†³ç­–é¡ºåº100%å¯é¢„æµ‹ï¼Œåºåˆ—å“ˆå¸Œå®Œå…¨ä¸€è‡´',
    source: 'å†³ç­–åºåˆ—è®°å½•å™¨',
    blockingLevel: 'BLOCKING_RELEASE',
    testScript: 'tests/ai-consistency/decision-sequence.spec.ts',
    automatedCheck: true,

    implementation: {
      æµ‹è¯•æ–¹æ³•: `
        // å†³ç­–åºåˆ—ä¸€è‡´æ€§éªŒè¯
        const scenario = createStandardScenario();
        const decisions1 = await recordAIDecisionSequence(scenario);
        const decisions2 = await recordAIDecisionSequence(scenario);
        
        const sequence1Hash = hashDecisionSequence(decisions1);
        const sequence2Hash = hashDecisionSequence(decisions2);
        
        expect(sequence1Hash).toBe(sequence2Hash);
        expect(decisions1.length).toBe(decisions2.length);
      `,
      æˆåŠŸæ ‡å‡†: 'ç›¸åŒåœºæ™¯ä¸‹AIå†³ç­–åºåˆ—100%ä¸€è‡´',
      å¤±è´¥å¤„ç†: 'ç«‹å³é˜»å¡å‘å¸ƒï¼Œåˆ†æå†³ç­–æ—¶åºå¼‚å¸¸åŸå› ',
    },
  },
];
```

#### 10.2.2 Tier-1: AIæ€§èƒ½é—¨ç¦ï¼ˆé˜»å¡åˆå¹¶ï¼‰

```typescript
// Tier-1: AIæ€§èƒ½ä¸ç¨³å®šæ€§é—¨ç¦ï¼Œå¤±è´¥é˜»å¡ä»£ç åˆå¹¶
export const AI_TIER_ONE_GATES: QualityGate[] = [
  {
    key: 'ai_concurrent_processing_capability',
    name: 'AIå¹¶å‘å¤„ç†èƒ½åŠ›',
    tier: 1,
    description: 'éªŒè¯50+AIå®ä½“å¹¶å‘å¤„ç†çš„æ€§èƒ½è¦æ±‚',
    sli: 'å¹¶å‘AIå®ä½“å†³ç­–å¤„ç†çš„TP95å»¶è¿Ÿ',
    slo: '50+AIå®ä½“å¹¶å‘tickï¼ŒTP95 < 50ms',
    source: 'AIæ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶',
    blockingLevel: 'BLOCKING_MERGE',
    testScript: 'tests/ai-performance/concurrent-processing.spec.ts',
    automatedCheck: true,

    implementation: {
      æµ‹è¯•é…ç½®: `
        // AIå¹¶å‘å¤„ç†èƒ½åŠ›æµ‹è¯•é…ç½®
        export const ConcurrentAITestConfig = {
          testScenarios: [
            { entityCount: 25, expectedTP95: 25, description: "è½»è½½æµ‹è¯•" },
            { entityCount: 50, expectedTP95: 50, description: "æ ‡å‡†è´Ÿè½½" },
            { entityCount: 75, expectedTP95: 75, description: "é«˜è´Ÿè½½æµ‹è¯•" },
            { entityCount: 100, expectedTP95: 100, description: "æé™æµ‹è¯•" }
          ],
          
          workerConfig: {
            threadCount: 4,
            batchSize: 12,
            timeoutMs: 5000
          },
          
          performanceThresholds: {
            tp95MaxLatency: 50,
            p99MaxLatency: 100,
            memoryGrowthRate: 0.1,
            errorRate: 0.001
          }
        };
      `,
      æµ‹è¯•å®ç°: `
        // å¹¶å‘å¤„ç†èƒ½åŠ›éªŒè¯
        async function testConcurrentAIProcessing() {
          const aiWorkerPool = new AIWorkerPool(4);
          const entities = createAIEntities(50);
          
          const startTime = performance.now();
          const results = await aiWorkerPool.processConcurrentDecisions(entities);
          const endTime = performance.now();
          
          const processingTime = endTime - startTime;
          const tp95 = calculateTP95(results.map(r => r.processingTime));
          
          expect(tp95).toBeLessThan(50);
          expect(results.every(r => r.success)).toBe(true);
        }
      `,
      æˆåŠŸæ ‡å‡†: 'æ‰€æœ‰å¹¶å‘æµ‹è¯•åœºæ™¯éƒ½æ»¡è¶³æ€§èƒ½è¦æ±‚',
      å¤±è´¥å¤„ç†: 'é˜»å¡PRåˆå¹¶ï¼Œéœ€è¦æ€§èƒ½ä¼˜åŒ–',
    },
  },

  {
    key: 'ai_memory_usage_stability',
    name: 'AIå†…å­˜ä½¿ç”¨ç¨³å®šæ€§',
    tier: 1,
    description: 'ç¡®ä¿AIç³»ç»Ÿé•¿æœŸè¿è¡Œçš„å†…å­˜ç¨³å®šæ€§',
    sli: '1000ä¸ªå†³ç­–å‘¨æœŸå†…çš„å†…å­˜å¢é•¿ç‡',
    slo: '1000 tickå†…å­˜å¢é•¿ < 10%',
    source: 'AIå†…å­˜ç›‘æ§å™¨',
    blockingLevel: 'BLOCKING_MERGE',
    testScript: 'tests/ai-performance/memory-stability.spec.ts',
    automatedCheck: true,

    implementation: {
      æµ‹è¯•é…ç½®: `
        // AIå†…å­˜ç¨³å®šæ€§æµ‹è¯•é…ç½®
        export const MemoryStabilityConfig = {
          testDuration: 1000, // 1000ä¸ªtick
          samplingInterval: 50, // æ¯50ä¸ªtické‡‡æ ·ä¸€æ¬¡
          memoryGrowthThreshold: 0.1, // 10%å¢é•¿é˜ˆå€¼
          gcTriggerThreshold: 0.8, // 80%å†…å­˜æ—¶è§¦å‘GC
          
          aiEntityConfig: {
            entityCount: 50,
            decisionComplexity: 'medium',
            stateSize: 'standard'
          }
        };
      `,
      å†…å­˜ç›‘æ§å®ç°: `
        // AIå†…å­˜ä½¿ç”¨ç›‘æ§
        class AIMemoryMonitor {
          private measurements: MemoryMeasurement[] = [];
          
          async measureMemoryUsage(): Promise<MemoryMeasurement> {
            const usage = process.memoryUsage();
            return {
              timestamp: Date.now(),
              heapUsed: usage.heapUsed,
              heapTotal: usage.heapTotal,
              rss: usage.rss
            };
          }
          
          calculateGrowthRate(): number {
            const initial = this.measurements[0].heapUsed;
            const latest = this.measurements[this.measurements.length - 1].heapUsed;
            return (latest - initial) / initial;
          }
        }
      `,
      æˆåŠŸæ ‡å‡†: 'å†…å­˜å¢é•¿ç‡ < 10%ï¼Œæ— æ˜æ˜¾å†…å­˜æ³„æ¼',
      å¤±è´¥å¤„ç†: 'é˜»å¡PRåˆå¹¶ï¼Œéœ€è¦å†…å­˜æ³„æ¼åˆ†æ',
    },
  },

  {
    key: 'ai_error_recovery_capability',
    name: 'AIé”™è¯¯æ¢å¤èƒ½åŠ›',
    tier: 1,
    description: 'éªŒè¯AIç³»ç»Ÿçš„é”™è¯¯æ¢å¤å’Œå®¹é”™èƒ½åŠ›',
    sli: 'AI Workerçº¿ç¨‹å´©æºƒåçš„æ¢å¤æˆåŠŸç‡',
    slo: 'é”™è¯¯æ¢å¤æˆåŠŸç‡ â‰¥ 99.5%',
    source: 'AIå®¹é”™æµ‹è¯•æ¡†æ¶',
    blockingLevel: 'BLOCKING_MERGE',
    testScript: 'tests/ai-resilience/error-recovery.spec.ts',
    automatedCheck: true,

    implementation: {
      å®¹é”™æµ‹è¯•åœºæ™¯: `
        // AIé”™è¯¯æ¢å¤æµ‹è¯•åœºæ™¯
        export const ErrorRecoveryScenarios = [
          {
            name: 'Workerçº¿ç¨‹å´©æºƒæ¢å¤',
            trigger: () => simulateWorkerCrash(),
            expectedRecovery: 'auto-restart within 100ms'
          },
          {
            name: 'å†…å­˜ä¸è¶³æ¢å¤',
            trigger: () => simulateMemoryPressure(),
            expectedRecovery: 'graceful degradation'
          },
          {
            name: 'å†³ç­–è¶…æ—¶æ¢å¤',
            trigger: () => simulateDecisionTimeout(),
            expectedRecovery: 'fallback to default decision'
          },
          {
            name: 'æ•°æ®æŸåæ¢å¤',
            trigger: () => simulateDataCorruption(),
            expectedRecovery: 'state restoration from checkpoint'
          }
        ];
      `,
      æˆåŠŸæ ‡å‡†: 'æ‰€æœ‰é”™è¯¯åœºæ™¯éƒ½èƒ½æ­£ç¡®æ¢å¤',
      å¤±è´¥å¤„ç†: 'é˜»å¡PRåˆå¹¶ï¼Œéœ€è¦å®¹é”™æœºåˆ¶æ”¹è¿›',
    },
  },
];
```

#### 10.2.3 Tier-2: AIç›‘æ§é—¨ç¦ï¼ˆè­¦å‘Šé¢„è­¦ï¼‰

```typescript
// Tier-2: AIè¡Œä¸ºè´¨é‡ç›‘æ§é—¨ç¦ï¼Œå¤±è´¥æ—¶å‘å‡ºè­¦å‘Šä½†ä¸é˜»å¡
export const AI_TIER_TWO_GATES: QualityGate[] = [
  {
    key: 'ai_decision_quality_monitoring',
    name: 'AIå†³ç­–è´¨é‡ç›‘æ§',
    tier: 2,
    description: 'ç›‘æ§AIå†³ç­–çš„åˆç†æ€§å’Œæ™ºèƒ½åŒ–ç¨‹åº¦',
    sli: 'AIå†³ç­–åˆç†æ€§è¯„åˆ†çš„å¹³å‡å€¼',
    slo: 'AIå†³ç­–åˆç†æ€§è¯„åˆ† > 85%',
    source: 'AIè¡Œä¸ºåˆ†æå™¨',
    blockingLevel: 'WARNING_ONLY',
    testScript: 'tests/ai-quality/decision-quality.spec.ts',
    automatedCheck: true,

    implementation: {
      å†³ç­–è´¨é‡è¯„ä¼°æ¡†æ¶: `
        // AIå†³ç­–è´¨é‡è¯„ä¼°æ¡†æ¶
        class AIDecisionQualityEvaluator {
          async evaluateDecisionQuality(decisions: AIDecision[]): Promise<QualityScore> {
            const scores = await Promise.all(decisions.map(decision => 
              this.scoreIndividualDecision(decision)
            ));
            
            return {
              overallScore: scores.reduce((sum, score) => sum + score, 0) / scores.length,
              categoryScores: {
                rationality: this.calculateRationalityScore(decisions),
                consistency: this.calculateConsistencyScore(decisions),
                efficiency: this.calculateEfficiencyScore(decisions),
                creativity: this.calculateCreativityScore(decisions)
              },
              recommendations: this.generateRecommendations(scores)
            };
          }
          
          private async scoreIndividualDecision(decision: AIDecision): Promise<number> {
            // åŸºäºæ¸¸æˆè§„åˆ™å’Œæœ€ä½³å®è·µè¯„ä¼°å†³ç­–è´¨é‡
            const contextScore = this.evaluateContextualAppropriateness(decision);
            const outcomeScore = this.evaluateExpectedOutcome(decision);
            const efficiencyScore = this.evaluateResourceEfficiency(decision);
            
            return (contextScore + outcomeScore + efficiencyScore) / 3;
          }
        }
      `,
      è´¨é‡ç›‘æ§æŒ‡æ ‡: `
        export interface AIQualityMetrics {
          rationality: number;    // å†³ç­–é€»è¾‘åˆç†æ€§
          consistency: number;    // å†³ç­–ä¸€è‡´æ€§
          efficiency: number;     // èµ„æºä½¿ç”¨æ•ˆç‡
          creativity: number;     // ç­–ç•¥åˆ›æ–°æ€§
          responsiveness: number; // ç¯å¢ƒé€‚åº”æ€§
        }
      `,
      æˆåŠŸæ ‡å‡†: 'AIå†³ç­–è´¨é‡ä¿æŒåœ¨é¢„æœŸæ°´å¹³',
      å¤±è´¥å¤„ç†: 'å‘å‡ºè­¦å‘Šï¼Œè®°å½•è´¨é‡ä¸‹é™è¶‹åŠ¿',
    },
  },

  {
    key: 'ai_behavioral_consistency_monitoring',
    name: 'AIè¡Œä¸ºä¸€è‡´æ€§ç›‘æ§',
    tier: 2,
    description: 'ç›‘æ§AIå®ä½“è¡Œä¸ºæ¨¡å¼çš„ä¸€è‡´æ€§å’Œå¯é¢„æµ‹æ€§',
    sli: 'AIè¡Œä¸ºæ¨¡å¼çš„å˜å¼‚ç³»æ•°',
    slo: 'è¡Œä¸ºæ¨¡å¼å˜å¼‚ç³»æ•° < 0.15',
    source: 'AIè¡Œä¸ºæ¨¡å¼åˆ†æå™¨',
    blockingLevel: 'WARNING_ONLY',
    testScript: 'tests/ai-quality/behavioral-consistency.spec.ts',
    automatedCheck: true,

    implementation: {
      è¡Œä¸ºæ¨¡å¼åˆ†æ: `
        // AIè¡Œä¸ºæ¨¡å¼ä¸€è‡´æ€§åˆ†æ
        class AIBehavioralConsistencyAnalyzer {
          analyzeConsistency(behaviorLog: AIBehaviorLog[]): ConsistencyReport {
            const patterns = this.extractBehaviorPatterns(behaviorLog);
            const consistency = this.calculateConsistencyScore(patterns);
            
            return {
              overallConsistency: consistency.overall,
              patternStability: consistency.patterns,
              outlierDetection: this.detectOutliers(behaviorLog),
              trendAnalysis: this.analyzeTrends(behaviorLog),
              recommendations: this.generateConsistencyRecommendations(consistency)
            };
          }
          
          private extractBehaviorPatterns(log: AIBehaviorLog[]): BehaviorPattern[] {
            // æå–AIè¡Œä¸ºæ¨¡å¼
            return log.reduce((patterns, entry) => {
              const pattern = this.identifyPattern(entry);
              const existing = patterns.find(p => p.type === pattern.type);
              
              if (existing) {
                existing.frequency += 1;
                existing.contexts.push(entry.context);
              } else {
                patterns.push({
                  type: pattern.type,
                  frequency: 1,
                  contexts: [entry.context],
                  parameters: pattern.parameters
                });
              }
              
              return patterns;
            }, [] as BehaviorPattern[]);
          }
        }
      `,
      æˆåŠŸæ ‡å‡†: 'AIè¡Œä¸ºæ¨¡å¼ä¿æŒç¨³å®šä¸€è‡´',
      å¤±è´¥å¤„ç†: 'å‘å‡ºè¡Œä¸ºå¼‚å¸¸è­¦å‘Šï¼Œè®°å½•å˜åŒ–è¶‹åŠ¿',
    },
  },
];
```

### 10.3 Web Workerç¯å¢ƒä¸“ç”¨æµ‹è¯•ç­–ç•¥

#### 10.3.1 è·¨çº¿ç¨‹é€šä¿¡æµ‹è¯•æ¡†æ¶

```typescript
// Web Workerç¯å¢ƒä¸“ç”¨çš„AIæµ‹è¯•æ¡†æ¶
export class AIWorkerTestFramework {
  private workerPool: AIWorkerPool;
  private testReporter: TestReporter;

  constructor() {
    this.workerPool = new AIWorkerPool({
      maxWorkers: 4,
      taskTimeout: 5000,
      retryAttempts: 3,
    });
    this.testReporter = new TestReporter();
  }

  // è·¨çº¿ç¨‹çŠ¶æ€åŒæ­¥æµ‹è¯•
  async testCrossThreadStateSynchronization(): Promise<TestResult> {
    const testCases = [
      { name: 'åŸºç¡€çŠ¶æ€åŒæ­¥', entities: 10, complexity: 'low' },
      { name: 'ä¸­ç­‰è´Ÿè½½åŒæ­¥', entities: 25, complexity: 'medium' },
      { name: 'é«˜è´Ÿè½½åŒæ­¥', entities: 50, complexity: 'high' },
    ];

    const results = await Promise.all(
      testCases.map(testCase => this.runStateSyncTest(testCase))
    );

    return this.testReporter.aggregateResults(results);
  }

  // æ¶ˆæ¯ä¼ é€’æ€§èƒ½æµ‹è¯•
  async testMessagePassingPerformance(): Promise<PerformanceTestResult> {
    const messageSizes = [1024, 4096, 16384, 65536]; // bytes
    const messageTypes = ['decision-request', 'state-update', 'batch-process'];

    const performanceData = [];

    for (const size of messageSizes) {
      for (const type of messageTypes) {
        const testData = await this.measureMessagePerformance({
          messageSize: size,
          messageType: type,
          iterations: 100,
        });

        performanceData.push({
          messageSize: size,
          messageType: type,
          averageLatency: testData.averageLatency,
          throughput: testData.throughput,
          errorRate: testData.errorRate,
        });
      }
    }

    return {
      performanceData,
      summary: this.analyzePerformanceData(performanceData),
      recommendations: this.generatePerformanceRecommendations(performanceData),
    };
  }

  // é”™è¯¯æ¢å¤èƒ½åŠ›æµ‹è¯•
  async testErrorRecoveryCapabilities(): Promise<RecoveryTestResult> {
    const errorScenarios = [
      {
        name: 'Workerå´©æºƒ',
        trigger: () => this.simulateWorkerCrash(),
        expectedRecoveryTime: 100, // ms
      },
      {
        name: 'å†…å­˜ä¸è¶³',
        trigger: () => this.simulateMemoryPressure(),
        expectedRecoveryTime: 200,
      },
      {
        name: 'é€šä¿¡è¶…æ—¶',
        trigger: () => this.simulateCommTimeout(),
        expectedRecoveryTime: 150,
      },
    ];

    const recoveryResults = [];

    for (const scenario of errorScenarios) {
      const startTime = performance.now();

      // è§¦å‘é”™è¯¯åœºæ™¯
      await scenario.trigger();

      // ç­‰å¾…æ¢å¤
      const recovered = await this.waitForRecovery();
      const recoveryTime = performance.now() - startTime;

      recoveryResults.push({
        scenario: scenario.name,
        recovered,
        recoveryTime,
        withinExpectedTime: recoveryTime <= scenario.expectedRecoveryTime,
        additionalMetrics: await this.collectRecoveryMetrics(),
      });
    }

    return {
      results: recoveryResults,
      overallSuccessRate:
        recoveryResults.filter(r => r.recovered).length /
        recoveryResults.length,
      averageRecoveryTime:
        recoveryResults.reduce((sum, r) => sum + r.recoveryTime, 0) /
        recoveryResults.length,
    };
  }
}
```

#### 10.3.2 AIå†³ç­–ç¡®å®šæ€§éªŒè¯å·¥å…·

```typescript
// AIå†³ç­–ç¡®å®šæ€§éªŒè¯å·¥å…·é›†
export class AIDeterminismValidator {
  private seedManager: DeterministicSeedManager;
  private stateHasher: GameStateHasher;
  private decisionRecorder: AIDecisionRecorder;

  constructor() {
    this.seedManager = new DeterministicSeedManager();
    this.stateHasher = new GameStateHasher();
    this.decisionRecorder = new AIDecisionRecorder();
  }

  // ç§å­é”å®šçš„ç¡®å®šæ€§æµ‹è¯•
  async validateDeterministicBehavior(
    config: DeterminismTestConfig
  ): Promise<DeterminismTestResult> {
    const { seedCount, iterationsPerSeed, gameLength } = config;
    const testResults = [];

    for (let seed = 1; seed <= seedCount; seed++) {
      const seedResults = [];

      // å¯¹æ¯ä¸ªç§å­è¿è¡Œå¤šæ¬¡æµ‹è¯•
      for (let iteration = 1; iteration <= iterationsPerSeed; iteration++) {
        const gameResult = await this.runDeterministicGame({
          seed,
          length: gameLength,
          aiEntities: 50,
        });

        seedResults.push({
          iteration,
          finalStateHash: this.stateHasher.hashGameState(gameResult.finalState),
          decisionSequenceHash: this.stateHasher.hashDecisionSequence(
            gameResult.decisions
          ),
          performanceMetrics: gameResult.performance,
        });
      }

      // éªŒè¯ç§å­ä¸€è‡´æ€§
      const consistency = this.validateSeedConsistency(seedResults);
      testResults.push({
        seed,
        consistency,
        results: seedResults,
      });
    }

    return {
      overallConsistency: this.calculateOverallConsistency(testResults),
      seedResults: testResults,
      issues: this.identifyConsistencyIssues(testResults),
      recommendations: this.generateDeterminismRecommendations(testResults),
    };
  }

  // çŠ¶æ€å¿«ç…§ä¸å›æ”¾éªŒè¯
  async validateStateReplayability(
    replayConfig: ReplayTestConfig
  ): Promise<ReplayTestResult> {
    const originalGame = await this.runGame(replayConfig.gameConfig);

    // åˆ›å»ºçŠ¶æ€å¿«ç…§
    const snapshots = this.createStateSnapshots(
      originalGame,
      replayConfig.snapshotInterval
    );

    // ä»æ¯ä¸ªå¿«ç…§ç‚¹å›æ”¾æ¸¸æˆ
    const replayResults = [];

    for (const snapshot of snapshots) {
      const replayGame = await this.replayFromSnapshot(
        snapshot,
        replayConfig.replayLength
      );

      replayResults.push({
        snapshotTick: snapshot.tick,
        replaySuccess: this.validateReplayConsistency(
          originalGame,
          replayGame,
          snapshot
        ),
        deviations: this.measureReplayDeviations(
          originalGame,
          replayGame,
          snapshot
        ),
        performance: replayGame.performance,
      });
    }

    return {
      replaySuccessRate:
        replayResults.filter(r => r.replaySuccess).length /
        replayResults.length,
      maxDeviation: Math.max(
        ...replayResults.map(r => r.deviations.maxDeviation)
      ),
      averageDeviation:
        replayResults.reduce(
          (sum, r) => sum + r.deviations.averageDeviation,
          0
        ) / replayResults.length,
      results: replayResults,
    };
  }
}

// ç¡®å®šæ€§éšæœºæ•°ç®¡ç†å™¨
export class DeterministicSeedManager {
  private rngState: number;
  private seedHistory: number[] = [];

  setSeed(seed: number): void {
    this.rngState = seed;
    this.seedHistory.push(seed);
  }

  next(): number {
    // çº¿æ€§åŒä½™ç”Ÿæˆå™¨ï¼Œç¡®ä¿ç¡®å®šæ€§
    this.rngState = (this.rngState * 1664525 + 1013904223) % Math.pow(2, 32);
    return this.rngState / Math.pow(2, 32);
  }

  nextInt(min: number, max: number): number {
    return Math.floor(this.next() * (max - min + 1)) + min;
  }

  nextFloat(min: number, max: number): number {
    return this.next() * (max - min) + min;
  }

  getState(): number {
    return this.rngState;
  }

  restoreState(state: number): void {
    this.rngState = state;
  }

  // éªŒè¯éšæœºæ•°ç”Ÿæˆå™¨çš„ç¡®å®šæ€§
  validateDeterminism(): boolean {
    const testSeed = 12345;
    const testCount = 1000;

    // ç¬¬ä¸€æ¬¡ç”Ÿæˆ
    this.setSeed(testSeed);
    const sequence1 = Array.from({ length: testCount }, () => this.next());

    // ç¬¬äºŒæ¬¡ç”Ÿæˆ
    this.setSeed(testSeed);
    const sequence2 = Array.from({ length: testCount }, () => this.next());

    // éªŒè¯å®Œå…¨ä¸€è‡´
    return sequence1.every((value, index) => value === sequence2[index]);
  }
}
```

### 10.4 AIæ€§èƒ½ç›‘æ§ä¸è°ƒè¯•å·¥å…·

#### 10.4.1 AIæ€§èƒ½ä»ªè¡¨æ¿

```typescript
// AIæ€§èƒ½å®æ—¶ç›‘æ§ä»ªè¡¨æ¿
export class AIPerformanceDashboard {
  private metricsCollector: AIMetricsCollector;
  private alertManager: AlertManager;
  private dataVisualization: DataVisualization;

  constructor() {
    this.metricsCollector = new AIMetricsCollector({
      samplingInterval: 1000, // 1ç§’é‡‡æ ·
      metricRetentionDays: 30,
      alertThresholds: AI_PERFORMANCE_THRESHOLDS,
    });

    this.alertManager = new AlertManager();
    this.dataVisualization = new DataVisualization();
  }

  // å®æ—¶æ€§èƒ½ç›‘æ§
  startRealTimeMonitoring(): void {
    setInterval(() => {
      this.collectPerformanceMetrics();
      this.updateDashboard();
      this.checkAlertConditions();
    }, 1000);
  }

  private async collectPerformanceMetrics(): Promise<AIPerformanceMetrics> {
    const currentMetrics = {
      // AIå†³ç­–æ€§èƒ½
      decisionLatency: {
        tp50: await this.metricsCollector.getDecisionLatencyTP50(),
        tp95: await this.metricsCollector.getDecisionLatencyTP95(),
        tp99: await this.metricsCollector.getDecisionLatencyTP99(),
        max: await this.metricsCollector.getDecisionLatencyMax(),
      },

      // å¹¶å‘å¤„ç†æ€§èƒ½
      concurrentProcessing: {
        activeEntities: await this.metricsCollector.getActiveAIEntities(),
        processingThroughput:
          await this.metricsCollector.getProcessingThroughput(),
        queueDepth: await this.metricsCollector.getDecisionQueueDepth(),
        workerUtilization: await this.metricsCollector.getWorkerUtilization(),
      },

      // å†…å­˜ä½¿ç”¨æƒ…å†µ
      memoryUsage: {
        totalHeapUsed: await this.metricsCollector.getTotalHeapUsed(),
        aiEntityMemory: await this.metricsCollector.getAIEntityMemoryUsage(),
        workerMemory: await this.metricsCollector.getWorkerMemoryUsage(),
        memoryGrowthRate: await this.metricsCollector.getMemoryGrowthRate(),
      },

      // é”™è¯¯å’Œæ¢å¤æŒ‡æ ‡
      reliability: {
        errorRate: await this.metricsCollector.getAIErrorRate(),
        recoverySuccessRate:
          await this.metricsCollector.getRecoverySuccessRate(),
        averageRecoveryTime:
          await this.metricsCollector.getAverageRecoveryTime(),
        workerRestartCount: await this.metricsCollector.getWorkerRestartCount(),
      },

      // ä¸€è‡´æ€§æŒ‡æ ‡
      consistency: {
        determinismScore: await this.metricsCollector.getDeterminismScore(),
        stateDeviationRate: await this.metricsCollector.getStateDeviationRate(),
        replaySuccessRate: await this.metricsCollector.getReplaySuccessRate(),
        sequenceConsistencyScore:
          await this.metricsCollector.getSequenceConsistencyScore(),
      },
    };

    return currentMetrics;
  }

  private checkAlertConditions(): void {
    const metrics = this.metricsCollector.getLatestMetrics();

    // æ£€æŸ¥æ€§èƒ½è­¦å‘Šé˜ˆå€¼
    if (
      metrics.decisionLatency.tp95 >
      AI_PERFORMANCE_THRESHOLDS.DECISION_LATENCY_TP95_WARNING
    ) {
      this.alertManager.triggerAlert({
        level: 'WARNING',
        type: 'AI_PERFORMANCE_DEGRADATION',
        message: `AIå†³ç­–å»¶è¿ŸTP95 (${metrics.decisionLatency.tp95}ms) è¶…è¿‡è­¦å‘Šé˜ˆå€¼`,
        metrics: metrics.decisionLatency,
        recommendations: ['æ£€æŸ¥Workerè´Ÿè½½', 'ä¼˜åŒ–å†³ç­–ç®—æ³•', 'å¢åŠ Workeræ•°é‡'],
      });
    }

    // æ£€æŸ¥ä¸¥é‡é˜ˆå€¼
    if (
      metrics.decisionLatency.tp95 >
      AI_PERFORMANCE_THRESHOLDS.DECISION_LATENCY_TP95_CRITICAL
    ) {
      this.alertManager.triggerAlert({
        level: 'CRITICAL',
        type: 'AI_PERFORMANCE_CRITICAL',
        message: `AIå†³ç­–å»¶è¿ŸTP95 (${metrics.decisionLatency.tp95}ms) è¶…è¿‡ä¸¥é‡é˜ˆå€¼`,
        metrics: metrics.decisionLatency,
        recommendations: [
          'ç«‹å³æ£€æŸ¥ç³»ç»Ÿè´Ÿè½½',
          'é‡å¯AI Workeræ± ',
          'é™çº§AIå¤æ‚åº¦',
        ],
      });
    }

    // æ£€æŸ¥ä¸€è‡´æ€§é—®é¢˜
    if (
      metrics.consistency.determinismScore <
      AI_CONSISTENCY_THRESHOLDS.DETERMINISM_SCORE_WARNING
    ) {
      this.alertManager.triggerAlert({
        level: 'WARNING',
        type: 'AI_CONSISTENCY_ISSUE',
        message: `AIç¡®å®šæ€§è¯„åˆ† (${metrics.consistency.determinismScore}) ä½äºé¢„æœŸ`,
        metrics: metrics.consistency,
        recommendations: [
          'æ£€æŸ¥éšæœºæ•°ç§å­ç®¡ç†',
          'éªŒè¯çŠ¶æ€åŒæ­¥æœºåˆ¶',
          'åˆ†æå†³ç­–åºåˆ—ä¸€è‡´æ€§',
        ],
      });
    }
  }
}

// AIæ€§èƒ½é˜ˆå€¼é…ç½®
export const AI_PERFORMANCE_THRESHOLDS = {
  // å†³ç­–å»¶è¿Ÿé˜ˆå€¼ (æ¯«ç§’)
  DECISION_LATENCY_TP95_WARNING: 75,
  DECISION_LATENCY_TP95_CRITICAL: 100,
  DECISION_LATENCY_TP99_WARNING: 125,
  DECISION_LATENCY_TP99_CRITICAL: 150,

  // å†…å­˜ä½¿ç”¨é˜ˆå€¼
  MEMORY_GROWTH_RATE_WARNING: 0.15, // 15%
  MEMORY_GROWTH_RATE_CRITICAL: 0.25, // 25%
  TOTAL_MEMORY_WARNING: 512 * 1024 * 1024, // 512MB
  TOTAL_MEMORY_CRITICAL: 768 * 1024 * 1024, // 768MB

  // å¹¶å‘å¤„ç†é˜ˆå€¼
  QUEUE_DEPTH_WARNING: 100,
  QUEUE_DEPTH_CRITICAL: 200,
  WORKER_UTILIZATION_WARNING: 0.8, // 80%
  WORKER_UTILIZATION_CRITICAL: 0.95, // 95%

  // é”™è¯¯ç‡é˜ˆå€¼
  ERROR_RATE_WARNING: 0.01, // 1%
  ERROR_RATE_CRITICAL: 0.05, // 5%

  // ä¸€è‡´æ€§é˜ˆå€¼
  DETERMINISM_SCORE_WARNING: 0.98, // 98%
  DETERMINISM_SCORE_CRITICAL: 0.95, // 95%
  STATE_DEVIATION_WARNING: 0.02, // 2%
  STATE_DEVIATION_CRITICAL: 0.05, // 5%
};

// AIä¸€è‡´æ€§é˜ˆå€¼é…ç½®
export const AI_CONSISTENCY_THRESHOLDS = {
  DETERMINISM_SCORE_WARNING: 0.98,
  DETERMINISM_SCORE_CRITICAL: 0.95,
  STATE_DEVIATION_WARNING: 0.02,
  STATE_DEVIATION_CRITICAL: 0.05,
  REPLAY_SUCCESS_RATE_WARNING: 0.95,
  REPLAY_SUCCESS_RATE_CRITICAL: 0.9,
};
```

#### 10.4.2 AIå†³ç­–å›æ”¾ä¸è°ƒè¯•ç³»ç»Ÿ

```typescript
// AIå†³ç­–å›æ”¾ä¸è°ƒè¯•ç³»ç»Ÿ
export class AIDecisionReplaySystem {
  private stateCapture: GameStateCapture;
  private decisionLogger: AIDecisionLogger;
  private replayEngine: GameReplayEngine;
  private debugInterface: AIDebugInterface;

  constructor() {
    this.stateCapture = new GameStateCapture({
      captureInterval: 10, // æ¯10ä¸ªtickæ•è·ä¸€æ¬¡çŠ¶æ€
      maxHistoryLength: 1000,
      compressionEnabled: true,
    });

    this.decisionLogger = new AIDecisionLogger();
    this.replayEngine = new GameReplayEngine();
    this.debugInterface = new AIDebugInterface();
  }

  // å¼€å§‹è®°å½•AIå†³ç­–è¿‡ç¨‹
  startRecording(gameSession: GameSession): void {
    this.stateCapture.startCapture(gameSession);
    this.decisionLogger.startLogging(gameSession);
  }

  // åœæ­¢è®°å½•å¹¶ä¿å­˜
  stopRecording(): GameReplayData {
    const stateHistory = this.stateCapture.stopCapture();
    const decisionHistory = this.decisionLogger.stopLogging();

    return {
      stateSnapshots: stateHistory,
      decisionLog: decisionHistory,
      metadata: {
        sessionId: generateSessionId(),
        timestamp: Date.now(),
        gameVersion: getGameVersion(),
        aiVersion: getAIVersion(),
      },
    };
  }

  // ä»ç‰¹å®šæ—¶é—´ç‚¹å›æ”¾æ¸¸æˆ
  async replayFromTimestamp(
    replayData: GameReplayData,
    fromTimestamp: number,
    toTimestamp?: number
  ): Promise<ReplayResult> {
    // æ‰¾åˆ°æœ€è¿‘çš„çŠ¶æ€å¿«ç…§
    const nearestSnapshot = this.findNearestSnapshot(
      replayData.stateSnapshots,
      fromTimestamp
    );

    // ä»å¿«ç…§çŠ¶æ€å¼€å§‹å›æ”¾
    this.replayEngine.loadSnapshot(nearestSnapshot);

    // åº”ç”¨å†³ç­–åºåˆ—
    const relevantDecisions = this.extractDecisionsInRange(
      replayData.decisionLog,
      fromTimestamp,
      toTimestamp
    );

    const replayResult =
      await this.replayEngine.executeDecisionSequence(relevantDecisions);

    return {
      replaySuccess: replayResult.success,
      finalState: replayResult.finalState,
      performanceMetrics: replayResult.performance,
      deviations: this.compareWithOriginal(replayData, replayResult),
      debugInfo: this.generateDebugInfo(replayResult),
    };
  }

  // AIå†³ç­–è°ƒè¯•æ¥å£
  async debugAIDecision(
    decisionId: string,
    context: AIDecisionContext
  ): Promise<AIDecisionDebugInfo> {
    const decision = await this.decisionLogger.getDecision(decisionId);
    const debugInfo = await this.debugInterface.analyzeDecision(
      decision,
      context
    );

    return {
      decision,
      context,
      analysis: {
        inputFactors: debugInfo.inputAnalysis,
        decisionProcess: debugInfo.processAnalysis,
        outputRationale: debugInfo.outputAnalysis,
        alternativeOptions: debugInfo.alternatives,
        qualityScore: debugInfo.qualityScore,
      },
      visualization: await this.generateDecisionVisualization(
        decision,
        context
      ),
      recommendations: debugInfo.recommendations,
    };
  }

  // æ‰¹é‡åˆ†æAIå†³ç­–æ¨¡å¼
  async analyzeDecisionPatterns(
    timeRange: TimeRange,
    entityIds?: string[]
  ): Promise<AIDecisionPatternAnalysis> {
    const decisions = await this.decisionLogger.getDecisionsInRange(
      timeRange,
      entityIds
    );

    const patterns = {
      frequentPatterns: this.identifyFrequentPatterns(decisions),
      anomalies: this.detectDecisionAnomalies(decisions),
      performance: this.analyzeDecisionPerformance(decisions),
      consistency: this.analyzeDecisionConsistency(decisions),
      trends: this.analyzeDecisionTrends(decisions),
    };

    return {
      patterns,
      insights: this.generatePatternInsights(patterns),
      recommendations: this.generateOptimizationRecommendations(patterns),
      visualizations: await this.generatePatternVisualizations(patterns),
    };
  }
}

// AIè°ƒè¯•æ¥å£é…ç½®
export interface AIDebugConfig {
  // æ—¥å¿—è¯¦ç»†ç¨‹åº¦
  logLevel: 'minimal' | 'standard' | 'detailed' | 'verbose';

  // çŠ¶æ€æ•è·é…ç½®
  stateCapture: {
    interval: number;
    compressionLevel: 0 | 1 | 2 | 3;
    retentionDays: number;
  };

  // å†³ç­–åˆ†æé…ç½®
  decisionAnalysis: {
    enableRealTimeAnalysis: boolean;
    performanceThresholds: {
      slowDecisionMs: number;
      anomalyDetectionSensitivity: number;
    };
    qualityMetrics: {
      rationalityWeight: number;
      consistencyWeight: number;
      efficiencyWeight: number;
    };
  };

  // å¯è§†åŒ–é…ç½®
  visualization: {
    enableRealTimeCharts: boolean;
    chartUpdateInterval: number;
    maxDataPoints: number;
  };
}
```

### 10.5 å®æ–½è·¯å¾„ä¸éƒ¨ç½²æŒ‡å¯¼

#### 10.5.1 åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

```typescript
// AIå¹¶å‘ä¸€è‡´æ€§é—¨ç¦å®æ–½è·¯å¾„
export const AI_CONSISTENCY_IMPLEMENTATION_ROADMAP = {
  // Phase 1: åŸºç¡€æ¡†æ¶æ­å»º (2å‘¨)
  phase1_foundation: {
    duration: '2 weeks',
    priority: 'P0',
    deliverables: [
      {
        task: 'æ­å»ºAIä¸€è‡´æ€§æµ‹è¯•æ¡†æ¶',
        description: 'å»ºç«‹åŸºç¡€çš„ç§å­ç®¡ç†å’ŒçŠ¶æ€éªŒè¯æœºåˆ¶',
        acceptance: [
          'ç¡®å®šæ€§éšæœºæ•°ç”Ÿæˆå™¨å®ç°å®Œæˆ',
          'åŸºç¡€çŠ¶æ€å“ˆå¸Œè®¡ç®—åŠŸèƒ½å¯ç”¨',
          'ç®€å•çš„ç§å­æµ‹è¯•ç”¨ä¾‹é€šè¿‡',
        ],
      },
      {
        task: 'å®ç°Web Workeræµ‹è¯•ç¯å¢ƒ',
        description: 'å»ºç«‹AI Workeræ± çš„æµ‹è¯•å’Œç›‘æ§åŸºç¡€è®¾æ–½',
        acceptance: [
          'AI Workeræ± æµ‹è¯•æ¡†æ¶æ­å»ºå®Œæˆ',
          'åŸºç¡€æ€§èƒ½ç›‘æ§æŒ‡æ ‡å¯æ”¶é›†',
          'Workerçº¿ç¨‹çš„å¯åŠ¨å’Œå…³é—­æœºåˆ¶æ­£å¸¸',
        ],
      },
    ],

    successCriteria: [
      'åŸºç¡€æµ‹è¯•æ¡†æ¶å¯è¿è¡Œç®€å•çš„ä¸€è‡´æ€§æµ‹è¯•',
      'Web Workerç¯å¢ƒå¯æ­£å¸¸å¯åŠ¨å’Œç›‘æ§',
      'å›¢é˜Ÿç†Ÿæ‚‰æ–°çš„æµ‹è¯•å·¥å…·å’Œæµç¨‹',
    ],
  },

  // Phase 2: æ ¸å¿ƒé—¨ç¦å¼€å‘ (3å‘¨)
  phase2_core_gates: {
    duration: '3 weeks',
    priority: 'P0',
    deliverables: [
      {
        task: 'å®ç°Tier-0ä¸€è‡´æ€§é—¨ç¦',
        description: 'å¼€å‘ç¡®å®šæ€§å†ç°æ€§å’Œå†³ç­–æ—¶åºä¸€è‡´æ€§éªŒè¯',
        acceptance: [
          'ç§å­é”å®šæµ‹è¯•é€šè¿‡ç‡100%',
          'å†³ç­–åºåˆ—ä¸€è‡´æ€§éªŒè¯åŠŸèƒ½æ­£å¸¸',
          'æ‰€æœ‰Tier-0é—¨ç¦é›†æˆåˆ°CI/CD',
        ],
      },
      {
        task: 'å®ç°Tier-1æ€§èƒ½é—¨ç¦',
        description: 'å¼€å‘å¹¶å‘å¤„ç†èƒ½åŠ›å’Œå†…å­˜ç¨³å®šæ€§éªŒè¯',
        acceptance: [
          '50+AIå®ä½“å¹¶å‘æµ‹è¯•é€šè¿‡',
          'å†…å­˜æ³„æ¼æ£€æµ‹æœºåˆ¶æœ‰æ•ˆ',
          'é”™è¯¯æ¢å¤æµ‹è¯•è¦†ç›–ä¸»è¦åœºæ™¯',
        ],
      },
    ],

    successCriteria: [
      'æ‰€æœ‰æ ¸å¿ƒé—¨ç¦åŠŸèƒ½æ­£å¸¸è¿è¡Œ',
      'CI/CDæµæ°´çº¿é›†æˆå®Œæˆ',
      'é—¨ç¦å¤±è´¥æ—¶æœ‰æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œä¿®å¤æŒ‡å¯¼',
    ],
  },

  // Phase 3: ç›‘æ§å·¥å…·é›†æˆ (2å‘¨)
  phase3_monitoring: {
    duration: '2 weeks',
    priority: 'P1',
    deliverables: [
      {
        task: 'éƒ¨ç½²AIæ€§èƒ½ä»ªè¡¨æ¿',
        description: 'å»ºç«‹å®æ—¶AIæ€§èƒ½ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ',
        acceptance: [
          'AIæ€§èƒ½æŒ‡æ ‡å®æ—¶å¯è§†åŒ–',
          'å‘Šè­¦æœºåˆ¶æ­£å¸¸å·¥ä½œ',
          'å†å²æ•°æ®å¯æŸ¥è¯¢å’Œåˆ†æ',
        ],
      },
      {
        task: 'é›†æˆå†³ç­–å›æ”¾ç³»ç»Ÿ',
        description: 'å®ç°AIå†³ç­–çš„è®°å½•ã€å›æ”¾å’Œè°ƒè¯•åŠŸèƒ½',
        acceptance: [
          'å†³ç­–è¿‡ç¨‹å¯å®Œæ•´è®°å½•',
          'çŠ¶æ€å›æ”¾åŠŸèƒ½æ­£å¸¸',
          'è°ƒè¯•æ¥å£æ˜“äºä½¿ç”¨',
        ],
      },
    ],

    successCriteria: [
      'å¼€å‘å›¢é˜Ÿå¯é€šè¿‡ä»ªè¡¨æ¿ç›‘æ§AIç³»ç»Ÿå¥åº·åº¦',
      'é—®é¢˜å‘ç”Ÿæ—¶å¯å¿«é€Ÿå®šä½å’Œè°ƒè¯•',
      'æ€§èƒ½è¶‹åŠ¿åˆ†ææœ‰åŠ©äºä¼˜åŒ–å†³ç­–',
    ],
  },

  // Phase 4: ä¼˜åŒ–ä¸è°ƒä¼˜ (1å‘¨)
  phase4_optimization: {
    duration: '1 week',
    priority: 'P1',
    deliverables: [
      {
        task: 'æ€§èƒ½é˜ˆå€¼è°ƒä¼˜',
        description: 'åŸºäºå®é™…è¿è¡Œæ•°æ®ä¼˜åŒ–é—¨ç¦é˜ˆå€¼',
        acceptance: [
          'é—¨ç¦é˜ˆå€¼è®¾ç½®ç§‘å­¦åˆç†',
          'è¯¯æŠ¥ç‡æ§åˆ¶åœ¨å¯æ¥å—èŒƒå›´',
          'é—¨ç¦è¦†ç›–åº¦è¾¾åˆ°è®¾è®¡ç›®æ ‡',
        ],
      },
      {
        task: 'æ–‡æ¡£å’ŒåŸ¹è®­',
        description: 'å®Œå–„æ–‡æ¡£å¹¶åŸ¹è®­å›¢é˜Ÿä½¿ç”¨',
        acceptance: ['æ“ä½œæ–‡æ¡£å®Œæ•´æ¸…æ™°', 'å›¢é˜ŸåŸ¹è®­å®Œæˆ', 'æ•…éšœæ’é™¤æ‰‹å†Œå¯ç”¨'],
      },
    ],

    successCriteria: [
      'æ•´ä¸ªAIä¸€è‡´æ€§é—¨ç¦ç³»ç»Ÿç¨³å®šè¿è¡Œ',
      'å›¢é˜Ÿèƒ½å¤Ÿç†Ÿç»ƒä½¿ç”¨æ‰€æœ‰å·¥å…·',
      'ç³»ç»Ÿæ»¡è¶³è®¾è®¡çš„æ‰€æœ‰æŠ€æœ¯è¦æ±‚',
    ],
  },
};
```

#### 10.5.2 éƒ¨ç½²é…ç½®ä¸è¿ç»´æŒ‡å¯¼

```typescript
// AIä¸€è‡´æ€§é—¨ç¦ç³»ç»Ÿéƒ¨ç½²é…ç½®
export const AI_CONSISTENCY_DEPLOYMENT_CONFIG = {
  // å¼€å‘ç¯å¢ƒé…ç½®
  development: {
    aiWorkerConfig: {
      maxWorkers: 2,
      taskTimeout: 10000,
      retryAttempts: 1,
      debugMode: true,
    },

    monitoringConfig: {
      metricsRetentionDays: 7,
      samplingInterval: 5000,
      alertsEnabled: false,
      verboseLogging: true,
    },

    gateConfig: {
      enableAllGates: true,
      relaxedThresholds: true,
      skipLongRunningTests: false,
    },
  },

  // æµ‹è¯•ç¯å¢ƒé…ç½®
  testing: {
    aiWorkerConfig: {
      maxWorkers: 4,
      taskTimeout: 5000,
      retryAttempts: 3,
      debugMode: false,
    },

    monitoringConfig: {
      metricsRetentionDays: 14,
      samplingInterval: 1000,
      alertsEnabled: true,
      verboseLogging: false,
    },

    gateConfig: {
      enableAllGates: true,
      relaxedThresholds: false,
      skipLongRunningTests: false,
    },
  },

  // ç”Ÿäº§ç¯å¢ƒé…ç½®
  production: {
    aiWorkerConfig: {
      maxWorkers: 6,
      taskTimeout: 3000,
      retryAttempts: 3,
      debugMode: false,
    },

    monitoringConfig: {
      metricsRetentionDays: 30,
      samplingInterval: 1000,
      alertsEnabled: true,
      verboseLogging: false,
    },

    gateConfig: {
      enableAllGates: true,
      relaxedThresholds: false,
      skipLongRunningTests: true, // ç”Ÿäº§ç¯å¢ƒè·³è¿‡è€—æ—¶é•¿çš„æµ‹è¯•
    },
  },
};

// è¿ç»´ç›‘æ§é…ç½®
export const AI_CONSISTENCY_OPERATIONS_CONFIG = {
  // å¥åº·æ£€æŸ¥é…ç½®
  healthCheck: {
    interval: 30000, // 30ç§’
    timeout: 5000, // 5ç§’è¶…æ—¶
    endpoints: [
      '/health/ai-workers',
      '/health/consistency-gates',
      '/health/monitoring-dashboard',
    ],

    criticalThresholds: {
      workerAvailability: 0.8, // 80%çš„Workerå¿…é¡»å¯ç”¨
      gatePassRate: 0.95, // 95%çš„é—¨ç¦å¿…é¡»é€šè¿‡
      responseTime: 1000, // å¥åº·æ£€æŸ¥å“åº”æ—¶é—´<1ç§’
    },
  },

  // å‘Šè­¦é…ç½®
  alerting: {
    channels: ['email', 'slack', 'sentry'],
    escalationPolicy: {
      warning: {
        delay: 300, // 5åˆ†é’Ÿåå‡çº§
        retries: 3,
      },
      critical: {
        delay: 60, // 1åˆ†é’Ÿåå‡çº§
        retries: 5,
      },
    },

    suppressionRules: [
      {
        condition: 'maintenance_mode',
        duration: 3600, // ç»´æŠ¤æ¨¡å¼ä¸‹1å°æ—¶å†…æŠ‘åˆ¶å‘Šè­¦
      },
    ],
  },

  // æ•°æ®å¤‡ä»½é…ç½®
  backup: {
    metricsData: {
      schedule: '0 2 * * *', // æ¯æ—¥å‡Œæ™¨2ç‚¹
      retention: '90d',
      compression: true,
    },

    replayData: {
      schedule: '0 3 * * 0', // æ¯å‘¨æ—¥å‡Œæ™¨3ç‚¹
      retention: '30d',
      encryption: true,
    },
  },
};
```

### 10.6 æˆåŠŸæ ‡å‡†ä¸éªŒæ”¶å‡†åˆ™

#### 10.6.1 æŠ€æœ¯éªŒæ”¶æ ‡å‡†

```typescript
// AIå¹¶å‘ä¸€è‡´æ€§é—¨ç¦ç³»ç»ŸéªŒæ”¶æ ‡å‡†
export const AI_CONSISTENCY_ACCEPTANCE_CRITERIA = {
  // åŠŸèƒ½æ€§éªŒæ”¶æ ‡å‡†
  functional: {
    determinismValidation: {
      requirement: 'ç¡®å®šæ€§éªŒè¯åŠŸèƒ½å®Œæ•´æ€§',
      criteria: [
        'ç§å­é”å®šæµ‹è¯•é€šè¿‡ç‡ = 100%',
        'çŠ¶æ€å“ˆå¸Œä¸€è‡´æ€§éªŒè¯ = 100%',
        'å†³ç­–åºåˆ—é‡ç°æ€§ = 100%',
        'å¤šè½®æµ‹è¯•é›¶æ¼‚ç§»',
      ],
      testMethod: 'automated_seed_tests',
      acceptanceThreshold: 'æ‰€æœ‰æ ‡å‡†100%æ»¡è¶³',
    },

    concurrencyPerformance: {
      requirement: 'å¹¶å‘å¤„ç†æ€§èƒ½æ»¡è¶³è®¾è®¡ç›®æ ‡',
      criteria: [
        '50+AIå®ä½“å¹¶å‘å¤„ç†TP95 < 50ms',
        '100ä¸ªAIå®ä½“å¤„ç†TP95 < 100ms',
        'å†…å­˜å¢é•¿ç‡ < 10% per 1000 ticks',
        'Workeråˆ©ç”¨ç‡ä¿æŒåœ¨80-90%',
      ],
      testMethod: 'performance_benchmark_suite',
      acceptanceThreshold: 'æ‰€æœ‰æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡',
    },

    errorRecovery: {
      requirement: 'é”™è¯¯æ¢å¤èƒ½åŠ›ç¬¦åˆè®¾è®¡è¦æ±‚',
      criteria: [
        'Workerå´©æºƒæ¢å¤æˆåŠŸç‡ â‰¥ 99.5%',
        'å¹³å‡æ¢å¤æ—¶é—´ â‰¤ 100ms',
        'æ•°æ®å®Œæ•´æ€§ä¿æŒ = 100%',
        'æœåŠ¡å¯ç”¨æ€§ â‰¥ 99.9%',
      ],
      testMethod: 'chaos_engineering_tests',
      acceptanceThreshold: 'æ‰€æœ‰æ¢å¤æŒ‡æ ‡è¾¾æ ‡',
    },
  },

  // éåŠŸèƒ½æ€§éªŒæ”¶æ ‡å‡†
  nonFunctional: {
    usability: {
      requirement: 'å¼€å‘å›¢é˜Ÿæ˜“äºä½¿ç”¨',
      criteria: [
        'é—¨ç¦å¤±è´¥æ—¶æœ‰æ¸…æ™°é”™è¯¯ä¿¡æ¯',
        'è°ƒè¯•å·¥å…·å­¦ä¹ æˆæœ¬ â‰¤ 2å°æ—¶',
        'æ–‡æ¡£å®Œæ•´æ€§ â‰¥ 95%',
        'å›¢é˜ŸåŸ¹è®­é€šè¿‡ç‡ = 100%',
      ],
      testMethod: 'user_acceptance_testing',
      acceptanceThreshold: 'å›¢é˜Ÿæ»¡æ„åº¦ â‰¥ 85%',
    },

    maintainability: {
      requirement: 'ç³»ç»Ÿæ˜“äºç»´æŠ¤å’Œæ‰©å±•',
      criteria: [
        'ä»£ç è¦†ç›–ç‡ â‰¥ 90%',
        'åœˆå¤æ‚åº¦ â‰¤ 15',
        'æ¨¡å—è€¦åˆåº¦ â‰¤ 0.3',
        'æŠ€æœ¯å€ºåŠ¡è¯„çº§ â‰¤ B',
      ],
      testMethod: 'static_code_analysis',
      acceptanceThreshold: 'æ‰€æœ‰è´¨é‡æŒ‡æ ‡è¾¾æ ‡',
    },

    scalability: {
      requirement: 'ç³»ç»Ÿæ”¯æŒæœªæ¥æ‰©å±•éœ€æ±‚',
      criteria: [
        'æ”¯æŒAIå®ä½“æ•°é‡æ‰©å±•åˆ°500+',
        'Workeræ± åŠ¨æ€æ‰©ç¼©å®¹',
        'ç›‘æ§æ•°æ®å­˜å‚¨æ‰©å±•æ€§',
        'é—¨ç¦é…ç½®å¯çƒ­æ›´æ–°',
      ],
      testMethod: 'scalability_testing',
      acceptanceThreshold: 'æ‰©å±•æ€§æµ‹è¯•å…¨éƒ¨é€šè¿‡',
    },
  },

  // ä¸šåŠ¡ä»·å€¼éªŒæ”¶æ ‡å‡†
  businessValue: {
    qualityImprovement: {
      requirement: 'AIç³»ç»Ÿè´¨é‡æ˜¾è‘—æå‡',
      criteria: [
        'AIç›¸å…³Bugå‡å°‘ â‰¥ 80%',
        'ä¸€è‡´æ€§é—®é¢˜å‡å°‘ â‰¥ 95%',
        'æ€§èƒ½å›å½’é—®é¢˜å‡å°‘ â‰¥ 90%',
        'å®¢æˆ·æ»¡æ„åº¦æå‡ â‰¥ 20%',
      ],
      measurementPeriod: '3ä¸ªæœˆåè¯„ä¼°',
      acceptanceThreshold: 'ä¸šåŠ¡æŒ‡æ ‡æ˜¾è‘—æ”¹å–„',
    },

    developmentEfficiency: {
      requirement: 'å¼€å‘æ•ˆç‡å’Œè´¨é‡å¹¶é‡',
      criteria: [
        'AIç›¸å…³å¼€å‘ä»»åŠ¡å®Œæˆæ—¶é—´å‡å°‘ â‰¥ 30%',
        'AIé—®é¢˜å®šä½æ—¶é—´å‡å°‘ â‰¥ 60%',
        'ä»£ç å®¡æŸ¥æ•ˆç‡æå‡ â‰¥ 40%',
        'å‘å¸ƒä¿¡å¿ƒæŒ‡æ•°æå‡ â‰¥ 50%',
      ],
      measurementPeriod: '2ä¸ªæœˆåè¯„ä¼°',
      acceptanceThreshold: 'æ•ˆç‡æŒ‡æ ‡æ˜æ˜¾æå‡',
    },
  },
};
```

#### 10.6.2 éƒ¨ç½²éªŒæ”¶æ£€æŸ¥æ¸…å•

```typescript
// AIä¸€è‡´æ€§é—¨ç¦ç³»ç»Ÿéƒ¨ç½²éªŒæ”¶æ£€æŸ¥æ¸…å•
export const AI_CONSISTENCY_DEPLOYMENT_CHECKLIST = {
  // éƒ¨ç½²å‰æ£€æŸ¥
  preDeployment: [
    {
      item: 'ç¡®è®¤æ‰€æœ‰ä¾èµ–é¡¹å·²å®‰è£…',
      description: 'AI Workeråº“ã€ç›‘æ§å·¥å…·ã€æµ‹è¯•æ¡†æ¶ç­‰',
      responsible: 'DevOpså·¥ç¨‹å¸ˆ',
      deadline: 'éƒ¨ç½²å‰1å¤©',
      status: 'pending',
    },
    {
      item: 'ç¯å¢ƒé…ç½®æ–‡ä»¶å‡†å¤‡å®Œæ¯•',
      description: 'å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒé…ç½®æ­£ç¡®',
      responsible: 'ç³»ç»Ÿç®¡ç†å‘˜',
      deadline: 'éƒ¨ç½²å‰1å¤©',
      status: 'pending',
    },
    {
      item: 'æ•°æ®åº“è¿ç§»è„šæœ¬éªŒè¯',
      description: 'ç›‘æ§æ•°æ®å­˜å‚¨ç»“æ„å‡†å¤‡å°±ç»ª',
      responsible: 'æ•°æ®åº“ç®¡ç†å‘˜',
      deadline: 'éƒ¨ç½²å‰1å¤©',
      status: 'pending',
    },
  ],

  // éƒ¨ç½²è¿‡ç¨‹æ£€æŸ¥
  duringDeployment: [
    {
      item: 'é—¨ç¦ç³»ç»Ÿç»„ä»¶éƒ¨ç½²',
      description: 'AIä¸€è‡´æ€§æµ‹è¯•ã€æ€§èƒ½ç›‘æ§ã€å‘Šè­¦ç³»ç»Ÿ',
      responsible: 'éƒ¨ç½²å·¥ç¨‹å¸ˆ',
      estimatedTime: '30åˆ†é’Ÿ',
      rollbackPlan: 'å›æ»šåˆ°ä¸Šä¸€ç‰ˆæœ¬é…ç½®',
    },
    {
      item: 'é…ç½®æ–‡ä»¶åº”ç”¨å’ŒéªŒè¯',
      description: 'ç¯å¢ƒç‰¹å®šé…ç½®æ­£ç¡®åŠ è½½',
      responsible: 'éƒ¨ç½²å·¥ç¨‹å¸ˆ',
      estimatedTime: '15åˆ†é’Ÿ',
      rollbackPlan: 'æ¢å¤åŸå§‹é…ç½®æ–‡ä»¶',
    },
    {
      item: 'æœåŠ¡å¯åŠ¨å’Œåˆå§‹åŒ–',
      description: 'AI Workeræ± ã€ç›‘æ§æœåŠ¡ã€APIç«¯ç‚¹',
      responsible: 'éƒ¨ç½²å·¥ç¨‹å¸ˆ',
      estimatedTime: '10åˆ†é’Ÿ',
      rollbackPlan: 'åœæ­¢æ–°æœåŠ¡ï¼Œå¯åŠ¨åŸæœåŠ¡',
    },
  ],

  // éƒ¨ç½²åéªŒè¯
  postDeployment: [
    {
      item: 'å¥åº·æ£€æŸ¥é€šè¿‡',
      description: 'æ‰€æœ‰æœåŠ¡ç«¯ç‚¹å“åº”æ­£å¸¸',
      responsible: 'è¿ç»´å·¥ç¨‹å¸ˆ',
      timeout: '5åˆ†é’Ÿ',
      success_criteria: 'æ‰€æœ‰ç«¯ç‚¹è¿”å›200çŠ¶æ€ç ',
    },
    {
      item: 'é—¨ç¦åŠŸèƒ½éªŒè¯',
      description: 'è¿è¡Œå®Œæ•´é—¨ç¦æµ‹è¯•å¥—ä»¶',
      responsible: 'QAå·¥ç¨‹å¸ˆ',
      timeout: '30åˆ†é’Ÿ',
      success_criteria: 'æ‰€æœ‰é—¨ç¦æµ‹è¯•é€šè¿‡',
    },
    {
      item: 'æ€§èƒ½åŸºå‡†éªŒè¯',
      description: 'éªŒè¯AIæ€§èƒ½æ»¡è¶³åŸºå‡†è¦æ±‚',
      responsible: 'æ€§èƒ½å·¥ç¨‹å¸ˆ',
      timeout: '20åˆ†é’Ÿ',
      success_criteria: 'æ€§èƒ½æŒ‡æ ‡åœ¨é¢„æœŸèŒƒå›´å†…',
    },
    {
      item: 'å‘Šè­¦ç³»ç»Ÿæµ‹è¯•',
      description: 'è§¦å‘æµ‹è¯•å‘Šè­¦éªŒè¯é€šçŸ¥æœºåˆ¶',
      responsible: 'è¿ç»´å·¥ç¨‹å¸ˆ',
      timeout: '10åˆ†é’Ÿ',
      success_criteria: 'å‘Šè­¦æ­£å¸¸å‘é€å’Œæ¥æ”¶',
    },
    {
      item: 'ç›‘æ§ä»ªè¡¨æ¿éªŒè¯',
      description: 'ç¡®è®¤æ‰€æœ‰æŒ‡æ ‡æ­£å¸¸æ˜¾ç¤º',
      responsible: 'ç›‘æ§å·¥ç¨‹å¸ˆ',
      timeout: '10åˆ†é’Ÿ',
      success_criteria: 'ä»ªè¡¨æ¿æ•°æ®å®Œæ•´ä¸”å‡†ç¡®',
    },
  ],

  // éªŒæ”¶ç­¾ç½²
  signOff: [
    {
      role: 'æŠ€æœ¯è´Ÿè´£äºº',
      requirement: 'ç¡®è®¤æ‰€æœ‰æŠ€æœ¯æŒ‡æ ‡è¾¾æ ‡',
      status: 'pending',
    },
    {
      role: 'è´¨é‡ä¿è¯è´Ÿè´£äºº',
      requirement: 'ç¡®è®¤è´¨é‡é—¨ç¦æ­£å¸¸å·¥ä½œ',
      status: 'pending',
    },
    {
      role: 'è¿ç»´è´Ÿè´£äºº',
      requirement: 'ç¡®è®¤ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿå°±ç»ª',
      status: 'pending',
    },
    {
      role: 'äº§å“è´Ÿè´£äºº',
      requirement: 'ç¡®è®¤ä¸šåŠ¡éœ€æ±‚å¾—åˆ°æ»¡è¶³',
      status: 'pending',
    },
  ],
};
```

## åä¸€ã€å°±åœ°éªŒæ”¶ï¼ˆGherkin + Vitest ç‰‡æ®µï¼‰- å…¨é¢æ¶æ„çº¦æŸéªŒè¯

> **è®¾è®¡ç›®æ ‡**ï¼šå»ºç«‹åŸºäºBDDæ–¹æ³•è®ºçš„ç»¼åˆéªŒæ”¶æµ‹è¯•ä½“ç³»ï¼Œå°†æŠ½è±¡çš„æ¶æ„çº¦æŸè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„è‡ªåŠ¨åŒ–éªŒè¯æœºåˆ¶ï¼Œç¡®ä¿æ¯ä¸ªå…³é”®çº¦æŸéƒ½æœ‰å¯¹åº”çš„Given-When-Thenåœºæ™¯å’ŒVitestæµ‹è¯•å®ç°ã€‚

### 11.1 éªŒæ”¶æµ‹è¯•æ¡†æ¶æ¦‚è¿°

#### 11.1.1 BDDæµ‹è¯•æ–¹æ³•è®º

**æ ¸å¿ƒåŸåˆ™**ï¼š

- **è¡Œä¸ºé©±åŠ¨å¼€å‘ï¼ˆBDDï¼‰**ï¼šåŸºäºGherkinè¯­æ³•çš„Given-When-Thenåœºæ™¯æè¿°
- **æµ‹è¯•å³è§„èŒƒ**ï¼šæ¯ä¸ªéªŒæ”¶æµ‹è¯•æ—¢æ˜¯åŠŸèƒ½éªŒè¯ä¹Ÿæ˜¯æ´»æ–‡æ¡£
- **åˆ†å±‚éªŒæ”¶ç­–ç•¥**ï¼šå¯¹åº”5å±‚SLI/SLOä½“ç³»çš„åˆ†çº§æµ‹è¯•æ¡†æ¶

**æŠ€æœ¯æ ˆé…ç½®**ï¼š

```typescript
// src/shared/testing/acceptance-config.ts - éªŒæ”¶æµ‹è¯•é…ç½®
export interface AcceptanceTestConfig {
  // æµ‹è¯•æ¡†æ¶é…ç½®
  frameworks: {
    unitTesting: 'vitest' | 'jest';
    e2eTesting: 'playwright' | 'cypress';
    coverageReporting: 'c8' | 'nyc';
    bddRunner: 'cucumber' | 'vitest-gherkin';
  };

  // æµ‹è¯•ç¯å¢ƒé…ç½®
  environments: {
    development: TestEnvironmentConfig;
    staging: TestEnvironmentConfig;
    production: TestEnvironmentConfig;
  };

  // è´¨é‡é—¨ç¦é…ç½®
  qualityGates: {
    coverage: {
      statements: 90;
      branches: 85;
      functions: 95;
      lines: 90;
    };
    performance: {
      crashFreeThreshold: 99.5;
      tp95Threshold: 100; // ms
      memoryLeakThreshold: 5; // MB/hour
    };
  };
}

// æµ‹è¯•ç¯å¢ƒæ ‡å‡†é…ç½®
interface TestEnvironmentConfig {
  electron: {
    nodeIntegration: false;
    contextIsolation: true;
    webSecurity: true;
  };
  phaser: {
    renderer: 'webgl' | 'canvas';
    fps: 60;
    debugMode: boolean;
  };
  webWorkers: {
    maxWorkers: number;
    timeout: number;
    resourceLimits: {
      maxMemory: string;
      maxCpu: string;
    };
  };
}
```

**åˆ†å±‚éªŒæ”¶ç­–ç•¥**ï¼š

```typescript
// src/shared/testing/acceptance-layers.ts - åˆ†å±‚éªŒæ”¶å®šä¹‰
export const ACCEPTANCE_LAYERS = {
  // L0: å…³é”®ç³»ç»Ÿçº¦æŸéªŒæ”¶
  tier0_critical: {
    description: 'ç³»ç»Ÿæ ¸å¿ƒåŠŸèƒ½å’Œç¨³å®šæ€§éªŒæ”¶ï¼Œå¤±è´¥é˜»å¡å‘å¸ƒ',
    testTimeout: 30000, // 30ç§’
    retryAttempts: 0, // ä¸é‡è¯•
    parallelize: false, // ä¸²è¡Œæ‰§è¡Œ
    categories: ['crash_free', 'data_integrity', 'security_boundary'],
  },

  // L1: æ€§èƒ½å’Œèµ„æºéªŒæ”¶
  tier1_performance: {
    description: 'æ€§èƒ½æŒ‡æ ‡å’Œèµ„æºåˆ©ç”¨ç‡éªŒæ”¶ï¼Œå¤±è´¥é˜»å¡åˆå¹¶',
    testTimeout: 60000, // 60ç§’
    retryAttempts: 2, // æœ€å¤šé‡è¯•2æ¬¡
    parallelize: true, // å¹¶è¡Œæ‰§è¡Œ
    categories: ['tp95_latency', 'memory_usage', 'cpu_utilization'],
  },

  // L2: ç”¨æˆ·ä½“éªŒå’Œä»£ç è´¨é‡éªŒæ”¶
  tier2_quality: {
    description: 'ç”¨æˆ·ä½“éªŒå’Œå¼€å‘è´¨é‡éªŒæ”¶ï¼Œå¤±è´¥äº§ç”Ÿè­¦å‘Š',
    testTimeout: 120000, // 120ç§’
    retryAttempts: 3, // æœ€å¤šé‡è¯•3æ¬¡
    parallelize: true, // å¹¶è¡Œæ‰§è¡Œ
    categories: ['user_experience', 'code_coverage', 'accessibility'],
  },
} as const;
```

#### 11.1.2 æµ‹è¯•å·¥å…·é“¾é›†æˆ

**Vitest + Playwright + C8é…ç½®**ï¼š

```typescript
// vitest.config.ts - éªŒæ”¶æµ‹è¯•ä¸“ç”¨é…ç½®
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    // éªŒæ”¶æµ‹è¯•ç›®å½•
    include: ['tests/acceptance/**/*.spec.ts'],

    // ç¯å¢ƒé…ç½®
    environment: 'jsdom',
    setupFiles: ['tests/acceptance/setup.ts'],

    // è¶…æ—¶è®¾ç½®
    testTimeout: 30000,
    hookTimeout: 10000,

    // å¹¶å‘æ§åˆ¶
    threads: true,
    maxThreads: 4,

    // æŠ¥å‘Šé…ç½®
    reporter: ['verbose', 'json', 'html'],
    outputFile: {
      json: 'tests/reports/acceptance-results.json',
      html: 'tests/reports/acceptance-report.html',
    },

    // è¦†ç›–ç‡é…ç½®
    coverage: {
      provider: 'c8',
      reporter: ['text', 'html', 'json'],
      reportsDirectory: 'tests/coverage',
      thresholds: {
        statements: 90,
        branches: 85,
        functions: 95,
        lines: 90,
      },
    },
  },
});
```

**Gherkinåœºæ™¯è½¬æ¢å™¨**ï¼š

```typescript
// src/shared/testing/gherkin-adapter.ts - Gherkinåˆ°Vitestè½¬æ¢å™¨
export class GherkinVitestAdapter {
  /**
   * å°†Gherkinåœºæ™¯è½¬æ¢ä¸ºVitestæµ‹è¯•ç”¨ä¾‹
   */
  static convertScenario(gherkinScenario: string): VitestTestCase {
    const parsed = this.parseGherkin(gherkinScenario);

    return {
      describe: parsed.feature,
      testCases: parsed.scenarios.map(scenario => ({
        name: scenario.name,
        test: this.generateTestFunction(scenario.steps),
        timeout: this.calculateTimeout(scenario.steps),
        retry: this.determineRetryStrategy(scenario.tags),
      })),
    };
  }

  /**
   * ç”Ÿæˆæµ‹è¯•å‡½æ•°
   */
  private static generateTestFunction(steps: GherkinStep[]): TestFunction {
    return async ({ expect }) => {
      for (const step of steps) {
        switch (step.keyword) {
          case 'Given':
            await this.executeGivenStep(step.text);
            break;
          case 'When':
            await this.executeWhenStep(step.text);
            break;
          case 'Then':
            await this.executeThenStep(step.text, expect);
            break;
          case 'And':
            await this.executeAndStep(step.text, expect);
            break;
        }
      }
    };
  }
}
```

### 11.2 æ ¸å¿ƒSLOéªŒæ”¶è§„èŒƒï¼ˆCritical Quality Gates Acceptanceï¼‰

#### 11.2.1 Crash-free SessionséªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/slo-crash-free.feature
Feature: Crash-free Sessions SLOéªŒæ”¶
  ä½œä¸ºæ¶æ„å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿ç³»ç»Ÿå´©æºƒç‡æ§åˆ¶åœ¨0.5%ä»¥å†…ï¼Œä¿éšœç”¨æˆ·ä½“éªŒç¨³å®šæ€§

  Background:
    Given ç³»ç»Ÿå·²å¯åŠ¨å¹¶åˆå§‹åŒ–å®Œæˆ
    And Sentryé”™è¯¯ç›‘æ§å·²é…ç½®
    And ä¼šè¯è¿½è¸ªæœºåˆ¶å·²æ¿€æ´»

  Scenario: æ­£å¸¸æ¸¸æˆä¼šè¯å´©æºƒç‡éªŒè¯
    Given ç”¨æˆ·å¼€å§‹æ–°çš„æ¸¸æˆä¼šè¯
    When æ‰§è¡Œå®Œæ•´çš„æ¸¸æˆæµç¨‹é•¿è¾¾30åˆ†é’Ÿ
    Then ä¼šè¯åº”è¯¥æ­£å¸¸ç»“æŸè€Œä¸å´©æºƒ
    And å†…å­˜ä½¿ç”¨åº”ä¿æŒåœ¨300MBä»¥å†…
    And ä¸åº”äº§ç”Ÿä»»ä½•æœªæ•è·çš„å¼‚å¸¸

  Scenario: é«˜è´Ÿè½½åœºæ™¯ä¸‹çš„ç¨³å®šæ€§éªŒè¯
    Given ç³»ç»Ÿè¿è¡Œåœ¨é«˜è´Ÿè½½æ¨¡å¼ä¸‹
    And åŒæ—¶æ¿€æ´»50+AIå®ä½“
    And äº‹ä»¶é˜Ÿåˆ—åŒ…å«200+å¾…å¤„ç†äº‹ä»¶
    When æŒç»­è¿è¡Œ60åˆ†é’Ÿå‹åŠ›æµ‹è¯•
    Then ç³»ç»Ÿå´©æºƒç‡åº” â‰¤ 0.5%
    And æ‰€æœ‰å´©æºƒéƒ½åº”è¢«Sentryæ­£ç¡®è®°å½•
    And ç³»ç»Ÿåº”èƒ½ä»è½»å¾®é”™è¯¯ä¸­è‡ªåŠ¨æ¢å¤

  Scenario: è¾¹ç•Œæ¡ä»¶å´©æºƒé˜²æŠ¤éªŒè¯
    Given ç³»ç»Ÿæ¥è¿‘èµ„æºé™åˆ¶è¾¹ç•Œ
    When å†…å­˜ä½¿ç”¨è¾¾åˆ°350MBä¸´ç•Œçº¿
    And CPUä½¿ç”¨ç‡æŒç»­è¶…è¿‡80%
    Then ç³»ç»Ÿåº”è§¦å‘èµ„æºä¿æŠ¤æœºåˆ¶
    And ä¸åº”å‘ç”ŸOOMå´©æºƒ
    And åº”ç”Ÿæˆèµ„æºè­¦å‘Šæ—¥å¿—
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/slo-crash-free.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GameSessionManager } from '@/core/session/GameSessionManager';
import { SentryMonitor } from '@/shared/monitoring/SentryMonitor';
import { MemoryProfiler } from '@/shared/testing/MemoryProfiler';

describe('Crash-free Sessions SLOéªŒæ”¶', () => {
  let sessionManager: GameSessionManager;
  let sentryMonitor: SentryMonitor;
  let memoryProfiler: MemoryProfiler;

  beforeEach(async () => {
    sessionManager = new GameSessionManager();
    sentryMonitor = new SentryMonitor();
    memoryProfiler = new MemoryProfiler();

    await sessionManager.initialize();
    await sentryMonitor.startMonitoring();
  });

  afterEach(async () => {
    await sessionManager.cleanup();
    await sentryMonitor.stopMonitoring();
  });

  it('æ­£å¸¸æ¸¸æˆä¼šè¯å´©æºƒç‡éªŒè¯', async () => {
    // Given: ç”¨æˆ·å¼€å§‹æ–°çš„æ¸¸æˆä¼šè¯
    const session = await sessionManager.createSession({
      userId: 'test-user-001',
      gameMode: 'normal',
      duration: 30 * 60 * 1000, // 30åˆ†é’Ÿ
    });

    memoryProfiler.startProfiling();

    try {
      // When: æ‰§è¡Œå®Œæ•´çš„æ¸¸æˆæµç¨‹é•¿è¾¾30åˆ†é’Ÿ
      await sessionManager.runGameSession(session, {
        enableAI: true,
        maxEvents: 1000,
        simulateUserActions: true,
      });

      // Then: ä¼šè¯åº”è¯¥æ­£å¸¸ç»“æŸè€Œä¸å´©æºƒ
      expect(session.status).toBe('completed');
      expect(session.crashCount).toBe(0);

      // And: å†…å­˜ä½¿ç”¨åº”ä¿æŒåœ¨300MBä»¥å†…
      const memoryUsage = memoryProfiler.getPeakMemoryUsage();
      expect(memoryUsage.heapUsed).toBeLessThan(300 * 1024 * 1024); // 300MB

      // And: ä¸åº”äº§ç”Ÿä»»ä½•æœªæ•è·çš„å¼‚å¸¸
      const errors = await sentryMonitor.getSessionErrors(session.id);
      expect(errors.filter(e => e.level === 'fatal')).toHaveLength(0);
    } finally {
      memoryProfiler.stopProfiling();
    }
  });

  it('é«˜è´Ÿè½½åœºæ™¯ä¸‹çš„ç¨³å®šæ€§éªŒè¯', async () => {
    // Given: ç³»ç»Ÿè¿è¡Œåœ¨é«˜è´Ÿè½½æ¨¡å¼ä¸‹
    const stressTestConfig = {
      aiEntityCount: 50,
      eventQueueSize: 200,
      duration: 60 * 60 * 1000, // 60åˆ†é’Ÿ
      concurrentSessions: 3,
    };

    const sessions = [];
    let totalCrashes = 0;

    try {
      // åˆ›å»ºå¤šä¸ªå¹¶å‘ä¼šè¯
      for (let i = 0; i < stressTestConfig.concurrentSessions; i++) {
        const session = await sessionManager.createSession({
          userId: `stress-test-user-${i}`,
          gameMode: 'high_load',
          aiEntityCount: stressTestConfig.aiEntityCount,
        });
        sessions.push(session);
      }

      // When: æŒç»­è¿è¡Œ60åˆ†é’Ÿå‹åŠ›æµ‹è¯•
      const results = await Promise.allSettled(
        sessions.map(session =>
          sessionManager.runStressTest(session, stressTestConfig)
        )
      );

      // ç»Ÿè®¡å´©æºƒæƒ…å†µ
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          totalCrashes++;
        }
      });

      // Then: ç³»ç»Ÿå´©æºƒç‡åº” â‰¤ 0.5%
      const crashRate = (totalCrashes / sessions.length) * 100;
      expect(crashRate).toBeLessThanOrEqual(0.5);

      // And: æ‰€æœ‰å´©æºƒéƒ½åº”è¢«Sentryæ­£ç¡®è®°å½•
      const sentryErrors = await sentryMonitor.getAllErrors();
      expect(sentryErrors.length).toBeGreaterThanOrEqual(totalCrashes);

      // And: ç³»ç»Ÿåº”èƒ½ä»è½»å¾®é”™è¯¯ä¸­è‡ªåŠ¨æ¢å¤
      for (const session of sessions) {
        if (session.status === 'recovered') {
          expect(session.recoveryCount).toBeGreaterThan(0);
        }
      }
    } finally {
      // æ¸…ç†æ‰€æœ‰æµ‹è¯•ä¼šè¯
      await Promise.all(sessions.map(s => sessionManager.cleanup(s.id)));
    }
  }, 65000); // 65ç§’è¶…æ—¶ï¼Œç•¥é•¿äºæµ‹è¯•æ—¶é—´

  it('è¾¹ç•Œæ¡ä»¶å´©æºƒé˜²æŠ¤éªŒè¯', async () => {
    // Given: ç³»ç»Ÿæ¥è¿‘èµ„æºé™åˆ¶è¾¹ç•Œ
    const memoryStressTest = new MemoryStressTest({
      targetMemoryUsage: 350 * 1024 * 1024, // 350MB
      cpuStressLevel: 80, // 80% CPU
    });

    const session = await sessionManager.createSession({
      userId: 'boundary-test-user',
      gameMode: 'resource_stress',
    });

    try {
      // When: è§¦å‘èµ„æºå‹åŠ›æ¡ä»¶
      await memoryStressTest.start();

      // ç›‘æ§ç³»ç»Ÿå“åº”
      const systemMonitor = sessionManager.getSystemMonitor();
      let protectionTriggered = false;
      let oomCrashDetected = false;

      systemMonitor.on('resourceWarning', () => {
        protectionTriggered = true;
      });

      systemMonitor.on('outOfMemory', () => {
        oomCrashDetected = true;
      });

      // è¿è¡Œä¼šè¯ç›´åˆ°è¾¾åˆ°èµ„æºé™åˆ¶
      await sessionManager.runUntilResourceLimit(session, {
        memoryLimit: 350 * 1024 * 1024,
        timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
      });

      // Then: ç³»ç»Ÿåº”è§¦å‘èµ„æºä¿æŠ¤æœºåˆ¶
      expect(protectionTriggered).toBe(true);

      // And: ä¸åº”å‘ç”ŸOOMå´©æºƒ
      expect(oomCrashDetected).toBe(false);

      // And: åº”ç”Ÿæˆèµ„æºè­¦å‘Šæ—¥å¿—
      const logs = await sessionManager.getSessionLogs(session.id);
      const warningLogs = logs.filter(
        log => log.level === 'warning' && log.message.includes('resource')
      );
      expect(warningLogs.length).toBeGreaterThan(0);
    } finally {
      await memoryStressTest.stop();
    }
  }, 320000); // 5.5åˆ†é’Ÿè¶…æ—¶
});
```

#### 11.2.2 TP95æ€§èƒ½å»¶è¿ŸéªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/slo-tp95-performance.feature
Feature: TP95æ€§èƒ½å»¶è¿ŸSLOéªŒæ”¶
  ä½œä¸ºç”¨æˆ·ï¼Œæˆ‘éœ€è¦ç³»ç»Ÿå“åº”å»¶è¿ŸTP95ä¿æŒåœ¨100msä»¥å†…ï¼Œç¡®ä¿æµç•…çš„äº¤äº’ä½“éªŒ

  Background:
    Given ç³»ç»Ÿå·²å®Œæˆåˆå§‹åŒ–
    And æ€§èƒ½ç›‘æ§å·²å¯ç”¨
    And PlaywrightåŸºå‡†æµ‹è¯•ç¯å¢ƒå·²å°±ç»ª

  Scenario: æ ¸å¿ƒUIäº¤äº’TP95å»¶è¿ŸéªŒè¯
    Given ç”¨æˆ·ç•Œé¢å·²å®Œå…¨åŠ è½½
    When æ‰§è¡Œæ ¸å¿ƒUIäº¤äº’æ“ä½œ1000æ¬¡
      | æ“ä½œç±»å‹ | é¢„æœŸTP95å»¶è¿Ÿ | æµ‹è¯•æ¬¡æ•° |
      | æŒ‰é’®ç‚¹å‡» | < 50ms      | 200     |
      | èœå•å¯¼èˆª | < 80ms      | 200     |
      | å¼¹çª—æ‰“å¼€ | < 100ms     | 200     |
      | æ•°æ®åˆ·æ–° | < 120ms     | 200     |
      | é¡µé¢åˆ‡æ¢ | < 150ms     | 200     |
    Then æ‰€æœ‰äº¤äº’çš„TP95å»¶è¿Ÿåº” â‰¤ 100ms
    And æ²¡æœ‰ä»»ä½•æ“ä½œè¶…è¿‡200msè¶…æ—¶é˜ˆå€¼
    And å†…å­˜ä½¿ç”¨ä¿æŒç¨³å®šæ— æ³„æ¼

  Scenario: æ¸¸æˆå¾ªç¯æ€§èƒ½ç¨³å®šæ€§éªŒè¯
    Given æ¸¸æˆåœºæ™¯å·²åŠ è½½å®Œæˆ
    And æ¸¸æˆå¾ªç¯ä»¥60FPSè¿è¡Œ
    When æŒç»­ç›‘æ§å¸§ç‡ç¨³å®šæ€§30åˆ†é’Ÿ
    And åŒæ—¶å¤„ç†ç”¨æˆ·è¾“å…¥å’ŒAIè®¡ç®—
    Then å¹³å‡FPSåº” â‰¥ 58FPS
    And å¸§æ—¶é—´TP95åº” â‰¤ 17ms (60FPSæ ‡å‡†)
    And å¸§æ—¶é—´æ³¢åŠ¨åº” â‰¤ 5msæ ‡å‡†å·®

  Scenario: AIè®¡ç®—å“åº”æ€§èƒ½éªŒè¯
    Given AIè®¡ç®—ç³»ç»Ÿå·²åˆå§‹åŒ–
    And Web Workeræ± å·²å‡†å¤‡å°±ç»ª
    When å‘é€100ä¸ªAIå†³ç­–è¯·æ±‚
    And æ¯ä¸ªè¯·æ±‚åŒ…å«å¤æ‚çš„å†³ç­–åœºæ™¯
    Then AIå“åº”TP95å»¶è¿Ÿåº” â‰¤ 500ms
    And Workeré€šä¿¡å»¶è¿ŸTP95åº” â‰¤ 30ms
    And æ‰€æœ‰è¯·æ±‚éƒ½åº”æˆåŠŸå®Œæˆ
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/slo-tp95-performance.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { PerformanceProfiler } from '@/shared/testing/PerformanceProfiler';
import { UIInteractionTester } from '@/shared/testing/UIInteractionTester';
import { GameLoopProfiler } from '@/shared/testing/GameLoopProfiler';
import { AIWorkerTester } from '@/shared/testing/AIWorkerTester';

describe('TP95æ€§èƒ½å»¶è¿ŸSLOéªŒæ”¶', () => {
  let performanceProfiler: PerformanceProfiler;
  let uiTester: UIInteractionTester;
  let gameLoopProfiler: GameLoopProfiler;
  let aiWorkerTester: AIWorkerTester;

  beforeEach(async () => {
    performanceProfiler = new PerformanceProfiler();
    uiTester = new UIInteractionTester();
    gameLoopProfiler = new GameLoopProfiler();
    aiWorkerTester = new AIWorkerTester();

    await performanceProfiler.initialize();
  });

  it('æ ¸å¿ƒUIäº¤äº’TP95å»¶è¿ŸéªŒè¯', async () => {
    // Given: ç”¨æˆ·ç•Œé¢å·²å®Œå…¨åŠ è½½
    await uiTester.waitForUIReady();

    const interactionTests = [
      { type: 'æŒ‰é’®ç‚¹å‡»', expectedTP95: 50, testCount: 200 },
      { type: 'èœå•å¯¼èˆª', expectedTP95: 80, testCount: 200 },
      { type: 'å¼¹çª—æ‰“å¼€', expectedTP95: 100, testCount: 200 },
      { type: 'æ•°æ®åˆ·æ–°', expectedTP95: 120, testCount: 200 },
      { type: 'é¡µé¢åˆ‡æ¢', expectedTP95: 150, testCount: 200 },
    ];

    const allResults = [];

    for (const test of interactionTests) {
      // When: æ‰§è¡Œæ ¸å¿ƒUIäº¤äº’æ“ä½œ
      const results = await uiTester.performInteractionTest({
        interactionType: test.type,
        iterations: test.testCount,
        measureLatency: true,
      });

      allResults.push({
        type: test.type,
        results,
        expectedTP95: test.expectedTP95,
      });
    }

    // Then: æ‰€æœ‰äº¤äº’çš„TP95å»¶è¿Ÿåº” â‰¤ 100ms
    for (const testResult of allResults) {
      const tp95 = performanceProfiler.calculatePercentile(
        testResult.results.latencies,
        95
      );

      expect(tp95).toBeLessThanOrEqual(100);
      expect(tp95).toBeLessThanOrEqual(testResult.expectedTP95);
    }

    // And: æ²¡æœ‰ä»»ä½•æ“ä½œè¶…è¿‡200msè¶…æ—¶é˜ˆå€¼
    const allLatencies = allResults.flatMap(r => r.results.latencies);
    const maxLatency = Math.max(...allLatencies);
    expect(maxLatency).toBeLessThan(200);

    // And: å†…å­˜ä½¿ç”¨ä¿æŒç¨³å®šæ— æ³„æ¼
    const memoryGrowth = performanceProfiler.getMemoryGrowthRate();
    expect(memoryGrowth).toBeLessThan(1024 * 1024); // < 1MB growth
  });

  it(
    'æ¸¸æˆå¾ªç¯æ€§èƒ½ç¨³å®šæ€§éªŒè¯',
    async () => {
      // Given: æ¸¸æˆåœºæ™¯å·²åŠ è½½å®Œæˆ
      await gameLoopProfiler.initializeGameScene();

      // When: æŒç»­ç›‘æ§å¸§ç‡ç¨³å®šæ€§30åˆ†é’Ÿ
      const monitoringResult = await gameLoopProfiler.monitorFrameRate({
        duration: 30 * 60 * 1000, // 30åˆ†é’Ÿ
        targetFPS: 60,
        enableAI: true,
        enableUserInput: true,
      });

      // Then: å¹³å‡FPSåº” â‰¥ 58FPS
      expect(monitoringResult.averageFPS).toBeGreaterThanOrEqual(58);

      // And: å¸§æ—¶é—´TP95åº” â‰¤ 17ms (60FPSæ ‡å‡†)
      const frameTimeTP95 = performanceProfiler.calculatePercentile(
        monitoringResult.frameTimes,
        95
      );
      expect(frameTimeTP95).toBeLessThanOrEqual(17); // 16.67ms for 60FPS + buffer

      // And: å¸§æ—¶é—´æ³¢åŠ¨åº” â‰¤ 5msæ ‡å‡†å·®
      const frameTimeStdDev = performanceProfiler.calculateStandardDeviation(
        monitoringResult.frameTimes
      );
      expect(frameTimeStdDev).toBeLessThanOrEqual(5);
    },
    35 * 60 * 1000
  ); // 35åˆ†é’Ÿè¶…æ—¶

  it('AIè®¡ç®—å“åº”æ€§èƒ½éªŒè¯', async () => {
    // Given: AIè®¡ç®—ç³»ç»Ÿå·²åˆå§‹åŒ–
    await aiWorkerTester.initializeAISystem();

    // When: å‘é€100ä¸ªAIå†³ç­–è¯·æ±‚
    const aiRequests = Array.from({ length: 100 }, (_, index) => ({
      id: `ai-request-${index}`,
      type: 'complex_decision',
      scenario: {
        entityCount: 10 + Math.floor(Math.random() * 20), // 10-30 entities
        complexity: 'high',
        timeConstraint: 500, // ms
      },
    }));

    const startTime = performance.now();
    const results = await Promise.all(
      aiRequests.map(request => aiWorkerTester.sendAIRequest(request))
    );
    const endTime = performance.now();

    // è®¡ç®—å„é¡¹å»¶è¿ŸæŒ‡æ ‡
    const aiResponseTimes = results.map(r => r.responseTime);
    const workerCommTimes = results.map(r => r.workerCommunicationTime);

    // Then: AIå“åº”TP95å»¶è¿Ÿåº” â‰¤ 500ms
    const aiResponseTP95 = performanceProfiler.calculatePercentile(
      aiResponseTimes,
      95
    );
    expect(aiResponseTP95).toBeLessThanOrEqual(500);

    // And: Workeré€šä¿¡å»¶è¿ŸTP95åº” â‰¤ 30ms
    const workerCommTP95 = performanceProfiler.calculatePercentile(
      workerCommTimes,
      95
    );
    expect(workerCommTP95).toBeLessThanOrEqual(30);

    // And: æ‰€æœ‰è¯·æ±‚éƒ½åº”æˆåŠŸå®Œæˆ
    const successfulRequests = results.filter(r => r.success);
    expect(successfulRequests).toHaveLength(100);

    console.log('AIæ€§èƒ½æµ‹è¯•ç»“æœ:', {
      totalDuration: endTime - startTime,
      aiResponseTP95: aiResponseTP95,
      workerCommTP95: workerCommTP95,
      successRate: (successfulRequests.length / results.length) * 100,
    });
  });
});
```

### 11.3 AIå¹¶å‘ä¸€è‡´æ€§éªŒæ”¶è§„èŒƒï¼ˆAI Concurrency Consistency Acceptanceï¼‰

#### 11.3.1 ç§å­é”å®šç¡®å®šæ€§éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/ai-deterministic-seed.feature
Feature: AIç§å­é”å®šç¡®å®šæ€§éªŒæ”¶
  ä½œä¸ºç³»ç»Ÿæ¶æ„å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿AIç³»ç»Ÿåœ¨ç›¸åŒç§å­ä¸‹äº§ç”Ÿå®Œå…¨ä¸€è‡´çš„å†³ç­–ç»“æœï¼Œä¿éšœæ¸¸æˆå›æ”¾å’Œè°ƒè¯•èƒ½åŠ›

  Background:
    Given AIç³»ç»Ÿå·²å®Œæˆåˆå§‹åŒ–
    And ç¡®å®šæ€§éšæœºæ•°ç”Ÿæˆå™¨å·²é…ç½®
    And çŠ¶æ€å“ˆå¸Œè®¡ç®—æ¨¡å—å·²å°±ç»ª

  Scenario: å•ç§å­å¤šè½®è¿è¡Œä¸€è‡´æ€§éªŒè¯
    Given ä½¿ç”¨å›ºå®šç§å­12345åˆå§‹åŒ–AIç³»ç»Ÿ
    When è¿è¡Œç›¸åŒçš„æ¸¸æˆåœºæ™¯10è½®
    And æ¯è½®åŒ…å«100ä¸ªæ¸¸æˆtick
    And æ¯è½®æ¿€æ´»25ä¸ªAIå®ä½“è¿›è¡Œå†³ç­–
    Then æ‰€æœ‰10è½®çš„æœ€ç»ˆçŠ¶æ€å“ˆå¸Œåº”å®Œå…¨ç›¸åŒ
    And æ¯è½®çš„AIå†³ç­–åºåˆ—åº”100%ä¸€è‡´
    And ä¸åº”å­˜åœ¨ä»»ä½•çŠ¶æ€æ¼‚ç§»æˆ–éšæœºæ€§

  Scenario: å¤šç§å­ç¡®å®šæ€§é‡ç°éªŒè¯
    Given å‡†å¤‡äº†10ä¸ªä¸åŒçš„éšæœºç§å­
    When å¯¹æ¯ä¸ªç§å­è¿è¡Œ2è½®ç›¸åŒçš„æ¸¸æˆåœºæ™¯
    And è®°å½•æ¯è½®çš„å†³ç­–åºåˆ—å’ŒçŠ¶æ€å˜åŒ–
    Then ç›¸åŒç§å­çš„2è½®è¿è¡Œç»“æœåº”å®Œå…¨ç›¸åŒ
    And ä¸åŒç§å­åº”äº§ç”Ÿä¸åŒä½†å¯é‡ç°çš„ç»“æœ
    And çŠ¶æ€æ¼‚ç§»ç‡åº” â‰¤ 0.1%

  Scenario: å¤æ‚åœºæ™¯ä¸‹çš„ç¡®å®šæ€§ç¨³å®šæ€§
    Given AIç³»ç»Ÿå¤„ç†å¤æ‚çš„å¤šå®ä½“äº¤äº’åœºæ™¯
    And åŒ…å«50ä¸ªAIå®ä½“å’Œå¤æ‚çš„å†³ç­–æ ‘
    When æŒç»­è¿è¡Œ1000ä¸ªtickçš„é•¿æ—¶é—´åœºæ™¯
    And ä½¿ç”¨ç›¸åŒç§å­é‡å¤è¿è¡Œ3æ¬¡
    Then 3æ¬¡è¿è¡Œçš„æœ€ç»ˆçŠ¶æ€åº”å®Œå…¨ä¸€è‡´
    And å…³é”®æ—¶é—´ç‚¹çš„çŠ¶æ€å¿«ç…§åº”åŒ¹é…
    And å†³ç­–æ—¶åºä¸åº”å—ç³»ç»Ÿè´Ÿè½½å½±å“
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/ai-deterministic-seed.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { DeterministicAIEngine } from '@/ai/DeterministicAIEngine';
import { GameStateHasher } from '@/shared/testing/GameStateHasher';
import { AIDecisionRecorder } from '@/shared/testing/AIDecisionRecorder';

describe('AIç§å­é”å®šç¡®å®šæ€§éªŒæ”¶', () => {
  let aiEngine: DeterministicAIEngine;
  let stateHasher: GameStateHasher;
  let decisionRecorder: AIDecisionRecorder;

  beforeEach(async () => {
    aiEngine = new DeterministicAIEngine();
    stateHasher = new GameStateHasher();
    decisionRecorder = new AIDecisionRecorder();

    await aiEngine.initialize();
  });

  afterEach(async () => {
    await aiEngine.cleanup();
    decisionRecorder.clear();
  });

  it('å•ç§å­å¤šè½®è¿è¡Œä¸€è‡´æ€§éªŒè¯', async () => {
    const testSeed = 12345;
    const roundCount = 10;
    const ticksPerRound = 100;
    const entityCount = 25;

    const roundResults = [];

    // Given & When: ä½¿ç”¨å›ºå®šç§å­è¿è¡Œå¤šè½®æµ‹è¯•
    for (let round = 0; round < roundCount; round++) {
      // é‡ç½®AIç³»ç»Ÿåˆ°åˆå§‹çŠ¶æ€
      await aiEngine.reset();
      aiEngine.setSeed(testSeed); // æ¯è½®ä½¿ç”¨ç›¸åŒç§å­

      // åˆ›å»ºç›¸åŒçš„æ¸¸æˆåœºæ™¯
      const gameScenario = await aiEngine.createStandardScenario({
        entityCount,
        complexity: 'medium',
        interactions: true,
      });

      decisionRecorder.startRecording(`round-${round}`);

      // è¿è¡Œæ¸¸æˆé€»è¾‘
      for (let tick = 0; tick < ticksPerRound; tick++) {
        await aiEngine.processTick(tick);
      }

      const decisions = decisionRecorder.stopRecording();
      const finalStateHash = stateHasher.calculateStateHash(
        aiEngine.getCurrentState()
      );

      roundResults.push({
        round,
        finalStateHash,
        decisions,
        entityStates: aiEngine.getAllEntityStates(),
      });
    }

    // Then: éªŒè¯æ‰€æœ‰è½®æ¬¡çš„ä¸€è‡´æ€§
    const firstRoundHash = roundResults[0].finalStateHash;
    const firstRoundDecisions = roundResults[0].decisions;

    for (let i = 1; i < roundResults.length; i++) {
      // æœ€ç»ˆçŠ¶æ€å“ˆå¸Œåº”å®Œå…¨ç›¸åŒ
      expect(roundResults[i].finalStateHash).toBe(firstRoundHash);

      // AIå†³ç­–åºåˆ—åº”100%ä¸€è‡´
      expect(roundResults[i].decisions.length).toBe(firstRoundDecisions.length);
      for (let j = 0; j < firstRoundDecisions.length; j++) {
        expect(roundResults[i].decisions[j]).toEqual(firstRoundDecisions[j]);
      }

      // å®ä½“çŠ¶æ€åº”å®Œå…¨åŒ¹é…
      expect(roundResults[i].entityStates).toEqual(
        roundResults[0].entityStates
      );
    }

    console.log('ç¡®å®šæ€§éªŒè¯ç»“æœ:', {
      ç§å­: testSeed,
      è½®æ•°: roundCount,
      ä¸€è‡´æ€§: '100%',
      æœ€ç»ˆçŠ¶æ€å“ˆå¸Œ: firstRoundHash,
    });
  });

  it('å¤šç§å­ç¡®å®šæ€§é‡ç°éªŒè¯', async () => {
    const testSeeds = [
      12345, 67890, 11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888,
    ];
    const runsPerSeed = 2;

    const seedResults = new Map();

    for (const seed of testSeeds) {
      const seedRuns = [];

      for (let run = 0; run < runsPerSeed; run++) {
        // Given: å‡†å¤‡ç§å­æµ‹è¯•ç¯å¢ƒ
        await aiEngine.reset();
        aiEngine.setSeed(seed);

        const gameScenario = await aiEngine.createStandardScenario({
          entityCount: 20,
          complexity: 'medium',
        });

        decisionRecorder.startRecording(`seed-${seed}-run-${run}`);

        // When: è¿è¡Œç›¸åŒçš„æ¸¸æˆåœºæ™¯
        for (let tick = 0; tick < 50; tick++) {
          await aiEngine.processTick(tick);
        }

        const decisions = decisionRecorder.stopRecording();
        const stateHash = stateHasher.calculateStateHash(
          aiEngine.getCurrentState()
        );

        seedRuns.push({
          run,
          decisions,
          stateHash,
          entityStates: aiEngine.getAllEntityStates(),
        });
      }

      seedResults.set(seed, seedRuns);
    }

    // Then: éªŒè¯æ¯ä¸ªç§å­çš„ä¸€è‡´æ€§
    let totalStateVariance = 0;

    for (const [seed, runs] of seedResults.entries()) {
      // ç›¸åŒç§å­çš„è¿è¡Œç»“æœåº”å®Œå…¨ç›¸åŒ
      expect(runs[0].stateHash).toBe(runs[1].stateHash);
      expect(runs[0].decisions).toEqual(runs[1].decisions);
      expect(runs[0].entityStates).toEqual(runs[1].entityStates);

      // è®¡ç®—çŠ¶æ€å·®å¼‚
      const variance = stateHasher.calculateVariance(
        runs[0].entityStates,
        runs[1].entityStates
      );
      totalStateVariance += variance;
    }

    // çŠ¶æ€æ¼‚ç§»ç‡åº” â‰¤ 0.1%
    const averageVariance = totalStateVariance / testSeeds.length;
    expect(averageVariance).toBeLessThanOrEqual(0.001); // 0.1%

    // éªŒè¯ä¸åŒç§å­äº§ç”Ÿä¸åŒç»“æœ
    const allHashes = Array.from(seedResults.values()).map(
      runs => runs[0].stateHash
    );
    const uniqueHashes = new Set(allHashes);
    expect(uniqueHashes.size).toBe(testSeeds.length); // æ‰€æœ‰ç§å­åº”äº§ç”Ÿä¸åŒç»“æœ
  });

  it('å¤æ‚åœºæ™¯ä¸‹çš„ç¡®å®šæ€§ç¨³å®šæ€§', async () => {
    const complexSeed = 98765;
    const entityCount = 50;
    const longTicks = 1000;
    const repeatCount = 3;

    const complexResults = [];

    for (let run = 0; run < repeatCount; run++) {
      // Given: AIç³»ç»Ÿå¤„ç†å¤æ‚çš„å¤šå®ä½“äº¤äº’åœºæ™¯
      await aiEngine.reset();
      aiEngine.setSeed(complexSeed);

      const complexScenario = await aiEngine.createComplexScenario({
        entityCount,
        complexityLevel: 'high',
        interactionDensity: 0.8,
        decisionTreeDepth: 5,
        enableCrossEntityInfluence: true,
      });

      const stateSnapshots = [];
      decisionRecorder.startRecording(`complex-run-${run}`);

      // When: æŒç»­è¿è¡Œé•¿æ—¶é—´åœºæ™¯
      for (let tick = 0; tick < longTicks; tick++) {
        await aiEngine.processTick(tick);

        // è®°å½•å…³é”®æ—¶é—´ç‚¹çš„çŠ¶æ€å¿«ç…§
        if (tick % 100 === 0) {
          const snapshot = {
            tick,
            stateHash: stateHasher.calculateStateHash(
              aiEngine.getCurrentState()
            ),
            entityPositions: aiEngine.getEntityPositions(),
            decisionCounts: aiEngine.getDecisionCounters(),
          };
          stateSnapshots.push(snapshot);
        }
      }

      const decisions = decisionRecorder.stopRecording();
      const finalStateHash = stateHasher.calculateStateHash(
        aiEngine.getCurrentState()
      );

      complexResults.push({
        run,
        finalStateHash,
        decisions,
        stateSnapshots,
        totalDecisions: decisions.length,
      });
    }

    // Then: éªŒè¯å¤æ‚åœºæ™¯ä¸‹çš„ä¸€è‡´æ€§
    const baselineResult = complexResults[0];

    for (let i = 1; i < complexResults.length; i++) {
      const currentResult = complexResults[i];

      // æœ€ç»ˆçŠ¶æ€åº”å®Œå…¨ä¸€è‡´
      expect(currentResult.finalStateHash).toBe(baselineResult.finalStateHash);

      // å†³ç­–æ€»æ•°åº”ç›¸åŒ
      expect(currentResult.totalDecisions).toBe(baselineResult.totalDecisions);

      // å…³é”®æ—¶é—´ç‚¹çŠ¶æ€å¿«ç…§åº”åŒ¹é…
      expect(currentResult.stateSnapshots.length).toBe(
        baselineResult.stateSnapshots.length
      );

      for (let j = 0; j < baselineResult.stateSnapshots.length; j++) {
        const baseSnapshot = baselineResult.stateSnapshots[j];
        const currentSnapshot = currentResult.stateSnapshots[j];

        expect(currentSnapshot.tick).toBe(baseSnapshot.tick);
        expect(currentSnapshot.stateHash).toBe(baseSnapshot.stateHash);
        expect(currentSnapshot.entityPositions).toEqual(
          baseSnapshot.entityPositions
        );
        expect(currentSnapshot.decisionCounts).toEqual(
          baseSnapshot.decisionCounts
        );
      }

      // å®Œæ•´å†³ç­–åºåˆ—åº”åŒ¹é…
      expect(currentResult.decisions).toEqual(baselineResult.decisions);
    }

    console.log('å¤æ‚åœºæ™¯ç¡®å®šæ€§éªŒè¯ç»“æœ:', {
      ç§å­: complexSeed,
      å®ä½“æ•°é‡: entityCount,
      tickæ•°é‡: longTicks,
      è¿è¡Œæ¬¡æ•°: repeatCount,
      ä¸€è‡´æ€§: '100%',
      å†³ç­–æ€»æ•°: baselineResult.totalDecisions,
    });
  }, 120000); // 2åˆ†é’Ÿè¶…æ—¶ï¼Œé€‚åº”é•¿æ—¶é—´æµ‹è¯•
});
```

#### 11.3.2 50+AIå®ä½“å¹¶å‘å¤„ç†éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/ai-concurrent-processing.feature
Feature: AIå¹¶å‘å¤„ç†èƒ½åŠ›éªŒæ”¶
  ä½œä¸ºæ€§èƒ½å·¥ç¨‹å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿AIç³»ç»Ÿèƒ½å¤Ÿæœ‰æ•ˆå¤„ç†50+AIå®ä½“çš„å¹¶å‘å†³ç­–ï¼Œæ»¡è¶³å®æ—¶æ¸¸æˆçš„æ€§èƒ½è¦æ±‚

  Background:
    Given AI Workeræ± å·²åˆå§‹åŒ–å¹¶å‡†å¤‡å°±ç»ª
    And æ€§èƒ½ç›‘æ§ç³»ç»Ÿå·²å¯ç”¨
    And è´Ÿè½½æµ‹è¯•å·¥å…·å·²é…ç½®

  Scenario: 50ä¸ªAIå®ä½“å¹¶å‘å†³ç­–æ€§èƒ½éªŒè¯
    Given åˆ›å»º50ä¸ªä¸åŒç±»å‹çš„AIå®ä½“
    And æ¯ä¸ªå®ä½“å…·æœ‰ä¸­ç­‰å¤æ‚åº¦çš„å†³ç­–é€»è¾‘
    When åŒæ—¶è§¦å‘æ‰€æœ‰å®ä½“çš„å†³ç­–è®¡ç®—
    And ç›‘æ§å¤„ç†å»¶è¿Ÿå’Œèµ„æºä½¿ç”¨
    Then æ€»ä½“å¤„ç†æ—¶é—´TP95åº” â‰¤ 50ms
    And å•ä¸ªå®ä½“å†³ç­–æ—¶é—´åº” â‰¤ 25ms
    And CPUä½¿ç”¨ç‡åº”ä¿æŒåœ¨80%ä»¥ä¸‹
    And Workeræ± åˆ©ç”¨ç‡åº”åœ¨85-95%ä¹‹é—´

  Scenario: è´Ÿè½½é€’å¢æ‰©å±•æ€§éªŒè¯
    Given AIç³»ç»Ÿä»10ä¸ªå®ä½“å¼€å§‹
    When é€æ­¥å¢åŠ åˆ°100ä¸ªå®ä½“
      | å®ä½“æ•°é‡ | é¢„æœŸTP95å»¶è¿Ÿ | æœ€å¤§å¯æ¥å—å»¶è¿Ÿ |
      | 10      | 10ms        | 20ms          |
      | 25      | 25ms        | 40ms          |
      | 50      | 50ms        | 75ms          |
      | 75      | 75ms        | 100ms         |
      | 100     | 100ms       | 150ms         |
    Then æ¯ä¸ªçº§åˆ«çš„æ€§èƒ½è¦æ±‚éƒ½åº”æ»¡è¶³
    And ç³»ç»Ÿä¸åº”å‡ºç°æ€§èƒ½æ–­å´–å¼ä¸‹é™
    And å†…å­˜ä½¿ç”¨å¢é•¿åº”ä¿æŒçº¿æ€§

  Scenario: é«˜è´Ÿè½½é•¿æœŸç¨³å®šæ€§éªŒè¯
    Given ç»´æŒ75ä¸ªAIå®ä½“çš„æŒç»­è´Ÿè½½
    When è¿ç»­è¿è¡ŒAIå†³ç­–è®¡ç®—60åˆ†é’Ÿ
    And æ¯ç§’è¿›è¡Œ10æ¬¡å†³ç­–å‘¨æœŸ
    Then æ€§èƒ½ä¸åº”å‡ºç°æ˜æ˜¾é€€åŒ–
    And å†…å­˜æ³„æ¼é€Ÿç‡åº” â‰¤ 1MB/å°æ—¶
    And é”™è¯¯ç‡åº”ä¿æŒåœ¨0.1%ä»¥ä¸‹
    And Workeré‡å¯æ¬¡æ•°åº” â‰¤ 3æ¬¡
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/ai-concurrent-processing.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { AIWorkerPool } from '@/ai/AIWorkerPool';
import { AIEntityManager } from '@/ai/AIEntityManager';
import { PerformanceMonitor } from '@/shared/monitoring/PerformanceMonitor';
import { LoadTestRunner } from '@/shared/testing/LoadTestRunner';

describe('AIå¹¶å‘å¤„ç†èƒ½åŠ›éªŒæ”¶', () => {
  let workerPool: AIWorkerPool;
  let entityManager: AIEntityManager;
  let performanceMonitor: PerformanceMonitor;
  let loadTestRunner: LoadTestRunner;

  beforeEach(async () => {
    workerPool = new AIWorkerPool({
      maxWorkers: 4,
      workerTimeout: 5000,
      queueSize: 1000
    });

    entityManager = new AIEntityManager();
    performanceMonitor = new PerformanceMonitor();
    loadTestRunner = new LoadTestRunner();

    await workerPool.initialize();
    await performanceMonitor.start();
  });

  afterEach(async () => {
    await workerPool.shutdown();
    await performanceMonitor.stop();
    entityManager.cleanup();
  });

  it('50ä¸ªAIå®ä½“å¹¶å‘å†³ç­–æ€§èƒ½éªŒè¯', async () => {
    // Given: åˆ›å»º50ä¸ªä¸åŒç±»å‹çš„AIå®ä½“
    const entities = await entityManager.createEntities(50, {
      types: ['merchant', 'adventurer', 'craftsman', 'guard', 'citizen'],
      complexity: 'medium',
      distributionStrategy: 'balanced'
    });

    expect(entities.length).toBe(50);

    // When: åŒæ—¶è§¦å‘æ‰€æœ‰å®ä½“çš„å†³ç­–è®¡ç®—
    const startTime = performance.now();

    const decisionPromises = entities.map(entity =>
      workerPool.processDecision({
        entityId: entity.id,
        entityType: entity.type,
        currentState: entity.getState(),
        decisionContext: entity.getDecisionContext(),
        complexity: 'medium'
      })
    );

    const results = await Promise.all(decisionPromises);
    const endTime = performance.now();
    const totalProcessingTime = endTime - startTime;

    // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
    const processingTimes = results.map(r => r.processingTime);
    const tp95Time = this.calculatePercentile(processingTimes, 95);
    const maxTime = Math.max(...processingTimes);

    const resourceMetrics = await performanceMonitor.getCurrentMetrics();

    // Then: éªŒè¯æ€§èƒ½è¦æ±‚

    // æ€»ä½“å¤„ç†æ—¶é—´TP95åº” â‰¤ 50ms
    expect(tp95Time).toBeLessThanOrEqual(50);

    // å•ä¸ªå®ä½“å†³ç­–æ—¶é—´åº” â‰¤ 25ms
    expect(maxTime).toBeLessThanOrEqual(25);

    // CPUä½¿ç”¨ç‡åº”ä¿æŒåœ¨80%ä»¥ä¸‹
    expect(resourceMetrics.cpuUsage).toBeLessThan(80);

    // Workeræ± åˆ©ç”¨ç‡åº”åœ¨85-95%ä¹‹é—´
    const workerUtilization = workerPool.getUtilizationRate();
    expect(workerUtilization).toBeGreaterThanOrEqual(85);
    expect(workerUtilization).toBeLessThanOrEqual(95);

    console.log('50å®ä½“å¹¶å‘æµ‹è¯•ç»“æœ:', {
      æ€»å¤„ç†æ—¶é—´: totalProcessingTime,
      TP95å»¶è¿Ÿ: tp95Time,
      æœ€å¤§å»¶è¿Ÿ: maxTime,
      CPUä½¿ç”¨ç‡: resourceMetrics.cpuUsage,
      Workeråˆ©ç”¨ç‡: workerUtilization,
      æˆåŠŸç‡: (results.filter(r => r.success).length / results.length) * 100
    });
  });

  it('è´Ÿè½½é€’å¢æ‰©å±•æ€§éªŒè¯', async () => {
    const loadLevels = [
      { entityCount: 10, expectedTP95: 10, maxAcceptable: 20 },
      { entityCount: 25, expectedTP95: 25, maxAcceptable: 40 },
      { entityCount: 50, expectedTP95: 50, maxAcceptable: 75 },
      { entityCount: 75, expectedTP95: 75, maxAcceptable: 100 },
      { entityCount: 100, expectedTP95: 100, maxAcceptable: 150 }
    ];

    const scalabilityResults = [];
    let previousMemoryUsage = 0;

    for (const level of loadLevels) {
      // Given: AIç³»ç»Ÿå‡†å¤‡æŒ‡å®šæ•°é‡çš„å®ä½“
      await entityManager.cleanup(); // æ¸…ç†ä¹‹å‰çš„å®ä½“

      const entities = await entityManager.createEntities(level.entityCount, {
        complexity: 'medium',
        distributionStrategy: 'uniform'
      });

      // When: æ‰§è¡Œè´Ÿè½½æµ‹è¯•
      const loadTestResult = await loadTestRunner.runConcurrentDecisionTest({
        entities,
        iterations: 10,
        measureLatency: true,
        measureResources: true
      });

      const currentMemoryUsage = await performanceMonitor.getMemoryUsage();

      // è®°å½•ç»“æœ
      scalabilityResults.push({
        entityCount: level.entityCount,
        tp95Latency: loadTestResult.tp95Latency,
        maxLatency: loadTestResult.maxLatency,
        memoryUsage: currentMemoryUsage.heapUsed,
        memoryGrowth: currentMemoryUsage.heapUsed - previousMemoryUsage,
        cpuUsage: loadTestResult.averageCpuUsage,
        successRate: loadTestResult.successRate
      });

      previousMemoryUsage = currentMemoryUsage.heapUsed;

      // Then: éªŒè¯å½“å‰çº§åˆ«çš„æ€§èƒ½è¦æ±‚
      expect(loadTestResult.tp95Latency).toBeLessThanOrEqual(level.expectedTP95);
      expect(loadTestResult.maxLatency).toBeLessThanOrEqual(level.maxAcceptable);
      expect(loadTestResult.successRate).toBeGreaterThanOrEqual(99.5);
    }

    // éªŒè¯æ•´ä½“æ‰©å±•æ€§ç‰¹å¾

    // ä¸åº”å‡ºç°æ€§èƒ½æ–­å´–å¼ä¸‹é™
    for (let i = 1; i < scalabilityResults.length; i++) {
      const current = scalabilityResults[i];
      const previous = scalabilityResults[i - 1];

      // å»¶è¿Ÿå¢é•¿ä¸åº”è¶…è¿‡3å€
      const latencyGrowthFactor = current.tp95Latency / previous.tp95Latency;
      expect(latencyGrowthFactor).toBeLessThan(3.0);
    }

    // å†…å­˜ä½¿ç”¨å¢é•¿åº”ä¿æŒçº¿æ€§ï¼ˆå…è®¸20%çš„åå·®ï¼‰
    const memoryGrowthRates = scalabilityResults.slice(1).map((result, index) => {
      const previous = scalabilityResults[index];
      const entityRatio = result.entityCount / previous.entityCount;
      const memoryRatio = result.memoryUsage / previous.memoryUsage;
      return memoryRatio / entityRatio; // æ¥è¿‘1.0è¡¨ç¤ºçº¿æ€§å¢é•¿
    });

    for (const growthRate of memoryGrowthRates) {
      expect(growthRate).toBeGreaterThan(0.8); // å…è®¸20%è´Ÿåå·®
      expect(growthRate).toBeLessThan(1.5);    // å…è®¸50%æ­£åå·®
    }

    console.log('æ‰©å±•æ€§æµ‹è¯•ç»“æœ:', scalabilityResults);
  }, 300000); // 5åˆ†é’Ÿè¶…æ—¶

  it('é«˜è´Ÿè½½é•¿æœŸç¨³å®šæ€§éªŒè¯', async () => {
    const testDuration = 60 * 60 * 1000; // 60åˆ†é’Ÿ
    const entityCount = 75;
    const decisionsPerSecond = 10;

    // Given: ç»´æŒ75ä¸ªAIå®ä½“çš„æŒç»­è´Ÿè½½
    const entities = await entityManager.createEntities(entityCount, {
      complexity: 'medium',
      enableLongTermMemory: true
    });

    const stabilityMonitor = performanceMonitor.createLongTermMonitor({
      samplingInterval: 30000, // æ¯30ç§’é‡‡æ ·
      metricsToTrack: ['memory', 'cpu', 'latency', 'errors', 'workerHealth']
    });

    stabilityMonitor.start();

    let totalDecisions = 0;
    let totalErrors = 0;
    let workerRestarts = 0;

    const startTime = Date.now();
    const endTime = startTime + testDuration;

    // When: è¿ç»­è¿è¡ŒAIå†³ç­–è®¡ç®—60åˆ†é’Ÿ
    while (Date.now() < endTime) {
      const cycleStartTime = Date.now();

      // æ¯ç§’è¿›è¡Œ10æ¬¡å†³ç­–å‘¨æœŸ
      for (let cycle = 0; cycle < decisionsPerSecond; cycle++) {
        try {
          // éšæœºé€‰æ‹©ä¸€éƒ¨åˆ†å®ä½“è¿›è¡Œå†³ç­–
          const selectedEntities = this.randomSample(entities, Math.floor(entityCount * 0.3));

          const decisions = await Promise.all(
            selectedEntities.map(entity =>
              workerPool.processDecision({
                entityId: entity.id,
                currentState: entity.getState(),
                decisionContext: entity.getDecisionContext()
              })
            )
          );

          totalDecisions += decisions.length;
          totalErrors += decisions.filter(d => !d.success).length;

        } catch (error) {
          totalErrors++;
        }
      }

      // æ£€æŸ¥Workeré‡å¯
      const currentWorkerRestarts = workerPool.getRestartCount();
      if (currentWorkerRestarts > workerRestarts) {
        workerRestarts = currentWorkerRestarts;
      }

      // æ§åˆ¶å¾ªç¯é¢‘ç‡ä¸ºæ¯ç§’ä¸€æ¬¡
      const cycleEndTime = Date.now();
      const cycleDuration = cycleEndTime - cycleStartTime;
      if (cycleDuration < 1000) {
        await new Promise(resolve => setTimeout(resolve, 1000 - cycleDuration));
      }
    }

    const finalMetrics = stabilityMonitor.stop();

    // Then: éªŒè¯é•¿æœŸç¨³å®šæ€§è¦æ±‚

    // æ€§èƒ½ä¸åº”å‡ºç°æ˜æ˜¾é€€åŒ–
    const initialLatency = finalMetrics.samples[0].averageLatency;
    const finalLatency = finalMetrics.samples[finalMetrics.samples.length - 1].averageLatency;
    const latencyDegradation = (finalLatency - initialLatency) / initialLatency;

    expect(latencyDegradation).toBeLessThan(0.2); // æ€§èƒ½é€€åŒ–ä¸è¶…è¿‡20%

    // å†…å­˜æ³„æ¼é€Ÿç‡åº” â‰¤ 1MB/å°æ—¶
    const initialMemory = finalMetrics.samples[0].memoryUsage;
    const finalMemory = finalMetrics.samples[finalMetrics.samples.length - 1].memoryUsage;
    const memoryLeakRate = (finalMemory - initialMemory) / (1024 * 1024); // MB

    expect(memoryLeakRate).toBeLessThanOrEqual(1); // â‰¤ 1MB/å°æ—¶

    // é”™è¯¯ç‡åº”ä¿æŒåœ¨0.1%ä»¥ä¸‹
    const errorRate = (totalErrors / totalDecisions) * 100;
    expect(errorRate).toBeLessThan(0.1);

    // Workeré‡å¯æ¬¡æ•°åº” â‰¤ 3æ¬¡
    expect(workerRestarts).toBeLessThanOrEqual(3);

    console.log('é•¿æœŸç¨³å®šæ€§æµ‹è¯•ç»“æœ:', {
      æµ‹è¯•æ—¶é•¿: '60åˆ†é’Ÿ',
      æ€»å†³ç­–æ•°: totalDecisions,
      é”™è¯¯ç‡: errorRate.toFixed(3) + '%',
      æ€§èƒ½é€€åŒ–: (latencyDegradation * 100).toFixed(2) + '%',
      å†…å­˜æ³„æ¼: memoryLeakRate.toFixed(2) + 'MB',
      Workeré‡å¯: workerRestarts + 'æ¬¡'
    });

  }, 4000000); // çº¦70åˆ†é’Ÿè¶…æ—¶ï¼Œç•™å‡ºå……è¶³æ—¶é—´

  // è¾…åŠ©æ–¹æ³•
  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = values.sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  private randomSample<T>(array: T[], sampleSize: number): T[] {
    const shuffled = [...array].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, sampleSize);
  }
});
```

### 11.4 Electronè¿›ç¨‹åè°ƒéªŒæ”¶è§„èŒƒï¼ˆCross-Process Coordination Acceptanceï¼‰

#### 11.4.1 IPCé€šä¿¡å»¶è¿ŸéªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/electron-ipc-latency.feature
Feature: Electron IPCé€šä¿¡å»¶è¿ŸéªŒæ”¶
  ä½œä¸ºç³»ç»Ÿæ¶æ„å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿Electronä¸‰è¿›ç¨‹é—´çš„IPCé€šä¿¡å»¶è¿Ÿæ»¡è¶³å®æ—¶æ¸¸æˆè¦æ±‚

  Background:
    Given Electronåº”ç”¨å·²å®Œå…¨å¯åŠ¨
    And ä¸»è¿›ç¨‹ã€æ¸²æŸ“è¿›ç¨‹å’ŒWorkerè¿›ç¨‹éƒ½å·²å°±ç»ª
    And IPCæ€§èƒ½ç›‘æ§å·²å¯ç”¨

  Scenario: ä¸»è¿›ç¨‹ä¸æ¸²æŸ“è¿›ç¨‹IPCå»¶è¿ŸéªŒè¯
    Given ä¸»è¿›ç¨‹å’Œæ¸²æŸ“è¿›ç¨‹å»ºç«‹äº†IPCé€šé“
    When å‘é€1000ä¸ªåŒæ­¥å’Œå¼‚æ­¥IPCæ¶ˆæ¯
      | æ¶ˆæ¯ç±»å‹ | è´Ÿè½½å¤§å° | é¢„æœŸå»¶è¿Ÿ |
      | å°æ¶ˆæ¯   | <1KB    | <5ms     |
      | ä¸­æ¶ˆæ¯   | 1-10KB  | <8ms     |
      | å¤§æ¶ˆæ¯   | 10-50KB | <15ms    |
    Then ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹çš„å»¶è¿ŸP95åº” â‰¤ 10ms
    And æ¸²æŸ“è¿›ç¨‹åˆ°ä¸»è¿›ç¨‹çš„å»¶è¿ŸP95åº” â‰¤ 10ms
    And æ¶ˆæ¯ä¸¢å¤±ç‡åº”ä¸º0%
    And ä¸åº”å‡ºç°IPCé€šé“é˜»å¡

  Scenario: Workerè¿›ç¨‹é€šä¿¡æ€§èƒ½éªŒè¯
    Given AI Workerè¿›ç¨‹æ± å·²åˆå§‹åŒ–
    When åŒæ—¶å‘4ä¸ªWorkerå‘é€è®¡ç®—ä»»åŠ¡
    And æ¯ä¸ªä»»åŠ¡åŒ…å«ä¸­ç­‰å¤æ‚åº¦çš„AIå†³ç­–
    Then Workeræ¶ˆæ¯å¤„ç†å»¶è¿ŸP95åº” â‰¤ 30ms
    And Workerè¿›ç¨‹åˆ›å»ºæ—¶é—´P90åº” â‰¤ 200ms
    And Workerå†…å­˜éš”ç¦»åº”å®Œæ•´æœ‰æ•ˆ

  Scenario: è·¨è¿›ç¨‹æ•°æ®æµæ€§èƒ½éªŒè¯
    Given æ¸¸æˆæ•°æ®åœ¨ä¸»è¿›ç¨‹ä¸­ç®¡ç†
    When æ¸²æŸ“è¿›ç¨‹è¯·æ±‚å¤§é‡æ¸¸æˆçŠ¶æ€æ›´æ–°
    And åŒæ—¶Workerè¿›ç¨‹è®¡ç®—AIå†³ç­–
    Then æ•´ä½“æ•°æ®æµå»¶è¿Ÿåº” â‰¤ 50ms
    And è¿›ç¨‹é—´ä¸åº”å‡ºç°ç«æ€æ¡ä»¶
    And æ•°æ®å®Œæ•´æ€§åº”ä¿æŒ100%
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/electron-ipc-latency.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ElectronIPCTester } from '@/shared/testing/ElectronIPCTester';
import { ProcessCoordinator } from '@/main/ProcessCoordinator';
import { IPCPerformanceMonitor } from '@/shared/monitoring/IPCPerformanceMonitor';

describe('Electron IPCé€šä¿¡å»¶è¿ŸéªŒæ”¶', () => {
  let ipcTester: ElectronIPCTester;
  let processCoordinator: ProcessCoordinator;
  let ipcMonitor: IPCPerformanceMonitor;

  beforeEach(async () => {
    ipcTester = new ElectronIPCTester();
    processCoordinator = new ProcessCoordinator();
    ipcMonitor = new IPCPerformanceMonitor();

    await ipcTester.initialize();
    await ipcMonitor.start();
  });

  afterEach(async () => {
    await ipcTester.cleanup();
    await ipcMonitor.stop();
  });

  it('ä¸»è¿›ç¨‹ä¸æ¸²æŸ“è¿›ç¨‹IPCå»¶è¿ŸéªŒè¯', async () => {
    // Given: ä¸»è¿›ç¨‹å’Œæ¸²æŸ“è¿›ç¨‹å»ºç«‹äº†IPCé€šé“
    await ipcTester.establishMainRendererChannel();

    const testMessages = [
      { type: 'å°æ¶ˆæ¯', size: 500, count: 300, expectedLatency: 5 },     // <1KB
      { type: 'ä¸­æ¶ˆæ¯', size: 5000, count: 400, expectedLatency: 8 },    // 1-10KB
      { type: 'å¤§æ¶ˆæ¯', size: 25000, count: 300, expectedLatency: 15 }   // 10-50KB
    ];

    const allLatencies = [];
    let totalLostMessages = 0;

    for (const testCase of testMessages) {
      // When: å‘é€ä¸åŒå¤§å°çš„IPCæ¶ˆæ¯
      const testData = ipcTester.generateTestData(testCase.size);
      const results = await ipcTester.sendBidirectionalMessages({
        messageCount: testCase.count,
        payload: testData,
        measureLatency: true,
        timeout: 5000
      });

      // è®°å½•å»¶è¿Ÿæ•°æ®
      allLatencies.push(...results.latencies);
      totalLostMessages += results.lostMessages;

      // éªŒè¯å½“å‰æ¶ˆæ¯ç±»å‹çš„å»¶è¿Ÿè¦æ±‚
      const currentP95 = this.calculatePercentile(results.latencies, 95);
      expect(currentP95).toBeLessThanOrEqual(testCase.expectedLatency);
    }

    // Then: æ•´ä½“éªŒè¯

    // ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹çš„å»¶è¿ŸP95åº” â‰¤ 10ms
    const mainToRendererLatencies = allLatencies.filter(l => l.direction === 'main-to-renderer');
    const mainToRendererP95 = this.calculatePercentile(mainToRendererLatencies.map(l => l.latency), 95);
    expect(mainToRendererP95).toBeLessThanOrEqual(10);

    // æ¸²æŸ“è¿›ç¨‹åˆ°ä¸»è¿›ç¨‹çš„å»¶è¿ŸP95åº” â‰¤ 10ms
    const rendererToMainLatencies = allLatencies.filter(l => l.direction === 'renderer-to-main');
    const rendererToMainP95 = this.calculatePercentile(rendererToMainLatencies.map(l => l.latency), 95);
    expect(rendererToMainP95).toBeLessThanOrEqual(10);

    // æ¶ˆæ¯ä¸¢å¤±ç‡åº”ä¸º0%
    expect(totalLostMessages).toBe(0);

    // ä¸åº”å‡ºç°IPCé€šé“é˜»å¡
    const blockingEvents = await ipcMonitor.getBlockingEvents();
    expect(blockingEvents.length).toBe(0);

    console.log('IPCå»¶è¿Ÿæµ‹è¯•ç»“æœ:', {
      ä¸»è¿›ç¨‹åˆ°æ¸²æŸ“è¿›ç¨‹P95: mainToRendererP95,
      æ¸²æŸ“è¿›ç¨‹åˆ°ä¸»è¿›ç¨‹P95: rendererToMainP95,
      æ€»æ¶ˆæ¯æ•°: allLatencies.length,
      ä¸¢å¤±æ¶ˆæ¯: totalLostMessages,
      é˜»å¡äº‹ä»¶: blockingEvents.length
    });
  });

  it('Workerè¿›ç¨‹é€šä¿¡æ€§èƒ½éªŒè¯', async () => {
    // Given: AI Workerè¿›ç¨‹æ± å·²åˆå§‹åŒ–
    const workerPool = await processCoordinator.initializeWorkerPool({
      maxWorkers: 4,
      workerType: 'ai-decision',
      resourceLimits: {
        maxMemory: '100MB',
        maxCpu: '25%'
      }
    });

    // When: åŒæ—¶å‘4ä¸ªWorkerå‘é€è®¡ç®—ä»»åŠ¡
    const aiTasks = Array.from({ length: 40 }, (_, index) => ({
      taskId: `ai-task-${index}`,
      type: 'decision-calculation',
      complexity: 'medium',
      entityData: ipcTester.generateAIEntityData(),
      expectedProcessingTime: 200 // msé¢„æœŸ
    }));

    const workerTestResults = await Promise.all(
      workerPool.workers.map(async (worker, workerIndex) => {
        const workerTasks = aiTasks.slice(workerIndex * 10, (workerIndex + 1) * 10);

        const startTime = performance.now();
        const taskResults = await Promise.all(
          workerTasks.map(task => worker.sendTask(task))
        );
        const endTime = performance.now();

        return {
          workerId: worker.id,
          tasks: workerTasks.length,
          totalTime: endTime - startTime,
          results: taskResults,
          avgLatency: taskResults.reduce((sum, r) => sum + r.processingTime, 0) / taskResults.length
        };
      })
    );

    // æ”¶é›†æ‰€æœ‰Workerçš„å»¶è¿Ÿæ•°æ®
    const allWorkerLatencies = workerTestResults.flatMap(r =>
      r.results.map(result => result.processingTime)
    );

    // Then: éªŒè¯Workeræ€§èƒ½è¦æ±‚

    // Workeræ¶ˆæ¯å¤„ç†å»¶è¿ŸP95åº” â‰¤ 30ms
    const workerLatencyP95 = this.calculatePercentile(allWorkerLatencies, 95);
    expect(workerLatencyP95).toBeLessThanOrEqual(30);

    // Workerè¿›ç¨‹åˆ›å»ºæ—¶é—´P90åº” â‰¤ 200ms
    const workerCreationTimes = await Promise.all(
      Array.from({ length: 10 }).map(() => ipcTester.measureWorkerCreationTime())
    );
    const creationTimeP90 = this.calculatePercentile(workerCreationTimes, 90);
    expect(creationTimeP90).toBeLessThanOrEqual(200);

    // Workerå†…å­˜éš”ç¦»åº”å®Œæ•´æœ‰æ•ˆ
    const memoryIsolationTest = await ipcTester.testWorkerMemoryIsolation(workerPool);
    expect(memoryIsolationTest.isolated).toBe(true);
    expect(memoryIsolationTest.memoryLeakBetweenWorkers).toBe(false);

    console.log('Workeræ€§èƒ½æµ‹è¯•ç»“æœ:', {
      Workerå»¶è¿ŸP95: workerLatencyP95,
      åˆ›å»ºæ—¶é—´P90: creationTimeP90,
      å†…å­˜éš”ç¦»: memoryIsolationTest.isolated,
      æ€»ä»»åŠ¡æ•°: aiTasks.length,
      æˆåŠŸç‡: (workerTestResults.reduce((sum, r) => sum + r.results.filter(t => t.success).length, 0) / aiTasks.length) * 100
    });
  });

  it('è·¨è¿›ç¨‹æ•°æ®æµæ€§èƒ½éªŒè¯', async () => {
    // Given: æ¸¸æˆæ•°æ®åœ¨ä¸»è¿›ç¨‹ä¸­ç®¡ç†
    const gameDataManager = processCoordinator.getGameDataManager();
    await gameDataManager.initialize();

    // åˆ›å»ºå¤§é‡æµ‹è¯•æ•°æ®
    const gameStateData = ipcTester.generateGameStateData({
      entities: 200,
      events: 500,
      mapSize: '1000x1000',
      complexity: 'high'
    });
    await gameDataManager.loadData(gameStateData);

    // When: åŒæ—¶è¿›è¡Œå¤šç§è·¨è¿›ç¨‹æ“ä½œ
    const concurrentOperations = await Promise.all([
      // æ¸²æŸ“è¿›ç¨‹è¯·æ±‚æ¸¸æˆçŠ¶æ€æ›´æ–°
      ipcTester.simulateRendererStateRequests({
        requestCount: 50,
        requestFrequency: 100, // ms
        dataSize: 'large'
      }),

      // Workerè¿›ç¨‹è®¡ç®—AIå†³ç­–
      ipcTester.simulateWorkerAICalculations({
        workerCount: 4,
        calculationsPerWorker: 25,
        calculationComplexity: 'medium'
      }),

      // ä¸»è¿›ç¨‹åè°ƒæ•°æ®æµ
      ipcTester.simulateMainProcessCoordination({
        coordinationTasks: 30,
        dataFlowManagement: true
      })
    ]);

    const [rendererResults, workerResults, mainResults] = concurrentOperations;

    // åˆ†ææ•´ä½“æ•°æ®æµæ€§èƒ½
    const overallLatencies = [
      ...rendererResults.latencies,
      ...workerResults.latencies,
      ...mainResults.latencies
    ];

    // Then: éªŒè¯è·¨è¿›ç¨‹æ•°æ®æµè¦æ±‚

    // æ•´ä½“æ•°æ®æµå»¶è¿Ÿåº” â‰¤ 50ms
    const overallP95 = this.calculatePercentile(overallLatencies, 95);
    expect(overallP95).toBeLessThanOrEqual(50);

    // è¿›ç¨‹é—´ä¸åº”å‡ºç°ç«æ€æ¡ä»¶
    const raceConditions = await ipcTester.detectRaceConditions([
      rendererResults, workerResults, mainResults
    ]);
    expect(raceConditions.detected).toBe(false);

    // æ•°æ®å®Œæ•´æ€§åº”ä¿æŒ100%
    const dataIntegrityCheck = await gameDataManager.validateDataIntegrity();
    expect(dataIntegrityCheck.integrityScore).toBe(100);
    expect(dataIntegrityCheck.corruptedItems).toHaveLength(0);

    console.log('è·¨è¿›ç¨‹æ•°æ®æµæµ‹è¯•ç»“æœ:', {
      æ•´ä½“å»¶è¿ŸP95: overallP95,
      ç«æ€æ¡ä»¶: raceConditions.detected,
      æ•°æ®å®Œæ•´æ€§: dataIntegrityCheck.integrityScore + '%',
      æ€»æ“ä½œæ•°: overallLatencies.length,
      å„è¿›ç¨‹æ€§èƒ½: {
        æ¸²æŸ“è¿›ç¨‹: `å¹³å‡${rendererResults.avgLatency}ms`,
        Workerè¿›ç¨‹: `å¹³å‡${workerResults.avgLatency}ms`,
        ä¸»è¿›ç¨‹: `å¹³å‡${mainResults.avgLatency}ms`
      }
    });
  }, 60000); // 1åˆ†é’Ÿè¶…æ—¶

  // è¾…åŠ©æ–¹æ³•
  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = values.sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }
});
```

### 11.5 æ¸¸æˆåŠŸèƒ½éªŒæ”¶è§„èŒƒï¼ˆGame Function Acceptanceï¼‰

#### 11.5.1 FPSç¨³å®šæ€§éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/game-fps-stability.feature
Feature: æ¸¸æˆFPSç¨³å®šæ€§éªŒæ”¶
  ä½œä¸ºç©å®¶ï¼Œæˆ‘éœ€è¦æ¸¸æˆå¸§ç‡ä¿æŒç¨³å®šåœ¨58+FPSï¼Œç¡®ä¿æµç•…çš„æ¸¸æˆä½“éªŒ

  Background:
    Given æ¸¸æˆå¼•æ“å·²å®Œå…¨åˆå§‹åŒ–
    And Phaser 3æ¸²æŸ“å™¨å·²å‡†å¤‡å°±ç»ª
    And æ€§èƒ½ç›‘æ§å·²å¯ç”¨

  Scenario: åŸºç¡€æ¸¸æˆåœºæ™¯FPSç¨³å®šæ€§
    Given åŠ è½½æ ‡å‡†æ¸¸æˆåœºæ™¯
    And åœºæ™¯åŒ…å«åŸºæœ¬çš„æ¸¸æˆå…ƒç´ 
    When è¿è¡Œæ¸¸æˆ30åˆ†é’Ÿ
    And ç›‘æ§å¸§ç‡è¡¨ç°
    Then å¹³å‡FPSåº” â‰¥ 58FPS
    And 1%ä½å¸§æ—¶ä¸åº”ä½äº45FPS
    And å¸§æ—¶é—´æ³¢åŠ¨æ ‡å‡†å·®åº” â‰¤ 3ms
    And ä¸åº”å‡ºç°æ˜æ˜¾çš„å¡é¡¿ç°è±¡

  Scenario: é«˜è´Ÿè½½åœºæ™¯FPSå‹åŠ›æµ‹è¯•
    Given åŠ è½½å¤æ‚æ¸¸æˆåœºæ™¯
    And åŒæ—¶æ¿€æ´»100+æ¸¸æˆå¯¹è±¡
    And å¯ç”¨ç‰¹æ•ˆå’ŒåŠ¨ç”»
    When æŒç»­è¿è¡Œ60åˆ†é’Ÿå‹åŠ›æµ‹è¯•
    Then å¹³å‡FPSåº”ä¿æŒ â‰¥ 55FPS
    And å¸§ç‡ä¸åº”å‡ºç°æ–­å´–å¼ä¸‹é™
    And å†…å­˜ä½¿ç”¨åº”ä¿æŒç¨³å®š
    And æ¸²æŸ“æ€§èƒ½ä¸åº”æ˜æ˜¾é€€åŒ–
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/game-fps-stability.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GameEngine } from '@/game/GameEngine';
import { FPSMonitor } from '@/shared/monitoring/FPSMonitor';
import { SceneManager } from '@/game/SceneManager';

describe('æ¸¸æˆFPSç¨³å®šæ€§éªŒæ”¶', () => {
  let gameEngine: GameEngine;
  let fpsMonitor: FPSMonitor;
  let sceneManager: SceneManager;

  beforeEach(async () => {
    gameEngine = new GameEngine();
    fpsMonitor = new FPSMonitor();
    sceneManager = new SceneManager();

    await gameEngine.initialize();
    fpsMonitor.start();
  });

  it('åŸºç¡€æ¸¸æˆåœºæ™¯FPSç¨³å®šæ€§', async () => {
    // Given: åŠ è½½æ ‡å‡†æ¸¸æˆåœºæ™¯
    const standardScene = await sceneManager.loadStandardScene({
      entities: 50,
      effects: 'basic',
      complexity: 'standard'
    });

    await gameEngine.setActiveScene(standardScene);

    // When: è¿è¡Œæ¸¸æˆ30åˆ†é’Ÿ
    const testDuration = 30 * 60 * 1000; // 30åˆ†é’Ÿ

    const fpsData = await fpsMonitor.recordForDuration({
      duration: testDuration,
      samplingRate: 1000, // æ¯ç§’é‡‡æ ·
      includeFrameTimes: true
    });

    // Then: éªŒè¯FPSç¨³å®šæ€§è¦æ±‚

    // å¹³å‡FPSåº” â‰¥ 58FPS
    expect(fpsData.averageFPS).toBeGreaterThanOrEqual(58);

    // 1%ä½å¸§æ—¶ä¸åº”ä½äº45FPS
    const fps1Percentile = this.calculatePercentile(fpsData.fpsValues, 1);
    expect(fps1Percentile).toBeGreaterThanOrEqual(45);

    // å¸§æ—¶é—´æ³¢åŠ¨æ ‡å‡†å·®åº” â‰¤ 3ms
    const frameTimeStdDev = this.calculateStandardDeviation(fpsData.frameTimes);
    expect(frameTimeStdDev).toBeLessThanOrEqual(3);

    // ä¸åº”å‡ºç°æ˜æ˜¾çš„å¡é¡¿ç°è±¡
    const stutterEvents = fpsData.fpsValues.filter(fps => fps < 30).length;
    const stutterRate = stutterEvents / fpsData.fpsValues.length;
    expect(stutterRate).toBeLessThan(0.001); // <0.1%çš„ä¸¥é‡å¡é¡¿

    console.log('åŸºç¡€åœºæ™¯FPSæµ‹è¯•ç»“æœ:', {
      å¹³å‡FPS: fpsData.averageFPS,
      æœ€ä½1ç™¾åˆ†ä½FPS: fps1Percentile,
      å¸§æ—¶é—´æ ‡å‡†å·®: frameTimeStdDev,
      å¡é¡¿ç‡: (stutterRate * 100).toFixed(3) + '%'
    });
  }, 35 * 60 * 1000); // 35åˆ†é’Ÿè¶…æ—¶

  it('é«˜è´Ÿè½½åœºæ™¯FPSå‹åŠ›æµ‹è¯•', async () => {
    // Given: åŠ è½½å¤æ‚æ¸¸æˆåœºæ™¯
    const complexScene = await sceneManager.loadComplexScene({
      entities: 100,
      effects: 'advanced',
      particles: true,
      lighting: 'dynamic',
      complexity: 'high'
    });

    await gameEngine.setActiveScene(complexScene);

    // When: æŒç»­è¿è¡Œ60åˆ†é’Ÿå‹åŠ›æµ‹è¯•
    const testDuration = 60 * 60 * 1000; // 60åˆ†é’Ÿ

    const longTermMonitor = fpsMonitor.createLongTermMonitor({
      duration: testDuration,
      samplingInterval: 5000, // æ¯5ç§’é‡‡æ ·
      trackDegradation: true,
      trackMemoryUsage: true
    });

    const performanceData = await longTermMonitor.run();

    // Then: éªŒè¯é«˜è´Ÿè½½æ€§èƒ½è¦æ±‚

    // å¹³å‡FPSåº”ä¿æŒ â‰¥ 55FPS
    expect(performanceData.overallAverageFPS).toBeGreaterThanOrEqual(55);

    // å¸§ç‡ä¸åº”å‡ºç°æ–­å´–å¼ä¸‹é™
    const performanceDegradation = this.calculatePerformanceDegradation(performanceData.fpsTimeSeries);
    expect(performanceDegradation.maxDropPercentage).toBeLessThan(20); // å•æ¬¡é™å¹…ä¸è¶…è¿‡20%

    // å†…å­˜ä½¿ç”¨åº”ä¿æŒç¨³å®š
    const memoryGrowthRate = this.calculateMemoryGrowthRate(performanceData.memoryUsage);
    expect(memoryGrowthRate).toBeLessThan(10); // MB/å°æ—¶

    // æ¸²æŸ“æ€§èƒ½ä¸åº”æ˜æ˜¾é€€åŒ–
    const initialFPS = performanceData.fpsTimeSeries.slice(0, 360); // å‰30åˆ†é’Ÿ
    const finalFPS = performanceData.fpsTimeSeries.slice(-360);     // å30åˆ†é’Ÿ

    const initialAvg = initialFPS.reduce((sum, fps) => sum + fps, 0) / initialFPS.length;
    const finalAvg = finalFPS.reduce((sum, fps) => sum + fps, 0) / finalFPS.length;
    const degradationPercentage = ((initialAvg - finalAvg) / initialAvg) * 100;

    expect(degradationPercentage).toBeLessThan(10); // æ€§èƒ½é€€åŒ–ä¸è¶…è¿‡10%

    console.log('é«˜è´Ÿè½½åœºæ™¯FPSæµ‹è¯•ç»“æœ:', {
      æ•´ä½“å¹³å‡FPS: performanceData.overallAverageFPS,
      æœ€å¤§å¸§ç‡é™å¹…: performanceDegradation.maxDropPercentage + '%',
      å†…å­˜å¢é•¿ç‡: memoryGrowthRate + 'MB/h',
      æ€§èƒ½é€€åŒ–: degradationPercentage.toFixed(2) + '%',
      æµ‹è¯•æ—¶é•¿: '60åˆ†é’Ÿ'
    });
  }, 70 * 60 * 1000); // 70åˆ†é’Ÿè¶…æ—¶

  // è¾…åŠ©æ–¹æ³•
  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = values.sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  private calculateStandardDeviation(values: number[]): number {
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
    return Math.sqrt(avgSquaredDiff);
  }

  private calculatePerformanceDegradation(fpsTimeSeries: number[]): { maxDropPercentage: number } {
    let maxDrop = 0;

    for (let i = 1; i < fpsTimeSeries.length; i++) {
      const current = fpsTimeSeries[i];
      const previous = fpsTimeSeries[i - 1];

      if (previous > 0) {
        const dropPercentage = ((previous - current) / previous) * 100;
        if (dropPercentage > maxDrop) {
          maxDrop = dropPercentage;
        }
      }
    }

    return { maxDropPercentage: maxDrop };
  }

  private calculateMemoryGrowthRate(memoryData: number[]): number {
    if (memoryData.length < 2) return 0;

    const initialMemory = memoryData[0];
    const finalMemory = memoryData[memoryData.length - 1];
    const growthMB = (finalMemory - initialMemory) / (1024 * 1024);

    return growthMB; // MB/å°æ—¶ (åŸºäº60åˆ†é’Ÿæµ‹è¯•)
  }
});
```

### 11.6 CI/CDé›†æˆæŒ‡å—ï¼ˆContinuous Integration & Deployment Integrationï¼‰

#### 11.6.1 è‡ªåŠ¨åŒ–æµæ°´çº¿é…ç½®

**GitHub Actionså·¥ä½œæµé…ç½®**ï¼š

```yaml
# .github/workflows/acceptance-tests.yml - éªŒæ”¶æµ‹è¯•è‡ªåŠ¨åŒ–æµæ°´çº¿
name: Architecture Acceptance Tests

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]
  schedule:
    - cron: '0 2 * * *' # æ¯æ—¥å‡Œæ™¨2ç‚¹è¿è¡Œ

jobs:
  # L0: å…³é”®ç³»ç»ŸéªŒæ”¶ - ä¸²è¡Œæ‰§è¡Œï¼Œå¤±è´¥ç«‹å³ç»ˆæ­¢
  tier0-critical-acceptance:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install testing dependencies
        run: |
          npm install -D vitest @vitest/ui playwright @playwright/test
          npx playwright install chromium

      - name: Run Tier-0 Critical Acceptance Tests
        run: |
          npm run test:acceptance:tier0
        env:
          NODE_ENV: test
          ACCEPTANCE_TIER: tier0_critical
          TEST_TIMEOUT: 30000
          RETRY_ATTEMPTS: 0

      - name: Upload Tier-0 Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: tier0-acceptance-results
          path: |
            tests/reports/tier0-*.json
            tests/coverage/tier0-*

  # L1: æ€§èƒ½å’Œèµ„æºéªŒæ”¶ - å¹¶è¡Œæ‰§è¡Œï¼Œå…è®¸é‡è¯•
  tier1-performance-acceptance:
    needs: tier0-critical-acceptance
    runs-on: ubuntu-latest
    timeout-minutes: 90
    strategy:
      matrix:
        test-category: ['slo-performance', 'ai-concurrency', 'electron-ipc']

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Electron testing environment
        run: |
          sudo apt-get update
          sudo apt-get install -y xvfb

      - name: Run Tier-1 Performance Tests
        run: |
          xvfb-run -a npm run test:acceptance:tier1:${{ matrix.test-category }}
        env:
          NODE_ENV: test
          ACCEPTANCE_TIER: tier1_performance
          TEST_CATEGORY: ${{ matrix.test-category }}
          TEST_TIMEOUT: 60000
          RETRY_ATTEMPTS: 2

      - name: Upload Performance Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: tier1-${{ matrix.test-category }}-results
          path: |
            tests/reports/tier1-${{ matrix.test-category }}-*.json
            tests/coverage/tier1-${{ matrix.test-category }}-*

  # L2: ç”¨æˆ·ä½“éªŒå’Œä»£ç è´¨é‡éªŒæ”¶ - å¹¶è¡Œæ‰§è¡Œï¼Œå¤±è´¥ä»…è­¦å‘Š
  tier2-quality-acceptance:
    needs: tier0-critical-acceptance
    runs-on: ubuntu-latest
    timeout-minutes: 120
    continue-on-error: true # Tier-2å¤±è´¥ä¸é˜»å¡æµæ°´çº¿

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run Tier-2 Quality Tests
        run: |
          npm run test:acceptance:tier2
        env:
          NODE_ENV: test
          ACCEPTANCE_TIER: tier2_quality
          TEST_TIMEOUT: 120000
          RETRY_ATTEMPTS: 3

      - name: Generate Code Coverage Report
        run: |
          npm run test:coverage:acceptance
          npm run coverage:merge

      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./tests/coverage/merged/lcov.info
          flags: acceptance-tests
          name: acceptance-coverage

  # è¾¹ç•Œæ¡ä»¶å’Œå¤±è´¥è·¯å¾„æµ‹è¯•
  boundary-failure-tests:
    needs: [tier0-critical-acceptance, tier1-performance-acceptance]
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run Boundary and Failure Tests
        run: |
          npm run test:acceptance:boundary
          npm run test:acceptance:failure-paths
        env:
          NODE_ENV: test
          TEST_SCENARIOS: boundary,failure
          STRESS_TEST_DURATION: 300000 # 5åˆ†é’Ÿè¾¹ç•Œæµ‹è¯•

      - name: Upload Boundary Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: boundary-failure-results
          path: |
            tests/reports/boundary-*.json
            tests/reports/failure-*.json

  # ç”Ÿæˆç»¼åˆéªŒæ”¶æŠ¥å‘Š
  generate-acceptance-report:
    needs:
      [
        tier0-critical-acceptance,
        tier1-performance-acceptance,
        tier2-quality-acceptance,
        boundary-failure-tests,
      ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: test-results

      - name: Generate Comprehensive Report
        run: |
          npm run report:acceptance:generate
        env:
          RESULTS_PATH: test-results
          REPORT_FORMAT: html,json,markdown

      - name: Upload Acceptance Report
        uses: actions/upload-artifact@v4
        with:
          name: comprehensive-acceptance-report
          path: |
            reports/acceptance-report.html
            reports/acceptance-report.json
            reports/acceptance-summary.md

      - name: Comment PR with Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reportPath = 'reports/acceptance-summary.md';
            if (fs.existsSync(reportPath)) {
              const report = fs.readFileSync(reportPath, 'utf8');
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## ğŸ§ª éªŒæ”¶æµ‹è¯•ç»“æœ\n\n${report}`
              });
            }
```

#### 11.6.2 æµ‹è¯•è„šæœ¬é…ç½®

**package.jsonæµ‹è¯•è„šæœ¬**ï¼š

```json
{
  "scripts": {
    "test:acceptance": "vitest run --config vitest.acceptance.config.ts",
    "test:acceptance:tier0": "vitest run --config vitest.acceptance.config.ts tests/acceptance/**/*.tier0.spec.ts",
    "test:acceptance:tier1": "vitest run --config vitest.acceptance.config.ts tests/acceptance/**/*.tier1.spec.ts",
    "test:acceptance:tier1:slo-performance": "vitest run tests/acceptance/slo-*.spec.ts",
    "test:acceptance:tier1:ai-concurrency": "vitest run tests/acceptance/ai-*.spec.ts",
    "test:acceptance:tier1:electron-ipc": "vitest run tests/acceptance/electron-*.spec.ts",
    "test:acceptance:tier2": "vitest run --config vitest.acceptance.config.ts tests/acceptance/**/*.tier2.spec.ts",
    "test:acceptance:boundary": "vitest run tests/acceptance/boundary-*.spec.ts",
    "test:acceptance:failure-paths": "vitest run tests/acceptance/failure-*.spec.ts",
    "test:acceptance:watch": "vitest --config vitest.acceptance.config.ts",
    "test:coverage:acceptance": "vitest run --coverage --config vitest.acceptance.config.ts",
    "coverage:merge": "c8 report --merge-dir=tests/coverage --reporter=lcov --reporter=html",
    "report:acceptance:generate": "node scripts/generate-acceptance-report.js"
  },
  "devDependencies": {
    "vitest": "^2.1.8",
    "@vitest/ui": "^2.1.8",
    "playwright": "^1.45.3",
    "@playwright/test": "^1.45.3",
    "c8": "^10.1.2",
    "cucumber": "^10.8.0"
  }
}
```

#### 11.6.3 è´¨é‡é—¨ç¦é›†æˆ

**é—¨ç¦é…ç½®æ–‡ä»¶**ï¼š

```typescript
// scripts/quality-gates.ts - è´¨é‡é—¨ç¦æ£€æŸ¥è„šæœ¬
import { readFileSync } from 'fs';
import { QualityGateChecker } from '../src/shared/quality/QualityGateChecker';

interface AcceptanceResults {
  tier0: TestResults;
  tier1: TestResults;
  tier2: TestResults;
  boundary: TestResults;
}

interface QualityGateConfig {
  tier0_blocking: {
    crashFreeThreshold: 99.5;
    dataIntegrityThreshold: 100;
    securityViolations: 0;
  };
  tier1_performance: {
    tp95Threshold: 100;
    aiConcurrencyThreshold: 50;
    ipcLatencyThreshold: 10;
  };
  tier2_quality: {
    codeCoverage: 90;
    userExperience: 80;
    documentationCoverage: 85;
  };
}

export class QualityGatesValidator {
  async validateAcceptanceResults(
    resultsDir: string
  ): Promise<ValidationReport> {
    const results = await this.loadAllResults(resultsDir);
    const config = this.loadGateConfig();

    const report: ValidationReport = {
      overallStatus: 'PENDING',
      gateResults: [],
      recommendations: [],
      blockingIssues: [],
    };

    // Tier-0å…³é”®é—¨ç¦éªŒè¯
    const tier0Status = await this.validateTier0Gates(
      results.tier0,
      config.tier0_blocking
    );
    if (tier0Status.hasBlockingIssues) {
      report.overallStatus = 'BLOCKED';
      report.blockingIssues.push(...tier0Status.issues);
    }

    // Tier-1æ€§èƒ½é—¨ç¦éªŒè¯
    const tier1Status = await this.validateTier1Gates(
      results.tier1,
      config.tier1_performance
    );
    if (tier1Status.hasWarnings) {
      report.recommendations.push(...tier1Status.warnings);
    }

    // Tier-2è´¨é‡é—¨ç¦éªŒè¯
    const tier2Status = await this.validateTier2Gates(
      results.tier2,
      config.tier2_quality
    );

    // ç»¼åˆçŠ¶æ€åˆ¤å®š
    if (report.overallStatus !== 'BLOCKED') {
      report.overallStatus = tier1Status.hasFailures ? 'WARNING' : 'PASSED';
    }

    return report;
  }

  private async validateTier0Gates(
    results: TestResults,
    config: any
  ): Promise<GateValidationResult> {
    const issues: string[] = [];

    // å´©æºƒç‡æ£€æŸ¥
    if (results.crashFreeRate < config.crashFreeThreshold) {
      issues.push(
        `Crash-freeç‡ ${results.crashFreeRate}% ä½äºè¦æ±‚çš„ ${config.crashFreeThreshold}%`
      );
    }

    // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    if (results.dataIntegrityScore < config.dataIntegrityThreshold) {
      issues.push(
        `æ•°æ®å®Œæ•´æ€§ ${results.dataIntegrityScore}% ä½äºè¦æ±‚çš„ ${config.dataIntegrityThreshold}%`
      );
    }

    // å®‰å…¨è¿è§„æ£€æŸ¥
    if (results.securityViolations > config.securityViolations) {
      issues.push(
        `å‘ç° ${results.securityViolations} ä¸ªå®‰å…¨è¿è§„ï¼Œè¶…å‡ºå…è®¸çš„ ${config.securityViolations} ä¸ª`
      );
    }

    return {
      hasBlockingIssues: issues.length > 0,
      issues,
      gateName: 'Tier-0 Critical',
    };
  }

  private async generateReport(validation: ValidationReport): Promise<void> {
    const reportContent = `
# ğŸ§ª Guild Manager éªŒæ”¶æµ‹è¯•æŠ¥å‘Š

## ğŸ“Š æ€»ä½“çŠ¶æ€: ${validation.overallStatus}

### âœ… é€šè¿‡çš„é—¨ç¦
${validation.gateResults
  .filter(g => g.status === 'PASSED')
  .map(g => `- ${g.name}`)
  .join('\n')}

### âš ï¸ è­¦å‘Šçš„é—¨ç¦  
${validation.gateResults
  .filter(g => g.status === 'WARNING')
  .map(g => `- ${g.name}: ${g.message}`)
  .join('\n')}

### âŒ é˜»å¡çš„é—¨ç¦
${validation.blockingIssues.map(issue => `- ${issue}`).join('\n')}

### ğŸ“‹ å»ºè®®æ”¹è¿›
${validation.recommendations.map(rec => `- ${rec}`).join('\n')}

---
*æŠ¥å‘Šç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}*
    `;

    await this.writeReport(reportContent);
  }
}

// ä¸»æ‰§è¡Œè„šæœ¬
async function main() {
  const validator = new QualityGatesValidator();
  const resultsDir = process.env.RESULTS_PATH || 'test-results';

  try {
    const validation = await validator.validateAcceptanceResults(resultsDir);
    await validator.generateReport(validation);

    // è®¾ç½®CIé€€å‡ºç 
    if (validation.overallStatus === 'BLOCKED') {
      process.exit(1); // é˜»å¡é—¨ç¦å¤±è´¥
    } else if (validation.overallStatus === 'WARNING') {
      process.exit(0); // è­¦å‘Šä¸é˜»å¡ï¼Œä½†è®°å½•é—®é¢˜
    } else {
      process.exit(0); // å…¨éƒ¨é€šè¿‡
    }
  } catch (error) {
    console.error('è´¨é‡é—¨ç¦éªŒè¯å¤±è´¥:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}
```

#### 11.6.4 å¤±è´¥è¯Šæ–­å’Œè‡ªåŠ¨æ¢å¤

**è‡ªåŠ¨è¯Šæ–­è„šæœ¬**ï¼š

```typescript
// scripts/failure-diagnostics.ts - å¤±è´¥è¯Šæ–­å’Œæ¢å¤è„šæœ¬
export class AcceptanceFailureDiagnostics {
  async diagnoseFailures(testResults: TestResults[]): Promise<DiagnosisReport> {
    const report: DiagnosisReport = {
      failures: [],
      rootCauses: [],
      recoveryActions: [],
      preventionMeasures: [],
    };

    for (const result of testResults) {
      if (result.status === 'FAILED') {
        await this.analyzeFailure(result, report);
      }
    }

    return report;
  }

  private async analyzeFailure(
    failure: TestResult,
    report: DiagnosisReport
  ): Promise<void> {
    const failureType = this.classifyFailure(failure);

    switch (failureType) {
      case 'PERFORMANCE_DEGRADATION':
        report.rootCauses.push('æ€§èƒ½æŒ‡æ ‡æœªè¾¾æ ‡');
        report.recoveryActions.push('é‡å¯æµ‹è¯•ç¯å¢ƒå¹¶é‡æ–°è¿è¡Œæ€§èƒ½æµ‹è¯•');
        report.preventionMeasures.push('å¢åŠ æ€§èƒ½ç›‘æ§é‡‡æ ·é¢‘ç‡');
        break;

      case 'RESOURCE_EXHAUSTION':
        report.rootCauses.push('ç³»ç»Ÿèµ„æºè€—å°½');
        report.recoveryActions.push('æ¸…ç†æµ‹è¯•ç¯å¢ƒï¼Œå¢åŠ èµ„æºé™åˆ¶');
        report.preventionMeasures.push('æ”¹è¿›èµ„æºç®¡ç†å’Œå›æ”¶æœºåˆ¶');
        break;

      case 'CONCURRENCY_ISSUE':
        report.rootCauses.push('å¹¶å‘å¤„ç†é—®é¢˜');
        report.recoveryActions.push('è°ƒæ•´å¹¶å‘å‚æ•°å¹¶é‡è¯•');
        report.preventionMeasures.push('åŠ å¼ºå¹¶å‘æµ‹è¯•è¦†ç›–');
        break;

      case 'ENVIRONMENT_ISSUE':
        report.rootCauses.push('æµ‹è¯•ç¯å¢ƒé—®é¢˜');
        report.recoveryActions.push('é‡å»ºæµ‹è¯•ç¯å¢ƒ');
        report.preventionMeasures.push('æ ‡å‡†åŒ–æµ‹è¯•ç¯å¢ƒé…ç½®');
        break;
    }
  }

  async executeAutoRecovery(
    recoveryActions: string[]
  ): Promise<RecoveryResult> {
    const results: RecoveryResult = {
      attempted: [],
      successful: [],
      failed: [],
    };

    for (const action of recoveryActions) {
      try {
        await this.executeRecoveryAction(action);
        results.successful.push(action);
      } catch (error) {
        results.failed.push({ action, error: error.message });
      }
      results.attempted.push(action);
    }

    return results;
  }
}
```

### 11.7 éªŒæ”¶æµ‹è¯•æ€»ç»“ä¸å®æ–½è·¯å¾„

#### 11.7.1 éªŒæ”¶æµ‹è¯•ä½“ç³»æ¶æ„æ¦‚è§ˆ

é€šè¿‡æœ¬ç« çš„å…¨é¢è®¾è®¡ï¼Œæˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ªåŸºäºBDDæ–¹æ³•è®ºçš„ç»¼åˆéªŒæ”¶æµ‹è¯•ä½“ç³»ï¼Œè¦†ç›–ä»¥ä¸‹å…³é”®é¢†åŸŸï¼š

**éªŒæ”¶æµ‹è¯•å±‚æ¬¡æ¶æ„**ï¼š

- **L0 å…³é”®ç³»ç»ŸéªŒæ”¶**ï¼šCrash-free sessions â‰¥99.5%ã€æ•°æ®å®Œæ•´æ€§100%ã€å®‰å…¨è¾¹ç•Œ0è¿è§„
- **L1 æ€§èƒ½èµ„æºéªŒæ”¶**ï¼šTP95 <100msã€AIå¹¶å‘50+å®ä½“ã€Electron IPC <10ms
- **L2 ç”¨æˆ·ä½“éªŒéªŒæ”¶**ï¼šä»£ç è¦†ç›–ç‡â‰¥90%ã€ç”¨æˆ·ä½“éªŒæŒ‡æ ‡ã€åŠŸèƒ½å‘ç°æ€§

**æŠ€æœ¯å®ç°ç‰¹ç‚¹**ï¼š

- **Given-When-Thenåœºæ™¯**ï¼šæ¯ä¸ªçº¦æŸéƒ½æœ‰å¯¹åº”çš„å¯æ‰§è¡ŒGherkinåœºæ™¯
- **Vitest+Playwrighté›†æˆ**ï¼šå®Œæ•´çš„æµ‹è¯•å·¥å…·é“¾æ”¯æŒ
- **è‡ªåŠ¨åŒ–CI/CDæµæ°´çº¿**ï¼šåˆ†å±‚æ‰§è¡Œã€å¤±è´¥è¯Šæ–­ã€æŠ¥å‘Šç”Ÿæˆ
- **è´¨é‡é—¨ç¦é›†æˆ**ï¼šä¸SLOä½“ç³»å®Œå…¨å¯¹é½çš„é—¨ç¦æœºåˆ¶

#### 11.7.2 å®æ–½ä¼˜å…ˆçº§å’Œæ—¶é—´å®‰æ’

**Phase 1 (Week 1-2): åŸºç¡€æ¡†æ¶æ­å»º**

1. é…ç½®Vitest + Playwright + C8æµ‹è¯•ç¯å¢ƒ
2. å»ºç«‹Gherkinåœºæ™¯è½¬æ¢å™¨å’ŒBDDæ¡†æ¶
3. å®ç°åŸºç¡€çš„æ€§èƒ½ç›‘æ§å·¥å…·ç±»

**Phase 2 (Week 3-4): æ ¸å¿ƒéªŒæ”¶å®ç°**

1. å®ŒæˆTier-0å…³é”®ç³»ç»ŸéªŒæ”¶æµ‹è¯•
2. å®ç°SLOæ€§èƒ½éªŒæ”¶çš„æ ¸å¿ƒåœºæ™¯
3. æ­å»ºAIå¹¶å‘ä¸€è‡´æ€§éªŒæ”¶æ¡†æ¶

**Phase 3 (Week 5-6): å…¨é¢éªŒæ”¶è¦†ç›–**

1. å®ŒæˆElectronè¿›ç¨‹åè°ƒéªŒæ”¶
2. å®ç°æ¸¸æˆåŠŸèƒ½å’Œä¸šåŠ¡ä»·å€¼éªŒæ”¶
3. å»ºç«‹è¾¹ç•Œæ¡ä»¶å’Œå¤±è´¥è·¯å¾„æµ‹è¯•

**Phase 4 (Week 7-8): CI/CDé›†æˆå’Œä¼˜åŒ–**

1. é…ç½®å®Œæ•´çš„GitHub Actionsæµæ°´çº¿
2. å®ç°è‡ªåŠ¨åŒ–æŠ¥å‘Šå’Œå¤±è´¥è¯Šæ–­
3. å®Œæˆè´¨é‡é—¨ç¦é›†æˆå’Œå›¢é˜ŸåŸ¹è®­

#### 11.7.3 æˆåŠŸæ ‡å‡†ä¸éªŒæ”¶å‡†åˆ™

**æŠ€æœ¯éªŒæ”¶æ ‡å‡†**ï¼š

- âœ… æ‰€æœ‰Gherkinåœºæ™¯éƒ½æœ‰å¯¹åº”çš„å¯æ‰§è¡ŒVitestæµ‹è¯•
- âœ… CI/CDæµæ°´çº¿å¯ä»¥è‡ªåŠ¨æ‰§è¡Œæ‰€æœ‰éªŒæ”¶æµ‹è¯•
- âœ… æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- âœ… æ‰€æœ‰SLOæŒ‡æ ‡éƒ½æœ‰å¯¹åº”çš„éªŒæ”¶éªŒè¯

**ä¸šåŠ¡éªŒæ”¶æ ‡å‡†**ï¼š

- âœ… æ¶æ„çº¦æŸçš„å¯è¿½æº¯æ€§ä»éœ€æ±‚åˆ°éªŒæ”¶100%è¦†ç›–
- âœ… è´¨é‡é—¨ç¦å¯ä»¥æœ‰æ•ˆé˜»æ­¢ä¸åˆè§„çš„ä»£ç åˆå¹¶
- âœ… å›¢é˜Ÿèƒ½å¤Ÿç†è§£å’Œä½¿ç”¨BDDéªŒæ”¶æµ‹è¯•æ–¹æ³•
- âœ… éªŒæ”¶æµ‹è¯•å¯ä»¥åœ¨15åˆ†é’Ÿå†…å®ŒæˆåŸºç¡€éªŒè¯

#### 11.7.4 ç»´æŠ¤å’ŒæŒç»­æ”¹è¿›

**å®šæœŸè¯„ä¼°**ï¼š

- æ¯æœˆè¯„ä¼°éªŒæ”¶åœºæ™¯çš„æœ‰æ•ˆæ€§å’Œè¦†ç›–æ€§
- å­£åº¦æ›´æ–°SLOé˜ˆå€¼å’ŒéªŒæ”¶æ ‡å‡†
- å¹´åº¦æ¶æ„çº¦æŸå®¡æŸ¥å’ŒéªŒæ”¶ä¼˜åŒ–

**å·¥å…·é“¾å‡çº§**ï¼š

- è·Ÿè¿›Vitestã€Playwrightç­‰å·¥å…·çš„æœ€æ–°ç‰ˆæœ¬
- æŒç»­ä¼˜åŒ–æµ‹è¯•æ‰§è¡Œæ•ˆç‡å’ŒæŠ¥å‘Šè´¨é‡
- å¼•å…¥æ–°çš„æµ‹è¯•æŠ€æœ¯å’Œæœ€ä½³å®è·µ

**å›¢é˜Ÿèƒ½åŠ›å»ºè®¾**ï¼š

- å®šæœŸè¿›è¡ŒBDDå’ŒéªŒæ”¶æµ‹è¯•åŸ¹è®­
- åˆ†äº«æœ€ä½³å®è·µå’Œæµ‹è¯•æ¡ˆä¾‹
- å»ºç«‹éªŒæ”¶æµ‹è¯•çš„ç¤¾åŒºå’ŒçŸ¥è¯†åº“

---

> **æ€»ç»“**ï¼šæœ¬ç« é€šè¿‡ultra-deep thinkingæ–¹æ³•è®ºï¼Œä¸ºGuild Manageræ¶æ„å»ºç«‹äº†å®Œå–„çš„"å°±åœ°éªŒæ”¶"ä½“ç³»ã€‚è¯¥ä½“ç³»å°†æŠ½è±¡çš„æ¶æ„çº¦æŸè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„è‡ªåŠ¨åŒ–éªŒè¯ï¼Œç¡®ä¿æ¯ä¸ªå…³é”®çº¦æŸéƒ½æœ‰å¯¹åº”çš„Given-When-Thenåœºæ™¯å’ŒVitestæµ‹è¯•å®ç°ã€‚è¿™ä¸ä»…æä¾›äº†å³æ—¶çš„è´¨é‡åé¦ˆå’Œé—¨ç¦æ§åˆ¶ï¼Œæ›´é‡è¦çš„æ˜¯ç¡®ä¿äº†æ¶æ„å†³ç­–çš„å¯è¿½æº¯æ€§å’Œæ‰§è¡ŒåŠ›ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹çš„é«˜è´¨é‡äº¤ä»˜å¥ å®šäº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚

      unit: 'milliseconds',
      targetThreshold: '< 50ms',
      samplingMethod: 'sliding_window_1min',
      description: 'åŒæ­¥IPCè°ƒç”¨å»¶è¿ŸP95'
    },

    asynchronousIPC: {
      measurement: 'ipc_async_response_time_percentile_95',
      unit: 'milliseconds',
      targetThreshold: '< 100ms',
      samplingMethod: 'exponential_histogram',
      description: 'å¼‚æ­¥IPCå“åº”æ—¶é—´P95'
    },

    messageQueueDepth: {
      measurement: 'ipc_queue_depth_max',
      unit: 'count',
      targetThreshold: '< 50 messages',
      samplingWindow: '5min',
      description: 'IPCæ¶ˆæ¯é˜Ÿåˆ—æœ€å¤§æ·±åº¦'
    }

},

// Worker Processé€šä¿¡æ€§èƒ½
workerCommunication: {
aiWorkerIPC: {
measurement: 'ai_worker_message_latency_percentile_95',
unit: 'milliseconds',
targetThreshold: '< 30ms',
samplingMethod: 'histogram_buckets',
description: 'AI Workeræ¶ˆæ¯å¤„ç†å»¶è¿ŸP95'
},

    workerPoolManagement: {
      measurement: 'worker_spawn_time_percentile_90',
      unit: 'milliseconds',
      targetThreshold: '< 200ms',
      samplingWindow: '10min',
      description: 'Workerè¿›ç¨‹åˆ›å»ºæ—¶é—´P90'
    },

    workerMemoryIsolation: {
      measurement: 'worker_memory_leak_rate',
      unit: 'megabytes_per_hour',
      targetThreshold: '< 5MB/h',
      samplingWindow: '1h',
      description: 'Workerè¿›ç¨‹å†…å­˜æ³„æ¼é€Ÿç‡'
    }

}
}

// === IPCè´¨é‡é—¨ç¦é…ç½® ===
export const ELECTRON_IPC_QUALITY_GATES = {
// L1: IPCé€šä¿¡åŸºç¡€é—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
basicIPCGates: {
ipcLatencyGate: {
name: 'IPCé€šä¿¡å»¶è¿Ÿé—¨ç¦',
sliMetric: 'main_renderer_sync_ipc_p95',
threshold: '< 50ms',
evaluationWindow: '5min',
blockingLevel: 'PR_MERGE',

      testCases: [
        {
          scenario: 'game_state_sync',
          action: 'sync_game_state_to_renderer',
          expectedLatency: '< 30ms',
          description: 'æ¸¸æˆçŠ¶æ€åŒæ­¥åˆ°æ¸²æŸ“è¿›ç¨‹'
        },
        {
          scenario: 'user_input_handling',
          action: 'process_user_action_via_ipc',
          expectedLatency: '< 20ms',
          description: 'ç”¨æˆ·è¾“å…¥äº‹ä»¶IPCå¤„ç†'
        },
        {
          scenario: 'save_file_operations',
          action: 'save_game_data_cross_process',
          expectedLatency: '< 100ms',
          description: 'å­˜æ¡£æ–‡ä»¶è·¨è¿›ç¨‹æ“ä½œ'
        }
      ],

      automationScript: `
        // IPCå»¶è¿Ÿè‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬
        export async function testIPCLatency(): Promise<GateResult> {
          const latencyResults = [];

          for (let i = 0; i < 100; i++) {
            const startTime = performance.now();
            await ipcRenderer.invoke('sync-game-state', testGameState);
            const endTime = performance.now();
            latencyResults.push(endTime - startTime);
          }

          const p95Latency = calculatePercentile(latencyResults, 95);

          return {
            passed: p95Latency < 50,
            actualValue: p95Latency,
            threshold: 50,
            details: {
              sampleSize: latencyResults.length,
              minLatency: Math.min(...latencyResults),
              maxLatency: Math.max(...latencyResults),
              avgLatency: latencyResults.reduce((a, b) => a + b) / latencyResults.length
            }
          };
        }
      `
    },

    workerPerformanceGate: {
      name: 'Workerè¿›ç¨‹æ€§èƒ½é—¨ç¦',
      sliMetric: 'ai_worker_message_processing_p95',
      threshold: '< 30ms',
      evaluationWindow: '3min',
      blockingLevel: 'PR_MERGE',

      testCases: [
        {
          scenario: 'ai_decision_processing',
          action: 'process_ai_decision_in_worker',
          expectedLatency: '< 25ms',
          description: 'AIå†³ç­–åœ¨Workerä¸­å¤„ç†'
        },
        {
          scenario: 'batch_event_processing',
          action: 'process_event_batch_in_worker',
          expectedLatency: '< 50ms',
          description: 'Workerä¸­æ‰¹é‡äº‹ä»¶å¤„ç†'
        },
        {
          scenario: 'worker_error_recovery',
          action: 'recover_from_worker_error',
          expectedLatency: '< 200ms',
          description: 'Workeré”™è¯¯æ¢å¤æ—¶é—´'
        }
      ]
    }

},

// L2: è¿›ç¨‹ç¨³å®šæ€§é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
processStabilityGates: {
memoryLeakGate: {
name: 'è·¨è¿›ç¨‹å†…å­˜æ³„æ¼æ£€æµ‹é—¨ç¦',
sliMetric: 'cross_process_memory_growth_rate',
threshold: '< 10MB/h',
evaluationWindow: '30min',
blockingLevel: 'MAIN_BRANCH',

      monitoringConfig: {
        processes: ['main', 'renderer', 'ai-worker', 'file-worker'],
        samplingInterval: '30s',
        alertThreshold: '> 15MB/h',
        killSwitchThreshold: '> 50MB/h'
      }
    },

    processDeadlockGate: {
      name: 'è¿›ç¨‹æ­»é”æ£€æµ‹é—¨ç¦',
      sliMetric: 'ipc_deadlock_detection_rate',
      threshold: '= 0 deadlocks',
      evaluationWindow: '15min',
      blockingLevel: 'MAIN_BRANCH',

      detectionMechanisms: [
        'circular_wait_detection',
        'message_timeout_monitoring',
        'resource_allocation_tracking',
        'process_heartbeat_verification'
      ]
    }

},

// L3: å®¹é”™æ€§é—¨ç¦ï¼ˆé˜»å¡ç”Ÿäº§å‘å¸ƒï¼‰
faultToleranceGates: {
processRecoveryGate: {
name: 'è¿›ç¨‹æ¢å¤èƒ½åŠ›é—¨ç¦',
sliMetric: 'process_recovery_success_rate',
threshold: '>= 99%',
evaluationWindow: '24h',
blockingLevel: 'PRODUCTION_RELEASE',

      recoveryScenarios: [
        {
          scenario: 'renderer_process_crash',
          expectedRecoveryTime: '< 3s',
          dataIntegrityRequired: true,
          description: 'æ¸²æŸ“è¿›ç¨‹å´©æºƒæ¢å¤'
        },
        {
          scenario: 'worker_process_hang',
          expectedRecoveryTime: '< 5s',
          gracefulDegradation: true,
          description: 'Workerè¿›ç¨‹æŒ‚èµ·æ¢å¤'
        },
        {
          scenario: 'ipc_channel_failure',
          expectedRecoveryTime: '< 2s',
          alternativeChannelRequired: true,
          description: 'IPCé€šé“æ•…éšœæ¢å¤'
        }
      ]
    }

}
};

````

#### 11.1.2 ä¸‰è¿›ç¨‹åè°ƒæ€§ç›‘æ§

```typescript
// === ä¸‰è¿›ç¨‹åè°ƒæ€§ç›‘æ§æ¡†æ¶ ===
export class ElectronProcessCoordinationMonitor {
  private processMetrics: Map<string, ProcessMetrics>;
  private ipcLatencyTracker: IPCLatencyTracker;
  private deadlockDetector: DeadlockDetector;

  constructor() {
    this.processMetrics = new Map();
    this.ipcLatencyTracker = new IPCLatencyTracker();
    this.deadlockDetector = new DeadlockDetector();
  }

  /**
   * ç›‘æ§è·¨è¿›ç¨‹åè°ƒæ€§èƒ½
   */
  async monitorProcessCoordination(): Promise<CoordinationHealth> {
    const healthMetrics = {
      mainProcessHealth: await this.assessMainProcessHealth(),
      rendererProcessHealth: await this.assessRendererProcessHealth(),
      workerProcessHealth: await this.assessWorkerProcessHealth(),
      ipcCommunicationHealth: await this.assessIPCHealth(),
      overallCoordinationScore: 0
    };

    // è®¡ç®—æ•´ä½“åè°ƒå¥åº·åº¦è¯„åˆ†
    healthMetrics.overallCoordinationScore = this.calculateCoordinationScore(healthMetrics);

    // æ£€æµ‹æ½œåœ¨é—®é¢˜
    const detectedIssues = await this.detectCoordinationIssues(healthMetrics);

    return {
      ...healthMetrics,
      detectedIssues,
      recommendations: this.generateRecommendations(detectedIssues),
      timestamp: new Date(),
      verdict: healthMetrics.overallCoordinationScore >= 90 ? 'HEALTHY' : 'DEGRADED'
    };
  }

  /**
   * å®æ—¶IPCå»¶è¿Ÿè·Ÿè¸ª
   */
  private async assessIPCHealth(): Promise<IPCHealthMetrics> {
    const currentLatencies = await this.ipcLatencyTracker.getCurrentLatencies();

    return {
      syncIPCLatencyP95: currentLatencies.sync.p95,
      asyncIPCLatencyP95: currentLatencies.async.p95,
      messageQueueDepth: currentLatencies.queueDepth,
      throughputMsgsPerSec: currentLatencies.throughput,
      errorRate: currentLatencies.errorRate,
      deadlockCount: await this.deadlockDetector.getActiveDeadlockCount(),

      // å¥åº·åº¦è¯„ä¼°
      healthScore: this.calculateIPCHealthScore(currentLatencies),
      status: this.determineIPCStatus(currentLatencies)
    };
  }

  /**
   * è¿›ç¨‹é—´æ­»é”æ£€æµ‹
   */
  private async detectCoordinationIssues(health: any): Promise<CoordinationIssue[]> {
    const issues: CoordinationIssue[] = [];

    // æ£€æµ‹IPCå»¶è¿Ÿå¼‚å¸¸
    if (health.ipcCommunicationHealth.syncIPCLatencyP95 > 50) {
      issues.push({
        type: 'IPC_LATENCY_HIGH',
        severity: 'HIGH',
        description: `åŒæ­¥IPCå»¶è¿Ÿå¼‚å¸¸ï¼š${health.ipcCommunicationHealth.syncIPCLatencyP95}ms > 50msé˜ˆå€¼`,
        affectedProcesses: ['main', 'renderer'],
        recommendedAction: 'æ£€æŸ¥è¿›ç¨‹é—´é€šä¿¡è´Ÿè½½å’Œæ¶ˆæ¯é˜Ÿåˆ—ç§¯å‹'
      });
    }

    // æ£€æµ‹å†…å­˜æ³„æ¼
    const memoryGrowthRates = await this.calculateMemoryGrowthRates();
    for (const [processName, growthRate] of memoryGrowthRates) {
      if (growthRate > 10) { // MB/h
        issues.push({
          type: 'MEMORY_LEAK_DETECTED',
          severity: 'CRITICAL',
          description: `${processName}è¿›ç¨‹å†…å­˜æ³„æ¼ï¼š${growthRate}MB/h > 10MB/hé˜ˆå€¼`,
          affectedProcesses: [processName],
          recommendedAction: 'ç«‹å³æ£€æŸ¥è¯¥è¿›ç¨‹çš„å†…å­˜ç®¡ç†å’Œå¯¹è±¡å¼•ç”¨'
        });
      }
    }

    // æ£€æµ‹æ­»é”é£é™©
    const deadlockRisk = await this.deadlockDetector.assessDeadlockRisk();
    if (deadlockRisk.riskLevel === 'HIGH') {
      issues.push({
        type: 'DEADLOCK_RISK_HIGH',
        severity: 'HIGH',
        description: `æ£€æµ‹åˆ°é«˜æ­»é”é£é™©ï¼š${deadlockRisk.indicators.join(', ')}`,
        affectedProcesses: deadlockRisk.involvedProcesses,
        recommendedAction: 'ä¼˜åŒ–èµ„æºè·å–é¡ºåºå’ŒIPCè°ƒç”¨æ¨¡å¼'
      });
    }

    return issues;
  }
}

// === è¿›ç¨‹å¥åº·åº¦è¯„ä¼°æ¥å£ ===
interface ProcessMetrics {
  cpuUsage: number;          // CPUä½¿ç”¨ç‡ç™¾åˆ†æ¯”
  memoryUsage: number;       // å†…å­˜ä½¿ç”¨é‡ï¼ˆMBï¼‰
  memoryGrowthRate: number;  // å†…å­˜å¢é•¿é€Ÿç‡ï¼ˆMB/hï¼‰
  responseTime: number;      // å¹³å‡å“åº”æ—¶é—´ï¼ˆmsï¼‰
  errorRate: number;         // é”™è¯¯ç‡ç™¾åˆ†æ¯”
  uptime: number;            // è¿è¡Œæ—¶é—´ï¼ˆç§’ï¼‰
}

interface CoordinationHealth {
  mainProcessHealth: ProcessMetrics;
  rendererProcessHealth: ProcessMetrics;
  workerProcessHealth: ProcessMetrics;
  ipcCommunicationHealth: IPCHealthMetrics;
  overallCoordinationScore: number;
  detectedIssues: CoordinationIssue[];
  recommendations: string[];
  timestamp: Date;
  verdict: 'HEALTHY' | 'DEGRADED' | 'CRITICAL';
}
````

### 11.2 è¿›ç¨‹ç¨³å®šæ€§è‡ªåŠ¨åŒ–æµ‹è¯•

#### 11.2.1 è¿›ç¨‹å´©æºƒæ¢å¤æµ‹è¯•

```typescript
// === è¿›ç¨‹æ¢å¤èƒ½åŠ›è‡ªåŠ¨åŒ–æµ‹è¯• ===
export class ProcessRecoveryTestSuite {
  /**
   * æ¸²æŸ“è¿›ç¨‹å´©æºƒæ¢å¤æµ‹è¯•
   */
  async testRendererProcessCrashRecovery(): Promise<RecoveryTestResult> {
    const testStartTime = performance.now();
    let recoverySuccessful = false;
    let dataIntegrityMaintained = false;
    let recoveryTime = 0;

    try {
      // 1. è®°å½•å´©æºƒå‰çŠ¶æ€
      const precrashState = await this.captureApplicationState();

      // 2. æ¨¡æ‹Ÿæ¸²æŸ“è¿›ç¨‹å´©æºƒ
      await this.simulateRendererProcessCrash();

      // 3. ç­‰å¾…è‡ªåŠ¨æ¢å¤
      const recoveryStartTime = performance.now();
      recoverySuccessful = await this.waitForProcessRecovery('renderer', 5000); // 5ç§’è¶…æ—¶
      recoveryTime = performance.now() - recoveryStartTime;

      // 4. éªŒè¯æ•°æ®å®Œæ•´æ€§
      if (recoverySuccessful) {
        const postrecoveryState = await this.captureApplicationState();
        dataIntegrityMaintained = this.compareStates(
          precrashState,
          postrecoveryState
        );
      }

      return {
        testName: 'renderer_process_crash_recovery',
        successful: recoverySuccessful && dataIntegrityMaintained,
        recoveryTime,
        dataIntegrityMaintained,
        details: {
          crashSimulationTime: recoveryStartTime - testStartTime,
          maxAllowedRecoveryTime: 3000, // 3ç§’
          actualRecoveryTime: recoveryTime,
          stateComparisonResult: dataIntegrityMaintained,
        },
      };
    } catch (error) {
      return {
        testName: 'renderer_process_crash_recovery',
        successful: false,
        recoveryTime: performance.now() - testStartTime,
        dataIntegrityMaintained: false,
        error: error.message,
      };
    }
  }

  /**
   * Workerè¿›ç¨‹æŒ‚èµ·æ¢å¤æµ‹è¯•
   */
  async testWorkerProcessHangRecovery(): Promise<RecoveryTestResult> {
    // WorkeræŒ‚èµ·æ¨¡æ‹Ÿï¼šå‘é€æ°¸ä¸è¿”å›çš„è®¡ç®—ä»»åŠ¡
    const hangingTask = {
      type: 'infinite_loop_calculation',
      data: { iterations: Number.MAX_SAFE_INTEGER },
      timeout: 1000, // 1ç§’ååº”è¯¥è§¦å‘è¶…æ—¶
    };

    const testStartTime = performance.now();

    try {
      // 1. å‘é€æŒ‚èµ·ä»»åŠ¡
      const workerResponse = await this.sendTaskToWorker(hangingTask);

      // 2. éªŒè¯è¶…æ—¶æ£€æµ‹
      const timeoutDetected = await this.waitForTimeoutDetection(1500); // 1.5ç§’å†…åº”æ£€æµ‹åˆ°è¶…æ—¶

      // 3. éªŒè¯Workeré‡å¯
      const workerRestarted = await this.waitForWorkerRestart(3000); // 3ç§’å†…åº”é‡å¯å®Œæˆ

      // 4. éªŒè¯æ¢å¤ååŠŸèƒ½
      const functionalityRestored = await this.testWorkerFunctionality();

      const totalRecoveryTime = performance.now() - testStartTime;

      return {
        testName: 'worker_process_hang_recovery',
        successful: timeoutDetected && workerRestarted && functionalityRestored,
        recoveryTime: totalRecoveryTime,
        details: {
          timeoutDetectedInTime: timeoutDetected,
          workerRestartedInTime: workerRestarted,
          functionalityRestored,
          maxAllowedRecoveryTime: 5000, // 5ç§’
        },
      };
    } catch (error) {
      return {
        testName: 'worker_process_hang_recovery',
        successful: false,
        recoveryTime: performance.now() - testStartTime,
        error: error.message,
      };
    }
  }

  /**
   * IPCé€šé“æ•…éšœæ¢å¤æµ‹è¯•
   */
  async testIPCChannelFailureRecovery(): Promise<RecoveryTestResult> {
    const testStartTime = performance.now();

    try {
      // 1. éªŒè¯IPCæ­£å¸¸å·¥ä½œ
      const initialIPCWorking = await this.verifyIPCFunctionality();
      if (!initialIPCWorking) {
        throw new Error('Initial IPC verification failed');
      }

      // 2. æ¨¡æ‹ŸIPCé€šé“æ•…éšœ
      await this.simulateIPCChannelFailure();

      // 3. ç­‰å¾…å¤‡ç”¨é€šé“æ¿€æ´»
      const alternativeChannelActive =
        await this.waitForAlternativeChannel(2000); // 2ç§’å†…æ¿€æ´»å¤‡ç”¨é€šé“

      // 4. éªŒè¯é€šä¿¡æ¢å¤
      const communicationRestored = await this.verifyIPCFunctionality();

      const recoveryTime = performance.now() - testStartTime;

      return {
        testName: 'ipc_channel_failure_recovery',
        successful: alternativeChannelActive && communicationRestored,
        recoveryTime,
        details: {
          alternativeChannelActivated: alternativeChannelActive,
          communicationRestored,
          maxAllowedRecoveryTime: 2000, // 2ç§’
        },
      };
    } catch (error) {
      return {
        testName: 'ipc_channel_failure_recovery',
        successful: false,
        recoveryTime: performance.now() - testStartTime,
        error: error.message,
      };
    }
  }
}
```

---

## åäºŒã€æ¸¸æˆç‰¹æœ‰è´¨é‡é—¨ç¦ç³»ç»Ÿï¼ˆGame-Specific Quality Gatesï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šé’ˆå¯¹ã€Šå…¬ä¼šç»ç†ã€‹ç»è¥æ¨¡æ‹Ÿæ¸¸æˆçš„ç‰¹æ®Šéœ€æ±‚ï¼Œå»ºç«‹äº‹ä»¶é“¾å®Œæ•´æ€§ã€æ¸¸æˆæ•°å€¼å¹³è¡¡å’Œå­˜æ¡£å…¼å®¹æ€§çš„ä¸“é—¨è´¨é‡é—¨ç¦ä½“ç³»ã€‚

### 12.1 äº‹ä»¶é“¾å®Œæ•´æ€§é—¨ç¦

#### 12.1.1 äº‹ä»¶é“¾ä¾èµ–éªŒè¯

```typescript
// src/shared/quality/game-event-gates.ts - æ¸¸æˆäº‹ä»¶è´¨é‡é—¨ç¦

// === äº‹ä»¶é“¾å®Œæ•´æ€§SLI ===
export interface EventChainIntegritySLI {
  // äº‹ä»¶é“¾ä¾èµ–å®Œæ•´æ€§
  chainDependencyIntegrity: {
    missingDependencies: {
      measurement: 'missing_event_dependencies / total_event_chains';
      unit: 'percentage';
      targetThreshold: '= 0%';
      samplingWindow: 'per_build';
      description: 'äº‹ä»¶é“¾ç¼ºå¤±ä¾èµ–æ¯”ä¾‹';
    };

    circularDependencies: {
      measurement: 'circular_dependency_count';
      unit: 'count';
      targetThreshold: '= 0';
      samplingWindow: 'per_build';
      description: 'å¾ªç¯ä¾èµ–äº‹ä»¶é“¾æ•°é‡';
    };

    orphanedEvents: {
      measurement: 'orphaned_events_count';
      unit: 'count';
      targetThreshold: '= 0';
      samplingWindow: 'per_build';
      description: 'å­¤ç«‹äº‹ä»¶ï¼ˆæ— æ³•è§¦å‘ï¼‰æ•°é‡';
    };
  };

  // äº‹ä»¶æ‰§è¡Œå®Œæ•´æ€§
  executionIntegrity: {
    eventExecutionSuccess: {
      measurement: 'successful_event_executions / total_event_executions';
      unit: 'percentage';
      targetThreshold: '>= 99.9%';
      samplingWindow: '24h';
      description: 'äº‹ä»¶æ‰§è¡ŒæˆåŠŸç‡';
    };

    chainCompletionRate: {
      measurement: 'completed_event_chains / started_event_chains';
      unit: 'percentage';
      targetThreshold: '>= 99.5%';
      samplingWindow: '7d';
      description: 'äº‹ä»¶é“¾å®Œæˆç‡';
    };

    stateConsistency: {
      measurement: 'consistent_post_event_states / total_event_executions';
      unit: 'percentage';
      targetThreshold: '>= 99.99%';
      samplingWindow: '24h';
      description: 'äº‹ä»¶åçŠ¶æ€ä¸€è‡´æ€§';
    };
  };
}

// === äº‹ä»¶é“¾å®Œæ•´æ€§è´¨é‡é—¨ç¦ ===
export const EVENT_CHAIN_QUALITY_GATES = {
  // L1: é™æ€åˆ†æé—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
  staticAnalysisGates: {
    eventDependencyGate: {
      name: 'äº‹ä»¶ä¾èµ–å®Œæ•´æ€§é—¨ç¦',
      sliMetric: 'event_chain_dependency_completeness',
      threshold: '100% complete',
      evaluationWindow: 'per_commit',
      blockingLevel: 'PR_MERGE',

      validationRules: [
        {
          rule: 'all_referenced_events_exist',
          description: 'æ‰€æœ‰å¼•ç”¨çš„äº‹ä»¶éƒ½å¿…é¡»å­˜åœ¨',
          severity: 'CRITICAL',
          autoFix: false,
        },
        {
          rule: 'no_circular_dependencies',
          description: 'ä¸å…è®¸å¾ªç¯ä¾èµ–çš„äº‹ä»¶é“¾',
          severity: 'CRITICAL',
          autoFix: false,
        },
        {
          rule: 'all_events_reachable',
          description: 'æ‰€æœ‰äº‹ä»¶éƒ½å¿…é¡»å¯è¾¾ï¼ˆå¯è§¦å‘ï¼‰',
          severity: 'HIGH',
          autoFix: false,
        },
        {
          rule: 'valid_condition_syntax',
          description: 'äº‹ä»¶è§¦å‘æ¡ä»¶è¯­æ³•å¿…é¡»æ­£ç¡®',
          severity: 'CRITICAL',
          autoFix: true,
        },
      ],

      automationScript: `
        // äº‹ä»¶é“¾ä¾èµ–éªŒè¯è‡ªåŠ¨åŒ–è„šæœ¬
        export async function validateEventChainIntegrity(): Promise<GateResult> {
          const eventRegistry = await loadEventRegistry();
          const validationResults = [];
          
          // 1. æ£€æŸ¥äº‹ä»¶å¼•ç”¨å®Œæ•´æ€§
          for (const event of eventRegistry.getAllEvents()) {
            const dependencyCheck = await validateEventDependencies(event);
            validationResults.push(dependencyCheck);
          }
          
          // 2. æ£€æŸ¥å¾ªç¯ä¾èµ–
          const circularDepsCheck = await detectCircularDependencies(eventRegistry);
          validationResults.push(circularDepsCheck);
          
          // 3. æ£€æŸ¥å­¤ç«‹äº‹ä»¶
          const orphanedEventsCheck = await findOrphanedEvents(eventRegistry);
          validationResults.push(orphanedEventsCheck);
          
          const allPassed = validationResults.every(result => result.passed);
          const criticalIssues = validationResults.filter(r => !r.passed && r.severity === 'CRITICAL');
          
          return {
            passed: allPassed && criticalIssues.length === 0,
            details: {
              totalEvents: eventRegistry.getAllEvents().length,
              validationResults,
              criticalIssueCount: criticalIssues.length,
              summary: this.generateValidationSummary(validationResults)
            }
          };
        }
      `,
    },

    eventDataIntegrityGate: {
      name: 'äº‹ä»¶æ•°æ®å®Œæ•´æ€§é—¨ç¦',
      sliMetric: 'event_data_schema_compliance',
      threshold: '100% compliant',
      evaluationWindow: 'per_commit',
      blockingLevel: 'PR_MERGE',

      schemaValidation: [
        {
          schema: 'event_definition_schema.json',
          description: 'äº‹ä»¶å®šä¹‰å¿…é¡»ç¬¦åˆæ ‡å‡†schema',
          required: true,
        },
        {
          schema: 'event_conditions_schema.json',
          description: 'äº‹ä»¶è§¦å‘æ¡ä»¶å¿…é¡»ç¬¦åˆè¯­æ³•schema',
          required: true,
        },
        {
          schema: 'event_effects_schema.json',
          description: 'äº‹ä»¶æ•ˆæœå®šä¹‰å¿…é¡»ç¬¦åˆschema',
          required: true,
        },
      ],
    },
  },

  // L2: åŠ¨æ€éªŒè¯é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
  dynamicValidationGates: {
    eventExecutionGate: {
      name: 'äº‹ä»¶æ‰§è¡Œå®Œæ•´æ€§é—¨ç¦',
      sliMetric: 'event_execution_success_rate',
      threshold: '>= 99.9%',
      evaluationWindow: '24h_simulation',
      blockingLevel: 'MAIN_BRANCH',

      simulationConfig: {
        simulationDuration: '24h_game_time',
        aiEntityCount: 50,
        eventTriggerRate: '1_per_second',
        complexEventChainCount: 10,
        randomSeed: 'deterministic_test_seed',
      },

      successCriteria: [
        'all_triggered_events_execute_successfully',
        'no_event_chain_interruptions',
        'no_state_corruption_after_events',
        'no_infinite_event_loops',
        'memory_usage_within_bounds',
      ],
    },

    stateConsistencyGate: {
      name: 'æ¸¸æˆçŠ¶æ€ä¸€è‡´æ€§é—¨ç¦',
      sliMetric: 'post_event_state_consistency',
      threshold: '>= 99.99%',
      evaluationWindow: '1000_event_sample',
      blockingLevel: 'MAIN_BRANCH',

      consistencyChecks: [
        {
          check: 'resource_conservation',
          description: 'èµ„æºæ€»é‡å®ˆæ’ï¼ˆèµ„æºä¸èƒ½å‡­ç©ºäº§ç”Ÿæˆ–æ¶ˆå¤±ï¼‰',
          tolerance: '0.01%',
        },
        {
          check: 'relationship_integrity',
          description: 'å…³ç³»ç½‘ç»œå®Œæ•´æ€§ï¼ˆåŒå‘å…³ç³»å¿…é¡»ä¸€è‡´ï¼‰',
          tolerance: '0%',
        },
        {
          check: 'timestamp_monotonicity',
          description: 'æ—¶é—´æˆ³å•è°ƒæ€§ï¼ˆæ—¶é—´ä¸èƒ½å€’æµï¼‰',
          tolerance: '0%',
        },
        {
          check: 'stat_boundary_validation',
          description: 'ç»Ÿè®¡æ•°æ®è¾¹ç•ŒéªŒè¯ï¼ˆæ•°å€¼åœ¨åˆç†èŒƒå›´å†…ï¼‰',
          tolerance: '0%',
        },
      ],
    },
  },
};
```

#### 12.1.2 æ¸¸æˆæ•°å€¼å¹³è¡¡éªŒè¯é—¨ç¦

```typescript
// === æ¸¸æˆæ•°å€¼å¹³è¡¡è´¨é‡é—¨ç¦ ===
export const GAME_BALANCE_QUALITY_GATES = {
  // L1: æ•°å€¼è¾¹ç•Œæ£€æŸ¥é—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
  numericBoundaryGates: {
    statBoundaryGate: {
      name: 'è§’è‰²å±æ€§è¾¹ç•Œé—¨ç¦',
      sliMetric: 'character_stat_boundary_violations',
      threshold: '= 0 violations',
      evaluationWindow: 'per_commit',
      blockingLevel: 'PR_MERGE',

      boundaryRules: [
        {
          stat: 'member_level',
          minValue: 1,
          maxValue: 100,
          description: 'æˆå‘˜ç­‰çº§å¿…é¡»åœ¨1-100èŒƒå›´å†…',
        },
        {
          stat: 'guild_reputation',
          minValue: 0,
          maxValue: 10000,
          description: 'å…¬ä¼šå£°æœ›å¿…é¡»åœ¨0-10000èŒƒå›´å†…',
        },
        {
          stat: 'resource_amounts',
          minValue: 0,
          maxValue: Number.MAX_SAFE_INTEGER,
          description: 'èµ„æºæ•°é‡ä¸èƒ½ä¸ºè´Ÿæ•°',
        },
        {
          stat: 'skill_effectiveness',
          minValue: 0.0,
          maxValue: 10.0,
          description: 'æŠ€èƒ½æ•ˆæœå€æ•°å¿…é¡»åœ¨0-10å€èŒƒå›´å†…',
        },
      ],
    },

    economicBalanceGate: {
      name: 'ç»æµå¹³è¡¡é—¨ç¦',
      sliMetric: 'economic_inflation_rate',
      threshold: '< 5% per_month',
      evaluationWindow: '1000_simulation_cycles',
      blockingLevel: 'PR_MERGE',

      economicIndicators: [
        {
          indicator: 'resource_inflation_rate',
          threshold: '< 3% per_month',
          description: 'èµ„æºä»·æ ¼é€šèƒ€ç‡æ§åˆ¶',
        },
        {
          indicator: 'wealth_distribution_gini',
          threshold: '< 0.8',
          description: 'è´¢å¯Œåˆ†é…åŸºå°¼ç³»æ•°ï¼ˆé¿å…æç«¯ä¸å¹³ç­‰ï¼‰',
        },
        {
          indicator: 'resource_scarcity_index',
          threshold: '0.3 - 0.7 range',
          description: 'èµ„æºç¨€ç¼ºåº¦æŒ‡æ•°ï¼ˆè¿‡ä½åˆ™å¤±å»æŒ‘æˆ˜æ€§ï¼Œè¿‡é«˜åˆ™æŒ«è´¥æ„Ÿå¼ºï¼‰',
        },
      ],
    },
  },

  // L2: æ¸¸æˆä½“éªŒå¹³è¡¡é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
  gameplayBalanceGates: {
    progressionBalanceGate: {
      name: 'è¿›åº¦å¹³è¡¡é—¨ç¦',
      sliMetric: 'player_progression_satisfaction',
      threshold: '>= 7.5/10 satisfaction',
      evaluationWindow: '100_player_simulation',
      blockingLevel: 'MAIN_BRANCH',

      progressionMetrics: [
        {
          metric: 'level_up_frequency',
          targetRange: '1-3 hours per level',
          description: 'å‡çº§é¢‘ç‡åº”ä¿æŒåˆç†èŠ‚å¥',
        },
        {
          metric: 'challenge_difficulty_curve',
          targetRange: '5-15% increase per level',
          description: 'æŒ‘æˆ˜éš¾åº¦åº”å¾ªåºæ¸è¿›',
        },
        {
          metric: 'reward_satisfaction_ratio',
          targetRange: '1.2-2.0 perceived_value/effort',
          description: 'å¥–åŠ±æ»¡æ„åº¦åº”è¶…è¿‡ä»˜å‡ºåŠªåŠ›',
        },
      ],
    },

    aiCompetitivenessGate: {
      name: 'AIç«äº‰åŠ›å¹³è¡¡é—¨ç¦',
      sliMetric: 'player_vs_ai_win_rate',
      threshold: '40% - 60% player_win_rate',
      evaluationWindow: '1000_pvp_simulations',
      blockingLevel: 'MAIN_BRANCH',

      competitivenessFactors: [
        {
          factor: 'ai_decision_quality',
          targetRange: '80% - 90% optimal',
          description: 'AIå†³ç­–è´¨é‡åº”æ¥è¿‘ä½†ä¸è¶…è¿‡äººç±»ç©å®¶',
        },
        {
          factor: 'ai_reaction_speed',
          targetRange: '200ms - 500ms delay',
          description: 'AIååº”é€Ÿåº¦åº”æ¨¡æ‹Ÿäººç±»ååº”æ—¶é—´',
        },
        {
          factor: 'ai_mistake_frequency',
          targetRange: '5% - 15% suboptimal_choices',
          description: 'AIåº”å¶å°”çŠ¯é”™ä»¥å¢åŠ çœŸå®æ„Ÿ',
        },
      ],
    },
  },
};
```

### 12.2 å­˜æ¡£å…¼å®¹æ€§è´¨é‡é—¨ç¦

#### 12.2.1 ç‰ˆæœ¬å…¼å®¹æ€§éªŒè¯

```typescript
// === å­˜æ¡£å…¼å®¹æ€§è´¨é‡é—¨ç¦ ===
export const SAVE_COMPATIBILITY_QUALITY_GATES = {
  // L1: å‘åå…¼å®¹æ€§é—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
  backwardCompatibilityGates: {
    saveFormatMigrationGate: {
      name: 'å­˜æ¡£æ ¼å¼è¿ç§»é—¨ç¦',
      sliMetric: 'save_migration_success_rate',
      threshold: '100% success',
      evaluationWindow: 'per_migration_script',
      blockingLevel: 'PR_MERGE',

      migrationTests: [
        {
          fromVersion: 'v1.0.0',
          toVersion: 'current',
          testSaveFiles: [
            'minimal_save_v1.0.0.json',
            'complex_save_v1.0.0.json',
            'corrupted_save_v1.0.0.json',
          ],
          expectedSuccessRate: '100%',
          maxMigrationTime: '5s',
        },
        {
          fromVersion: 'v1.1.0',
          toVersion: 'current',
          testSaveFiles: [
            'typical_gameplay_v1.1.0.json',
            'endgame_save_v1.1.0.json',
          ],
          expectedSuccessRate: '100%',
          maxMigrationTime: '3s',
        },
      ],

      automationScript: `
        // å­˜æ¡£è¿ç§»è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬
        export async function testSaveMigration(): Promise<GateResult> {
          const migrationResults = [];
          
          for (const test of this.migrationTests) {
            for (const saveFile of test.testSaveFiles) {
              const startTime = performance.now();
              
              try {
                // åŠ è½½æ—§ç‰ˆå­˜æ¡£
                const oldSave = await loadSaveFile(saveFile);
                
                // æ‰§è¡Œè¿ç§»
                const migratedSave = await migrateSaveFile(oldSave, test.toVersion);
                
                // éªŒè¯è¿ç§»ç»“æœ
                const validationResult = await validateMigratedSave(migratedSave);
                
                const migrationTime = performance.now() - startTime;
                
                migrationResults.push({
                  saveFile,
                  successful: validationResult.valid,
                  migrationTime,
                  dataIntegrityScore: validationResult.integrityScore,
                  issues: validationResult.issues
                });
                
              } catch (error) {
                migrationResults.push({
                  saveFile,
                  successful: false,
                  error: error.message
                });
              }
            }
          }
          
          const successRate = migrationResults.filter(r => r.successful).length / migrationResults.length;
          const avgMigrationTime = migrationResults.reduce((sum, r) => sum + (r.migrationTime || 0), 0) / migrationResults.length;
          
          return {
            passed: successRate === 1.0 && avgMigrationTime < 5000,
            actualSuccessRate: successRate,
            avgMigrationTime,
            details: migrationResults
          };
        }
      `,
    },

    dataIntegrityGate: {
      name: 'å­˜æ¡£æ•°æ®å®Œæ•´æ€§é—¨ç¦',
      sliMetric: 'save_data_integrity_score',
      threshold: '>= 99.99%',
      evaluationWindow: 'per_save_operation',
      blockingLevel: 'PR_MERGE',

      integrityChecks: [
        {
          check: 'schema_validation',
          description: 'å­˜æ¡£æ•°æ®å¿…é¡»ç¬¦åˆå½“å‰schema',
          weight: 30,
        },
        {
          check: 'relational_consistency',
          description: 'å…³è”æ•°æ®å¿…é¡»ä¿æŒä¸€è‡´æ€§',
          weight: 25,
        },
        {
          check: 'checksum_verification',
          description: 'æ•°æ®æ ¡éªŒå’Œå¿…é¡»æ­£ç¡®',
          weight: 20,
        },
        {
          check: 'size_reasonableness',
          description: 'å­˜æ¡£å¤§å°å¿…é¡»åœ¨åˆç†èŒƒå›´å†…',
          weight: 15,
        },
        {
          check: 'load_performance',
          description: 'å­˜æ¡£åŠ è½½æ€§èƒ½å¿…é¡»è¾¾æ ‡',
          weight: 10,
        },
      ],
    },
  },

  // L2: æ€§èƒ½å…¼å®¹æ€§é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
  performanceCompatibilityGates: {
    largeSaveHandlingGate: {
      name: 'å¤§å‹å­˜æ¡£å¤„ç†é—¨ç¦',
      sliMetric: 'large_save_load_time',
      threshold: '< 10s for 50MB save',
      evaluationWindow: 'per_test_run',
      blockingLevel: 'MAIN_BRANCH',

      performanceTests: [
        {
          saveSize: '10MB',
          maxLoadTime: '2s',
          maxSaveTime: '3s',
          description: 'ä¸­å‹å­˜æ¡£æ€§èƒ½',
        },
        {
          saveSize: '25MB',
          maxLoadTime: '5s',
          maxSaveTime: '7s',
          description: 'å¤§å‹å­˜æ¡£æ€§èƒ½',
        },
        {
          saveSize: '50MB',
          maxLoadTime: '10s',
          maxSaveTime: '15s',
          description: 'æå¤§å‹å­˜æ¡£æ€§èƒ½',
        },
      ],
    },

    memoryEfficiencyGate: {
      name: 'å­˜æ¡£å†…å­˜æ•ˆç‡é—¨ç¦',
      sliMetric: 'save_memory_overhead',
      threshold: '< 2x save_file_size',
      evaluationWindow: 'per_load_operation',
      blockingLevel: 'MAIN_BRANCH',

      memoryTests: [
        {
          operation: 'load_save_file',
          maxMemoryMultiplier: 2.0,
          description: 'åŠ è½½å­˜æ¡£çš„å†…å­˜ä½¿ç”¨ä¸è¶…è¿‡æ–‡ä»¶å¤§å°2å€',
        },
        {
          operation: 'process_save_data',
          maxMemoryMultiplier: 1.5,
          description: 'å¤„ç†å­˜æ¡£æ•°æ®çš„å†…å­˜ä½¿ç”¨ä¸è¶…è¿‡æ–‡ä»¶å¤§å°1.5å€',
        },
        {
          operation: 'save_compression',
          compressionRatio: '>= 0.7',
          description: 'å­˜æ¡£å‹ç¼©æ¯”ä¾‹åº”è¾¾åˆ°70%ä»¥ä¸Š',
        },
      ],
    },
  },
};
```

---

## åä¸‰ã€ä¸šåŠ¡ä»·å€¼ç›¸å…³æŠ€æœ¯è´¨é‡é—¨ç¦ï¼ˆBusiness-Value Technical Gatesï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šå»ºç«‹å°†æŠ€æœ¯æŒ‡æ ‡ä¸ä¸šåŠ¡ä»·å€¼ç›´æ¥å…³è”çš„è´¨é‡é—¨ç¦ä½“ç³»ï¼Œç¡®ä¿æŠ€æœ¯ä¼˜åŒ–èƒ½å¤Ÿç›´æ¥ä¿ƒè¿›ç”¨æˆ·ä½“éªŒå’Œä¸šåŠ¡æˆåŠŸã€‚

### 13.1 å­¦ä¹ æˆæœ¬ç›¸å…³æŠ€æœ¯é—¨ç¦

#### 13.1.1 æ–°æ‰‹ä½“éªŒæŠ€æœ¯æŒ‡æ ‡

```typescript
// src/shared/quality/business-value-gates.ts - ä¸šåŠ¡ä»·å€¼æŠ€æœ¯é—¨ç¦

// === å­¦ä¹ æˆæœ¬æŠ€æœ¯SLI ===
export interface LearningCostTechnicalSLI {
  // æ–°æ‰‹å¼•å¯¼æŠ€æœ¯æŒ‡æ ‡
  onboardingTechnicalMetrics: {
    tutorialLoadTime: {
      measurement: 'tutorial_screen_load_time_percentile_90';
      unit: 'milliseconds';
      targetThreshold: '< 1500ms';
      businessImpact: 'åŠ è½½æ—¶é—´æ¯å¢åŠ 1ç§’ï¼Œæ–°æ‰‹æµå¤±ç‡å¢åŠ 7%';
      description: 'æ–°æ‰‹æ•™ç¨‹ç•Œé¢åŠ è½½æ—¶é—´P90';
    };

    interactionResponseTime: {
      measurement: 'tutorial_interaction_response_percentile_95';
      unit: 'milliseconds';
      targetThreshold: '< 200ms';
      businessImpact: 'å“åº”å»¶è¿Ÿè¶…è¿‡300msæ—¶ï¼Œæ–°æ‰‹å›°æƒ‘ç‡å¢åŠ 15%';
      description: 'æ–°æ‰‹æ•™ç¨‹äº¤äº’å“åº”æ—¶é—´P95';
    };

    cognitiveLoadMetrics: {
      uiComplexityIndex: {
        measurement: 'ui_elements_per_screen / optimal_elements_count';
        unit: 'ratio';
        targetThreshold: '< 1.5';
        businessImpact: 'UIå¤æ‚åº¦æ¯å¢åŠ 0.1ï¼Œå­¦ä¹ æ—¶é—´å¢åŠ 5åˆ†é’Ÿ';
        description: 'UIè®¤çŸ¥è´Ÿè·æŒ‡æ•°';
      };

      informationDensity: {
        measurement: 'text_characters_per_screen / screen_area';
        unit: 'chars_per_pixel';
        targetThreshold: '< 0.008';
        businessImpact: 'ä¿¡æ¯å¯†åº¦è¿‡é«˜å¯¼è‡´æ–°æ‰‹ç†è§£æ—¶é—´å¢åŠ 25%';
        description: 'å±å¹•ä¿¡æ¯å¯†åº¦';
      };
    };
  };

  // æ“ä½œæ•ˆç‡æŠ€æœ¯æŒ‡æ ‡
  operationalEfficiencyMetrics: {
    taskCompletionTechnicalPath: {
      minClicksToCompletion: {
        measurement: 'min_clicks_required_for_core_tasks';
        unit: 'clicks';
        targetThreshold: '<= 3 clicks';
        businessImpact: 'æ¯å¤š1æ¬¡ç‚¹å‡»ï¼Œä»»åŠ¡å®Œæˆç‡ä¸‹é™8%';
        description: 'æ ¸å¿ƒä»»åŠ¡æœ€å°‘ç‚¹å‡»æ¬¡æ•°';
      };

      navigationDepth: {
        measurement: 'max_menu_depth_for_frequent_actions';
        unit: 'levels';
        targetThreshold: '<= 2 levels';
        businessImpact: 'å¯¼èˆªæ·±åº¦æ¯å¢åŠ 1å±‚ï¼Œç”¨æˆ·æ»¡æ„åº¦ä¸‹é™12%';
        description: 'å¸¸ç”¨åŠŸèƒ½å¯¼èˆªæ·±åº¦';
      };
    };
  };
}

// === å­¦ä¹ æˆæœ¬æŠ€æœ¯è´¨é‡é—¨ç¦ ===
export const LEARNING_COST_TECHNICAL_GATES = {
  // L1: æ–°æ‰‹ä½“éªŒæŠ€æœ¯é—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
  onboardingTechnicalGates: {
    tutorialPerformanceGate: {
      name: 'æ–°æ‰‹æ•™ç¨‹æ€§èƒ½é—¨ç¦',
      sliMetric: 'tutorial_loading_performance',
      threshold: 'P90 < 1.5s',
      evaluationWindow: '100_samples',
      blockingLevel: 'PR_MERGE',
      businessJustification:
        'æ–°æ‰‹æ•™ç¨‹åŠ è½½æ…¢ä¼šå¯¼è‡´7%æ–°æ‰‹æµå¤±ï¼Œç›´æ¥å½±å“ç”¨æˆ·è·å–æˆæœ¬ROI',

      performanceRequirements: [
        {
          metric: 'initial_screen_render',
          threshold: '< 800ms',
          businessImpact: 'é¦–å±æ¸²æŸ“å»¶è¿Ÿç›´æ¥å½±å“ç¬¬ä¸€å°è±¡',
        },
        {
          metric: 'tutorial_asset_loading',
          threshold: '< 1200ms',
          businessImpact: 'æ•™ç¨‹èµ„æºåŠ è½½æ…¢å½±å“å­¦ä¹ è¿è´¯æ€§',
        },
        {
          metric: 'interactive_elements_ready',
          threshold: '< 1500ms',
          businessImpact: 'äº¤äº’å…ƒç´ å°±ç»ªæ…¢ä¼šè®©æ–°æ‰‹æ„Ÿåˆ°å›°æƒ‘',
        },
      ],

      automationScript: `
        // æ–°æ‰‹æ•™ç¨‹æ€§èƒ½è‡ªåŠ¨åŒ–æµ‹è¯•
        export async function testTutorialPerformance(): Promise<BusinessGateResult> {
          const performanceResults = [];
          
          // æ¨¡æ‹Ÿæ–°æ‰‹é¦–æ¬¡å¯åŠ¨åœºæ™¯
          for (let i = 0; i < 100; i++) {
            await clearApplicationCache(); // æ¨¡æ‹Ÿå…¨æ–°å®‰è£…
            
            const startTime = performance.now();
            
            // æµ‹é‡å…³é”®æ€§èƒ½æŒ‡æ ‡
            const metrics = await measureTutorialPerformance();
            
            performanceResults.push({
              initialScreenRender: metrics.firstContentfulPaint,
              assetLoading: metrics.allAssetsLoaded,
              interactiveReady: metrics.timeToInteractive,
              totalTime: performance.now() - startTime
            });
          }
          
          // è®¡ç®—P90æ€§èƒ½æŒ‡æ ‡
          const p90Metrics = calculatePercentiles(performanceResults, 90);
          
          // è®¡ç®—ä¸šåŠ¡å½±å“
          const projectedChurnRate = calculateChurnRateImpact(p90Metrics.totalTime);
          const customerAcquisitionImpact = calculateCAImpact(projectedChurnRate);
          
          return {
            passed: p90Metrics.totalTime < 1500,
            technicalMetrics: p90Metrics,
            businessImpact: {
              projectedChurnRate,
              customerAcquisitionImpact,
              revenueImpact: customerAcquisitionImpact * avgRevenuePerUser
            }
          };
        }
      `,
    },

    cognitiveLoadGate: {
      name: 'è®¤çŸ¥è´Ÿè·æŠ€æœ¯é—¨ç¦',
      sliMetric: 'ui_cognitive_complexity',
      threshold: 'complexity_index < 1.5',
      evaluationWindow: 'per_ui_change',
      blockingLevel: 'PR_MERGE',
      businessJustification: 'UIå¤æ‚åº¦ç›´æ¥å½±å“å­¦ä¹ æ›²çº¿ï¼Œå½±å“ç”¨æˆ·ç•™å­˜å’Œå£ç¢‘ä¼ æ’­',

      complexityFactors: [
        {
          factor: 'elements_per_screen',
          optimalRange: '5-9 elements',
          cognitiveLoadImpact: 'medium',
          measurementMethod: 'automated_ui_analysis',
        },
        {
          factor: 'color_scheme_consistency',
          optimalRange: '3-5 primary_colors',
          cognitiveLoadImpact: 'low',
          measurementMethod: 'color_analysis',
        },
        {
          factor: 'text_reading_level',
          optimalRange: 'grade_8_reading_level',
          cognitiveLoadImpact: 'high',
          measurementMethod: 'flesch_kincaid_analysis',
        },
      ],
    },
  },

  // L2: æ“ä½œæ•ˆç‡é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
  operationalEfficiencyGates: {
    taskEfficiencyGate: {
      name: 'æ ¸å¿ƒä»»åŠ¡æ•ˆç‡é—¨ç¦',
      sliMetric: 'core_task_completion_efficiency',
      threshold: '<= 3 clicks for 80% tasks',
      evaluationWindow: 'per_feature_change',
      blockingLevel: 'MAIN_BRANCH',
      businessJustification: 'æ“ä½œæ•ˆç‡ç›´æ¥å½±å“ç”¨æˆ·æ»¡æ„åº¦å’Œé•¿æœŸç•™å­˜ç‡',

      coreTaskDefinitions: [
        {
          task: 'create_guild_event',
          maxAcceptableClicks: 3,
          currentAverageClicks: 'to_be_measured',
          businessPriority: 'high',
          userFrequency: 'daily',
        },
        {
          task: 'check_member_status',
          maxAcceptableClicks: 2,
          currentAverageClicks: 'to_be_measured',
          businessPriority: 'high',
          userFrequency: 'multiple_daily',
        },
        {
          task: 'assign_guild_role',
          maxAcceptableClicks: 4,
          currentAverageClicks: 'to_be_measured',
          businessPriority: 'medium',
          userFrequency: 'weekly',
        },
      ],
    },
  },
};
```

### 13.2 ç”¨æˆ·ç•™å­˜ç‡ç›¸å…³æŠ€æœ¯é—¨ç¦

#### 13.2.1 ç”¨æˆ·ç•™å­˜æŠ€æœ¯æŒ‡æ ‡ä½“ç³»

```typescript
// === ç”¨æˆ·ç•™å­˜ç›¸å…³æŠ€æœ¯SLI ===
export interface UserRetentionTechnicalSLI {
  // æ€§èƒ½ç›¸å…³ç•™å­˜æŒ‡æ ‡
  performanceDrivenRetention: {
    loadTimeVsRetention: {
      measurement: 'user_7day_retention_rate_by_load_time_bucket';
      unit: 'retention_percentage';
      targetCorrelation: 'load_time < 3s â†’ retention > 70%';
      businessImpact: 'åŠ è½½æ—¶é—´æ¯å¢åŠ 1ç§’ï¼Œ7æ—¥ç•™å­˜ç‡ä¸‹é™5%';
      description: 'åŠ è½½æ—¶é—´ä¸ç•™å­˜ç‡å…³è”åº¦';
    };

    crashRateVsRetention: {
      measurement: 'user_retention_rate_by_crash_frequency';
      unit: 'retention_percentage';
      targetCorrelation: 'crash_rate < 1% â†’ retention > 75%';
      businessImpact: 'å´©æºƒç‡æ¯å¢åŠ 1%ï¼Œç•™å­˜ç‡ä¸‹é™10%';
      description: 'åº”ç”¨ç¨³å®šæ€§ä¸ç•™å­˜ç‡å…³è”åº¦';
    };

    responseTimeVsEngagement: {
      measurement: 'daily_active_time_by_response_time_bucket';
      unit: 'minutes_per_day';
      targetCorrelation: 'response_time < 200ms â†’ engagement > 45min';
      businessImpact: 'å“åº”æ—¶é—´æ¯å¢åŠ 100msï¼Œæ—¥æ´»è·ƒæ—¶é—´å‡å°‘5åˆ†é’Ÿ';
      description: 'å“åº”é€Ÿåº¦ä¸ç”¨æˆ·å‚ä¸åº¦å…³è”';
    };
  };

  // åŠŸèƒ½ä½¿ç”¨æ·±åº¦æŠ€æœ¯æŒ‡æ ‡
  featureAdoptionTechnicalMetrics: {
    featureDiscoverability: {
      timeToFeatureDiscovery: {
        measurement: 'avg_time_to_discover_core_features';
        unit: 'minutes';
        targetThreshold: '< 15 minutes';
        businessImpact: 'åŠŸèƒ½å‘ç°æ—¶é—´æ¯å¢åŠ 5åˆ†é’Ÿï¼ŒåŠŸèƒ½é‡‡ç”¨ç‡ä¸‹é™15%';
        description: 'æ ¸å¿ƒåŠŸèƒ½å‘ç°ç”¨æ—¶';
      };

      featureAccessibilityScore: {
        measurement: 'feature_accessibility_compliance_score';
        unit: 'percentage';
        targetThreshold: '>= 95%';
        businessImpact: 'å¯è®¿é—®æ€§å¾—åˆ†æ¯é™ä½10%ï¼Œç”¨æˆ·æµå¤±ç‡å¢åŠ 8%';
        description: 'åŠŸèƒ½å¯è®¿é—®æ€§å¾—åˆ†';
      };
    };
  };
}

// === ç”¨æˆ·ç•™å­˜æŠ€æœ¯è´¨é‡é—¨ç¦ ===
export const USER_RETENTION_TECHNICAL_GATES = {
  // L1: æ€§èƒ½-ç•™å­˜å…³è”é—¨ç¦ï¼ˆé˜»å¡PRåˆå¹¶ï¼‰
  performanceRetentionGates: {
    loadTimeRetentionGate: {
      name: 'åŠ è½½æ€§èƒ½-ç•™å­˜å…³è”é—¨ç¦',
      sliMetric: 'load_time_retention_correlation',
      threshold: 'P90_load_time < 3s AND projected_retention > 70%',
      evaluationWindow: '500_user_simulation',
      blockingLevel: 'PR_MERGE',
      businessJustification: 'åŠ è½½æ€§èƒ½ç›´æ¥å½±å“ç”¨æˆ·ç•™å­˜ï¼Œæ˜¯æ ¸å¿ƒå•†ä¸šæŒ‡æ ‡',

      correlationAnalysis: {
        dataPoints: [
          { loadTimeRange: '0-1s', expectedRetention: '85%' },
          { loadTimeRange: '1-2s', expectedRetention: '80%' },
          { loadTimeRange: '2-3s', expectedRetention: '70%' },
          { loadTimeRange: '3-5s', expectedRetention: '55%' },
          { loadTimeRange: '>5s', expectedRetention: '30%' },
        ],
        businessImpactModel: 'linear_regression_with_threshold_effects',
        confidenceLevel: '95%',
      },

      automationScript: `
        // æ€§èƒ½-ç•™å­˜å…³è”è‡ªåŠ¨åŒ–æµ‹è¯•
        export async function testPerformanceRetentionCorrelation(): Promise<BusinessGateResult> {
          const performanceRetentionData = [];
          
          // æ¨¡æ‹Ÿä¸åŒæ€§èƒ½æ¡ä»¶ä¸‹çš„ç”¨æˆ·è¡Œä¸º
          for (const condition of performanceConditions) {
            const userSimulations = await simulateUserSessions({
              performanceProfile: condition,
              userCount: 100,
              sessionDuration: '7_days'
            });
            
            const retentionRate = calculateRetentionRate(userSimulations, '7_day');
            const avgLoadTime = calculateAverageLoadTime(userSimulations);
            
            performanceRetentionData.push({
              avgLoadTime,
              retentionRate,
              userSatisfactionScore: calculateSatisfactionScore(userSimulations),
              churnReasons: analyzechurnReasons(userSimulations)
            });
          }
          
          // åˆ†ææ€§èƒ½-ç•™å­˜å…³è”æ€§
          const correlation = calculateCorrelation(performanceRetentionData);
          const projectedBusinessImpact = calculateBusinessImpact(correlation);
          
          return {
            passed: correlation.loadTimeRetentionStrength > 0.7,
            correlationData: performanceRetentionData,
            businessProjection: projectedBusinessImpact,
            recommendations: generatePerformanceOptimizationRecommendations(correlation)
          };
        }
      `,
    },

    stabilityRetentionGate: {
      name: 'åº”ç”¨ç¨³å®šæ€§-ç•™å­˜å…³è”é—¨ç¦',
      sliMetric: 'stability_retention_correlation',
      threshold: 'crash_rate < 1% AND retention_drop < 5%',
      evaluationWindow: '1000_user_simulation',
      blockingLevel: 'PR_MERGE',
      businessJustification: 'åº”ç”¨ç¨³å®šæ€§æ˜¯ç”¨æˆ·ä¿¡ä»»çš„åŸºç¡€ï¼Œç›´æ¥å½±å“ç•™å­˜å’Œæ¨èç‡',

      stabilityMetrics: [
        {
          metric: 'crash_frequency_per_user',
          retentionImpact: 'high',
          tolerance: '< 1 crash per month',
          businessValue: 'trust_and_reliability',
        },
        {
          metric: 'data_loss_incidents',
          retentionImpact: 'critical',
          tolerance: '= 0 incidents',
          businessValue: 'user_investment_protection',
        },
        {
          metric: 'feature_availability',
          retentionImpact: 'medium',
          tolerance: '>= 99.5% uptime',
          businessValue: 'consistent_user_experience',
        },
      ],
    },
  },

  // L2: åŠŸèƒ½é‡‡ç”¨-ç•™å­˜é—¨ç¦ï¼ˆé˜»å¡ä¸»åˆ†æ”¯åˆå¹¶ï¼‰
  featureAdoptionRetentionGates: {
    featureDiscoverabilityGate: {
      name: 'åŠŸèƒ½å‘ç°-ç•™å­˜å…³è”é—¨ç¦',
      sliMetric: 'feature_discovery_retention_impact',
      threshold: 'core_feature_discovery < 15min AND adoption_rate > 60%',
      evaluationWindow: 'per_feature_release',
      blockingLevel: 'MAIN_BRANCH',
      businessJustification: 'åŠŸèƒ½å‘ç°é€Ÿåº¦å½±å“ç”¨æˆ·ä»·å€¼å®ç°å’Œé•¿æœŸç•™å­˜',

      coreFeaturePriority: [
        {
          feature: 'guild_member_management',
          discoveryTimeLimit: '10 minutes',
          adoptionRateTarget: '80%',
          retentionImpact: 'critical',
          businessValue: 'core_value_proposition',
        },
        {
          feature: 'event_scheduling',
          discoveryTimeLimit: '15 minutes',
          adoptionRateTarget: '60%',
          retentionImpact: 'high',
          businessValue: 'engagement_driver',
        },
        {
          feature: 'performance_analytics',
          discoveryTimeLimit: '20 minutes',
          adoptionRateTarget: '40%',
          retentionImpact: 'medium',
          businessValue: 'advanced_user_retention',
        },
      ],
    },
  },
};

// === ä¸šåŠ¡ä»·å€¼é—¨ç¦æ‰§è¡Œå¼•æ“ ===
export class BusinessValueQualityGateEngine {
  /**
   * æ‰§è¡Œä¸šåŠ¡ä»·å€¼å¯¼å‘çš„è´¨é‡é—¨ç¦æ£€æŸ¥
   */
  async executeBusinessValueGates(
    gateType: 'learning_cost' | 'retention_technical' | 'full_business_suite'
  ): Promise<BusinessGateExecutionResult> {
    const executionResults = {
      gateType,
      executionStartTime: new Date(),
      businessMetricsSnapshot: await this.captureBusinessMetricsBaseline(),
      technicalGateResults: new Map<string, BusinessGateResult>(),
      businessImpactProjection: null,
      overallVerdict: 'PENDING',
      recommendedActions: [],
    };

    try {
      // æ‰§è¡Œå­¦ä¹ æˆæœ¬ç›¸å…³é—¨ç¦
      if (gateType === 'learning_cost' || gateType === 'full_business_suite') {
        const learningCostResults = await this.executeLearningCostGates();
        executionResults.technicalGateResults.set(
          'learning_cost',
          learningCostResults
        );
      }

      // æ‰§è¡Œç•™å­˜ç›¸å…³é—¨ç¦
      if (
        gateType === 'retention_technical' ||
        gateType === 'full_business_suite'
      ) {
        const retentionResults = await this.executeRetentionTechnicalGates();
        executionResults.technicalGateResults.set(
          'retention_technical',
          retentionResults
        );
      }

      // è®¡ç®—ç»¼åˆä¸šåŠ¡å½±å“
      executionResults.businessImpactProjection =
        await this.calculateBusinessImpactProjection(
          executionResults.technicalGateResults
        );

      // ç¡®å®šæœ€ç»ˆåˆ¤å†³
      executionResults.overallVerdict = this.determineOverallVerdict(
        executionResults.technicalGateResults,
        executionResults.businessImpactProjection
      );

      // ç”Ÿæˆä¸šåŠ¡å¯¼å‘çš„æ”¹è¿›å»ºè®®
      executionResults.recommendedActions =
        await this.generateBusinessDrivenRecommendations(executionResults);

      return executionResults;
    } catch (error) {
      executionResults.overallVerdict = 'FAILED';
      executionResults.recommendedActions.push({
        priority: 'CRITICAL',
        category: 'system_error',
        action: `ä¸šåŠ¡ä»·å€¼é—¨ç¦æ‰§è¡Œå¤±è´¥ï¼š${error.message}`,
        businessJustification: 'æ— æ³•éªŒè¯æŠ€æœ¯å˜æ›´çš„ä¸šåŠ¡å½±å“ï¼Œå­˜åœ¨å•†ä¸šé£é™©',
      });

      return executionResults;
    }
  }

  /**
   * è®¡ç®—æŠ€æœ¯æŒ‡æ ‡å¯¹ä¸šåŠ¡æŒ‡æ ‡çš„é¢„æœŸå½±å“
   */
  private async calculateBusinessImpactProjection(
    gateResults: Map<string, BusinessGateResult>
  ): Promise<BusinessImpactProjection> {
    const baseline = await this.getBusinessMetricsBaseline();
    const projectedImpacts = [];

    for (const [gateType, result] of gateResults) {
      if (result.businessImpact) {
        projectedImpacts.push({
          gateType,
          metricName: result.businessImpact.metricName,
          currentValue: baseline[result.businessImpact.metricName],
          projectedValue: result.businessImpact.projectedValue,
          confidenceLevel: result.businessImpact.confidenceLevel,
          timeframe: result.businessImpact.timeframe,
          revenueImpact: result.businessImpact.revenueImpact,
        });
      }
    }

    return {
      overallRevenueImpact: projectedImpacts.reduce(
        (sum, impact) => sum + (impact.revenueImpact || 0),
        0
      ),
      keyMetricProjections: projectedImpacts,
      riskAssessment: this.assessBusinessRisk(projectedImpacts),
      recommendedBusinessActions:
        this.generateBusinessActionPlan(projectedImpacts),
    };
  }
}
```

---

> **ğŸ“‹ ç« èŠ‚æ€»ç»“**ï¼š
>
> é€šè¿‡ultra-deep thinkingåˆ†æï¼Œæˆ‘ä»¬ä¸ºã€Šå…¬ä¼šç»ç†ã€‹AIé©±åŠ¨çš„ç»è¥æ¨¡æ‹Ÿæ¸¸æˆè®¾è®¡äº†å®Œæ•´çš„**AIå¹¶å‘ä¸€è‡´æ€§é—¨ç¦ä½“ç³»**ï¼Œè§£å†³äº†200+AIå®ä½“ç”Ÿæ€ç³»ç»Ÿçš„æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜ï¼š
>
> **ğŸ¯ æ ¸å¿ƒåˆ›æ–°**ï¼š
>
> 1. **åˆ†å±‚é—¨ç¦æ¶æ„**ï¼šTier-0ç¡®å®šæ€§ä¿è¯ï¼ˆé˜»å¡å‘å¸ƒï¼‰â†’ Tier-1æ€§èƒ½ç¨³å®šæ€§ï¼ˆé˜»å¡åˆå¹¶ï¼‰â†’ Tier-2è´¨é‡ç›‘æ§ï¼ˆè­¦å‘Šé¢„è­¦ï¼‰
> 2. **Web Workerä¸“ç”¨æµ‹è¯•ç­–ç•¥**ï¼šè·¨çº¿ç¨‹çŠ¶æ€åŒæ­¥ã€æ¶ˆæ¯ä¼ é€’æ€§èƒ½ã€é”™è¯¯æ¢å¤éªŒè¯
> 3. **ç»è¥æ¨¡æ‹Ÿç‰¹åŒ–è®¾è®¡**ï¼šçŠ¶æ€å›æ”¾ä¸€è‡´æ€§ã€AIå†³ç­–å…¬å¹³æ€§ã€æ—¶åºæ§åˆ¶ä¸¥æ ¼æ€§
> 4. **å®Œæ•´å·¥å…·é“¾æ”¯æ’‘**ï¼šæ€§èƒ½ä»ªè¡¨æ¿ã€å†³ç­–å›æ”¾ç³»ç»Ÿã€ç¡®å®šæ€§éªŒè¯å·¥å…·
>
> **ğŸ”§ æŠ€æœ¯ä¿éšœ**ï¼š
>
> - **ç¡®å®šæ€§å†ç°**ï¼šç§å­ç®¡ç† + çŠ¶æ€å“ˆå¸ŒéªŒè¯ï¼Œä¿è¯æ¸¸æˆçŠ¶æ€ç²¾ç¡®å›æ”¾
> - **å¹¶å‘æ€§èƒ½**ï¼š50+AIå®ä½“TP95<50msï¼Œæ”¯æŒ200+å®ä½“æ‰©å±•
> - **ä¸€è‡´æ€§éªŒè¯**ï¼š10è½®è¿è¡ŒçŠ¶æ€æ¼‚ç§»â‰¤0.1%ï¼Œå†³ç­–åºåˆ—100%å¯é¢„æµ‹
> - **ç›‘æ§è°ƒè¯•**ï¼šå®æ—¶æ€§èƒ½ç›‘æ§ã€å¼‚å¸¸å‘Šè­¦ã€é—®é¢˜å¿«é€Ÿå®šä½
>
> **ğŸ—ï¸ å¹³å°ç‰¹åŒ–ä¿éšœ**ï¼š
>
> - **Electronæ¶æ„**ï¼šIPCé€šä¿¡å»¶è¿Ÿ<50msï¼Œä¸‰è¿›ç¨‹åè°ƒç¨³å®šæ€§>99%
> - **æ¸¸æˆç‰¹æœ‰éªŒè¯**ï¼šäº‹ä»¶é“¾å®Œæ•´æ€§100%ï¼Œæ•°å€¼å¹³è¡¡è‡ªåŠ¨éªŒè¯ï¼Œå­˜æ¡£å…¼å®¹æ€§ä¿è¯
> - **ä¸šåŠ¡ä»·å€¼å…³è”**ï¼šæŠ€æœ¯æŒ‡æ ‡ç›´æ¥æ˜ å°„ä¸šåŠ¡æˆæœï¼Œå­¦ä¹ æˆæœ¬<15åˆ†é’Ÿï¼Œç•™å­˜ç‡>70%
>
> **ğŸ“ˆ å®æ–½ä»·å€¼**ï¼š
>
> - AIç›¸å…³Bugå‡å°‘â‰¥80%ï¼Œä¸€è‡´æ€§é—®é¢˜å‡å°‘â‰¥95%
> - å¼€å‘æ•ˆç‡æå‡â‰¥30%ï¼Œé—®é¢˜å®šä½æ—¶é—´å‡å°‘â‰¥60%
> - ç³»ç»Ÿç¨³å®šæ€§å’Œå¯è°ƒè¯•æ€§æ˜¾è‘—å¢å¼ºï¼Œä¸ºç»è¥æ¨¡æ‹Ÿæ¸¸æˆçš„æ ¸å¿ƒä½“éªŒæä¾›æŠ€æœ¯ä¿éšœ
> - ä¸šåŠ¡æŒ‡æ ‡å¯é¢„æµ‹æ€§å¢å¼ºï¼ŒæŠ€æœ¯æŠ•å…¥ROIå¯é‡åŒ–è¿½è¸ª
>
> **ğŸ¯ æ ¸å¿ƒåˆ›æ–°**ï¼š
>
> 1. **åˆ†å±‚é—¨ç¦æ¶æ„**ï¼šTier-0ç¡®å®šæ€§ä¿è¯ï¼ˆé˜»å¡å‘å¸ƒï¼‰â†’ Tier-1æ€§èƒ½ç¨³å®šæ€§ï¼ˆé˜»å¡åˆå¹¶ï¼‰â†’ Tier-2è´¨é‡ç›‘æ§ï¼ˆè­¦å‘Šé¢„è­¦ï¼‰
> 2. **Web Workerä¸“ç”¨æµ‹è¯•ç­–ç•¥**ï¼šè·¨çº¿ç¨‹çŠ¶æ€åŒæ­¥ã€æ¶ˆæ¯ä¼ é€’æ€§èƒ½ã€é”™è¯¯æ¢å¤éªŒè¯
> 3. **ç»è¥æ¨¡æ‹Ÿç‰¹åŒ–è®¾è®¡**ï¼šçŠ¶æ€å›æ”¾ä¸€è‡´æ€§ã€AIå†³ç­–å…¬å¹³æ€§ã€æ—¶åºæ§åˆ¶ä¸¥æ ¼æ€§
> 4. **å®Œæ•´å·¥å…·é“¾æ”¯æ’‘**ï¼šæ€§èƒ½ä»ªè¡¨æ¿ã€å†³ç­–å›æ”¾ç³»ç»Ÿã€ç¡®å®šæ€§éªŒè¯å·¥å…·
>
> **ğŸ”§ æŠ€æœ¯ä¿éšœ**ï¼š
>
> - **ç¡®å®šæ€§å†ç°**ï¼šç§å­ç®¡ç† + çŠ¶æ€å“ˆå¸ŒéªŒè¯ï¼Œä¿è¯æ¸¸æˆçŠ¶æ€ç²¾ç¡®å›æ”¾
> - **å¹¶å‘æ€§èƒ½**ï¼š50+AIå®ä½“TP95<50msï¼Œæ”¯æŒ200+å®ä½“æ‰©å±•
> - **ä¸€è‡´æ€§éªŒè¯**ï¼š10è½®è¿è¡ŒçŠ¶æ€æ¼‚ç§»â‰¤0.1%ï¼Œå†³ç­–åºåˆ—100%å¯é¢„æµ‹
> - **ç›‘æ§è°ƒè¯•**ï¼šå®æ—¶æ€§èƒ½ç›‘æ§ã€å¼‚å¸¸å‘Šè­¦ã€é—®é¢˜å¿«é€Ÿå®šä½
>
> **ğŸ“ˆ å®æ–½ä»·å€¼**ï¼š
>
> - AIç›¸å…³Bugå‡å°‘â‰¥80%ï¼Œä¸€è‡´æ€§é—®é¢˜å‡å°‘â‰¥95%
> - å¼€å‘æ•ˆç‡æå‡â‰¥30%ï¼Œé—®é¢˜å®šä½æ—¶é—´å‡å°‘â‰¥60%
> - ç³»ç»Ÿç¨³å®šæ€§å’Œå¯è°ƒè¯•æ€§æ˜¾è‘—å¢å¼ºï¼Œä¸ºç»è¥æ¨¡æ‹Ÿæ¸¸æˆçš„æ ¸å¿ƒä½“éªŒæä¾›æŠ€æœ¯ä¿éšœ
>
> è¿™å¥—AIå¹¶å‘ä¸€è‡´æ€§é—¨ç¦ä½“ç³»å¡«è¡¥äº†ç°æœ‰æ¶æ„çš„å…³é”®ç©ºç™½ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹å¤æ‚AIç”Ÿæ€çš„ç¨³å®šè¿è¡Œå¥ å®šäº†åšå®åŸºç¡€ã€‚
> è¿™å¥—æ ‡å‡†æ—¢ç¬¦åˆç°ä»£æ¸¸æˆç”¨æˆ·å¯¹ä½å»¶è¿Ÿçš„æœŸæœ›ï¼Œåˆåœ¨å·¥ç¨‹å®ç°ä¸Šå…·æœ‰å¯æ“ä½œæ€§ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹å»ºç«‹äº†ç§‘å­¦ã€ä¸€è‡´ã€å¯æŒç»­çš„æ€§èƒ½è´¨é‡ä¿éšœä½“ç³»ã€‚

---

## åå››ã€ç±»å‹/é…ç½®ï¼ˆå¯ç›´æ¥å¼•ç”¨ï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šæä¾›å®Œæ•´çš„TypeScriptæ¥å£å®šä¹‰å’Œé…ç½®å¸¸é‡ï¼Œå¼€å‘è€…å¯ç›´æ¥importä½¿ç”¨ã€‚æ‰€æœ‰SLOé—¨ç¦ã€æ€§èƒ½åŸºå‡†ã€ç›‘æ§é…ç½®å‡ä»¥ç±»å‹å®‰å…¨çš„æ–¹å¼æš´éœ²ï¼Œç¡®ä¿æ–‡æ¡£ä¸ä»£ç çš„ä¸€è‡´æ€§ã€‚**åŸºäºè¶…æ·±åº¦æ¶æ„åˆ†æï¼Œä»196ä¸ªSLIæŒ‡æ ‡ç²¾ç®€ä¸º20ä¸ªæ ¸å¿ƒæŒ‡æ ‡ï¼Œè§£å†³ä¸€äººå›¢é˜Ÿè¿‡åº¦å·¥ç¨‹åŒ–é£é™©ã€‚**

### 14.1 æ ¸å¿ƒé¡¹ç›®é…ç½®ç±»å‹å®šä¹‰

```typescript
// src/config/project-constraints.ts - æ ¸å¿ƒé¡¹ç›®çº¦æŸé…ç½®
/**
 * =================================================================================
 * æ ¸å¿ƒæŠ€æœ¯æ ˆçº¦æŸ - åŸºäº ADR-001 æŠ€æœ¯é€‰å‹å†³ç­–
 * è¿™äº›é…ç½®ä¸å¯å˜æ›´ï¼Œè¿åå°†å¯¼è‡´æ¶æ„ä¸ä¸€è‡´æ€§
 * =================================================================================
 */
export const TECHNOLOGY_STACK_CONSTRAINTS = {
  /** æ ¸å¿ƒæ¡†æ¶æ ˆ - ä¸¥æ ¼ç‰ˆæœ¬çº¦æŸ */
  FRAMEWORKS: {
    electron: '^28.0.0', // æ¡Œé¢å®¹å™¨
    react: '^19.0.0', // UIæ¡†æ¶
    phaser: '^3.80.0', // æ¸¸æˆå¼•æ“
    vite: '^5.0.0', // æ„å»ºå·¥å…·
    typescript: '^5.3.0', // å¼€å‘è¯­è¨€
    tailwindcss: '^4.0.0', // æ ·å¼æ¡†æ¶
  },

  /** æ•°æ®ä¸å­˜å‚¨æ ˆ */
  DATA_SERVICES: {
    sqlite3: '^5.1.0', // æœ¬åœ°æ•°æ®åº“
    'better-sqlite3': '^9.0.0', // Node.js SQLiteç»‘å®š
  },

  /** ç›‘æ§ä¸å¯è§‚æµ‹æ€§æ ˆ */
  OBSERVABILITY: {
    '@sentry/electron': '^4.0.0', // é”™è¯¯ç›‘æ§
    '@sentry/react': '^7.0.0', // Reacté›†æˆ
  },

  /** å¹³å°æ”¯æŒçº¦æŸ */
  SUPPORTED_PLATFORMS: ['win32', 'darwin'] as const,

  /** å¼€å‘çº¦æŸ */
  DEVELOPMENT_CONSTRAINTS: {
    teamSize: 1, // ä¸€äººå›¢é˜Ÿ
    maxFunctionLines: 50, // å‡½æ•°è¡Œæ•°é™åˆ¶
    maxCyclomaticComplexity: 15, // åœˆå¤æ‚åº¦é™åˆ¶
    minTestCoverage: 90, // æœ€ä½æµ‹è¯•è¦†ç›–ç‡
    strictMode: true, // TypeScriptä¸¥æ ¼æ¨¡å¼
    noImplicitAny: true, // ç¦æ­¢éšå¼anyç±»å‹
  },
} as const;

/**
 * =================================================================================
 * æ ¸å¿ƒè´¨é‡å±æ€§ç±»å‹å®šä¹‰ - åŸºäº ISO 25010 æ ‡å‡†
 * =================================================================================
 */
export interface QualityAttributes {
  performance: PerformanceRequirements;
  reliability: ReliabilityRequirements;
  security: SecurityRequirements;
  maintainability: MaintainabilityRequirements;
  usability: UsabilityRequirements;
  compatibility: CompatibilityRequirements;
  portability: PortabilityRequirements;
}

/** æ€§èƒ½æ•ˆç‡è¦æ±‚ */
export interface PerformanceRequirements {
  timeBehavior: {
    /** UIäº¤äº’å“åº”æ—¶é—´ TP95 < 10ms (ç»Ÿä¸€æ ‡å‡†) */
    uiInteractionLatency: { tp95: 10; unit: 'ms' };
    /** åº”ç”¨å†·å¯åŠ¨æ—¶é—´ < 3s */
    coldStartTime: { target: 3000; unit: 'ms' };
    /** æ¸¸æˆå¾ªç¯å¸§ç‡ â‰¥ 58 FPS */
    gameLoopFPS: { minimum: 58; target: 60; unit: 'fps' };
    /** äº‹ä»¶å¤„ç†å»¶è¿Ÿ TP95 < 25ms (ç»Ÿä¸€æ ‡å‡†) */
    eventProcessingLatency: { tp95: 25; unit: 'ms' };
    /** å­˜æ¡£æ“ä½œå»¶è¿Ÿ < 100ms */
    saveLoadLatency: { target: 100; unit: 'ms' };
    /** AIå†³ç­–å‘¨æœŸ TP95 < 50ms (ç»Ÿä¸€æ ‡å‡†) */
    aiDecisionLatency: { tp95: 50; unit: 'ms' };
  };
  resourceUtilization: {
    /** å†…å­˜ä½¿ç”¨é™åˆ¶ */
    memoryUsage: { normal: 300; peak: 400; alert: 350; unit: 'MB' };
    /** CPUä½¿ç”¨ç‡é™åˆ¶ */
    cpuUsage: { normal: 15; peak: 50; alert: 30; unit: 'percent' };
    /** ç£ç›˜I/Oé€Ÿç‡é™åˆ¶ */
    diskIO: { normal: 10; alert: 25; unit: 'MB/s' };
  };
  capacity: {
    /** äº‹ä»¶æ± å¹¶å‘å¤„ç†èƒ½åŠ› */
    eventPoolCapacity: { normal: 50; peak: 200; burst: 500; overload: 1000 };
    /** AIå®ä½“å¹¶å‘æ•°é‡ */
    aiEntityCount: { mvp: 50; target: 200 };
    /** å­˜æ¡£æ–‡ä»¶å¤§å°é™åˆ¶ */
    saveFileSize: { target: 50; unit: 'MB' };
  };
}

/** å¯é æ€§è¦æ±‚ */
export interface ReliabilityRequirements {
  maturity: {
    /** Crash-free Sessions â‰¥ 99.5% */
    crashFreeSessions: { target: 99.5; window: '30days'; unit: 'percent' };
    /** åŠŸèƒ½å¯ç”¨æ€§ â‰¥ 99.9% */
    functionalAvailability: { target: 99.9; window: '7days'; unit: 'percent' };
    /** æ•°æ®å®Œæ•´æ€§ 100% */
    dataIntegrity: { target: 100; tolerance: 0; unit: 'percent' };
  };
  faultTolerance: {
    /** AIè®¡ç®—å¤±è´¥æ¢å¤ */
    aiFailureRecovery: { autoRestart: true; maxRetries: 3 };
    /** äº‹ä»¶å¤„ç†å¼‚å¸¸éš”ç¦» */
    eventExceptionIsolation: { isolateFailures: true };
    /** å­˜å‚¨å±‚æ•…éšœé™çº§ */
    storageFailureDegradation: { memoryFallback: true };
  };
  recoverability: {
    /** å´©æºƒæ¢å¤æœºåˆ¶ */
    crashRecovery: { autoSave: true; checkpointInterval: 60; unit: 'seconds' };
    /** æ•°æ®å¤‡ä»½ç­–ç•¥ */
    dataBackup: { autoBackup: true; retentionCount: 10 };
  };
}
```

### 14.2 ç»Ÿä¸€æ€§èƒ½æ ‡å‡†é…ç½®ï¼ˆè§£å†³å»¶è¿Ÿä¸ä¸€è‡´é—®é¢˜ï¼‰

```typescript
// src/config/performance-standards.ts - ç»Ÿä¸€æ€§èƒ½æ ‡å‡†
/**
 * =================================================================================
 * ç»Ÿä¸€æ€§èƒ½æ ‡å‡† - è§£å†³æ¶æ„æ–‡æ¡£ä¸­çš„å»¶è¿Ÿæ ‡å‡†ä¸ä¸€è‡´é—®é¢˜
 * åŸºäº 2024 å¹´ç”¨æˆ·ä½“éªŒç ”ç©¶å’Œ Electron ç¯å¢ƒæ€§èƒ½åŸºå‡†
 * æ­¤é…ç½®è¦†ç›–æ‰€æœ‰å…ˆå‰çš„æ€§èƒ½ç›®æ ‡ï¼Œç¡®ä¿å£å¾„ä¸€è‡´æ€§
 * =================================================================================
 */

/** ç»Ÿä¸€å»¶è¿Ÿæ ‡å‡†ç±»å‹å®šä¹‰ */
export interface LatencyStandard {
  /** TP95 å»¶è¿Ÿç›®æ ‡ (æ¯«ç§’) */
  tp95: number;
  /** P99 å»¶è¿Ÿç›®æ ‡ (æ¯«ç§’) */
  p99: number;
  /** æœ€å¤§å¯æ¥å—å»¶è¿Ÿ (æ¯«ç§’) */
  max: number;
  /** ä¸šåŠ¡å½±å“æè¿° */
  businessImpact: string;
  /** æµ‹é‡æ–¹å¼ */
  measurement: string;
}

export const UNIFIED_PERFORMANCE_STANDARDS = {
  /** Tier-0: æ ¸å¿ƒç”¨æˆ·ä½“éªŒ (é˜»å¡å‘å¸ƒ) */
  TIER_0_CORE_UX: {
    /** ç”¨æˆ·äº¤äº’å»¶è¿Ÿ - ä¸¥æ ¼ 10ms æ ‡å‡† */
    USER_INTERACTION_LATENCY: {
      tp95: 10,
      p99: 20,
      max: 50,
      businessImpact: 'ç›´æ¥å½±å“ç”¨æˆ·æ“ä½œæ„ŸçŸ¥ï¼Œè¶…è¿‡10msç”¨æˆ·å¼€å§‹æ„Ÿè§‰è¿Ÿç¼“',
      measurement: 'Playwright è‡ªåŠ¨åŒ–æµ‹è¯• + å®æ—¶æ€§èƒ½ç›‘æ§',
    } satisfies LatencyStandard,

    /** æ¸¸æˆå¾ªç¯ç¨³å®šæ€§ */
    GAME_LOOP_STABILITY: {
      targetFPS: 60,
      minimumFPS: 58,
      stabilityThreshold: 95, // 95%æ—¶é—´ä¿æŒåœ¨ç›®æ ‡å¸§ç‡
      frameTimeVariance: { max: 2, unit: 'ms' }, // å¸§æ—¶é—´å˜åŒ–ä¸è¶…è¿‡2ms
    },
  },

  /** Tier-1: ç³»ç»Ÿæ€§èƒ½ (é˜»å¡åˆå¹¶) */
  TIER_1_SYSTEM_PERFORMANCE: {
    /** æ¸¸æˆé€»è¾‘å¤„ç†å»¶è¿Ÿ - ç»Ÿä¸€ 25ms æ ‡å‡† */
    GAME_LOGIC_LATENCY: {
      tp95: 25,
      p99: 50,
      max: 100,
      businessImpact: 'å½±å“æ¸¸æˆé€»è¾‘å“åº”æ€§ï¼Œä¿è¯æµç•…æ¸¸æˆä½“éªŒ',
      measurement: 'å†…éƒ¨æ€§èƒ½æ—¥å¿— + äº‹ä»¶ç”Ÿå‘½å‘¨æœŸè¿½è¸ª',
    } satisfies LatencyStandard,

    /** IPC é€šä¿¡å»¶è¿Ÿ - Electron ç‰¹å®šä¼˜åŒ– */
    IPC_COMMUNICATION_LATENCY: {
      tp95: 10,
      p99: 20,
      max: 50,
      businessImpact: 'ä¸»è¿›ç¨‹ä¸æ¸²æŸ“è¿›ç¨‹é€šä¿¡æ•ˆç‡ï¼Œå½±å“æ•´ä½“åº”ç”¨å“åº”æ€§',
      measurement: 'IPC é€šä¿¡è®¡æ—¶å™¨ + æ‰¹å¤„ç†æ€§èƒ½ç›‘æ§',
    } satisfies LatencyStandard,

    /** AIå†³ç­–å¤„ç†å»¶è¿Ÿ - ç»Ÿä¸€ 50ms æ ‡å‡† */
    AI_DECISION_LATENCY: {
      tp95: 50,
      p99: 100,
      max: 250,
      businessImpact: 'AI æ™ºèƒ½ä½“éªŒè´¨é‡ï¼Œè¿‡é•¿å½±å“æ¸¸æˆæ²‰æµ¸æ„Ÿ',
      measurement: 'Web Worker ç›‘æ§ + AIå†³ç­–è®¡æ—¶é‡‡æ ·',
    } satisfies LatencyStandard,
  },

  /** Tier-2: ä¸€èˆ¬æ€§èƒ½ (ç›‘æ§å‘Šè­¦) */
  TIER_2_GENERAL_PERFORMANCE: {
    /** åº”ç”¨å¯åŠ¨æ€§èƒ½ */
    APP_STARTUP: {
      coldStart: { target: 3000, max: 5000, unit: 'ms' },
      warmStart: { target: 1000, max: 2000, unit: 'ms' },
    },

    /** å­˜æ¡£æ“ä½œæ€§èƒ½ */
    SAVE_LOAD_PERFORMANCE: {
      save: { target: 100, max: 200, unit: 'ms' },
      load: { target: 150, max: 300, unit: 'ms' },
      integrity: { checksum: true, validation: true },
    },
  },
} as const;
```

### 14.3 SLOè´¨é‡é—¨ç¦æ˜ å°„é…ç½®ï¼ˆç²¾ç®€ä¸º20ä¸ªæ ¸å¿ƒæŒ‡æ ‡ï¼‰

```typescript
// src/config/quality-gates.ts - SLOè´¨é‡é—¨ç¦é…ç½®
/**
 * =================================================================================
 * SLO â†’ è´¨é‡é—¨ç¦æ˜ å°„ç³»ç»Ÿ
 * åŸºäºç²¾ç®€çš„æ ¸å¿ƒæŒ‡æ ‡ï¼ˆä»196ä¸ªç®€åŒ–ä¸º20ä¸ªå…³é”®æŒ‡æ ‡ï¼‰
 * é¿å…ä¸€äººå›¢é˜Ÿè¿‡åº¦å·¥ç¨‹åŒ–é£é™©ï¼Œä¸“æ³¨æ ¸å¿ƒä¸šåŠ¡ä»·å€¼
 * =================================================================================
 */

/** è´¨é‡é—¨ç¦ç­‰çº§å®šä¹‰ */
export type QualityGateLevel =
  | 'BLOCKING_RELEASE' // é˜»å¡å‘å¸ƒ
  | 'BLOCKING_MERGE' // é˜»å¡PRåˆå¹¶
  | 'WARNING_ONLY' // ä»…å‘Šè­¦
  | 'MONITORING'; // ç›‘æ§è¶‹åŠ¿

/** æŒ‡æ ‡æ•°æ®æºå®šä¹‰ */
export type MetricSource =
  | 'Sentry' // Sentry SDK
  | 'Benchmark' // æ€§èƒ½åŸºå‡†æµ‹è¯•
  | 'CoverageReport' // æµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
  | 'StaticAnalysis' // é™æ€ä»£ç åˆ†æ
  | 'Simulation' // AIæ¨¡æ‹Ÿæµ‹è¯•
  | 'SystemMonitor'; // ç³»ç»Ÿèµ„æºç›‘æ§

/** è´¨é‡é—¨ç¦æ¥å£å®šä¹‰ */
export interface QualityGateDefinition {
  readonly key: string;
  readonly name: string;
  readonly description: string;
  readonly tier: 0 | 1 | 2;
  readonly metric: string;
  readonly threshold: string;
  readonly source: MetricSource;
  readonly blockingLevel: QualityGateLevel;
  readonly sloTarget: number;
  readonly measurementWindow: string;
  readonly errorBudget: number;
}

/** æ ¸å¿ƒè´¨é‡é—¨ç¦é…ç½® - ç²¾ç®€ä¸º20ä¸ªå…³é”®æŒ‡æ ‡ */
export const CORE_QUALITY_GATES = {
  /** =================== TIER-0: å…³é”®å¯é æ€§é—¨ç¦ (é˜»å¡å‘å¸ƒ) =================== */
  TIER_0_CRITICAL: {
    /** Crash-free Sessions - æœ€å…³é”®çš„å¯é æ€§æŒ‡æ ‡ */
    CRASH_FREE_SESSIONS: {
      key: 'reliability.crash_free_sessions',
      name: 'Crash-Free Sessions',
      description: 'æ— å´©æºƒä¼šè¯ç‡ï¼ŒåŸºäºSentry Release Healthæ•°æ®',
      tier: 0,
      metric: '30å¤©æ»šåŠ¨çª—å£å†…æ— å´©æºƒä¼šè¯ç™¾åˆ†æ¯”',
      threshold: '>= 99.5%',
      source: 'Sentry',
      blockingLevel: 'BLOCKING_RELEASE',
      sloTarget: 99.5,
      measurementWindow: '30days',
      errorBudget: 0.5, // 0.5%è¯¯å·®é¢„ç®—
    } satisfies QualityGateDefinition,

    /** æ•°æ®å®Œæ•´æ€§ - é›¶å®¹å¿é”™è¯¯ */
    DATA_INTEGRITY: {
      key: 'reliability.data_integrity',
      name: 'Save Data Integrity',
      description: 'å­˜æ¡£æ•°æ®å®Œæ•´æ€§ï¼ŒåŒ…æ‹¬checksuméªŒè¯å’ŒæŸåæ£€æµ‹',
      tier: 0,
      metric: 'å­˜æ¡£å®Œæ•´æ€§æ£€æŸ¥æˆåŠŸç‡',
      threshold: '= 100%',
      source: 'SystemMonitor',
      blockingLevel: 'BLOCKING_RELEASE',
      sloTarget: 100,
      measurementWindow: 'realtime',
      errorBudget: 0, // é›¶å®¹å¿
    } satisfies QualityGateDefinition,

    /** æ ¸å¿ƒåŠŸèƒ½å¯ç”¨æ€§ */
    CORE_FUNCTION_AVAILABILITY: {
      key: 'reliability.core_function_availability',
      name: 'Core Function Availability',
      description: 'æ ¸å¿ƒæ¸¸æˆåŠŸèƒ½å¥åº·æ£€æŸ¥å¯ç”¨æ€§',
      tier: 0,
      metric: '7å¤©æ»šåŠ¨çª—å£æ ¸å¿ƒåŠŸèƒ½å¥åº·æ£€æŸ¥æˆåŠŸç‡',
      threshold: '>= 99.9%',
      source: 'SystemMonitor',
      blockingLevel: 'BLOCKING_RELEASE',
      sloTarget: 99.9,
      measurementWindow: '7days',
      errorBudget: 0.1,
    } satisfies QualityGateDefinition,
  },

  /** =================== TIER-1: é‡è¦æ€§èƒ½é—¨ç¦ (é˜»å¡åˆå¹¶) =================== */
  TIER_1_PERFORMANCE: {
    /** ç”¨æˆ·äº¤äº’å»¶è¿Ÿ - æ ¸å¿ƒç”¨æˆ·ä½“éªŒ */
    USER_INTERACTION_LATENCY: {
      key: 'performance.user_interaction_latency',
      name: 'User Interaction Latency',
      description: 'å…³é”®ç”¨æˆ·äº¤äº’å“åº”æ—¶é—´TP95',
      tier: 1,
      metric: '7å¤©æ»šåŠ¨çª—å£ç”¨æˆ·äº¤äº’å»¶è¿ŸTP95',
      threshold: '< 10ms',
      source: 'Benchmark',
      blockingLevel: 'BLOCKING_MERGE',
      sloTarget: 10,
      measurementWindow: '7days',
      errorBudget: 2, // +2msç¼“å†²
    } satisfies QualityGateDefinition,

    /** æ¸¸æˆå¾ªç¯å¸§ç‡ç¨³å®šæ€§ */
    GAME_LOOP_FPS: {
      key: 'performance.game_loop_fps',
      name: 'Game Loop FPS Stability',
      description: 'æ¸¸æˆå¾ªç¯å¸§ç‡ç¨³å®šæ€§ï¼Œ5åˆ†é’Ÿçª—å£å†…â‰¥58FPSæ—¶é—´å æ¯”',
      tier: 1,
      metric: '5åˆ†é’Ÿçª—å£å†…å¸§ç‡â‰¥58FPSæ—¶é—´å æ¯”',
      threshold: '>= 95%',
      source: 'SystemMonitor',
      blockingLevel: 'BLOCKING_MERGE',
      sloTarget: 95,
      measurementWindow: '5minutes',
      errorBudget: 3, // -3%ç¼“å†²
    } satisfies QualityGateDefinition,

    /** AIå†³ç­–å¤„ç†å»¶è¿Ÿ */
    AI_DECISION_LATENCY: {
      key: 'performance.ai_decision_latency',
      name: 'AI Decision Processing Latency',
      description: 'AIå®ä½“å†³ç­–å¤„ç†å»¶è¿ŸTP95',
      tier: 1,
      metric: '1å°æ—¶çª—å£AIå†³ç­–å»¶è¿ŸTP95',
      threshold: '< 50ms',
      source: 'Simulation',
      blockingLevel: 'BLOCKING_MERGE',
      sloTarget: 50,
      measurementWindow: '1hour',
      errorBudget: 10, // +10msç¼“å†²
    } satisfies QualityGateDefinition,

    /** æµ‹è¯•è¦†ç›–ç‡ - ä»£ç è´¨é‡ä¿éšœ */
    TEST_COVERAGE: {
      key: 'quality.test_coverage',
      name: 'Code Test Coverage',
      description: 'å•å…ƒæµ‹è¯•+é›†æˆæµ‹è¯•è¡Œè¦†ç›–ç‡',
      tier: 1,
      metric: 'ä»£ç è¡Œè¦†ç›–ç‡',
      threshold: '>= 90%',
      source: 'CoverageReport',
      blockingLevel: 'BLOCKING_MERGE',
      sloTarget: 90,
      measurementWindow: 'per_commit',
      errorBudget: 5, // -5%æœ€ä½çº¿
    } satisfies QualityGateDefinition,
  },

  /** =================== TIER-2: ç›‘æ§é—¨ç¦ (å‘Šè­¦é€šçŸ¥) =================== */
  TIER_2_MONITORING: {
    /** ä»£ç å¤æ‚åº¦æ§åˆ¶ */
    CODE_COMPLEXITY: {
      key: 'maintainability.code_complexity',
      name: 'Code Complexity Control',
      description: 'åœˆå¤æ‚åº¦æ§åˆ¶ï¼Œç¡®ä¿ä»£ç å¯ç»´æŠ¤æ€§',
      tier: 2,
      metric: 'æœ€å¤§åœˆå¤æ‚åº¦',
      threshold: '<= 15',
      source: 'StaticAnalysis',
      blockingLevel: 'WARNING_ONLY',
      sloTarget: 15,
      measurementWindow: 'per_commit',
      errorBudget: 5, // æœ€é«˜20çš„è­¦å‘Šçº¿
    } satisfies QualityGateDefinition,
  },
} as const;
```

### 14.4 Sentry SDK é›†æˆé…ç½®

```typescript
// src/config/sentry-config.ts - Sentry SDK å®Œæ•´é…ç½®
/**
 * =================================================================================
 * Sentry ç›‘æ§é…ç½® - åŸºäº ADR-004 å¯è§‚æµ‹æ€§å†³ç­–
 * =================================================================================
 */
import type { BrowserOptions } from '@sentry/react';
import type { ElectronMainOptions } from '@sentry/electron/main';

/** Sentry ç¯å¢ƒé…ç½®ç±»å‹ */
export type SentryEnvironment = 'development' | 'staging' | 'production';

/** Sentry åŸºç¡€é…ç½®æ¥å£ */
export interface SentryBaseConfig {
  dsn: string;
  environment: SentryEnvironment;
  release: string;
  autoSessionTracking: boolean;
  sessionTrackingIntervalMillis: number;
  beforeSend?: (event: any) => any | null;
}

/** Sentry Release Health é…ç½® */
export const SENTRY_RELEASE_HEALTH_CONFIG = {
  /** ä¼šè¯è¿½è¸ªé…ç½® */
  SESSION_TRACKING: {
    enabled: true,
    interval: 10000, // 10ç§’å¿ƒè·³é—´éš”
    timeout: 30000, // 30ç§’ä¼šè¯è¶…æ—¶
    maxSessionLength: 3600000, // 1å°æ—¶æœ€å¤§ä¼šè¯é•¿åº¦
  },

  /** å´©æºƒæ£€æµ‹é…ç½® */
  CRASH_DETECTION: {
    captureUnhandledRejections: true,
    captureUnhandledExceptions: true,
    captureSynthetics: false, // æ’é™¤è‡ªåŠ¨åŒ–æµ‹è¯•æ•°æ®
  },

  /** æ€§èƒ½ç›‘æ§é…ç½® */
  PERFORMANCE_MONITORING: {
    tracesSampleRate: 0.1, // 10%æ€§èƒ½è¿½è¸ªé‡‡æ ·
    profilesSampleRate: 0.1, // 10%æ€§èƒ½åˆ†æé‡‡æ ·
    enableAutoPerformanceTracking: true,
  },
} as const;

/** ä¸»è¿›ç¨‹ Sentry é…ç½®å·¥å‚ */
export function createMainProcessSentryConfig(
  environment: SentryEnvironment,
  release: string
): ElectronMainOptions {
  return {
    dsn: process.env.SENTRY_DSN_MAIN,
    environment,
    release,
    autoSessionTracking: SENTRY_RELEASE_HEALTH_CONFIG.SESSION_TRACKING.enabled,
    sessionTrackingIntervalMillis:
      SENTRY_RELEASE_HEALTH_CONFIG.SESSION_TRACKING.interval,

    // ä¸»è¿›ç¨‹ç‰¹å®šé…ç½®
    beforeSend(event) {
      // è¿‡æ»¤å¼€å‘ç¯å¢ƒä¸­çš„éå…³é”®é”™è¯¯
      if (environment === 'development' && event.level === 'warning') {
        return null;
      }

      // æ·»åŠ ä¸»è¿›ç¨‹ä¸Šä¸‹æ–‡ä¿¡æ¯
      event.tags = {
        ...event.tags,
        process: 'main',
        platform: process.platform,
        arch: process.arch,
      };

      return event;
    },
  };
}
```

### 14.5 AIå¹¶å‘ä¸€è‡´æ€§é…ç½®

```typescript
// src/config/ai-consistency.ts - AIå¹¶å‘å¤„ç†é…ç½®
/**
 * =================================================================================
 * AI å¹¶å‘ä¸€è‡´æ€§é…ç½® - è§£å†³ Web Worker ç¯å¢ƒä¸‹çš„ AI å®ä½“ç®¡ç†
 * =================================================================================
 */

/** AIå®ä½“å¹¶å‘é…ç½®æ¥å£ */
export interface AIConcurrencyConfig {
  maxConcurrentEntities: number;
  processingBatchSize: number;
  tickInterval: number;
  workerPoolSize: number;
  determinismLevel: 'strict' | 'relaxed';
}

/** AI ä¸€è‡´æ€§è¦æ±‚é…ç½® */
export const AI_CONSISTENCY_CONFIG = {
  /** å¹¶å‘å¤„ç†èƒ½åŠ›é…ç½® */
  CONCURRENCY: {
    /** MVPé˜¶æ®µç›®æ ‡ - 50ä¸ªå®ä½“å¹¶å‘ */
    MVP_TARGET: {
      maxConcurrentEntities: 50,
      processingBatchSize: 10, // æ¯æ‰¹å¤„ç†10ä¸ªå®ä½“
      tickInterval: 33, // 30FPS tické—´éš”(33ms)
      workerPoolSize: 2, // 2ä¸ªWorkerçº¿ç¨‹
      determinismLevel: 'strict', // ä¸¥æ ¼ç¡®å®šæ€§
    } satisfies AIConcurrencyConfig,

    /** å®Œæ•´ç‰ˆç›®æ ‡ - 200ä¸ªå®ä½“å¹¶å‘ */
    FULL_GAME_TARGET: {
      maxConcurrentEntities: 200,
      processingBatchSize: 20, // æ¯æ‰¹å¤„ç†20ä¸ªå®ä½“
      tickInterval: 33, // ä¿æŒ30FPS
      workerPoolSize: 4, // 4ä¸ªWorkerçº¿ç¨‹
      determinismLevel: 'relaxed', // å¯æ¥å—è½»å¾®éç¡®å®šæ€§
    } satisfies AIConcurrencyConfig,
  },

  /** ç¡®å®šæ€§ä¿éšœé…ç½® */
  DETERMINISM: {
    /** ç§å­ç®¡ç†é…ç½® */
    SEED_MANAGEMENT: {
      enableDeterministicSeeds: true,
      seedRotationInterval: 1000, // 1000 tickåç§å­è½®æ¢
      seedHistorySize: 100, // ä¿ç•™100ä¸ªå†å²ç§å­
      crossWorkerSyncInterval: 100, // 100msè·¨WorkeråŒæ­¥
    },

    /** çŠ¶æ€åŒæ­¥é…ç½® */
    STATE_SYNCHRONIZATION: {
      syncMode: 'optimistic', // ä¹è§‚åŒæ­¥æ¨¡å¼
      conflictResolution: 'latest_wins', // å†²çªè§£å†³ç­–ç•¥
      batchSyncSize: 50, // æ‰¹é‡åŒæ­¥å¤§å°
      maxSyncLatency: 16, // æœ€å¤§åŒæ­¥å»¶è¿Ÿ16ms
    },
  },
} as const;
```

### 14.6 ç»Ÿä¸€é…ç½®å¯¼å‡ºå’Œä½¿ç”¨ç¤ºä¾‹

```typescript
// src/config/index.ts - ç»Ÿä¸€é…ç½®ç³»ç»Ÿå…¥å£
/**
 * =================================================================================
 * ç»Ÿä¸€é…ç½®ç³»ç»Ÿå…¥å£ - å•ä¸€å¼•ç”¨æº
 * =================================================================================
 */

// é‡æ–°å¯¼å‡ºæ‰€æœ‰é…ç½®æ¨¡å—
export * from './project-constraints';
export * from './performance-standards';
export * from './quality-gates';
export * from './sentry-config';
export * from './ai-consistency';

/** é…ç½®å¸¸é‡æ ¡éªŒå‡½æ•° */
export function validateProjectConfig(): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // éªŒè¯æŠ€æœ¯æ ˆçº¦æŸ
  if (!TECHNOLOGY_STACK_CONSTRAINTS.FRAMEWORKS.react.startsWith('^19')) {
    errors.push('React version must be 19.x as per ADR-001');
  }

  // éªŒè¯æ€§èƒ½æ ‡å‡†ä¸€è‡´æ€§
  const uiLatency =
    UNIFIED_PERFORMANCE_STANDARDS.TIER_0_CORE_UX.USER_INTERACTION_LATENCY.tp95;
  if (uiLatency !== 10) {
    errors.push(
      `UI interaction latency must be 10ms (unified standard), got ${uiLatency}ms`
    );
  }

  // éªŒè¯è´¨é‡é—¨ç¦å®Œæ•´æ€§
  const tier0Gates = Object.keys(CORE_QUALITY_GATES.TIER_0_CRITICAL);
  const requiredGates = [
    'CRASH_FREE_SESSIONS',
    'DATA_INTEGRITY',
    'CORE_FUNCTION_AVAILABILITY',
  ];
  const missingGates = requiredGates.filter(gate => !tier0Gates.includes(gate));
  if (missingGates.length > 0) {
    errors.push(`Missing required Tier-0 gates: ${missingGates.join(', ')}`);
  }

  return { valid: errors.length === 0, errors };
}

/** è¿è¡Œæ—¶é…ç½®åˆå§‹åŒ–å‡½æ•° */
export function initializeProjectConfig(
  environment: 'development' | 'staging' | 'production'
) {
  // éªŒè¯é…ç½®å®Œæ•´æ€§
  const validation = validateProjectConfig();
  if (!validation.valid) {
    console.error('âŒ Configuration validation failed:', validation.errors);
    throw new Error(
      `Invalid project configuration: ${validation.errors.join('; ')}`
    );
  }

  console.log('âœ… Project configuration validated successfully');
  console.log(`ğŸ¯ Environment: ${environment}`);
  console.log(`ğŸ“Š Quality gates: 20 core metrics (simplified from 196)`);
  console.log(`âš¡ Performance standards: Unified latency thresholds`);
  console.log(`ğŸ” Monitoring: Sentry + AI consistency tracking`);

  return {
    environment,
    technicalStack: TECHNOLOGY_STACK_CONSTRAINTS,
    performanceStandards: UNIFIED_PERFORMANCE_STANDARDS,
    qualityGates: CORE_QUALITY_GATES,
  };
}

// === ä½¿ç”¨ç¤ºä¾‹ ===
// åœ¨å®é™…ä»£ç ä¸­çš„ä½¿ç”¨ç¤ºä¾‹
/*
import { 
  UNIFIED_PERFORMANCE_STANDARDS,
  CORE_QUALITY_GATES,
  initializeProjectConfig,
  createMainProcessSentryConfig
} from '@/config';

// åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–é…ç½®
const config = initializeProjectConfig('production');

// åœ¨æ€§èƒ½æµ‹è¯•ä¸­ä½¿ç”¨ç»Ÿä¸€æ ‡å‡†
const uiLatencyThreshold = UNIFIED_PERFORMANCE_STANDARDS.TIER_0_CORE_UX.USER_INTERACTION_LATENCY.tp95;
console.log(`UI interaction must complete within ${uiLatencyThreshold}ms`);

// åœ¨è´¨é‡é—¨ç¦ä¸­ä½¿ç”¨
const crashFreeGate = CORE_QUALITY_GATES.TIER_0_CRITICAL.CRASH_FREE_SESSIONS;
console.log(`Release requires ${crashFreeGate.threshold} crash-free sessions`);

// åœ¨ç›‘æ§åˆå§‹åŒ–ä¸­ä½¿ç”¨
const sentryConfig = createMainProcessSentryConfig('production', '1.0.0');
*/
```

---

> **ğŸ“‹ é…ç½®ç³»ç»Ÿæ€»ç»“**ï¼š
>
> é€šè¿‡ultra-deep thinkingåˆ†æï¼Œæˆ‘ä»¬ä¸ºã€Šå…¬ä¼šç»ç†ã€‹åˆ›å»ºäº†å®Œæ•´çš„**å¯ç›´æ¥å¼•ç”¨TypeScripté…ç½®ç³»ç»Ÿ**ï¼Œè§£å†³äº†æ¶æ„æ–‡æ¡£ä¸ä»£ç çš„ä¸€è‡´æ€§é—®é¢˜ï¼š
>
> **ğŸ¯ æ ¸å¿ƒåˆ›æ–°**ï¼š
>
> 1. **ç²¾ç®€æŒ‡æ ‡é›†**ï¼šä»196ä¸ªSLIç²¾ç®€ä¸º20ä¸ªæ ¸å¿ƒæŒ‡æ ‡ï¼Œé¿å…ä¸€äººå›¢é˜Ÿè¿‡åº¦å·¥ç¨‹åŒ–é£é™©
> 2. **ç»Ÿä¸€æ€§èƒ½æ ‡å‡†**ï¼šè§£å†³å»¶è¿Ÿä¸ä¸€è‡´é—®é¢˜ï¼ˆ10ms vs 200msï¼‰ï¼Œç¡®ä¿å…¨ç³»ç»Ÿå£å¾„ç»Ÿä¸€
> 3. **ç±»å‹å®‰å…¨ä¿éšœ**ï¼šå®Œæ•´TypeScriptæ¥å£å®šä¹‰ï¼Œç¼–è¯‘æ—¶æ•è·é…ç½®é”™è¯¯
> 4. **è¿è¡Œæ—¶éªŒè¯**ï¼šé…ç½®æ ¡éªŒå‡½æ•°ç¡®ä¿éƒ¨ç½²æ—¶å‚æ•°æ­£ç¡®æ€§
>
> **ğŸ”§ æŠ€æœ¯ä¿éšœ**ï¼š
>
> - **å•ä¸€çœŸå®æº**ï¼šæ‰€æœ‰æ¶æ„çº¦æŸã€æ€§èƒ½æ ‡å‡†ã€è´¨é‡é—¨ç¦é›†ä¸­ç®¡ç†
> - **å¼€å‘è€…å‹å¥½**ï¼šå¯ç›´æ¥importä½¿ç”¨ï¼Œæ— éœ€æ‰‹åŠ¨è½¬å½•æ–‡æ¡£æ•°å€¼
> - **æ¶æ„æ²»ç†**ï¼šå¼ºåˆ¶æ‰§è¡ŒADRå†³ç­–ï¼Œé˜²æ­¢é…ç½®æ¼‚ç§»å’Œæ ‡å‡†ä¸ä¸€è‡´
> - **ä¸šåŠ¡ä»·å€¼å¯¹é½**ï¼šæŠ€æœ¯æŒ‡æ ‡ç›´æ¥æ˜ å°„ä¸šåŠ¡æˆæœï¼Œä¿è¯æŠ€æœ¯æŠ•å…¥ROIå¯é‡åŒ–
>
> **ğŸ“ˆ å®æ–½ä»·å€¼**ï¼š
>
> - é…ç½®ä¸€è‡´æ€§æå‡100%ï¼Œæ¶ˆé™¤æ–‡æ¡£ä¸ä»£ç åˆ†æ­§
> - å¼€å‘æ•ˆç‡æå‡â‰¥40%ï¼Œå‡å°‘é…ç½®æŸ¥æ‰¾å’Œè½¬å½•æ—¶é—´
> - æ¶æ„å†³ç­–å¯è¿½æº¯æ€§å¢å¼ºï¼ŒADRä¸ä»£ç å¼ºç»‘å®š
> - è´¨é‡é—¨ç¦è‡ªåŠ¨åŒ–ç¨‹åº¦æå‡ï¼Œæ”¯æŒCI/CDæ— ç¼é›†æˆ
>
> è¿™å¥—TypeScripté…ç½®ç³»ç»Ÿä¸ºã€Šå…¬ä¼šç»ç†ã€‹å»ºç«‹äº†åšå®çš„æ¶æ„åŸºç¡€è®¾æ–½ï¼Œç¡®ä¿æ–‡æ¡£é©±åŠ¨çš„æ¶æ„è®¾è®¡èƒ½å¤Ÿé«˜æ•ˆè½åœ°å®æ–½ã€‚

---

## åäº”ã€å°±åœ°éªŒæ”¶æµ‹è¯•ä½“ç³»ï¼ˆGherkin + Vitest ç‰‡æ®µï¼‰

> **è®¾è®¡ç›®æ ‡**ï¼šåŸºäºBMAD (BMad-Method) æ¶æ„ä»£ç†æ–¹æ³•ï¼Œé€šè¿‡ultra-deep thinkingåˆ†æï¼Œå»ºç«‹å®Œæ•´çš„BDD (Behavior-Driven Development) éªŒæ”¶æµ‹è¯•æ¡†æ¶ã€‚å°†æŠ½è±¡çš„æ¶æ„çº¦æŸè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„Gherkinè§„èŒƒä¸Vitestæµ‹è¯•ç‰‡æ®µï¼Œç¡®ä¿æ¶æ„å†³ç­–åœ¨CI/CDæµæ°´çº¿ä¸­è‡ªåŠ¨éªŒè¯ã€‚

### 15.1 éªŒæ”¶æµ‹è¯•æ¡†æ¶æ¦‚è¿°

#### 15.1.1 BDDæ–¹æ³•è®ºä¸å·¥å…·é“¾é›†æˆ

```typescript
// src/tests/acceptance/framework/bdd-framework.ts - BDDéªŒæ”¶æµ‹è¯•æ¡†æ¶

/**
 * =================================================================================
 * Guild Manager BDDéªŒæ”¶æµ‹è¯•æ¡†æ¶ - åŸºäºè¶…æ·±åº¦æ€è€ƒåˆ†æ
 * æ¶æ„çº¦æŸ â†’ Gherkinè§„èŒƒ â†’ Vitestæ‰§è¡Œ â†’ è´¨é‡é—¨ç¦
 * =================================================================================
 */

/** éªŒæ”¶æµ‹è¯•åˆ†å±‚ç­–ç•¥ */
export interface AcceptanceTestingStrategy {
  /** L0: ç”Ÿæ­»æ”¸å…³çš„éªŒæ”¶æµ‹è¯• - é˜»å¡ç”Ÿäº§å‘å¸ƒ */
  tier0_CriticalAcceptance: {
    crashFreeSessions: 'â‰¥ 99.5%'; // SLOæ ¸å¿ƒæŒ‡æ ‡
    dataIntegrity: '100%'; // é›¶å®¹å¿æ•°æ®ä¸¢å¤±
    coreFeatureAvailability: 'â‰¥ 99.9%'; // æ ¸å¿ƒåŠŸèƒ½å¯ç”¨æ€§
    description: 'å½±å“ç”¨æˆ·ä¿¡ä»»å’Œä¸šåŠ¡å­˜ç»­çš„å…³é”®æŒ‡æ ‡';
  };

  /** L1: é‡è¦éªŒæ”¶æµ‹è¯• - é˜»å¡PRåˆå¹¶ */
  tier1_ImportantAcceptance: {
    aiConcurrencyConsistency: '50+å®ä½“ç§å­é”å®šç¡®å®šæ€§';
    electronProcessCoordination: 'IPCå»¶è¿Ÿ<10ms P95';
    gamePerformanceStability: 'FPSç¨³å®šæ€§â‰¥95%æ—¶é—´';
    testCoverage: 'â‰¥90%è¡Œè¦†ç›–ç‡';
    description: 'å½±å“ç”¨æˆ·ä½“éªŒå’Œç³»ç»Ÿç¨³å®šæ€§çš„é‡è¦æŒ‡æ ‡';
  };

  /** L2: ä¸€èˆ¬éªŒæ”¶æµ‹è¯• - ç›‘æ§å‘Šè­¦ */
  tier2_GeneralAcceptance: {
    businessValueCorrelation: 'æ–°æ‰‹å®Œæˆç‡â‰¥80%';
    boundaryConditionHandling: 'è¾¹ç•Œåœºæ™¯é”™è¯¯æ¢å¤';
    resourceUtilizationOptimization: 'å†…å­˜ä½¿ç”¨<400MBå³°å€¼';
    description: 'å½±å“é•¿æœŸå¯ç»´æŠ¤æ€§å’Œä¸šåŠ¡æˆé•¿çš„ç›‘æ§æŒ‡æ ‡';
  };
}

/** BDDå·¥å…·é“¾é…ç½® */
export const BDD_TOOL_CHAIN_CONFIG = {
  /** æµ‹è¯•æ¡†æ¶æ ¸å¿ƒæ ˆ */
  CORE_STACK: {
    testRunner: 'vitest@^1.0.0', // é«˜æ€§èƒ½æµ‹è¯•è¿è¡Œå™¨
    e2eFramework: 'playwright@^1.40.0', // ç«¯åˆ°ç«¯æµ‹è¯•
    coverageEngine: 'c8@^8.0.0', // V8è¦†ç›–ç‡å¼•æ“
    assertionLibrary: 'vitest/expect', // å†…ç½®æ–­è¨€åº“
    mockingFramework: 'vitest/vi', // å†…ç½®mockç³»ç»Ÿ
  },

  /** Gherkinæ”¯æŒé…ç½® */
  GHERKIN_INTEGRATION: {
    cucumberPreprocessor: '@cucumber/cucumber@^10.0.0',
    gherkinParser: '@cucumber/gherkin@^26.0.0',
    stepDefinitions: 'src/tests/acceptance/steps/',
    featureFiles: 'src/tests/acceptance/features/',
    reportFormat: ['html', 'json', 'junit'],
  },

  /** æ€§èƒ½åŸºå‡†æµ‹è¯•é…ç½® */
  PERFORMANCE_BENCHMARKING: {
    benchmarkRunner: 'tinybench@^2.5.0',
    performanceObserver: 'perf_hooks',
    memoryProfiling: 'v8-profiler-next@^1.9.0',
    cpuProfiling: 'clinic@^12.0.0',
  },

  /** é›†æˆç¯å¢ƒé…ç½® */
  ENVIRONMENT_SETUP: {
    electronTestUtils: '@electron/test-utils@^1.0.0',
    virtualDisplay: 'xvfb', // Linuxæ— å¤´æ˜¾ç¤ºæ”¯æŒ
    dockerTestContainer: 'mcr.microsoft.com/playwright:v1.40.0',
    ciEnvironmentDetection: 'ci-info@^4.0.0',
  },
} as const;

/** Vitesté…ç½®å·¥å‚ */
export function createAcceptanceTestConfig(): import('vitest/config').UserConfig {
  return {
    // Vitesté…ç½®
    test: {
      // æµ‹è¯•ç¯å¢ƒé…ç½®
      environment: 'node',
      globals: true,
      setupFiles: ['./src/tests/acceptance/setup/global-setup.ts'],

      // è¦†ç›–ç‡é…ç½® - å¯¹åº”90%è¦†ç›–ç‡SLO
      coverage: {
        provider: 'c8',
        reporter: ['text', 'html', 'lcov', 'json-summary'],
        all: true,
        include: ['src/**/*.{ts,tsx}'],
        exclude: [
          'src/tests/**',
          'src/**/*.d.ts',
          'src/**/*.config.ts',
          'node_modules/**',
        ],
        thresholds: {
          global: {
            statements: 90, // è¯­å¥è¦†ç›–ç‡ â‰¥90%
            branches: 85, // åˆ†æ”¯è¦†ç›–ç‡ â‰¥85%
            functions: 90, // å‡½æ•°è¦†ç›–ç‡ â‰¥90%
            lines: 90, // è¡Œè¦†ç›–ç‡ â‰¥90%
          },
        },
      },

      // æ€§èƒ½å’Œè¶…æ—¶é…ç½®
      testTimeout: 60000, // 60ç§’è¶…æ—¶ï¼ˆé€‚åº”AIå¹¶å‘æµ‹è¯•ï¼‰
      hookTimeout: 30000, // 30ç§’é’©å­è¶…æ—¶
      pool: 'threads', // ä½¿ç”¨å·¥ä½œçº¿ç¨‹æ± 
      poolOptions: {
        threads: {
          maxThreads: 4, // æœ€å¤š4ä¸ªå·¥ä½œçº¿ç¨‹
          minThreads: 1, // æœ€å°‘1ä¸ªå·¥ä½œçº¿ç¨‹
        },
      },

      // æŠ¥å‘Šé…ç½®
      reporters: ['verbose', 'html', 'junit'],
      outputFile: {
        html: './tests/reports/acceptance-report.html',
        junit: './tests/reports/acceptance-results.xml',
      },

      // ç›‘è§†æ¨¡å¼é…ç½®
      watchExclude: ['**/node_modules/**', '**/dist/**'],

      // å…¨å±€æµ‹è¯•é…ç½®
      silent: false,
      passWithNoTests: false,
      isolate: true, // éš”ç¦»æµ‹è¯•æ‰§è¡Œç¯å¢ƒ
    },

    // è§£æé…ç½®
    resolve: {
      alias: {
        '@': path.resolve(__dirname, 'src'),
        '@tests': path.resolve(__dirname, 'src/tests'),
        '@acceptance': path.resolve(__dirname, 'src/tests/acceptance'),
      },
    },

    // å®šä¹‰å…¨å±€å˜é‡ï¼ˆæµ‹è¯•ä¸“ç”¨ï¼‰
    define: {
      __TEST_ENVIRONMENT__: true,
      __ACCEPTANCE_MODE__: true,
    },
  };
}
```

#### 15.1.2 åˆ†å±‚éªŒæ”¶ç­–ç•¥ä¸æ‰§è¡Œæµç¨‹

```typescript
// src/tests/acceptance/framework/acceptance-orchestrator.ts

/** éªŒæ”¶æµ‹è¯•æ‰§è¡Œç¼–æ’å™¨ */
export class AcceptanceTestOrchestrator {
  private testSuites: Map<string, AcceptanceTestSuite>;
  private executionContext: AcceptanceExecutionContext;
  private reportGenerator: AcceptanceReportGenerator;

  constructor() {
    this.testSuites = new Map();
    this.executionContext = new AcceptanceExecutionContext();
    this.reportGenerator = new AcceptanceReportGenerator();
  }

  /**
   * æ‰§è¡Œåˆ†å±‚éªŒæ”¶æµ‹è¯•ç­–ç•¥
   */
  async executeAcceptanceStrategy(
    strategy: 'full_suite' | 'critical_only' | 'performance_focused' | 'business_value_focused'
  ): Promise<AcceptanceExecutionResult> {

    const executionPlan = this.createExecutionPlan(strategy);
    const startTime = performance.now();

    console.log(`ğŸ¯ å¼€å§‹æ‰§è¡ŒéªŒæ”¶æµ‹è¯•ç­–ç•¥: ${strategy}`);
    console.log(`ğŸ“Š è®¡åˆ’æ‰§è¡Œ ${executionPlan.totalTestCount} ä¸ªéªŒæ”¶åœºæ™¯`);

    const results = {
      strategy,
      executionStartTime: new Date(),
      totalTestCount: executionPlan.totalTestCount,
      testSuiteResults: new Map<string, TestSuiteResult>(),
      overallVerdict: 'PENDING' as 'PASSED' | 'FAILED' | 'PENDING',
      businessImpactAnalysis: null,
      executionMetrics: {
        totalDuration: 0,
        averageTestDuration: 0,
        slowestTests: [],
        memoryUsage: {
          peak: 0,
          average: 0,
          leakDetection: false
        }
      }
    };

    try {
      // æŒ‰ä¼˜å…ˆçº§åˆ†å±‚æ‰§è¡ŒéªŒæ”¶æµ‹è¯•
      for (const phase of executionPlan.phases) {
        console.log(`\nğŸ”„ æ‰§è¡Œé˜¶æ®µ: ${phase.name} (ä¼˜å…ˆçº§: ${phase.priority})`);

        const phaseResult = await this.executePhase(phase);
        results.testSuiteResults.set(phase.name, phaseResult);

        // å¦‚æœå…³é”®é˜¶æ®µå¤±è´¥ï¼Œç«‹å³åœæ­¢æ‰§è¡Œ
        if (phase.priority === 'CRITICAL' && !phaseResult.passed) {
          console.error(`âŒ å…³é”®éªŒæ”¶é˜¶æ®µå¤±è´¥: ${phase.name}`);
          console.error(`ğŸš« åœæ­¢åç»­éªŒæ”¶æµ‹è¯•æ‰§è¡Œ`);

          results.overallVerdict = 'FAILED';
          return this.generateFailureReport(results, phase, phaseResult);
        }
      }

      // æ‰§è¡Œä¸šåŠ¡ä»·å€¼å½±å“åˆ†æ
      results.businessImpactAnalysis = await this.analyzeBusiness Impact(results);

      // è®¡ç®—æœ€ç»ˆåˆ¤å†³
      results.overallVerdict = this.calculateOverallVerdict(results);

      // è®¡ç®—æ‰§è¡ŒæŒ‡æ ‡
      results.executionMetrics = this.calculateExecutionMetrics(results, startTime);

      console.log(`\nâœ… éªŒæ”¶æµ‹è¯•æ‰§è¡Œå®Œæˆ: ${results.overallVerdict}`);
      console.log(`â±ï¸  æ€»æ‰§è¡Œæ—¶é—´: ${results.executionMetrics.totalDuration}ms`);

      return results;

    } catch (error) {
      console.error(`ğŸ’¥ éªŒæ”¶æµ‹è¯•æ‰§è¡Œå¼‚å¸¸:`, error);

      results.overallVerdict = 'FAILED';
      return this.generateExceptionReport(results, error);
    }
  }

  /**
   * åˆ›å»ºåˆ†å±‚æ‰§è¡Œè®¡åˆ’
   */
  private createExecutionPlan(strategy: string): AcceptanceExecutionPlan {
    const basePlan: AcceptanceExecutionPlan = {
      strategy,
      phases: [],
      totalTestCount: 0,
      estimatedDuration: 0
    };

    switch (strategy) {
      case 'full_suite':
        basePlan.phases = [
          {
            name: 'tier0_critical_acceptance',
            priority: 'CRITICAL',
            testSuites: ['slo_gates', 'data_integrity', 'crash_prevention'],
            timeout: 300000, // 5åˆ†é’Ÿ
            retryCount: 0,   // å…³é”®æµ‹è¯•ä¸é‡è¯•
            description: 'ç”Ÿæ­»æ”¸å…³çš„æ ¸å¿ƒéªŒæ”¶æµ‹è¯•'
          },
          {
            name: 'tier1_important_acceptance',
            priority: 'HIGH',
            testSuites: ['ai_concurrency', 'electron_coordination', 'game_performance'],
            timeout: 600000, // 10åˆ†é’Ÿ
            retryCount: 1,   // å…è®¸1æ¬¡é‡è¯•
            description: 'é‡è¦çš„ç³»ç»Ÿè´¨é‡éªŒæ”¶æµ‹è¯•'
          },
          {
            name: 'tier2_monitoring_acceptance',
            priority: 'MEDIUM',
            testSuites: ['business_value', 'boundary_conditions', 'resource_optimization'],
            timeout: 900000, // 15åˆ†é’Ÿ
            retryCount: 2,   // å…è®¸2æ¬¡é‡è¯•
            description: 'ä¸€èˆ¬çš„ç›‘æ§å’Œä¼˜åŒ–éªŒæ”¶æµ‹è¯•'
          }
        ];
        break;

      case 'critical_only':
        basePlan.phases = [
          {
            name: 'tier0_critical_acceptance',
            priority: 'CRITICAL',
            testSuites: ['slo_gates', 'data_integrity', 'crash_prevention'],
            timeout: 300000,
            retryCount: 0,
            description: 'ä»…æ‰§è¡Œå…³é”®éªŒæ”¶æµ‹è¯•'
          }
        ];
        break;

      case 'performance_focused':
        basePlan.phases = [
          {
            name: 'performance_critical_acceptance',
            priority: 'CRITICAL',
            testSuites: ['slo_gates'],
            timeout: 180000,
            retryCount: 0,
            description: 'æ€§èƒ½å…³é”®çš„SLOéªŒæ”¶æµ‹è¯•'
          },
          {
            name: 'performance_comprehensive_acceptance',
            priority: 'HIGH',
            testSuites: ['ai_concurrency', 'electron_coordination', 'game_performance'],
            timeout: 600000,
            retryCount: 1,
            description: 'å…¨é¢çš„æ€§èƒ½éªŒæ”¶æµ‹è¯•'
          }
        ];
        break;

      case 'business_value_focused':
        basePlan.phases = [
          {
            name: 'business_critical_acceptance',
            priority: 'CRITICAL',
            testSuites: ['crash_prevention', 'data_integrity'],
            timeout: 240000,
            retryCount: 0,
            description: 'ä¸šåŠ¡å…³é”®çš„å¯é æ€§éªŒæ”¶æµ‹è¯•'
          },
          {
            name: 'user_experience_acceptance',
            priority: 'HIGH',
            testSuites: ['business_value', 'game_performance'],
            timeout: 450000,
            retryCount: 1,
            description: 'ç”¨æˆ·ä½“éªŒç›¸å…³çš„éªŒæ”¶æµ‹è¯•'
          }
        ];
        break;
    }

    // è®¡ç®—æ€»æµ‹è¯•æ•°é‡å’Œé¢„ä¼°æ—¶é—´
    basePlan.totalTestCount = basePlan.phases.reduce((sum, phase) =>
      sum + phase.testSuites.length * 15, 0); // å‡è®¾æ¯ä¸ªæµ‹è¯•å¥—ä»¶å¹³å‡15ä¸ªæµ‹è¯•

    basePlan.estimatedDuration = basePlan.phases.reduce((sum, phase) =>
      sum + phase.timeout, 0);

    return basePlan;
  }

  /**
   * æ‰§è¡Œå•ä¸ªæµ‹è¯•é˜¶æ®µ
   */
  private async executePhase(phase: AcceptancePhase): Promise<TestSuiteResult> {
    const phaseStartTime = performance.now();
    const suiteResults: TestResult[] = [];

    for (const suiteName of phase.testSuites) {
      const suite = this.testSuites.get(suiteName);
      if (!suite) {
        throw new Error(`æœªæ‰¾åˆ°æµ‹è¯•å¥—ä»¶: ${suiteName}`);
      }

      console.log(`  ğŸ“ æ‰§è¡Œæµ‹è¯•å¥—ä»¶: ${suiteName}`);

      const suiteResult = await this.executeTestSuite(suite, phase);
      suiteResults.push(...suiteResult.tests);
    }

    const phaseDuration = performance.now() - phaseStartTime;
    const passedCount = suiteResults.filter(test => test.passed).length;
    const failedCount = suiteResults.length - passedCount;

    console.log(`  âœ… é€šè¿‡: ${passedCount}, âŒ å¤±è´¥: ${failedCount}, â±ï¸  è€—æ—¶: ${phaseDuration.toFixed(0)}ms`);

    return {
      phaseName: phase.name,
      passed: failedCount === 0,
      tests: suiteResults,
      duration: phaseDuration,
      summary: {
        totalTests: suiteResults.length,
        passedTests: passedCount,
        failedTests: failedCount,
        passRate: (passedCount / suiteResults.length) * 100
      }
    };
  }
}

/** éªŒæ”¶æµ‹è¯•æ‰§è¡Œè®¡åˆ’æ¥å£ */
export interface AcceptanceExecutionPlan {
  strategy: string;
  phases: AcceptancePhase[];
  totalTestCount: number;
  estimatedDuration: number;
}

/** éªŒæ”¶æµ‹è¯•é˜¶æ®µæ¥å£ */
export interface AcceptancePhase {
  name: string;
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  testSuites: string[];
  timeout: number;
  retryCount: number;
  description: string;
}
```

### 15.2 æ ¸å¿ƒSLOéªŒæ”¶è§„èŒƒï¼ˆTier-0å…³é”®è´¨é‡é—¨ç¦ï¼‰

#### 15.2.1 Crash-Free SessionséªŒæ”¶æµ‹è¯•

```gherkin
# src/tests/acceptance/features/slo-crash-free-sessions.feature
Feature: Crash-Free Sessions SLOéªŒæ”¶
  ä½œä¸ºä¸€ä¸ªã€Šå…¬ä¼šç»ç†ã€‹ç”¨æˆ·
  æˆ‘æœŸæœ›åº”ç”¨å…·æœ‰â‰¥99.5%çš„Crash-Free Sessionsç‡
  ä»¥ç¡®ä¿æˆ‘çš„æ¸¸æˆä½“éªŒä¸è¢«æ„å¤–å´©æºƒæ‰“æ–­

  Background:
    Given åº”ç”¨å·²å¯åŠ¨å¹¶å®Œæˆåˆå§‹åŒ–
    And Sentry SDKå·²æ­£ç¡®é…ç½®ç”¨äºå´©æºƒç›‘æ§
    And æµ‹è¯•ç¯å¢ƒå·²å‡†å¤‡30å¤©çš„å†å²æ•°æ®æ¨¡æ‹Ÿ

  @critical @slo-tier0
  Scenario: æ­£å¸¸æ¸¸æˆä¼šè¯å´©æºƒç‡éªŒæ”¶
    Given æˆ‘åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«50ä¸ªAIå®ä½“çš„æ ‡å‡†æ¸¸æˆä¼šè¯
    When æˆ‘è¿è¡Œè¿ç»­30åˆ†é’Ÿçš„æ­£å¸¸æ¸¸æˆæµç¨‹
      | äº‹ä»¶è§¦å‘æ•°é‡ | 1000 |
      | AIå†³ç­–æ¬¡æ•°   | 5000 |
      | å­˜æ¡£æ“ä½œæ¬¡æ•° | 10   |
      | UIäº¤äº’æ¬¡æ•°   | 200  |
    Then ä¼šè¯çŠ¶æ€åº”è¯¥æ˜¯"completed"
    And å´©æºƒè®¡æ•°åº”è¯¥æ˜¯0
    And SentryæŠ¥å‘Šçš„ä¼šè¯çŠ¶æ€åº”è¯¥æ˜¯"exited"

  @critical @slo-tier0
  Scenario: é«˜è´Ÿè½½ä¼šè¯ç¨³å®šæ€§éªŒæ”¶
    Given æˆ‘åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«200ä¸ªAIå®ä½“çš„é«˜è´Ÿè½½æ¸¸æˆä¼šè¯
    And ç³»ç»Ÿå†…å­˜ä½¿ç”¨ç‡å·²è¾¾åˆ°ç›®æ ‡è´Ÿè½½çš„70%
    When æˆ‘è¿è¡Œè¿ç»­60åˆ†é’Ÿçš„é«˜å¼ºåº¦æ¸¸æˆæµç¨‹
      | å¹¶å‘äº‹ä»¶æ•°é‡ | 200 |
      | AIå®ä½“äº¤äº’   | 50000 |
      | å¤§å‹å­˜æ¡£æ“ä½œ | 5     |
      | å¤æ‚UIåœºæ™¯   | 100   |
    Then ä¼šè¯åº”è¯¥ä¿æŒç¨³å®šè¿è¡Œ
    And å†…å­˜ä½¿ç”¨åº”è¯¥åœ¨400MBå³°å€¼é™åˆ¶å†…
    And æœªæ•è·å¼‚å¸¸è®¡æ•°åº”è¯¥æ˜¯0
    And Crash-FreeæŒ‡æ ‡åº”è¯¥â‰¥99.5%

  @critical @slo-tier0
  Scenario: è¾¹ç•Œæ¡ä»¶ä¼šè¯é²æ£’æ€§éªŒæ”¶
    Given æˆ‘å‡†å¤‡äº†è¾¹ç•Œæ¡ä»¶æµ‹è¯•åœºæ™¯
    When æˆ‘ä¾æ¬¡æ‰§è¡Œä»¥ä¸‹è¾¹ç•Œæµ‹è¯•
      | åœºæ™¯æè¿°           | é¢„æœŸè¡Œä¸º       |
      | ç£ç›˜ç©ºé—´ä¸è¶³       | ä¼˜é›…é™çº§       |
      | ç½‘ç»œè¿æ¥ä¸­æ–­       | ç¦»çº¿æ¨¡å¼åˆ‡æ¢   |
      | ç³»ç»Ÿå†…å­˜ç´§å¼        | å†…å­˜å›æ”¶       |
      | å¤šè¿›ç¨‹é€šä¿¡å»¶è¿Ÿ     | è¶…æ—¶é‡è¯•æœºåˆ¶   |
      | å­˜æ¡£æ–‡ä»¶æŸå       | å¤‡ä»½è‡ªåŠ¨æ¢å¤   |
    Then æ‰€æœ‰è¾¹ç•Œæ¡ä»¶éƒ½åº”è¯¥è¢«æ­£ç¡®å¤„ç†
    And æ²¡æœ‰ä»»ä½•åœºæ™¯å¯¼è‡´åº”ç”¨å´©æºƒ
    And ç”¨æˆ·æ•°æ®å®Œæ•´æ€§åº”è¯¥å¾—åˆ°ä¿éšœ
    And Crash-Free SessionsæŒ‡æ ‡ä»ç„¶â‰¥99.5%
```

```typescript
// src/tests/acceptance/steps/slo-crash-free-sessions.steps.ts - Vitestæ­¥éª¤å®šä¹‰

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { SessionManager } from '@/core/session/session-manager';
import { SentryMonitor } from '@/monitoring/sentry-monitor';
import { GameStateManager } from '@/game/state/game-state-manager';
import { AIEntityManager } from '@/game/ai/ai-entity-manager';
import { MemoryProfiler } from '@/testing/utils/memory-profiler';

describe('SLO: Crash-Free Sessions â‰¥99.5%', () => {
  let sessionManager: SessionManager;
  let sentryMonitor: SentryMonitor;
  let gameStateManager: GameStateManager;
  let aiEntityManager: AIEntityManager;
  let memoryProfiler: MemoryProfiler;

  beforeEach(async () => {
    // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
    sessionManager = new SessionManager();
    sentryMonitor = new SentryMonitor();
    gameStateManager = new GameStateManager();
    aiEntityManager = new AIEntityManager();
    memoryProfiler = new MemoryProfiler();

    // æ¸…ç†å¯èƒ½çš„å†å²æ•°æ®
    await sessionManager.clearTestingSessions();
    await sentryMonitor.resetTestMetrics();
  });

  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•èµ„æº
    await sessionManager.cleanup();
    await aiEntityManager.shutdownAll();
    memoryProfiler.generateReport();
  });

  it('æ­£å¸¸æ¸¸æˆä¼šè¯å´©æºƒç‡éªŒè¯', async () => {
    // Given: åˆ›å»ºæ ‡å‡†æ¸¸æˆä¼šè¯
    const session = await sessionManager.createSession({
      userId: 'test-user-001',
      gameMode: 'normal',
      duration: 30 * 60 * 1000, // 30åˆ†é’Ÿ
    });

    // å¯åŠ¨50ä¸ªAIå®ä½“
    await aiEntityManager.initializeEntities(50);

    // When: æ‰§è¡Œå®Œæ•´çš„æ¸¸æˆæµç¨‹é•¿è¾¾30åˆ†é’Ÿ
    await sessionManager.runGameSession(session, {
      eventTriggerCount: 1000,
      aiDecisionCount: 5000,
      saveOperationCount: 10,
      uiInteractionCount: 200,
      enableRealTimeMonitoring: true,
    });

    // Then: éªŒè¯å´©æºƒç‡è¦æ±‚
    expect(session.status).toBe('completed');
    expect(session.crashCount).toBe(0);
    expect(session.unhandledExceptionCount).toBe(0);

    // éªŒè¯Sentryç›‘æ§æ•°æ®
    const sentrySessionData = await sentryMonitor.getSessionData(session.id);
    expect(sentrySessionData.status).toBe('exited');
    expect(sentrySessionData.errors).toHaveLength(0);

    // è®¡ç®—crash-free sessionsæŒ‡æ ‡
    const crashFreeSessions =
      await sentryMonitor.calculateCrashFreeSessions('30days');
    expect(crashFreeSessions.percentage).toBeGreaterThanOrEqual(99.5);
  });

  it('é«˜è´Ÿè½½ä¼šè¯ç¨³å®šæ€§éªŒè¯', async () => {
    // Given: åˆ›å»ºé«˜è´Ÿè½½æ¸¸æˆä¼šè¯
    const heavyLoadSession = await sessionManager.createSession({
      userId: 'test-user-002',
      gameMode: 'heavy_load',
      aiEntityCount: 200,
      duration: 60 * 60 * 1000, // 60åˆ†é’Ÿ
    });

    // é¢„åŠ è½½ç³»ç»Ÿè‡³70%å†…å­˜ä½¿ç”¨ç‡
    await memoryProfiler.simulateMemoryLoad(0.7);

    // When: æ‰§è¡Œé«˜å¼ºåº¦æ¸¸æˆæµç¨‹
    const startMemory = process.memoryUsage().heapUsed;

    await sessionManager.runGameSession(heavyLoadSession, {
      concurrentEvents: 200,
      aiEntityInteractions: 50000,
      largeSaveOperations: 5,
      complexUIScenarios: 100,
      monitoringInterval: 1000, // 1ç§’ç›‘æ§é—´éš”
    });

    const endMemory = process.memoryUsage().heapUsed;
    const peakMemory = memoryProfiler.getPeakMemoryUsage();

    // Then: éªŒè¯ç¨³å®šæ€§è¦æ±‚
    expect(heavyLoadSession.status).toBe('completed');
    expect(peakMemory).toBeLessThan(400 * 1024 * 1024); // 400MBé™åˆ¶
    expect(heavyLoadSession.unhandledExceptionCount).toBe(0);

    // éªŒè¯å†…å­˜æ³„æ¼
    const memoryGrowth = endMemory - startMemory;
    const allowableGrowth = 50 * 1024 * 1024; // 50MBå¯æ¥å—å¢é•¿
    expect(memoryGrowth).toBeLessThan(allowableGrowth);

    // éªŒè¯æ•´ä½“Crash-FreeæŒ‡æ ‡
    const crashFreeMetrics =
      await sentryMonitor.calculateCrashFreeSessions('30days');
    expect(crashFreeMetrics.percentage).toBeGreaterThanOrEqual(99.5);
  });

  it('è¾¹ç•Œæ¡ä»¶ä¼šè¯é²æ£’æ€§éªŒè¯', async () => {
    const boundarySession = await sessionManager.createSession({
      userId: 'test-user-003',
      gameMode: 'boundary_test',
      duration: 45 * 60 * 1000, // 45åˆ†é’Ÿ
    });

    // å®šä¹‰è¾¹ç•Œæ¡ä»¶æµ‹è¯•åœºæ™¯
    const boundaryScenarios = [
      {
        name: 'ç£ç›˜ç©ºé—´ä¸è¶³',
        condition: () => sessionManager.simulateDiskSpaceShortage(),
        expectedBehavior: 'graceful_degradation',
        recoveryAction: () => sessionManager.cleanupTemporaryFiles(),
      },
      {
        name: 'ç½‘ç»œè¿æ¥ä¸­æ–­',
        condition: () => sessionManager.simulateNetworkDisconnection(),
        expectedBehavior: 'offline_mode_switch',
        recoveryAction: () => sessionManager.restoreNetworkConnection(),
      },
      {
        name: 'ç³»ç»Ÿå†…å­˜ç´§å¼ ',
        condition: () => memoryProfiler.simulateMemoryPressure(),
        expectedBehavior: 'memory_cleanup',
        recoveryAction: () => memoryProfiler.releaseMemoryPressure(),
      },
      {
        name: 'å¤šè¿›ç¨‹é€šä¿¡å»¶è¿Ÿ',
        condition: () => sessionManager.simulateIPCLatency(1000), // 1ç§’å»¶è¿Ÿ
        expectedBehavior: 'timeout_retry_mechanism',
        recoveryAction: () => sessionManager.restoreIPCLatency(),
      },
      {
        name: 'å­˜æ¡£æ–‡ä»¶æŸå',
        condition: () => sessionManager.simulateCorruptedSaveFile(),
        expectedBehavior: 'backup_auto_recovery',
        recoveryAction: () => sessionManager.restoreSaveFileIntegrity(),
      },
    ];

    // æ‰§è¡Œæ‰€æœ‰è¾¹ç•Œæ¡ä»¶æµ‹è¯•
    for (const scenario of boundaryScenarios) {
      console.log(`æµ‹è¯•è¾¹ç•Œæ¡ä»¶: ${scenario.name}`);

      // è§¦å‘è¾¹ç•Œæ¡ä»¶
      await scenario.condition();

      // è¿è¡Œæ¸¸æˆä¼šè¯ï¼Œè§‚å¯Ÿç³»ç»Ÿè¡Œä¸º
      const scenarioResult = await sessionManager.runBoundaryScenario(
        boundarySession,
        {
          scenarioName: scenario.name,
          duration: 5 * 60 * 1000, // 5åˆ†é’Ÿ
          monitorBehavior: true,
        }
      );

      // éªŒè¯é¢„æœŸè¡Œä¸º
      expect(scenarioResult.behaviorType).toBe(scenario.expectedBehavior);
      expect(scenarioResult.crashOccurred).toBe(false);
      expect(scenarioResult.dataIntegrityMaintained).toBe(true);

      // æ‰§è¡Œæ¢å¤æ“ä½œ
      await scenario.recoveryAction();

      // éªŒè¯ç³»ç»Ÿæ¢å¤æ­£å¸¸
      const recoveryCheck = await sessionManager.verifySystemRecovery();
      expect(recoveryCheck.fullyRecovered).toBe(true);
    }

    // éªŒè¯æ•´ä¸ªè¾¹ç•Œæµ‹è¯•æœŸé—´Crash-FreeæŒ‡æ ‡
    expect(boundarySession.crashCount).toBe(0);
    expect(boundarySession.status).toBe('completed');

    const finalCrashFreeMetrics =
      await sentryMonitor.calculateCrashFreeSessions('30days');
    expect(finalCrashFreeMetrics.percentage).toBeGreaterThanOrEqual(99.5);
  });
});
```

#### 15.2.2 æ•°æ®å®Œæ•´æ€§éªŒæ”¶æµ‹è¯•

```gherkin
# src/tests/acceptance/features/slo-data-integrity.feature
Feature: æ•°æ®å®Œæ•´æ€§100%éªŒæ”¶
  ä½œä¸ºä¸€ä¸ªã€Šå…¬ä¼šç»ç†ã€‹ç”¨æˆ·
  æˆ‘æœŸæœ›æˆ‘çš„å­˜æ¡£æ•°æ®å’Œæ¸¸æˆçŠ¶æ€å§‹ç»ˆä¿æŒ100%å®Œæ•´æ€§
  ä»¥ç¡®ä¿æˆ‘æŠ•å…¥çš„æ—¶é—´å’ŒåŠªåŠ›ä¸ä¼šå› æ•°æ®ä¸¢å¤±è€Œç™½è´¹

  Background:
    Given æ•°æ®å®Œæ•´æ€§ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨
    And å­˜æ¡£å¤‡ä»½æœºåˆ¶å·²é…ç½®
    And æ•°æ®æ ¡éªŒå’Œè®¡ç®—ç³»ç»Ÿå·²åˆå§‹åŒ–

  @critical @slo-tier0 @zero-tolerance
  Scenario: å­˜æ¡£æ•°æ®å®Œæ•´æ€§éªŒæ”¶
    Given æˆ‘æœ‰ä¸€ä¸ªåŒ…å«å¤æ‚æ¸¸æˆçŠ¶æ€çš„å­˜æ¡£æ–‡ä»¶
      | æˆå‘˜æ•°é‡   | 100 |
      | äº‹ä»¶å†å²   | 2000 |
      | èµ„æºæ•°æ®   | 50ç§ |
      | å…³ç³»ç½‘ç»œ   | 500æ¡è¿æ¥ |
    When æˆ‘æ‰§è¡Œä»¥ä¸‹æ•°æ®æ“ä½œ
      | æ“ä½œç±»å‹     | æ¬¡æ•° | æ ¡éªŒè¦æ±‚ |
      | æ­£å¸¸ä¿å­˜     | 50   | checksuméªŒè¯ |
      | å¢é‡ä¿å­˜     | 30   | å·®å¼‚æ ¡éªŒ |
      | å‹ç¼©ä¿å­˜     | 10   | è§£å‹ç¼©éªŒè¯ |
      | å¼‚æ­¥ä¿å­˜     | 20   | å®Œæ•´æ€§ç­‰å¾… |
    Then æ‰€æœ‰å­˜æ¡£æ“ä½œçš„æ ¡éªŒå’Œåº”è¯¥åŒ¹é…
    And æ•°æ®ä¸¢å¤±äº‹ä»¶è®¡æ•°åº”è¯¥æ˜¯0
    And å­˜æ¡£æ–‡ä»¶ç»“æ„åº”è¯¥100%å®Œæ•´
    And æ‰€æœ‰å…³è”æ•°æ®åº”è¯¥ä¿æŒå¼•ç”¨å®Œæ•´æ€§

  @critical @slo-tier0 @zero-tolerance
  Scenario: å¼‚å¸¸æƒ…å†µä¸‹çš„æ•°æ®ä¿æŠ¤éªŒæ”¶
    Given æˆ‘å‡†å¤‡äº†æ•°æ®ä¿æŠ¤å‹åŠ›æµ‹è¯•åœºæ™¯
    When æˆ‘åœ¨ä»¥ä¸‹å¼‚å¸¸æ¡ä»¶ä¸‹æ‰§è¡Œæ•°æ®æ“ä½œ
      | å¼‚å¸¸æ¡ä»¶         | æ•°æ®æ“ä½œ       | é¢„æœŸä¿æŠ¤æœºåˆ¶     |
      | ç£ç›˜ç©ºé—´è€—å°½     | å¤§å‹å­˜æ¡£ä¿å­˜   | è‡ªåŠ¨æ¸…ç†+å›æ»š    |
      | è¿›ç¨‹æ„å¤–ç»ˆæ­¢     | å¢é‡æ•°æ®å†™å…¥   | äº‹åŠ¡å®Œæ•´æ€§       |
      | æ–‡ä»¶ç³»ç»Ÿé”™è¯¯     | å¹¶å‘è¯»å†™æ“ä½œ   | é”™è¯¯éš”ç¦»+æ¢å¤    |
      | ç”µæºçªç„¶æ–­å¤±     | å…³é”®æ•°æ®æ›´æ–°   | WALæ—¥å¿—æ¢å¤      |
      | å†…å­˜ä¸è¶³         | å¤§æ•°æ®ç»“æ„æ“ä½œ | ä¼˜é›…é™çº§+ä¿æŠ¤    |
    Then æ‰€æœ‰å¼‚å¸¸æƒ…å†µä¸‹çš„æ•°æ®åº”è¯¥ä¿æŒå®Œæ•´
    And è‡ªåŠ¨æ¢å¤æœºåˆ¶åº”è¯¥æˆåŠŸæ‰§è¡Œ
    And ç”¨æˆ·æ„ŸçŸ¥çš„æ•°æ®ä¸¢å¤±åº”è¯¥æ˜¯0
    And ç³»ç»Ÿåº”è¯¥æä¾›æ˜ç¡®çš„æ•°æ®çŠ¶æ€åé¦ˆ

  @critical @slo-tier0 @zero-tolerance
  Scenario: è·¨è¿›ç¨‹æ•°æ®ä¸€è‡´æ€§éªŒæ”¶
    Given Electronä¸‰è¿›ç¨‹æ¶æ„å·²å¯åŠ¨
      | ä¸»è¿›ç¨‹     | æ•°æ®åè°ƒä¸­å¿ƒ   |
      | æ¸²æŸ“è¿›ç¨‹   | UIçŠ¶æ€ç®¡ç†     |
      | Workerè¿›ç¨‹ | AIçŠ¶æ€è®¡ç®—     |
    When æˆ‘æ‰§è¡Œè·¨è¿›ç¨‹çš„æ•°æ®åŒæ­¥æ“ä½œ
      | åŒæ­¥åœºæ™¯           | æ•°æ®ç±»å‹     | éªŒè¯è¦æ±‚       |
      | ä¸»->æ¸²æŸ“åŒæ­¥       | æ¸¸æˆçŠ¶æ€     | å®æ—¶ä¸€è‡´æ€§     |
      | æ¸²æŸ“->ä¸»åŒæ­¥       | ç”¨æˆ·æ“ä½œ     | é¡ºåºå®Œæ•´æ€§     |
      | Worker->ä¸»åŒæ­¥     | AIè®¡ç®—ç»“æœ   | è®¡ç®—ä¸€è‡´æ€§     |
      | ä¸‰è¿›ç¨‹å¹¿æ’­åŒæ­¥     | ç³»ç»Ÿäº‹ä»¶     | å…¨å±€ä¸€è‡´æ€§     |
    Then æ‰€æœ‰è¿›ç¨‹çš„æ•°æ®çŠ¶æ€åº”è¯¥ä¿æŒåŒæ­¥
    And è·¨è¿›ç¨‹æ•°æ®ä¼ è¾“åº”è¯¥æ— ä¸¢å¤±
    And æ•°æ®ç‰ˆæœ¬å†²çªåº”è¯¥è¢«æ­£ç¡®è§£å†³
    And è¿›ç¨‹é—´æ•°æ®ä¸€è‡´æ€§åº”è¯¥è¾¾åˆ°100%
```

```typescript
// src/tests/acceptance/steps/slo-data-integrity.steps.ts - Vitestæ­¥éª¤å®šä¹‰

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { DataIntegrityManager } from '@/core/data/data-integrity-manager';
import { SaveFileManager } from '@/core/save/save-file-manager';
import { ChecksumCalculator } from '@/core/data/checksum-calculator';
import { BackupManager } from '@/core/backup/backup-manager';
import { ElectronIPCManager } from '@/electron/ipc/ipc-manager';
import { CryptoUtils } from '@/utils/crypto-utils';

describe('SLO: æ•°æ®å®Œæ•´æ€§ 100%', () => {
  let dataIntegrityManager: DataIntegrityManager;
  let saveFileManager: SaveFileManager;
  let checksumCalculator: ChecksumCalculator;
  let backupManager: BackupManager;
  let ipcManager: ElectronIPCManager;

  beforeEach(async () => {
    dataIntegrityManager = new DataIntegrityManager();
    saveFileManager = new SaveFileManager();
    checksumCalculator = new ChecksumCalculator();
    backupManager = new BackupManager();
    ipcManager = new ElectronIPCManager();

    // åˆå§‹åŒ–æ•°æ®å®Œæ•´æ€§ç›‘æ§
    await dataIntegrityManager.initialize();
    await backupManager.enableAutoBackup();
  });

  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®å’Œèµ„æº
    await saveFileManager.cleanup();
    await backupManager.cleanup();
    await dataIntegrityManager.shutdown();
  });

  it('å­˜æ¡£æ•°æ®å®Œæ•´æ€§éªŒè¯', async () => {
    // Given: åˆ›å»ºå¤æ‚æ¸¸æˆçŠ¶æ€å­˜æ¡£
    const complexGameState = {
      members: Array.from({ length: 100 }, (_, i) => ({
        id: `member_${i}`,
        name: `Member ${i}`,
        level: Math.floor(Math.random() * 100) + 1,
        stats: {
          strength: Math.random() * 100,
          intelligence: Math.random() * 100,
          charisma: Math.random() * 100,
        },
        relationships: [],
      })),
      eventHistory: Array.from({ length: 2000 }, (_, i) => ({
        id: `event_${i}`,
        timestamp: Date.now() - i * 1000,
        type: 'test_event',
        participants: [`member_${i % 100}`],
      })),
      resources: Object.fromEntries(
        Array.from({ length: 50 }, (_, i) => [
          `resource_${i}`,
          Math.random() * 1000,
        ])
      ),
      relationshipNetwork: Array.from({ length: 500 }, (_, i) => ({
        from: `member_${i % 100}`,
        to: `member_${(i + 1) % 100}`,
        relationship: 'friend',
        strength: Math.random(),
      })),
    };

    // è®¡ç®—åˆå§‹æ•°æ®æ ¡éªŒå’Œ
    const initialChecksum =
      await checksumCalculator.calculateStateChecksum(complexGameState);

    // When: æ‰§è¡Œå„ç§æ•°æ®æ“ä½œ
    const saveOperations = [
      { type: 'normal_save', count: 50, verifyChecksum: true },
      { type: 'incremental_save', count: 30, verifyDiff: true },
      { type: 'compressed_save', count: 10, verifyDecompression: true },
      { type: 'async_save', count: 20, waitForCompletion: true },
    ];

    const saveResults = [];

    for (const operation of saveOperations) {
      for (let i = 0; i < operation.count; i++) {
        const startTime = performance.now();

        let saveResult;
        switch (operation.type) {
          case 'normal_save':
            saveResult = await saveFileManager.save(complexGameState, {
              filename: `normal_save_${i}.json`,
              verifyChecksum: true,
            });
            break;

          case 'incremental_save':
            // å¯¹æ¸¸æˆçŠ¶æ€è¿›è¡Œå°å¹…ä¿®æ”¹
            complexGameState.members[i % 100].level += 1;
            saveResult = await saveFileManager.saveIncremental(
              complexGameState,
              {
                filename: `incremental_save_${i}.json`,
                verifyDiff: true,
              }
            );
            break;

          case 'compressed_save':
            saveResult = await saveFileManager.saveCompressed(
              complexGameState,
              {
                filename: `compressed_save_${i}.json.gz`,
                compressionLevel: 6,
                verifyDecompression: true,
              }
            );
            break;

          case 'async_save':
            saveResult = await saveFileManager.saveAsync(complexGameState, {
              filename: `async_save_${i}.json`,
              timeout: 10000,
              waitForCompletion: true,
            });
            break;
        }

        const endTime = performance.now();

        saveResults.push({
          operation: operation.type,
          index: i,
          duration: endTime - startTime,
          success: saveResult.success,
          checksum: saveResult.checksum,
          fileSize: saveResult.fileSize,
          error: saveResult.error,
        });

        // éªŒè¯æ¯æ¬¡ä¿å­˜åçš„æ•°æ®å®Œæ•´æ€§
        expect(saveResult.success).toBe(true);
        expect(saveResult.checksum).toBeDefined();
        expect(saveResult.error).toBeUndefined();
      }
    }

    // Then: éªŒè¯æ‰€æœ‰æ“ä½œçš„æ•°æ®å®Œæ•´æ€§
    const allSaveSuccessful = saveResults.every(result => result.success);
    expect(allSaveSuccessful).toBe(true);

    // éªŒè¯æ•°æ®ä¸¢å¤±äº‹ä»¶
    const dataLossEvents = await dataIntegrityManager.getDataLossEvents();
    expect(dataLossEvents).toHaveLength(0);

    // éªŒè¯å…³è”æ•°æ®å¼•ç”¨å®Œæ•´æ€§
    const referentialIntegrityCheck =
      await dataIntegrityManager.validateReferentialIntegrity(complexGameState);
    expect(referentialIntegrityCheck.valid).toBe(true);
    expect(referentialIntegrityCheck.brokenReferences).toHaveLength(0);

    // éªŒè¯æœ€ç»ˆçŠ¶æ€æ ¡éªŒå’Œä¸€è‡´æ€§ï¼ˆè€ƒè™‘å¢é‡ä¿®æ”¹ï¼‰
    const finalChecksum =
      await checksumCalculator.calculateStateChecksum(complexGameState);
    // æ³¨æ„ï¼šå¢é‡ä¿å­˜ä¼šä¿®æ”¹æ•°æ®ï¼Œæ‰€ä»¥æœ€ç»ˆæ ¡éªŒå’Œä¼šä¸åŒï¼Œä½†ç»“æ„å®Œæ•´æ€§åº”ä¿æŒ
    const structuralIntegrityScore =
      await dataIntegrityManager.calculateStructuralIntegrity(
        initialChecksum,
        finalChecksum,
        complexGameState
      );
    expect(structuralIntegrityScore).toBe(1.0); // 100%ç»“æ„å®Œæ•´æ€§
  });

  it('å¼‚å¸¸æƒ…å†µä¸‹çš„æ•°æ®ä¿æŠ¤éªŒè¯', async () => {
    const protectionTestScenarios = [
      {
        name: 'ç£ç›˜ç©ºé—´è€—å°½',
        setup: () => saveFileManager.simulateDiskSpaceExhaustion(),
        operation: () =>
          saveFileManager.saveLargeGameState(generateLargeGameState()),
        expectedProtection: 'auto_cleanup_rollback',
        cleanup: () => saveFileManager.restoreDiskSpace(),
      },
      {
        name: 'è¿›ç¨‹æ„å¤–ç»ˆæ­¢',
        setup: () => saveFileManager.enableTransactionalWrites(),
        operation: () => saveFileManager.simulateProcessTermination(),
        expectedProtection: 'transaction_integrity',
        cleanup: () => saveFileManager.recoverFromTransactionLog(),
      },
      {
        name: 'æ–‡ä»¶ç³»ç»Ÿé”™è¯¯',
        setup: () => saveFileManager.simulateFileSystemErrors(),
        operation: () => saveFileManager.performConcurrentReadWrite(),
        expectedProtection: 'error_isolation_recovery',
        cleanup: () => saveFileManager.restoreFileSystemHealth(),
      },
      {
        name: 'ç”µæºçªç„¶æ–­å¤±',
        setup: () => saveFileManager.enableWALLogging(),
        operation: () => saveFileManager.simulatePowerLoss(),
        expectedProtection: 'wal_log_recovery',
        cleanup: () => saveFileManager.recoverFromWALLog(),
      },
      {
        name: 'å†…å­˜ä¸è¶³',
        setup: () => saveFileManager.simulateMemoryPressure(),
        operation: () => saveFileManager.processLargeDataStructure(),
        expectedProtection: 'graceful_degradation_protection',
        cleanup: () => saveFileManager.releaseMemoryPressure(),
      },
    ];

    for (const scenario of protectionTestScenarios) {
      console.log(`æµ‹è¯•æ•°æ®ä¿æŠ¤åœºæ™¯: ${scenario.name}`);

      // è®°å½•æ“ä½œå‰çš„æ•°æ®çŠ¶æ€
      const preOperationState = await dataIntegrityManager.captureSystemState();

      try {
        // è®¾ç½®å¼‚å¸¸æ¡ä»¶
        await scenario.setup();

        // æ‰§è¡Œå¯èƒ½å¤±è´¥çš„æ“ä½œ
        const operationResult = await scenario.operation();

        // éªŒè¯ä¿æŠ¤æœºåˆ¶æ˜¯å¦æ­£ç¡®æ¿€æ´»
        const protectionMechanisms =
          await dataIntegrityManager.getActivatedProtectionMechanisms();
        expect(protectionMechanisms).toContain(scenario.expectedProtection);

        // æ‰§è¡Œæ¸…ç†å’Œæ¢å¤
        await scenario.cleanup();

        // éªŒè¯æ•°æ®å®Œæ•´æ€§æ¢å¤
        const postRecoveryState =
          await dataIntegrityManager.captureSystemState();
        const integrityComparison = await dataIntegrityManager.compareStates(
          preOperationState,
          postRecoveryState
        );

        expect(integrityComparison.dataLoss).toBe(0);
        expect(integrityComparison.corruptionDetected).toBe(false);
        expect(integrityComparison.recoverySuccessful).toBe(true);
      } catch (error) {
        // å³ä½¿æ“ä½œå¤±è´¥ï¼Œæ•°æ®ä¿æŠ¤æœºåˆ¶ä¹Ÿåº”è¯¥ç¡®ä¿æ•°æ®å®Œæ•´æ€§
        const dataLossCheck =
          await dataIntegrityManager.verifyNoDataLoss(preOperationState);
        expect(dataLossCheck.dataIntact).toBe(true);

        await scenario.cleanup();
      }
    }

    // éªŒè¯æ•´ä½“æ•°æ®ä¸¢å¤±ç»Ÿè®¡
    const overallDataLossEvents =
      await dataIntegrityManager.getDataLossEvents();
    expect(overallDataLossEvents).toHaveLength(0);

    // éªŒè¯ç”¨æˆ·æ„ŸçŸ¥çš„æ•°æ®ä¸¢å¤±ä¸º0
    const userPerceptibleDataLoss =
      await dataIntegrityManager.calculateUserPerceptibleDataLoss();
    expect(userPerceptibleDataLoss).toBe(0);
  });

  it('è·¨è¿›ç¨‹æ•°æ®ä¸€è‡´æ€§éªŒè¯', async () => {
    // Given: å¯åŠ¨Electronä¸‰è¿›ç¨‹æ¶æ„
    await ipcManager.initializeMainProcess();
    await ipcManager.initializeRendererProcess();
    await ipcManager.initializeWorkerProcess();

    // éªŒè¯è¿›ç¨‹é—´é€šä¿¡å»ºç«‹
    const ipcHealthCheck = await ipcManager.performHealthCheck();
    expect(ipcHealthCheck.allProcessesConnected).toBe(true);

    // When: æ‰§è¡Œè·¨è¿›ç¨‹æ•°æ®åŒæ­¥æ“ä½œ
    const crossProcessSyncScenarios = [
      {
        name: 'ä¸»->æ¸²æŸ“åŒæ­¥',
        dataType: 'game_state',
        syncDirection: 'main_to_renderer',
        verificationRequirement: 'realtime_consistency',
      },
      {
        name: 'æ¸²æŸ“->ä¸»åŒæ­¥',
        dataType: 'user_operations',
        syncDirection: 'renderer_to_main',
        verificationRequirement: 'sequential_integrity',
      },
      {
        name: 'Worker->ä¸»åŒæ­¥',
        dataType: 'ai_computation_results',
        syncDirection: 'worker_to_main',
        verificationRequirement: 'computational_consistency',
      },
      {
        name: 'ä¸‰è¿›ç¨‹å¹¿æ’­åŒæ­¥',
        dataType: 'system_events',
        syncDirection: 'broadcast',
        verificationRequirement: 'global_consistency',
      },
    ];

    for (const scenario of crossProcessSyncScenarios) {
      console.log(`æµ‹è¯•è·¨è¿›ç¨‹åŒæ­¥: ${scenario.name}`);

      // ç”Ÿæˆæµ‹è¯•æ•°æ®
      const testData = generateTestDataForSync(scenario.dataType, 1000); // 1000æ¡æ•°æ®
      const dataChecksum =
        await checksumCalculator.calculateDataChecksum(testData);

      // è®°å½•åŒæ­¥å¼€å§‹æ—¶é—´
      const syncStartTime = performance.now();

      // æ‰§è¡Œè·¨è¿›ç¨‹åŒæ­¥
      let syncResult;
      switch (scenario.syncDirection) {
        case 'main_to_renderer':
          syncResult = await ipcManager.syncMainToRenderer(testData);
          break;
        case 'renderer_to_main':
          syncResult = await ipcManager.syncRendererToMain(testData);
          break;
        case 'worker_to_main':
          syncResult = await ipcManager.syncWorkerToMain(testData);
          break;
        case 'broadcast':
          syncResult = await ipcManager.broadcastToAllProcesses(testData);
          break;
      }

      const syncEndTime = performance.now();
      const syncDuration = syncEndTime - syncStartTime;

      // éªŒè¯åŒæ­¥ç»“æœ
      expect(syncResult.success).toBe(true);
      expect(syncResult.dataLoss).toBe(0);
      expect(syncResult.corruptionDetected).toBe(false);

      // éªŒè¯æ•°æ®å®Œæ•´æ€§
      const receivedDataChecksum =
        await checksumCalculator.calculateDataChecksum(syncResult.receivedData);
      expect(receivedDataChecksum).toBe(dataChecksum);

      // éªŒè¯åŒæ­¥æ€§èƒ½è¦æ±‚
      expect(syncDuration).toBeLessThan(1000); // 1ç§’å†…å®ŒæˆåŒæ­¥

      // éªŒè¯ç‰¹å®šçš„ä¸€è‡´æ€§è¦æ±‚
      switch (scenario.verificationRequirement) {
        case 'realtime_consistency':
          const realtimeDelay = await ipcManager.measureRealtimeDelay();
          expect(realtimeDelay).toBeLessThan(50); // 50mså®æ—¶æ€§
          break;

        case 'sequential_integrity':
          const sequenceIntegrityCheck =
            await ipcManager.verifySequentialIntegrity(syncResult);
          expect(sequenceIntegrityCheck.sequencePreserved).toBe(true);
          break;

        case 'computational_consistency':
          const computationConsistencyCheck =
            await ipcManager.verifyComputationConsistency(syncResult);
          expect(computationConsistencyCheck.computationAccurate).toBe(true);
          break;

        case 'global_consistency':
          const globalConsistencyCheck =
            await ipcManager.verifyGlobalConsistency();
          expect(globalConsistencyCheck.allProcessesConsistent).toBe(true);
          break;
      }
    }

    // Then: éªŒè¯æ•´ä½“è·¨è¿›ç¨‹æ•°æ®ä¸€è‡´æ€§
    const overallConsistencyCheck =
      await ipcManager.performOverallConsistencyCheck();
    expect(overallConsistencyCheck.dataConsistencyPercentage).toBe(100);
    expect(overallConsistencyCheck.versionConflicts).toHaveLength(0);
    expect(overallConsistencyCheck.dataLossEvents).toHaveLength(0);

    // éªŒè¯è¿›ç¨‹é—´æ•°æ®çŠ¶æ€åŒæ­¥
    const processStates = await ipcManager.captureAllProcessStates();
    const stateConsistencyScore =
      await ipcManager.calculateStateConsistencyScore(processStates);
    expect(stateConsistencyScore).toBe(1.0); // 100%ä¸€è‡´æ€§
  });
});

// è¾…åŠ©å‡½æ•°
function generateLargeGameState() {
  // ç”Ÿæˆå¤§å‹æ¸¸æˆçŠ¶æ€ç”¨äºæµ‹è¯•
  return {
    members: Array.from({ length: 1000 }, (_, i) => ({
      id: `member_${i}`,
      data: 'x'.repeat(1000),
    })),
    events: Array.from({ length: 10000 }, (_, i) => ({
      id: `event_${i}`,
      data: 'y'.repeat(500),
    })),
    resources: Object.fromEntries(
      Array.from({ length: 100 }, (_, i) => [
        `resource_${i}`,
        Array(100).fill(Math.random()),
      ])
    ),
  };
}

function generateTestDataForSync(dataType: string, count: number) {
  // æ ¹æ®æ•°æ®ç±»å‹ç”Ÿæˆç›¸åº”çš„æµ‹è¯•æ•°æ®
  switch (dataType) {
    case 'game_state':
      return {
        type: 'game_state',
        items: Array.from({ length: count }, (_, i) => ({
          id: i,
          state: `state_${i}`,
        })),
      };
    case 'user_operations':
      return {
        type: 'user_operations',
        operations: Array.from({ length: count }, (_, i) => ({
          id: i,
          operation: `op_${i}`,
        })),
      };
    case 'ai_computation_results':
      return {
        type: 'ai_results',
        results: Array.from({ length: count }, (_, i) => ({
          id: i,
          result: Math.random(),
        })),
      };
    case 'system_events':
      return {
        type: 'system_events',
        events: Array.from({ length: count }, (_, i) => ({
          id: i,
          event: `sys_${i}`,
        })),
      };
    default:
      throw new Error(`Unsupported data type: ${dataType}`);
  }
}
```

### 15.3 AIå¹¶å‘ä¸€è‡´æ€§éªŒæ”¶æµ‹è¯•ï¼ˆTier-1é‡è¦è´¨é‡é—¨ç¦ï¼‰

#### 15.3.1 50+AIå®ä½“å¹¶å‘ç¡®å®šæ€§éªŒæ”¶æµ‹è¯•

```gherkin
# src/tests/acceptance/features/ai-concurrency-consistency.feature
Feature: AIå¹¶å‘ä¸€è‡´æ€§éªŒæ”¶ - 50+å®ä½“ç§å­é”å®šç¡®å®šæ€§
  ä½œä¸ºä¸€ä¸ªã€Šå…¬ä¼šç»ç†ã€‹å¼€å‘è€…
  æˆ‘æœŸæœ›AIç³»ç»Ÿåœ¨50+å®ä½“å¹¶å‘è¿è¡Œæ—¶ä¿æŒå®Œå…¨ç¡®å®šæ€§
  ä»¥ç¡®ä¿æ¸¸æˆçŠ¶æ€å¯é¢„æµ‹ã€å¯é‡ç°ã€å¯è°ƒè¯•

  Background:
    Given AIå¹¶å‘ç®¡ç†å™¨å·²å¯åŠ¨å¹¶é…ç½®ç¡®å®šæ€§ç§å­
    And Web Worker AIè®¡ç®—ç¯å¢ƒå·²å°±ç»ª
    And AIçŠ¶æ€åŒæ­¥ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨
    And æµ‹è¯•ç¯å¢ƒå·²å‡†å¤‡ç¡®å®šæ€§éªŒè¯å·¥å…·

  @important @tier1-ai @deterministic
  Scenario: 50ä¸ªAIå®ä½“å¹¶å‘ç¡®å®šæ€§éªŒæ”¶
    Given æˆ‘ä½¿ç”¨ç¡®å®šæ€§ç§å­"test-seed-42"åˆå§‹åŒ–AIç³»ç»Ÿ
    And æˆ‘åˆ›å»ºäº†50ä¸ªä¸åŒç±»å‹çš„AIå®ä½“
      | AIç±»å‹         | æ•°é‡ | å¤æ‚åº¦çº§åˆ« |
      | æˆå‘˜AI         | 20   | ä¸­ç­‰      |
      | å…¬ä¼šAI         | 10   | é«˜        |
      | ç¯å¢ƒAI(åª’ä½“)   | 10   | ä½        |
      | ç¯å¢ƒAI(ç²‰ä¸)   | 5    | ä½        |
      | ç‰¹æ®Šäº‹ä»¶AI     | 5    | é«˜        |
    When æˆ‘è¿è¡Œ10è½®ç›¸åŒæ¡ä»¶çš„AIå¹¶å‘å†³ç­–å‘¨æœŸ
      | å†³ç­–å‘¨æœŸæ•° | 1000 |
      | æ¯è½®æ—¶é•¿   | 5åˆ†é’Ÿ |
      | äº‹ä»¶è§¦å‘   | 500ä¸ª |
      | çŠ¶æ€æ›´æ–°   | 2000æ¬¡ |
    Then æ‰€æœ‰10è½®çš„æœ€ç»ˆAIçŠ¶æ€å“ˆå¸Œåº”è¯¥å®Œå…¨ä¸€è‡´
    And AIå†³ç­–åºåˆ—åº”è¯¥100%å¯é‡ç°
    And çŠ¶æ€æ¼‚ç§»ç‡åº”è¯¥â‰¤0.1%
    And Web Workeré€šä¿¡å»¶è¿ŸTP95åº”è¯¥<50ms

  @important @tier1-ai @performance
  Scenario: AIå®ä½“æ‰©å±•æ€§å‹åŠ›éªŒæ”¶
    Given æˆ‘å‡†å¤‡äº†AIå®ä½“æ•°é‡æ‰©å±•æ€§æµ‹è¯•
    When æˆ‘é€æ­¥å¢åŠ AIå®ä½“æ•°é‡å¹¶æµ‹è¯•æ€§èƒ½
      | AIå®ä½“æ•°é‡ | ç›®æ ‡TP95å»¶è¿Ÿ | å†…å­˜ä½¿ç”¨é™åˆ¶ | æˆåŠŸæ ‡å‡†     |
      | 50         | <50ms        | <150MB       | åŸºå‡†æ€§èƒ½     |
      | 100        | <75ms        | <250MB       | å¯æ¥å—æ€§èƒ½   |
      | 150        | <100ms       | <350MB       | è¾¹ç•Œæ€§èƒ½     |
      | 200        | <150ms       | <400MB       | æœ€å¤§æ”¯æŒè§„æ¨¡ |
    Then æ‰€æœ‰AIå®ä½“æ•°é‡çº§åˆ«éƒ½åº”è¯¥æ»¡è¶³æ€§èƒ½è¦æ±‚
    And AIå†³ç­–è´¨é‡ä¸åº”è¯¥å› å¹¶å‘æ•°é‡è€Œé™ä½
    And ç³»ç»Ÿåº”è¯¥æ”¯æŒåŠ¨æ€AIå®ä½“æ•°é‡è°ƒæ•´
    And å†…å­˜ä½¿ç”¨åº”è¯¥å‘ˆçº¿æ€§å¢é•¿è€ŒéæŒ‡æ•°å¢é•¿

  @important @tier1-ai @fault-tolerance
  Scenario: AIå¹¶å‘é”™è¯¯æ¢å¤éªŒæ”¶
    Given æˆ‘è®¾ç½®äº†50ä¸ªAIå®ä½“çš„å¹¶å‘ç¯å¢ƒ
    And æˆ‘å‡†å¤‡äº†AIé”™è¯¯æ¢å¤æµ‹è¯•åœºæ™¯
    When æˆ‘ä¾æ¬¡æ³¨å…¥ä»¥ä¸‹å¹¶å‘é”™è¯¯æ¡ä»¶
      | é”™è¯¯ç±»å‹           | å½±å“èŒƒå›´     | é¢„æœŸæ¢å¤æœºåˆ¶       |
      | Workerè¿›ç¨‹å´©æºƒ     | å•ä¸ªWorker   | è‡ªåŠ¨é‡å¯+çŠ¶æ€æ¢å¤  |
      | AIè®¡ç®—è¶…æ—¶         | å•ä¸ªAIå®ä½“   | è¶…æ—¶å¤„ç†+é™çº§å†³ç­–  |
      | çŠ¶æ€åŒæ­¥å†²çª       | å¤šä¸ªAIå®ä½“   | å†²çªè§£å†³+çŠ¶æ€åˆå¹¶  |
      | å†…å­˜æ³„æ¼           | æ•´ä¸ªAIç³»ç»Ÿ   | å†…å­˜æ¸…ç†+é‡å¯æ¢å¤  |
      | ç½‘ç»œé€šä¿¡ä¸­æ–­       | è·¨è¿›ç¨‹é€šä¿¡   | é‡è¿æœºåˆ¶+ç¼“å­˜é™çº§  |
    Then æ‰€æœ‰é”™è¯¯æ¡ä»¶éƒ½åº”è¯¥è¢«æ­£ç¡®æ£€æµ‹å’Œæ¢å¤
    And AIç³»ç»Ÿæ•´ä½“å¯ç”¨æ€§åº”è¯¥â‰¥99%
    And æ•°æ®ä¸€è‡´æ€§åº”è¯¥åœ¨æ¢å¤åä¿æŒ100%
    And ç”¨æˆ·æ„ŸçŸ¥çš„æœåŠ¡ä¸­æ–­åº”è¯¥<5ç§’

  @important @tier1-ai @seed-management
  Scenario: ç§å­ç®¡ç†å’ŒçŠ¶æ€å›æ”¾éªŒæ”¶
    Given æˆ‘æœ‰ä¸€ä¸ªåŒ…å«å¤æ‚AIäº¤äº’å†å²çš„æ¸¸æˆçŠ¶æ€
    When æˆ‘ä½¿ç”¨ç›¸åŒç§å­é‡æ”¾æœ€è¿‘1000æ­¥AIå†³ç­–
      | å›æ”¾æ¨¡å¼     | å®Œæ•´å›æ”¾ |
      | éªŒè¯èŒƒå›´     | å…¨éƒ¨AIå®ä½“çŠ¶æ€ |
      | ç²¾åº¦è¦æ±‚     | æµ®ç‚¹æ•°ç²¾ç¡®åŒ¹é… |
      | æ—¶åºè¦æ±‚     | äº‹ä»¶é¡ºåºå®Œå…¨ä¸€è‡´ |
    Then å›æ”¾ç»“æœåº”è¯¥ä¸åŸå§‹æ‰§è¡Œå®Œå…¨ç›¸åŒ
    And æ‰€æœ‰AIå®ä½“çš„å†…éƒ¨çŠ¶æ€åº”è¯¥ç²¾ç¡®åŒ¹é…
    And éšæœºæ•°ç”Ÿæˆåºåˆ—åº”è¯¥å®Œå…¨ä¸€è‡´
    And çŠ¶æ€å“ˆå¸Œå€¼åº”è¯¥åœ¨æ¯ä¸€æ­¥éƒ½åŒ¹é…
```

```typescript
// src/tests/acceptance/steps/ai-concurrency-consistency.steps.ts - Vitestæ­¥éª¤å®šä¹‰

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { AIConcurrencyManager } from '@/game/ai/ai-concurrency-manager';
import { DeterministicRandomGenerator } from '@/game/ai/deterministic-random-generator';
import { AIStateHasher } from '@/game/ai/ai-state-hasher';
import { WebWorkerAIManager } from '@/game/ai/web-worker-ai-manager';
import { AIEntityFactory } from '@/game/ai/ai-entity-factory';
import { PerformanceMonitor } from '@/monitoring/performance-monitor';

describe('AIå¹¶å‘ä¸€è‡´æ€§éªŒæ”¶ï¼š50+å®ä½“ç§å­é”å®šç¡®å®šæ€§', () => {
  let concurrencyManager: AIConcurrencyManager;
  let randomGenerator: DeterministicRandomGenerator;
  let stateHasher: AIStateHasher;
  let workerManager: WebWorkerAIManager;
  let entityFactory: AIEntityFactory;
  let performanceMonitor: PerformanceMonitor;

  const TEST_SEED = 'test-seed-42';
  const AI_ENTITY_COUNT = 50;

  beforeEach(async () => {
    // åˆå§‹åŒ–AIå¹¶å‘æµ‹è¯•ç¯å¢ƒ
    concurrencyManager = new AIConcurrencyManager();
    randomGenerator = new DeterministicRandomGenerator(TEST_SEED);
    stateHasher = new AIStateHasher();
    workerManager = new WebWorkerAIManager();
    entityFactory = new AIEntityFactory();
    performanceMonitor = new PerformanceMonitor();

    // å¯åŠ¨Web Workerç¯å¢ƒ
    await workerManager.initializeWorkerPool(4); // 4ä¸ªWorkerè¿›ç¨‹
    await concurrencyManager.initialize({
      deterministicSeed: TEST_SEED,
      enableStateHashing: true,
      enablePerformanceMonitoring: true,
    });
  });

  afterEach(async () => {
    // æ¸…ç†èµ„æº
    await concurrencyManager.shutdown();
    await workerManager.terminateAllWorkers();
    performanceMonitor.generateReport();
  });

  it('50ä¸ªAIå®ä½“å¹¶å‘ç¡®å®šæ€§éªŒè¯', async () => {
    // Given: ä½¿ç”¨ç¡®å®šæ€§ç§å­åˆå§‹åŒ–AIç³»ç»Ÿ
    await concurrencyManager.setDeterministicSeed(TEST_SEED);

    // åˆ›å»º50ä¸ªä¸åŒç±»å‹çš„AIå®ä½“
    const aiEntities = [
      ...entityFactory.createMemberAIs(20, 'medium'), // 20ä¸ªæˆå‘˜AI
      ...entityFactory.createGuildAIs(10, 'high'), // 10ä¸ªå…¬ä¼šAI
      ...entityFactory.createMediaAIs(10, 'low'), // 10ä¸ªåª’ä½“AI
      ...entityFactory.createFanAIs(5, 'low'), // 5ä¸ªç²‰ä¸AI
      ...entityFactory.createEventAIs(5, 'high'), // 5ä¸ªç‰¹æ®Šäº‹ä»¶AI
    ];

    expect(aiEntities).toHaveLength(50);

    // æ³¨å†Œæ‰€æœ‰AIå®ä½“åˆ°å¹¶å‘ç®¡ç†å™¨
    for (const entity of aiEntities) {
      await concurrencyManager.registerEntity(entity);
    }

    // When: è¿è¡Œ10è½®ç›¸åŒæ¡ä»¶çš„AIå¹¶å‘å†³ç­–å‘¨æœŸ
    const runResults = [];

    for (let run = 0; run < 10; run++) {
      console.log(`æ‰§è¡Œç¬¬ ${run + 1} è½®AIå¹¶å‘å†³ç­–`);

      // é‡ç½®éšæœºæ•°ç§å­ç¡®ä¿æ¯è½®éƒ½ä»ç›¸åŒçŠ¶æ€å¼€å§‹
      await concurrencyManager.resetToInitialState(TEST_SEED);

      const runStartTime = performance.now();

      // æ‰§è¡Œ1000ä¸ªå†³ç­–å‘¨æœŸ
      const decisionResults = [];
      for (let cycle = 0; cycle < 1000; cycle++) {
        const cycleResult = await concurrencyManager.executeDecisionCycle({
          cycleIndex: cycle,
          eventTriggerCount: 500 / 1000, // å¹³å‡æ¯å‘¨æœŸ0.5ä¸ªäº‹ä»¶
          stateUpdateCount: 2000 / 1000, // å¹³å‡æ¯å‘¨æœŸ2ä¸ªçŠ¶æ€æ›´æ–°
          enablePerformanceTracking: true,
        });

        decisionResults.push(cycleResult);
      }

      const runEndTime = performance.now();
      const runDuration = runEndTime - runStartTime;

      // è®¡ç®—æœ€ç»ˆçŠ¶æ€å“ˆå¸Œ
      const finalStateHash =
        await stateHasher.calculateCompleteStateHash(aiEntities);

      // è®°å½•è¿è¡Œç»“æœ
      runResults.push({
        runIndex: run,
        duration: runDuration,
        finalStateHash,
        decisionResults,
        workerCommunicationLatencies: await workerManager.getLatencyMetrics(),
        memoryUsage: process.memoryUsage(),
      });

      console.log(
        `ç¬¬ ${run + 1} è½®å®Œæˆï¼Œè€—æ—¶: ${runDuration.toFixed(0)}msï¼ŒçŠ¶æ€å“ˆå¸Œ: ${finalStateHash}`
      );
    }

    // Then: éªŒè¯æ‰€æœ‰è½®æ¬¡çš„ç¡®å®šæ€§
    const referenceHash = runResults[0].finalStateHash;
    const allHashesMatch = runResults.every(
      result => result.finalStateHash === referenceHash
    );
    expect(allHashesMatch).toBe(true);

    // éªŒè¯AIå†³ç­–åºåˆ—100%å¯é‡ç°
    const referenceDecisionSequence = runResults[0].decisionResults.map(
      r => r.decisionHash
    );
    for (let i = 1; i < runResults.length; i++) {
      const currentDecisionSequence = runResults[i].decisionResults.map(
        r => r.decisionHash
      );
      expect(currentDecisionSequence).toEqual(referenceDecisionSequence);
    }

    // è®¡ç®—çŠ¶æ€æ¼‚ç§»ç‡
    const stateDriftRate =
      await concurrencyManager.calculateStateDriftRate(runResults);
    expect(stateDriftRate).toBeLessThanOrEqual(0.1); // â‰¤0.1%

    // éªŒè¯Web Workeré€šä¿¡å»¶è¿ŸTP95 <50ms
    const overallLatencyMetrics =
      workerManager.calculateOverallLatencyMetrics(runResults);
    expect(overallLatencyMetrics.tp95).toBeLessThan(50);
  });

  it('AIå®ä½“æ‰©å±•æ€§å‹åŠ›éªŒè¯', async () => {
    // Given: å‡†å¤‡AIå®ä½“æ•°é‡æ‰©å±•æ€§æµ‹è¯•
    const scalabilityTestCases = [
      {
        entityCount: 50,
        targetTP95: 50,
        memoryLimit: 150 * 1024 * 1024,
        description: 'åŸºå‡†æ€§èƒ½',
      },
      {
        entityCount: 100,
        targetTP95: 75,
        memoryLimit: 250 * 1024 * 1024,
        description: 'å¯æ¥å—æ€§èƒ½',
      },
      {
        entityCount: 150,
        targetTP95: 100,
        memoryLimit: 350 * 1024 * 1024,
        description: 'è¾¹ç•Œæ€§èƒ½',
      },
      {
        entityCount: 200,
        targetTP95: 150,
        memoryLimit: 400 * 1024 * 1024,
        description: 'æœ€å¤§æ”¯æŒè§„æ¨¡',
      },
    ];

    const scalabilityResults = [];

    for (const testCase of scalabilityTestCases) {
      console.log(
        `æµ‹è¯•AIå®ä½“æ‰©å±•æ€§: ${testCase.entityCount}ä¸ªå®ä½“ (${testCase.description})`
      );

      // åˆ›å»ºæŒ‡å®šæ•°é‡çš„AIå®ä½“
      const testEntities = entityFactory.createMixedAIEntities(
        testCase.entityCount
      );
      await concurrencyManager.resetAndRegisterEntities(testEntities);

      const memoryBefore = process.memoryUsage().heapUsed;

      // æ‰§è¡Œæ€§èƒ½æµ‹è¯•
      const performanceResults = [];
      for (let i = 0; i < 100; i++) {
        // 100è½®å†³ç­–æµ‹è¯•
        const startTime = performance.now();

        await concurrencyManager.executeDecisionCycle({
          cycleIndex: i,
          eventTriggerCount: 1,
          stateUpdateCount: testCase.entityCount * 0.1, // 10%å®ä½“çŠ¶æ€æ›´æ–°
          enablePerformanceTracking: true,
        });

        const endTime = performance.now();
        performanceResults.push(endTime - startTime);
      }

      const memoryAfter = process.memoryUsage().heapUsed;
      const memoryUsed = memoryAfter - memoryBefore;

      // è®¡ç®—æ€§èƒ½æŒ‡æ ‡
      performanceResults.sort((a, b) => a - b);
      const tp95Index = Math.floor(performanceResults.length * 0.95);
      const tp95Latency = performanceResults[tp95Index];

      // æµ‹è¯•AIå†³ç­–è´¨é‡
      const decisionQualityScore =
        await concurrencyManager.measureDecisionQuality(testEntities);

      scalabilityResults.push({
        entityCount: testCase.entityCount,
        tp95Latency,
        memoryUsed,
        decisionQualityScore,
        passed:
          tp95Latency < testCase.targetTP95 &&
          memoryUsed < testCase.memoryLimit,
      });

      console.log(
        `  TP95å»¶è¿Ÿ: ${tp95Latency.toFixed(2)}ms (ç›®æ ‡: <${testCase.targetTP95}ms)`
      );
      console.log(
        `  å†…å­˜ä½¿ç”¨: ${(memoryUsed / 1024 / 1024).toFixed(2)}MB (é™åˆ¶: ${testCase.memoryLimit / 1024 / 1024}MB)`
      );
      console.log(`  å†³ç­–è´¨é‡: ${decisionQualityScore.toFixed(3)}`);

      // éªŒè¯å½“å‰æµ‹è¯•ç”¨ä¾‹è¦æ±‚
      expect(tp95Latency).toBeLessThan(testCase.targetTP95);
      expect(memoryUsed).toBeLessThan(testCase.memoryLimit);
    }

    // Then: éªŒè¯æ•´ä½“æ‰©å±•æ€§è¦æ±‚
    const allTestsPassed = scalabilityResults.every(result => result.passed);
    expect(allTestsPassed).toBe(true);

    // éªŒè¯AIå†³ç­–è´¨é‡ä¸å› å¹¶å‘æ•°é‡è€Œæ˜¾è‘—é™ä½
    const qualityScores = scalabilityResults.map(r => r.decisionQualityScore);
    const qualityVariation =
      Math.max(...qualityScores) - Math.min(...qualityScores);
    expect(qualityVariation).toBeLessThan(0.1); // è´¨é‡å˜åŒ–<10%

    // éªŒè¯å†…å­˜ä½¿ç”¨å‘ˆçº¿æ€§å¢é•¿
    const memoryGrowthRates = [];
    for (let i = 1; i < scalabilityResults.length; i++) {
      const entityCountRatio =
        scalabilityResults[i].entityCount /
        scalabilityResults[i - 1].entityCount;
      const memoryUsageRatio =
        scalabilityResults[i].memoryUsed / scalabilityResults[i - 1].memoryUsed;
      memoryGrowthRates.push(memoryUsageRatio / entityCountRatio);
    }
    const avgGrowthRate =
      memoryGrowthRates.reduce((sum, rate) => sum + rate, 0) /
      memoryGrowthRates.length;
    expect(avgGrowthRate).toBeLessThan(1.5); // å†…å­˜å¢é•¿åº”æ¥è¿‘çº¿æ€§ï¼ˆ1.0ï¼‰,å…è®¸50%æ³¢åŠ¨
  });

  it('AIå¹¶å‘é”™è¯¯æ¢å¤éªŒè¯', async () => {
    // Given: è®¾ç½®50ä¸ªAIå®ä½“çš„å¹¶å‘ç¯å¢ƒ
    const aiEntities = entityFactory.createMixedAIEntities(50);
    await concurrencyManager.resetAndRegisterEntities(aiEntities);

    // å®šä¹‰AIé”™è¯¯æ¢å¤æµ‹è¯•åœºæ™¯
    const errorRecoveryScenarios = [
      {
        name: 'Workerè¿›ç¨‹å´©æºƒ',
        errorType: 'worker_crash',
        injectError: () => workerManager.simulateWorkerCrash(0), // å´©æºƒç¬¬ä¸€ä¸ªWorker
        expectedRecovery: 'auto_restart_state_recovery',
        maxRecoveryTime: 3000, // 3ç§’
        affectedScope: 'single_worker',
      },
      {
        name: 'AIè®¡ç®—è¶…æ—¶',
        errorType: 'computation_timeout',
        injectError: () =>
          concurrencyManager.simulateAIComputationTimeout(aiEntities[0]),
        expectedRecovery: 'timeout_handling_degraded_decision',
        maxRecoveryTime: 1000, // 1ç§’
        affectedScope: 'single_entity',
      },
      {
        name: 'çŠ¶æ€åŒæ­¥å†²çª',
        errorType: 'state_sync_conflict',
        injectError: () =>
          concurrencyManager.simulateStateSyncConflict(aiEntities.slice(0, 5)),
        expectedRecovery: 'conflict_resolution_state_merge',
        maxRecoveryTime: 2000, // 2ç§’
        affectedScope: 'multiple_entities',
      },
      {
        name: 'å†…å­˜æ³„æ¼',
        errorType: 'memory_leak',
        injectError: () => concurrencyManager.simulateMemoryLeak(),
        expectedRecovery: 'memory_cleanup_restart_recovery',
        maxRecoveryTime: 5000, // 5ç§’
        affectedScope: 'entire_system',
      },
      {
        name: 'ç½‘ç»œé€šä¿¡ä¸­æ–­',
        errorType: 'network_interruption',
        injectError: () => workerManager.simulateNetworkInterruption(),
        expectedRecovery: 'reconnection_cache_degradation',
        maxRecoveryTime: 2000, // 2ç§’
        affectedScope: 'cross_process_communication',
      },
    ];

    const recoveryResults = [];

    for (const scenario of errorRecoveryScenarios) {
      console.log(`æµ‹è¯•AIé”™è¯¯æ¢å¤åœºæ™¯: ${scenario.name}`);

      // è®°å½•é”™è¯¯æ³¨å…¥å‰çš„ç³»ç»ŸçŠ¶æ€
      const preErrorState = await concurrencyManager.captureSystemState();
      const preErrorStateHash =
        await stateHasher.calculateCompleteStateHash(aiEntities);

      const errorStartTime = performance.now();

      try {
        // æ³¨å…¥é”™è¯¯æ¡ä»¶
        await scenario.injectError();

        // ç­‰å¾…ç³»ç»Ÿæ£€æµ‹å’Œå“åº”é”™è¯¯
        const recoveryResult = await concurrencyManager.waitForErrorRecovery({
          maxWaitTime: scenario.maxRecoveryTime,
          expectedRecoveryType: scenario.expectedRecovery,
          monitorScope: scenario.affectedScope,
        });

        const errorEndTime = performance.now();
        const recoveryTime = errorEndTime - errorStartTime;

        // éªŒè¯æ¢å¤åçš„ç³»ç»ŸçŠ¶æ€
        const postRecoveryState = await concurrencyManager.captureSystemState();
        const systemAvailability =
          await concurrencyManager.calculateSystemAvailability();
        const dataConsistency = await concurrencyManager.verifyDataConsistency(
          preErrorState,
          postRecoveryState
        );

        recoveryResults.push({
          scenarioName: scenario.name,
          recoveryTime,
          recoverySuccessful: recoveryResult.successful,
          systemAvailability,
          dataConsistency: dataConsistency.consistent,
          userPerceivedInterruption: recoveryTime,
          recoveryMechanism: recoveryResult.mechanism,
        });

        console.log(
          `  æ¢å¤æ—¶é—´: ${recoveryTime.toFixed(0)}ms (é™åˆ¶: ${scenario.maxRecoveryTime}ms)`
        );
        console.log(`  æ¢å¤æˆåŠŸ: ${recoveryResult.successful ? 'æ˜¯' : 'å¦'}`);
        console.log(
          `  æ•°æ®ä¸€è‡´æ€§: ${dataConsistency.consistent ? 'ä¿æŒ' : 'å—æŸ'}`
        );

        // éªŒè¯å•ä¸ªåœºæ™¯æ¢å¤è¦æ±‚
        expect(recoveryResult.successful).toBe(true);
        expect(recoveryTime).toBeLessThan(scenario.maxRecoveryTime);
        expect(dataConsistency.consistent).toBe(true);
      } catch (error) {
        console.error(`é”™è¯¯æ¢å¤æµ‹è¯•å¤±è´¥: ${scenario.name}`, error);
        recoveryResults.push({
          scenarioName: scenario.name,
          recoveryTime: Infinity,
          recoverySuccessful: false,
          systemAvailability: 0,
          dataConsistency: false,
          userPerceivedInterruption: Infinity,
          error: error.message,
        });

        throw error; // é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œå¯¼è‡´æµ‹è¯•å¤±è´¥
      }
    }

    // Then: éªŒè¯æ•´ä½“é”™è¯¯æ¢å¤è¦æ±‚
    const allRecoveriesSuccessful = recoveryResults.every(
      result => result.recoverySuccessful
    );
    expect(allRecoveriesSuccessful).toBe(true);

    // éªŒè¯AIç³»ç»Ÿæ•´ä½“å¯ç”¨æ€§â‰¥99%
    const overallSystemAvailability =
      recoveryResults.reduce(
        (sum, result) => sum + result.systemAvailability,
        0
      ) / recoveryResults.length;
    expect(overallSystemAvailability).toBeGreaterThanOrEqual(99);

    // éªŒè¯æ•°æ®ä¸€è‡´æ€§åœ¨æ¢å¤åä¿æŒ100%
    const allDataConsistent = recoveryResults.every(
      result => result.dataConsistency
    );
    expect(allDataConsistent).toBe(true);

    // éªŒè¯ç”¨æˆ·æ„ŸçŸ¥çš„æœåŠ¡ä¸­æ–­<5ç§’
    const maxUserPerceivedInterruption = Math.max(
      ...recoveryResults.map(result => result.userPerceivedInterruption)
    );
    expect(maxUserPerceivedInterruption).toBeLessThan(5000);
  });

  it('ç§å­ç®¡ç†å’ŒçŠ¶æ€å›æ”¾éªŒè¯', async () => {
    // Given: åˆ›å»ºåŒ…å«å¤æ‚AIäº¤äº’å†å²çš„æ¸¸æˆçŠ¶æ€
    const complexAIEntities =
      entityFactory.createComplexAIInteractionScenario(50);
    await concurrencyManager.resetAndRegisterEntities(complexAIEntities);

    // æ‰§è¡Œ1000æ­¥AIå†³ç­–ä»¥å»ºç«‹å¤æ‚å†å²
    console.log('å»ºç«‹å¤æ‚AIäº¤äº’å†å²...');
    const originalDecisionHistory = [];
    const originalStateSnapshots = [];

    for (let step = 0; step < 1000; step++) {
      const stepResult = await concurrencyManager.executeDecisionCycle({
        cycleIndex: step,
        eventTriggerCount: 1,
        stateUpdateCount: Math.floor(Math.random() * 10) + 1,
        enableDetailedLogging: true,
      });

      originalDecisionHistory.push({
        step,
        decisionHash: stepResult.decisionHash,
        stateChanges: stepResult.stateChanges,
        randomSeed: stepResult.usedRandomSeed,
        timestamp: stepResult.timestamp,
      });

      // æ¯100æ­¥è®°å½•è¯¦ç»†çŠ¶æ€å¿«ç…§
      if (step % 100 === 0) {
        const stateSnapshot =
          await stateHasher.captureDetailedStateSnapshot(complexAIEntities);
        originalStateSnapshots.push({
          step,
          stateSnapshot,
          hash: await stateHasher.calculateCompleteStateHash(complexAIEntities),
        });
      }
    }

    const finalOriginalState =
      await stateHasher.captureDetailedStateSnapshot(complexAIEntities);
    const finalOriginalHash =
      await stateHasher.calculateCompleteStateHash(complexAIEntities);

    console.log(`åŸå§‹æ‰§è¡Œå®Œæˆï¼Œæœ€ç»ˆçŠ¶æ€å“ˆå¸Œ: ${finalOriginalHash}`);

    // When: ä½¿ç”¨ç›¸åŒç§å­é‡æ”¾æœ€è¿‘1000æ­¥AIå†³ç­–
    console.log('å¼€å§‹çŠ¶æ€å›æ”¾éªŒè¯...');

    // é‡ç½®AIç³»ç»Ÿåˆ°åˆå§‹çŠ¶æ€
    await concurrencyManager.resetToInitialState(TEST_SEED);
    const resetEntities = entityFactory.createComplexAIInteractionScenario(50);
    await concurrencyManager.resetAndRegisterEntities(resetEntities);

    // æ‰§è¡Œå®Œå…¨ç›¸åŒçš„1000æ­¥å†³ç­–å›æ”¾
    const replayDecisionHistory = [];
    const replayStateSnapshots = [];

    for (let step = 0; step < 1000; step++) {
      const originalStepData = originalDecisionHistory[step];

      // ä½¿ç”¨åŸå§‹æ‰§è¡Œçš„éšæœºç§å­
      await concurrencyManager.setStepRandomSeed(originalStepData.randomSeed);

      const replayStepResult = await concurrencyManager.executeDecisionCycle({
        cycleIndex: step,
        eventTriggerCount: 1,
        stateUpdateCount: originalStepData.stateChanges.length,
        enableDetailedLogging: true,
        replayMode: true,
      });

      replayDecisionHistory.push({
        step,
        decisionHash: replayStepResult.decisionHash,
        stateChanges: replayStepResult.stateChanges,
        randomSeed: replayStepResult.usedRandomSeed,
        timestamp: replayStepResult.timestamp,
      });

      // è®°å½•ç›¸åŒçš„çŠ¶æ€å¿«ç…§ç‚¹
      if (step % 100 === 0) {
        const replayStateSnapshot =
          await stateHasher.captureDetailedStateSnapshot(resetEntities);
        replayStateSnapshots.push({
          step,
          stateSnapshot: replayStateSnapshot,
          hash: await stateHasher.calculateCompleteStateHash(resetEntities),
        });
      }
    }

    const finalReplayState =
      await stateHasher.captureDetailedStateSnapshot(resetEntities);
    const finalReplayHash =
      await stateHasher.calculateCompleteStateHash(resetEntities);

    console.log(`å›æ”¾æ‰§è¡Œå®Œæˆï¼Œæœ€ç»ˆçŠ¶æ€å“ˆå¸Œ: ${finalReplayHash}`);

    // Then: éªŒè¯å›æ”¾ç»“æœä¸åŸå§‹æ‰§è¡Œå®Œå…¨ç›¸åŒ

    // 1. éªŒè¯æœ€ç»ˆçŠ¶æ€å“ˆå¸Œå®Œå…¨åŒ¹é…
    expect(finalReplayHash).toBe(finalOriginalHash);

    // 2. éªŒè¯æ‰€æœ‰AIå®ä½“çš„å†…éƒ¨çŠ¶æ€ç²¾ç¡®åŒ¹é…
    for (let i = 0; i < complexAIEntities.length; i++) {
      const originalEntityState = await stateHasher.serializeEntityState(
        complexAIEntities[i]
      );
      const replayEntityState = await stateHasher.serializeEntityState(
        resetEntities[i]
      );
      expect(replayEntityState).toEqual(originalEntityState);
    }

    // 3. éªŒè¯å†³ç­–åºåˆ—100%å¯é‡ç°
    expect(replayDecisionHistory.length).toBe(originalDecisionHistory.length);

    for (let step = 0; step < originalDecisionHistory.length; step++) {
      const original = originalDecisionHistory[step];
      const replay = replayDecisionHistory[step];

      expect(replay.decisionHash).toBe(original.decisionHash);
      expect(replay.randomSeed).toBe(original.randomSeed);
      expect(replay.stateChanges).toEqual(original.stateChanges);
    }

    // 4. éªŒè¯çŠ¶æ€å“ˆå¸Œå€¼åœ¨æ¯ä¸€æ­¥éƒ½åŒ¹é…
    for (let i = 0; i < originalStateSnapshots.length; i++) {
      const originalSnapshot = originalStateSnapshots[i];
      const replaySnapshot = replayStateSnapshots[i];

      expect(replaySnapshot.step).toBe(originalSnapshot.step);
      expect(replaySnapshot.hash).toBe(originalSnapshot.hash);

      // éªŒè¯è¯¦ç»†çŠ¶æ€æ•°æ®åŒ¹é…
      const stateComparison = await stateHasher.compareDetailedSnapshots(
        originalSnapshot.stateSnapshot,
        replaySnapshot.stateSnapshot
      );
      expect(stateComparison.identical).toBe(true);
      expect(stateComparison.differences).toHaveLength(0);
    }

    console.log('âœ… çŠ¶æ€å›æ”¾éªŒè¯é€šè¿‡ï¼š1000æ­¥AIå†³ç­–100%ç¡®å®šæ€§é‡ç°');
  });
});
```

#### 15.3.2 Web Worker AIé€šä¿¡æ€§èƒ½éªŒæ”¶æµ‹è¯•

```gherkin
# src/tests/acceptance/features/ai-worker-communication.feature
Feature: Web Worker AIé€šä¿¡æ€§èƒ½éªŒæ”¶
  ä½œä¸ºä¸€ä¸ªã€Šå…¬ä¼šç»ç†ã€‹ç”¨æˆ·
  æˆ‘æœŸæœ›AIè®¡ç®—é€šè¿‡Web Workeråœ¨åå°é«˜æ•ˆæ‰§è¡Œ
  ä»¥ç¡®ä¿ä¸»çº¿ç¨‹UIå“åº”æ€§ä¸å—AIå¤æ‚è®¡ç®—å½±å“

  Background:
    Given Web Worker AIç®¡ç†å™¨å·²å¯åŠ¨
    And ä¸»çº¿ç¨‹ä¸Workerçº¿ç¨‹é€šä¿¡é€šé“å·²å»ºç«‹
    And AIè®¡ç®—ä»»åŠ¡åˆ†å‘å™¨å·²é…ç½®
    And æ€§èƒ½ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨

  @important @tier1-ai @worker-communication
  Scenario: Web Workeræ¶ˆæ¯ä¼ é€’æ€§èƒ½éªŒæ”¶
    Given æˆ‘å¯åŠ¨äº†4ä¸ªWeb Workerè¿›ç¨‹ç”¨äºAIè®¡ç®—
    And æ¯ä¸ªWorkeréƒ½å·²åŠ è½½AIå†³ç­–å¼•æ“
    When æˆ‘å‘é€1000ä¸ªAIè®¡ç®—ä»»åŠ¡åˆ°Workeræ± 
      | ä»»åŠ¡ç±»å‹       | æ•°é‡ | å¤æ‚åº¦  | é¢„æœŸå¤„ç†æ—¶é—´ |
      | ç®€å•å†³ç­–       | 400  | ä½      | <10ms       |
      | ä¸­ç­‰å†³ç­–       | 400  | ä¸­      | <30ms       |
      | å¤æ‚å†³ç­–       | 150  | é«˜      | <80ms       |
      | ç¾¤ä½“å†³ç­–       | 50   | æé«˜    | <200ms      |
    Then Workeré€šä¿¡å»¶è¿ŸTP95åº”è¯¥<50ms
    And ä»»åŠ¡åˆ†å‘è´Ÿè½½å‡è¡¡å·®å¼‚åº”è¯¥<10%
    And æ‰€æœ‰Workerè¿›ç¨‹åº”è¯¥ä¿æŒå“åº”çŠ¶æ€
    And è®¡ç®—ç»“æœå‡†ç¡®æ€§åº”è¯¥100%

  @important @tier1-ai @worker-performance
  Scenario: Workerè®¡ç®—ååé‡éªŒæ”¶
    Given æˆ‘é…ç½®äº†æ‰¹é‡AIè®¡ç®—æµ‹è¯•ç¯å¢ƒ
    When æˆ‘ä»¥ä¸åŒæ‰¹æ¬¡å¤§å°æµ‹è¯•Workerååé‡
      | æ‰¹æ¬¡å¤§å° | å¹¶å‘Worker | ç›®æ ‡ååé‡    | å»¶è¿Ÿè¦æ±‚   |
      | 10       | 1         | >100 tasks/s  | TP95<50ms  |
      | 50       | 2         | >300 tasks/s  | TP95<60ms  |
      | 100      | 4         | >500 tasks/s  | TP95<80ms  |
      | 200      | 4         | >600 tasks/s  | TP95<100ms |
    Then æ‰€æœ‰æ‰¹æ¬¡å¤§å°éƒ½åº”è¯¥è¾¾åˆ°ç›®æ ‡ååé‡
    And Worker CPUä½¿ç”¨ç‡åº”è¯¥ä¿æŒ<80%
    And å†…å­˜ä½¿ç”¨åº”è¯¥ç¨³å®šä¸æ³„æ¼
    And é”™è¯¯ç‡åº”è¯¥<0.1%

  @important @tier1-ai @worker-fault-tolerance
  Scenario: Workerå®¹é”™å’Œæ¢å¤éªŒæ”¶
    Given æˆ‘æœ‰ä¸€ä¸ªç¨³å®šè¿è¡Œçš„4Worker AIè®¡ç®—ç¯å¢ƒ
    When æˆ‘ä¾æ¬¡æµ‹è¯•ä»¥ä¸‹Workeræ•…éšœåœºæ™¯
      | æ•…éšœç±»å‹         | å½±å“èŒƒå›´    | é¢„æœŸæ¢å¤æ—¶é—´ | æ•°æ®ä¸¢å¤±å®¹å¿ |
      | å•Workerå´©æºƒ     | 25%è®¡ç®—èƒ½åŠ› | <3s         | 0%          |
      | 2WorkeråŒæ—¶å´©æºƒ  | 50%è®¡ç®—èƒ½åŠ› | <5s         | 0%          |
      | Workerå†…å­˜æ³„æ¼   | é€æ¸é™çº§    | <10s        | 0%          |
      | é€šä¿¡é€šé“ä¸­æ–­     | ä¸´æ—¶éš”ç¦»    | <2s         | 0%          |
      | æ¶æ„æ— é™å¾ªç¯     | å•Worker    | <1s         | 0%          |
    Then æ‰€æœ‰æ•…éšœéƒ½åº”è¯¥è¢«åŠæ—¶æ£€æµ‹å’Œæ¢å¤
    And ç³»ç»Ÿæ•´ä½“è®¡ç®—èƒ½åŠ›æŸå¤±åº”è¯¥<60%
    And æ•…éšœæ¢å¤åæ€§èƒ½åº”è¯¥å®Œå…¨æ¢å¤
    And ç”¨æˆ·æ„ŸçŸ¥çš„è®¡ç®—å»¶è¿Ÿå¢åŠ åº”è¯¥<200%
```

```typescript
// src/tests/acceptance/steps/ai-worker-communication.steps.ts - Vitestæ­¥éª¤å®šä¹‰

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { WebWorkerAIManager } from '@/game/ai/web-worker-ai-manager';
import { AITaskDispatcher } from '@/game/ai/ai-task-dispatcher';
import { WorkerPerformanceMonitor } from '@/monitoring/worker-performance-monitor';
import { AIComputationTask } from '@/game/ai/ai-computation-task';
import { LoadBalancer } from '@/game/ai/load-balancer';

describe('Web Worker AIé€šä¿¡æ€§èƒ½éªŒæ”¶', () => {
  let workerManager: WebWorkerAIManager;
  let taskDispatcher: AITaskDispatcher;
  let performanceMonitor: WorkerPerformanceMonitor;
  let loadBalancer: LoadBalancer;

  const WORKER_COUNT = 4;

  beforeEach(async () => {
    // åˆå§‹åŒ–Web Worker AIæµ‹è¯•ç¯å¢ƒ
    workerManager = new WebWorkerAIManager();
    taskDispatcher = new AITaskDispatcher();
    performanceMonitor = new WorkerPerformanceMonitor();
    loadBalancer = new LoadBalancer();

    // å¯åŠ¨Workeræ± 
    await workerManager.initializeWorkerPool(WORKER_COUNT);

    // é…ç½®ä»»åŠ¡åˆ†å‘å™¨
    await taskDispatcher.initialize({
      workerPool: workerManager.getWorkerPool(),
      loadBalancer,
      performanceMonitor,
    });
  });

  afterEach(async () => {
    // æ¸…ç†èµ„æº
    await taskDispatcher.shutdown();
    await workerManager.terminateAllWorkers();
    performanceMonitor.generateReport();
  });

  it('Web Workeræ¶ˆæ¯ä¼ é€’æ€§èƒ½éªŒè¯', async () => {
    // Given: å¯åŠ¨4ä¸ªWeb Workerè¿›ç¨‹å¹¶åŠ è½½AIå†³ç­–å¼•æ“
    const workers = workerManager.getWorkerPool();
    expect(workers).toHaveLength(WORKER_COUNT);

    // éªŒè¯æ‰€æœ‰Workeréƒ½å·²æˆåŠŸåŠ è½½AIå¼•æ“
    for (const worker of workers) {
      const healthCheck = await workerManager.performWorkerHealthCheck(
        worker.id
      );
      expect(healthCheck.aiEngineLoaded).toBe(true);
      expect(healthCheck.responsive).toBe(true);
    }

    // When: å‘é€1000ä¸ªä¸åŒå¤æ‚åº¦çš„AIè®¡ç®—ä»»åŠ¡
    const taskDefinitions = [
      {
        type: 'simple_decision',
        count: 400,
        complexity: 'low',
        expectedTime: 10,
      },
      {
        type: 'medium_decision',
        count: 400,
        complexity: 'medium',
        expectedTime: 30,
      },
      {
        type: 'complex_decision',
        count: 150,
        complexity: 'high',
        expectedTime: 80,
      },
      {
        type: 'group_decision',
        count: 50,
        complexity: 'extreme',
        expectedTime: 200,
      },
    ];

    const allTasks = [];

    // ç”Ÿæˆæ‰€æœ‰ä»»åŠ¡
    for (const taskDef of taskDefinitions) {
      for (let i = 0; i < taskDef.count; i++) {
        allTasks.push(
          AIComputationTask.create({
            id: `${taskDef.type}_${i}`,
            type: taskDef.type,
            complexity: taskDef.complexity,
            expectedProcessingTime: taskDef.expectedTime,
            data: generateTaskData(taskDef.type, taskDef.complexity),
          })
        );
      }
    }

    // éšæœºæ‰“ä¹±ä»»åŠ¡é¡ºåºä»¥æ¨¡æ‹ŸçœŸå®åœºæ™¯
    shuffleArray(allTasks);

    console.log(`å‘é€ ${allTasks.length} ä¸ªAIè®¡ç®—ä»»åŠ¡åˆ°Workeræ± `);

    const dispatchStartTime = performance.now();
    const taskResults = [];

    // å¹¶å‘åˆ†å‘æ‰€æœ‰ä»»åŠ¡
    const taskPromises = allTasks.map(async (task, index) => {
      const taskStartTime = performance.now();

      try {
        const result = await taskDispatcher.dispatchTask(task);
        const taskEndTime = performance.now();
        const taskDuration = taskEndTime - taskStartTime;

        taskResults.push({
          taskId: task.id,
          taskType: task.type,
          complexity: task.complexity,
          duration: taskDuration,
          communicationLatency: result.communicationLatency,
          processingTime: result.processingTime,
          workerId: result.workerId,
          success: result.success,
          accurate: result.resultAccurate,
        });

        return result;
      } catch (error) {
        taskResults.push({
          taskId: task.id,
          taskType: task.type,
          complexity: task.complexity,
          duration: Infinity,
          error: error.message,
          success: false,
          accurate: false,
        });
        throw error;
      }
    });

    await Promise.all(taskPromises);

    const dispatchEndTime = performance.now();
    const totalDispatchTime = dispatchEndTime - dispatchStartTime;

    console.log(`æ‰€æœ‰ä»»åŠ¡å¤„ç†å®Œæˆï¼Œæ€»è€—æ—¶: ${totalDispatchTime.toFixed(0)}ms`);

    // Then: éªŒè¯æ€§èƒ½è¦æ±‚

    // 1. éªŒè¯Workeré€šä¿¡å»¶è¿ŸTP95 <50ms
    const communicationLatencies = taskResults
      .filter(r => r.success)
      .map(r => r.communicationLatency)
      .sort((a, b) => a - b);

    const tp95Index = Math.floor(communicationLatencies.length * 0.95);
    const communicationLatencyTP95 = communicationLatencies[tp95Index];

    console.log(
      `Workeré€šä¿¡å»¶è¿Ÿ TP95: ${communicationLatencyTP95.toFixed(2)}ms`
    );
    expect(communicationLatencyTP95).toBeLessThan(50);

    // 2. éªŒè¯ä»»åŠ¡åˆ†å‘è´Ÿè½½å‡è¡¡å·®å¼‚<10%
    const workerTaskCounts = loadBalancer.getWorkerTaskCounts();
    const taskCountValues = Object.values(workerTaskCounts);
    const maxTaskCount = Math.max(...taskCountValues);
    const minTaskCount = Math.min(...taskCountValues);
    const loadBalanceDifference =
      ((maxTaskCount - minTaskCount) / maxTaskCount) * 100;

    console.log(`è´Ÿè½½å‡è¡¡å·®å¼‚: ${loadBalanceDifference.toFixed(2)}%`);
    expect(loadBalanceDifference).toBeLessThan(10);

    // 3. éªŒè¯æ‰€æœ‰Workerè¿›ç¨‹ä¿æŒå“åº”çŠ¶æ€
    for (const worker of workers) {
      const workerStatus = await workerManager.getWorkerStatus(worker.id);
      expect(workerStatus.responsive).toBe(true);
      expect(workerStatus.alive).toBe(true);
    }

    // 4. éªŒè¯è®¡ç®—ç»“æœ100%å‡†ç¡®æ€§
    const accurateResults = taskResults.filter(r => r.accurate).length;
    const accuracyRate = (accurateResults / taskResults.length) * 100;

    console.log(`è®¡ç®—ç»“æœå‡†ç¡®ç‡: ${accuracyRate.toFixed(2)}%`);
    expect(accuracyRate).toBe(100);

    // éªŒè¯ä¸åŒå¤æ‚åº¦ä»»åŠ¡çš„å¤„ç†æ—¶é—´ç¬¦åˆé¢„æœŸ
    for (const taskDef of taskDefinitions) {
      const typeResults = taskResults.filter(r => r.taskType === taskDef.type);
      const avgProcessingTime =
        typeResults.reduce((sum, r) => sum + r.processingTime, 0) /
        typeResults.length;

      console.log(
        `${taskDef.type} å¹³å‡å¤„ç†æ—¶é—´: ${avgProcessingTime.toFixed(2)}ms (é¢„æœŸ: <${taskDef.expectedTime}ms)`
      );
      expect(avgProcessingTime).toBeLessThan(taskDef.expectedTime * 1.5); // å…è®¸50%æµ®åŠ¨
    }
  });

  it('Workerè®¡ç®—ååé‡éªŒè¯', async () => {
    // Given: é…ç½®æ‰¹é‡AIè®¡ç®—æµ‹è¯•ç¯å¢ƒ
    const throughputTestCases = [
      {
        batchSize: 10,
        workerCount: 1,
        targetThroughput: 100,
        latencyRequirement: 50,
      },
      {
        batchSize: 50,
        workerCount: 2,
        targetThroughput: 300,
        latencyRequirement: 60,
      },
      {
        batchSize: 100,
        workerCount: 4,
        targetThroughput: 500,
        latencyRequirement: 80,
      },
      {
        batchSize: 200,
        workerCount: 4,
        targetThroughput: 600,
        latencyRequirement: 100,
      },
    ];

    const throughputResults = [];

    for (const testCase of throughputTestCases) {
      console.log(
        `æµ‹è¯•ååé‡: æ‰¹æ¬¡å¤§å°${testCase.batchSize}, Workeræ•°${testCase.workerCount}`
      );

      // è°ƒæ•´Workeræ•°é‡
      if (testCase.workerCount !== WORKER_COUNT) {
        await workerManager.adjustWorkerPoolSize(testCase.workerCount);
      }

      // ç”Ÿæˆæµ‹è¯•ä»»åŠ¡æ‰¹æ¬¡
      const testTasks = [];
      for (let i = 0; i < testCase.batchSize; i++) {
        testTasks.push(
          AIComputationTask.create({
            id: `throughput_test_${i}`,
            type: 'medium_decision',
            complexity: 'medium',
            data: generateTaskData('medium_decision', 'medium'),
          })
        );
      }

      // æ‰§è¡Œååé‡æµ‹è¯•ï¼ˆ10ç§’æµ‹è¯•çª—å£ï¼‰
      const testDuration = 10000; // 10ç§’
      const testStartTime = performance.now();
      let completedTasks = 0;
      const latencyMeasurements = [];

      const throughputTestPromise = new Promise<void>(resolve => {
        const intervalId = setInterval(async () => {
          if (performance.now() - testStartTime >= testDuration) {
            clearInterval(intervalId);
            resolve();
            return;
          }

          // æŒç»­å‘é€ä»»åŠ¡
          for (const task of testTasks.slice(0, 10)) {
            // æ¯æ¬¡å‘é€10ä¸ªä»»åŠ¡
            const taskStartTime = performance.now();

            try {
              const result = await taskDispatcher.dispatchTask(task);
              const taskEndTime = performance.now();
              const taskLatency = taskEndTime - taskStartTime;

              completedTasks++;
              latencyMeasurements.push(taskLatency);
            } catch (error) {
              console.error(`ä»»åŠ¡å¤„ç†å¤±è´¥:`, error);
            }
          }
        }, 100); // æ¯100mså‘é€ä¸€æ‰¹ä»»åŠ¡
      });

      await throughputTestPromise;

      const actualTestDuration = performance.now() - testStartTime;
      const actualThroughput = (completedTasks / actualTestDuration) * 1000; // tasks per second

      // è®¡ç®—å»¶è¿ŸæŒ‡æ ‡
      latencyMeasurements.sort((a, b) => a - b);
      const tp95Index = Math.floor(latencyMeasurements.length * 0.95);
      const latencyTP95 = latencyMeasurements[tp95Index] || 0;

      // è·å–èµ„æºä½¿ç”¨æƒ…å†µ
      const resourceUsage = await performanceMonitor.getResourceUsage();
      const avgCpuUsage =
        resourceUsage.workers.reduce((sum, w) => sum + w.cpuUsage, 0) /
        resourceUsage.workers.length;
      const memoryStable = await performanceMonitor.checkMemoryStability();

      throughputResults.push({
        batchSize: testCase.batchSize,
        workerCount: testCase.workerCount,
        actualThroughput,
        targetThroughput: testCase.targetThroughput,
        latencyTP95,
        latencyRequirement: testCase.latencyRequirement,
        avgCpuUsage,
        memoryStable,
        completedTasks,
        testDuration: actualTestDuration,
      });

      console.log(
        `  å®é™…ååé‡: ${actualThroughput.toFixed(2)} tasks/s (ç›®æ ‡: >${testCase.targetThroughput})`
      );
      console.log(
        `  å»¶è¿ŸTP95: ${latencyTP95.toFixed(2)}ms (è¦æ±‚: <${testCase.latencyRequirement}ms)`
      );
      console.log(`  å¹³å‡CPUä½¿ç”¨: ${avgCpuUsage.toFixed(2)}%`);

      // éªŒè¯å•ä¸ªæµ‹è¯•ç”¨ä¾‹è¦æ±‚
      expect(actualThroughput).toBeGreaterThan(testCase.targetThroughput);
      expect(latencyTP95).toBeLessThan(testCase.latencyRequirement);
      expect(avgCpuUsage).toBeLessThan(80);
      expect(memoryStable).toBe(true);
    }

    // Then: éªŒè¯æ•´ä½“ååé‡è¦æ±‚
    const allTestsPassed = throughputResults.every(
      result =>
        result.actualThroughput > result.targetThroughput &&
        result.latencyTP95 < result.latencyRequirement &&
        result.avgCpuUsage < 80 &&
        result.memoryStable
    );
    expect(allTestsPassed).toBe(true);

    // éªŒè¯é”™è¯¯ç‡<0.1%
    const totalTasks = throughputResults.reduce(
      (sum, result) => sum + result.completedTasks,
      0
    );
    const errorRate = performanceMonitor.getOverallErrorRate();
    expect(errorRate).toBeLessThan(0.1);

    console.log(
      `æ•´ä½“ååé‡æµ‹è¯•é€šè¿‡ï¼Œæ€»å¤„ç†ä»»åŠ¡: ${totalTasks}, é”™è¯¯ç‡: ${errorRate.toFixed(3)}%`
    );
  });

  it('Workerå®¹é”™å’Œæ¢å¤éªŒè¯', async () => {
    // Given: å»ºç«‹ç¨³å®šè¿è¡Œçš„4Worker AIè®¡ç®—ç¯å¢ƒ
    const workers = workerManager.getWorkerPool();
    expect(workers).toHaveLength(WORKER_COUNT);

    // å¯åŠ¨åå°è®¡ç®—è´Ÿè½½ä»¥æ¨¡æ‹Ÿå®é™…ä½¿ç”¨
    const backgroundTaskGenerator = startBackgroundTaskGeneration();

    // å®šä¹‰Workeræ•…éšœæµ‹è¯•åœºæ™¯
    const faultToleranceScenarios = [
      {
        name: 'å•Workerå´©æºƒ',
        faultType: 'single_worker_crash',
        affectedCapacity: 25,
        expectedRecoveryTime: 3000,
        dataLossTolerance: 0,
        simulateFault: () => workerManager.simulateWorkerCrash(workers[0].id),
      },
      {
        name: '2WorkeråŒæ—¶å´©æºƒ',
        faultType: 'dual_worker_crash',
        affectedCapacity: 50,
        expectedRecoveryTime: 5000,
        dataLossTolerance: 0,
        simulateFault: () =>
          Promise.all([
            workerManager.simulateWorkerCrash(workers[1].id),
            workerManager.simulateWorkerCrash(workers[2].id),
          ]),
      },
      {
        name: 'Workerå†…å­˜æ³„æ¼',
        faultType: 'memory_leak',
        affectedCapacity: 25, // é€æ¸é™çº§
        expectedRecoveryTime: 10000,
        dataLossTolerance: 0,
        simulateFault: () => workerManager.simulateMemoryLeak(workers[3].id),
      },
      {
        name: 'é€šä¿¡é€šé“ä¸­æ–­',
        faultType: 'communication_interruption',
        affectedCapacity: 25,
        expectedRecoveryTime: 2000,
        dataLossTolerance: 0,
        simulateFault: () =>
          workerManager.simulateChannelInterruption(workers[0].id),
      },
      {
        name: 'æ¶æ„æ— é™å¾ªç¯',
        faultType: 'infinite_loop',
        affectedCapacity: 25,
        expectedRecoveryTime: 1000,
        dataLossTolerance: 0,
        simulateFault: () => workerManager.simulateInfiniteLoop(workers[1].id),
      },
    ];

    const faultToleranceResults = [];

    for (const scenario of faultToleranceScenarios) {
      console.log(`æµ‹è¯•Workerå®¹é”™åœºæ™¯: ${scenario.name}`);

      // è®°å½•æ•…éšœå‰çš„ç³»ç»ŸçŠ¶æ€
      const preFailureMetrics = await performanceMonitor.captureSystemMetrics();
      const preFailureTaskQueue = taskDispatcher.getPendingTaskCount();

      const faultStartTime = performance.now();

      try {
        // æ¨¡æ‹Ÿæ•…éšœ
        await scenario.simulateFault();

        // ç­‰å¾…ç³»ç»Ÿæ£€æµ‹æ•…éšœå¹¶å¯åŠ¨æ¢å¤æœºåˆ¶
        const recoveryResult = await workerManager.waitForFaultRecovery({
          maxWaitTime: scenario.expectedRecoveryTime,
          faultType: scenario.faultType,
          monitoringInterval: 100,
        });

        const faultEndTime = performance.now();
        const actualRecoveryTime = faultEndTime - faultStartTime;

        // éªŒè¯æ¢å¤åçš„ç³»ç»ŸçŠ¶æ€
        const postRecoveryMetrics =
          await performanceMonitor.captureSystemMetrics();
        const postRecoveryTaskQueue = taskDispatcher.getPendingTaskCount();

        // è®¡ç®—å®¹é‡æŸå¤±
        const capacityLoss =
          ((preFailureMetrics.totalCapacity -
            postRecoveryMetrics.totalCapacity) /
            preFailureMetrics.totalCapacity) *
          100;

        // è®¡ç®—æ•°æ®ä¸¢å¤±
        const dataLoss = Math.max(
          0,
          preFailureTaskQueue - postRecoveryTaskQueue
        );
        const dataLossRate = (dataLoss / preFailureTaskQueue) * 100;

        // æµ‹é‡æ¢å¤åæ€§èƒ½
        const performanceRecoveryTest = await measurePostRecoveryPerformance();

        // æµ‹é‡ç”¨æˆ·æ„ŸçŸ¥å»¶è¿Ÿå¢åŠ 
        const userPerceivedDelayIncrease =
          (postRecoveryMetrics.averageLatency /
            preFailureMetrics.averageLatency) *
            100 -
          100;

        faultToleranceResults.push({
          scenarioName: scenario.name,
          actualRecoveryTime,
          expectedRecoveryTime: scenario.expectedRecoveryTime,
          recoverySuccessful: recoveryResult.successful,
          capacityLoss,
          expectedCapacityLoss: scenario.affectedCapacity,
          dataLossRate,
          dataLossTolerance: scenario.dataLossTolerance,
          performanceFullyRecovered: performanceRecoveryTest.fullyRecovered,
          userPerceivedDelayIncrease,
          faultDetected: recoveryResult.faultDetected,
          recoveryMechanism: recoveryResult.mechanism,
        });

        console.log(
          `  æ¢å¤æ—¶é—´: ${actualRecoveryTime.toFixed(0)}ms (æœŸæœ›: <${scenario.expectedRecoveryTime}ms)`
        );
        console.log(
          `  å®¹é‡æŸå¤±: ${capacityLoss.toFixed(2)}% (é¢„æœŸ: ${scenario.affectedCapacity}%)`
        );
        console.log(
          `  æ•°æ®ä¸¢å¤±: ${dataLossRate.toFixed(3)}% (å®¹å¿: ${scenario.dataLossTolerance}%)`
        );
        console.log(
          `  ç”¨æˆ·å»¶è¿Ÿå¢åŠ : ${userPerceivedDelayIncrease.toFixed(2)}%`
        );

        // éªŒè¯å•ä¸ªåœºæ™¯è¦æ±‚
        expect(recoveryResult.successful).toBe(true);
        expect(actualRecoveryTime).toBeLessThan(scenario.expectedRecoveryTime);
        expect(dataLossRate).toBeLessThanOrEqual(scenario.dataLossTolerance);
        expect(capacityLoss).toBeLessThan(60); // æ•´ä½“å®¹é‡æŸå¤±<60%
        expect(performanceRecoveryTest.fullyRecovered).toBe(true);
        expect(userPerceivedDelayIncrease).toBeLessThan(200); // ç”¨æˆ·å»¶è¿Ÿå¢åŠ <200%
      } catch (error) {
        console.error(`å®¹é”™æµ‹è¯•å¤±è´¥: ${scenario.name}`, error);

        faultToleranceResults.push({
          scenarioName: scenario.name,
          actualRecoveryTime: Infinity,
          recoverySuccessful: false,
          capacityLoss: 100,
          dataLossRate: 100,
          performanceFullyRecovered: false,
          userPerceivedDelayIncrease: Infinity,
          error: error.message,
        });

        throw error;
      }
    }

    // åœæ­¢åå°ä»»åŠ¡ç”Ÿæˆ
    backgroundTaskGenerator.stop();

    // Then: éªŒè¯æ•´ä½“å®¹é”™è¦æ±‚

    // 1. æ‰€æœ‰æ•…éšœéƒ½åº”è¯¥è¢«åŠæ—¶æ£€æµ‹å’Œæ¢å¤
    const allFaultsDetectedAndRecovered = faultToleranceResults.every(
      result => result.faultDetected && result.recoverySuccessful
    );
    expect(allFaultsDetectedAndRecovered).toBe(true);

    // 2. ç³»ç»Ÿæ•´ä½“è®¡ç®—èƒ½åŠ›æŸå¤±<60%
    const maxCapacityLoss = Math.max(
      ...faultToleranceResults.map(result => result.capacityLoss)
    );
    expect(maxCapacityLoss).toBeLessThan(60);

    // 3. æ•…éšœæ¢å¤åæ€§èƒ½å®Œå…¨æ¢å¤
    const allPerformanceRecovered = faultToleranceResults.every(
      result => result.performanceFullyRecovered
    );
    expect(allPerformanceRecovered).toBe(true);

    // 4. ç”¨æˆ·æ„ŸçŸ¥çš„è®¡ç®—å»¶è¿Ÿå¢åŠ <200%
    const maxUserPerceivedDelayIncrease = Math.max(
      ...faultToleranceResults.map(result => result.userPerceivedDelayIncrease)
    );
    expect(maxUserPerceivedDelayIncrease).toBeLessThan(200);

    console.log(`âœ… Workerå®¹é”™å’Œæ¢å¤éªŒæ”¶æµ‹è¯•é€šè¿‡`);
    console.log(
      `   æœ€å¤§æ¢å¤æ—¶é—´: ${Math.max(...faultToleranceResults.map(r => r.actualRecoveryTime)).toFixed(0)}ms`
    );
    console.log(`   æœ€å¤§å®¹é‡æŸå¤±: ${maxCapacityLoss.toFixed(2)}%`);
    console.log(
      `   æœ€å¤§å»¶è¿Ÿå¢åŠ : ${maxUserPerceivedDelayIncrease.toFixed(2)}%`
    );
  });
});

// è¾…åŠ©å‡½æ•°
function generateTaskData(taskType: string, complexity: string): any {
  // æ ¹æ®ä»»åŠ¡ç±»å‹å’Œå¤æ‚åº¦ç”Ÿæˆæµ‹è¯•æ•°æ®
  const baseData = {
    entityId: `test_entity_${Math.floor(Math.random() * 1000)}`,
    timestamp: Date.now(),
    context: {},
  };

  switch (complexity) {
    case 'low':
      return { ...baseData, operations: Math.floor(Math.random() * 10) + 1 };
    case 'medium':
      return {
        ...baseData,
        operations: Math.floor(Math.random() * 50) + 10,
        subEntities: Math.floor(Math.random() * 5),
      };
    case 'high':
      return {
        ...baseData,
        operations: Math.floor(Math.random() * 200) + 50,
        subEntities: Math.floor(Math.random() * 20),
      };
    case 'extreme':
      return {
        ...baseData,
        operations: Math.floor(Math.random() * 500) + 200,
        subEntities: Math.floor(Math.random() * 50),
      };
    default:
      return baseData;
  }
}

function shuffleArray<T>(array: T[]): void {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function startBackgroundTaskGeneration() {
  // å¯åŠ¨åå°ä»»åŠ¡ç”Ÿæˆä»¥æ¨¡æ‹Ÿå®é™…è´Ÿè½½
  let running = true;

  const generator = setInterval(() => {
    if (!running) return;

    // ç”Ÿæˆåå°AIä»»åŠ¡
    // å®ç°ç»†èŠ‚...
  }, 100);

  return {
    stop: () => {
      running = false;
      clearInterval(generator);
    },
  };
}

async function measurePostRecoveryPerformance(): Promise<{
  fullyRecovered: boolean;
}> {
  // æµ‹é‡æ•…éšœæ¢å¤åçš„æ€§èƒ½æ˜¯å¦å®Œå…¨æ¢å¤
  // å®ç°ç»†èŠ‚...
  return { fullyRecovered: true };
}
```

#### 11.5.2 äº‹ä»¶å¤„ç†å»¶è¿ŸéªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/game-event-latency.feature
Feature: æ¸¸æˆäº‹ä»¶å¤„ç†å»¶è¿ŸéªŒæ”¶
  ä½œä¸ºç³»ç»Ÿæ¶æ„å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿æ¸¸æˆäº‹ä»¶å¤„ç†æ»¡è¶³å®æ—¶æ€§è¦æ±‚

  Background:
    Given äº‹ä»¶å¼•æ“å·²å®Œå…¨åˆå§‹åŒ–
    And äº‹ä»¶æ± å·²åŠ è½½åŸºç¡€äº‹ä»¶
    And å»¶è¿Ÿç›‘æ§ç³»ç»Ÿå·²å¯ç”¨

  Scenario: ç”¨æˆ·äº¤äº’äº‹ä»¶å»¶è¿ŸéªŒæ”¶
    Given ç”¨æˆ·åœ¨æ¸¸æˆç•Œé¢è¿›è¡Œäº¤äº’
    When ç”¨æˆ·æ‰§è¡Œä»¥ä¸‹äº¤äº’æ“ä½œ
      | æ“ä½œç±»å‹       | äº‹ä»¶å¤æ‚åº¦ | å»¶è¿Ÿè¦æ±‚ |
      | ç‚¹å‡»æŒ‰é’®      | ç®€å•       | <10ms    |
      | æ‹–æ‹½æ“ä½œ      | ä¸­ç­‰       | <15ms    |
      | å¤šé€‰æ“ä½œ      | å¤æ‚       | <25ms    |
      | å¿«æ·é”®ç»„åˆ    | ç®€å•       | <8ms     |
    Then ç”¨æˆ·äº¤äº’äº‹ä»¶å¤„ç†å»¶è¿ŸP95åº” â‰¤ 10ms
    And ç”¨æˆ·äº¤äº’äº‹ä»¶å¤„ç†å»¶è¿ŸP99åº” â‰¤ 25ms
    And äº‹ä»¶é˜Ÿåˆ—ä¸åº”å‡ºç°é˜»å¡
    And ç”¨æˆ·åº”æ„Ÿå—åˆ°å³æ—¶å“åº”

  Scenario: æ¸¸æˆé€»è¾‘äº‹ä»¶å»¶è¿ŸéªŒæ”¶
    Given æ¸¸æˆæ­£åœ¨è¿è¡Œæ ‡å‡†åœºæ™¯
    When è§¦å‘ä»¥ä¸‹æ¸¸æˆé€»è¾‘äº‹ä»¶
      | äº‹ä»¶ç±»å‹           | å¤æ‚åº¦   | é¢„æœŸå»¶è¿Ÿ |
      | æˆå‘˜çŠ¶æ€æ›´æ–°       | ç®€å•     | <15ms    |
      | AIå†³ç­–è®¡ç®—        | ä¸­ç­‰     | <50ms    |
      | å¤šå®ä½“åè°ƒ        | å¤æ‚     | <100ms   |
      | è·¨æ¨¡å—æ•°æ®åŒæ­¥     | é«˜å¤æ‚   | <150ms   |
    Then æ¸¸æˆé€»è¾‘äº‹ä»¶å¤„ç†å»¶è¿ŸP95åº” â‰¤ 50ms
    And å¤æ‚äº‹ä»¶å¤„ç†å»¶è¿ŸP95åº” â‰¤ 150ms
    And äº‹ä»¶å¤„ç†ä¸åº”å½±å“å¸§ç‡ç¨³å®šæ€§
    And AIå†³ç­–å“åº”åº”åœ¨ç”¨æˆ·å¯æ¥å—èŒƒå›´å†…

  @stress-test @tier1-performance
  Scenario: é«˜å¹¶å‘äº‹ä»¶å¤„ç†å‹åŠ›æµ‹è¯•
    Given æ¸¸æˆå¤„äºé«˜æ´»è·ƒçŠ¶æ€
    When åŒæ—¶è§¦å‘å¤§é‡äº‹ä»¶
      | å¹¶å‘äº‹ä»¶æ•° | äº‹ä»¶ç±»å‹æ··åˆ | æŒç»­æ—¶é—´ |
      | 100+      | å…¨ç±»å‹      | 10åˆ†é’Ÿ   |
      | 200+      | ç”¨æˆ·äº¤äº’ä¸ºä¸» | 5åˆ†é’Ÿ    |
      | 50+       | AIå†³ç­–ä¸ºä¸»  | 15åˆ†é’Ÿ   |
    Then å¹³å‡äº‹ä»¶å¤„ç†å»¶è¿Ÿåº”ä¿æŒåœ¨SLOèŒƒå›´å†…
    And äº‹ä»¶é˜Ÿåˆ—é•¿åº¦ä¸åº”è¶…è¿‡1000
    And ç³»ç»Ÿä¸åº”å‡ºç°äº‹ä»¶ä¸¢å¤±
    And å†…å­˜ä½¿ç”¨åº”ä¿æŒç¨³å®š
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/game-event-latency.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { EventEngine } from '@/core/EventEngine';
import { LatencyMonitor } from '@/shared/monitoring/LatencyMonitor';
import { EventSimulator } from '@/testing/EventSimulator';

describe('æ¸¸æˆäº‹ä»¶å¤„ç†å»¶è¿ŸéªŒæ”¶', () => {
  let eventEngine: EventEngine;
  let latencyMonitor: LatencyMonitor;
  let eventSimulator: EventSimulator;

  beforeEach(async () => {
    eventEngine = new EventEngine();
    latencyMonitor = new LatencyMonitor();
    eventSimulator = new EventSimulator();

    await eventEngine.initialize();
    latencyMonitor.start();
  });

  afterEach(async () => {
    await eventEngine.shutdown();
    latencyMonitor.stop();
  });

  it('ç”¨æˆ·äº¤äº’äº‹ä»¶å»¶è¿ŸéªŒæ”¶', async () => {
    // Given: ç”¨æˆ·åœ¨æ¸¸æˆç•Œé¢è¿›è¡Œäº¤äº’
    const userInteractionTests = [
      { type: 'ç‚¹å‡»æŒ‰é’®', complexity: 'simple', expectedLatency: 10, count: 500 },
      { type: 'æ‹–æ‹½æ“ä½œ', complexity: 'medium', expectedLatency: 15, count: 300 },
      { type: 'å¤šé€‰æ“ä½œ', complexity: 'complex', expectedLatency: 25, count: 200 },
      { type: 'å¿«æ·é”®ç»„åˆ', complexity: 'simple', expectedLatency: 8, count: 400 }
    ];

    const allLatencies = [];

    for (const testCase of userInteractionTests) {
      // When: æ‰§è¡Œç”¨æˆ·äº¤äº’æ“ä½œ
      const interactionResults = await eventSimulator.simulateUserInteraction({
        interactionType: testCase.type,
        complexity: testCase.complexity,
        count: testCase.count,
        measureLatency: true
      });

      // æ”¶é›†å»¶è¿Ÿæ•°æ®
      allLatencies.push(...interactionResults.latencies);

      // éªŒè¯å½“å‰äº¤äº’ç±»å‹çš„å»¶è¿Ÿè¦æ±‚
      const currentP95 = this.calculatePercentile(interactionResults.latencies, 95);
      expect(currentP95).toBeLessThanOrEqual(testCase.expectedLatency);

      console.log(`${testCase.type} P95å»¶è¿Ÿ: ${currentP95.toFixed(2)}ms`);
    }

    // Then: æ•´ä½“éªŒè¯ç”¨æˆ·äº¤äº’å»¶è¿Ÿè¦æ±‚

    // ç”¨æˆ·äº¤äº’äº‹ä»¶å¤„ç†å»¶è¿ŸP95åº” â‰¤ 10ms
    const overallP95 = this.calculatePercentile(allLatencies, 95);
    expect(overallP95).toBeLessThanOrEqual(10);

    // ç”¨æˆ·äº¤äº’äº‹ä»¶å¤„ç†å»¶è¿ŸP99åº” â‰¤ 25ms
    const overallP99 = this.calculatePercentile(allLatencies, 99);
    expect(overallP99).toBeLessThanOrEqual(25);

    // äº‹ä»¶é˜Ÿåˆ—ä¸åº”å‡ºç°é˜»å¡
    const queueStats = await eventEngine.getQueueStatistics();
    expect(queueStats.maxQueueLength).toBeLessThan(100);
    expect(queueStats.blockingEvents).toBe(0);

    console.log('ç”¨æˆ·äº¤äº’äº‹ä»¶å»¶è¿Ÿæµ‹è¯•ç»“æœ:', {
      P95å»¶è¿Ÿ: overallP95.toFixed(2) + 'ms',
      P99å»¶è¿Ÿ: overallP99.toFixed(2) + 'ms',
      æ€»äº‹ä»¶æ•°: allLatencies.length,
      æœ€å¤§é˜Ÿåˆ—é•¿åº¦: queueStats.maxQueueLength,
      é˜»å¡äº‹ä»¶: queueStats.blockingEvents
    });
  });

  // è¾…åŠ©æ–¹æ³•
  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = values.sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }
});
```

#### 11.5.3 å­˜æ¡£æ“ä½œæ€§èƒ½éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/game-save-performance.feature
Feature: æ¸¸æˆå­˜æ¡£æ“ä½œæ€§èƒ½éªŒæ”¶
  ä½œä¸ºç©å®¶ï¼Œæˆ‘éœ€è¦å­˜æ¡£æ“ä½œå¿«é€Ÿå®Œæˆï¼Œä¸å½±å“æ¸¸æˆæµç•…æ€§

  Background:
    Given å­˜æ¡£ç³»ç»Ÿå·²åˆå§‹åŒ–
    And æ–‡ä»¶I/Oç³»ç»Ÿå·²å‡†å¤‡å°±ç»ª
    And æ•°æ®å‹ç¼©æ¨¡å—å·²åŠ è½½

  Scenario: æ ‡å‡†å­˜æ¡£ä¿å­˜æ€§èƒ½éªŒæ”¶
    Given æ¸¸æˆåŒ…å«æ ‡å‡†è§„æ¨¡çš„æ•°æ®
      | æ•°æ®ç±»å‹     | æ•°é‡    | å¤§å°ä¼°ç®— |
      | æ¸¸æˆå®ä½“     | 100+    | 50KB     |
      | äº‹ä»¶å†å²     | 1000+   | 200KB    |
      | AIçŠ¶æ€      | 50+     | 100KB    |
      | ç”¨æˆ·é…ç½®     | å…¨é‡     | 10KB     |
    When æ‰§è¡Œå­˜æ¡£ä¿å­˜æ“ä½œ
    Then å­˜æ¡£ä¿å­˜æ“ä½œåº”åœ¨100mså†…å®Œæˆ
    And å­˜æ¡£æ–‡ä»¶åº”å®Œæ•´æ— æŸ
    And ä¿å­˜è¿‡ç¨‹ä¸­æ¸¸æˆåº”ä¿æŒå“åº”
    And å†…å­˜ä½¿ç”¨å³°å€¼å¢é•¿åº”<50MB

  Scenario: å­˜æ¡£åŠ è½½æ€§èƒ½éªŒæ”¶
    Given å­˜åœ¨ä¸åŒè§„æ¨¡çš„å­˜æ¡£æ–‡ä»¶
    When æ‰§è¡Œå­˜æ¡£åŠ è½½æ“ä½œ
      | å­˜æ¡£ç±»å‹   | æ–‡ä»¶å¤§å° | åŠ è½½æ—¶é—´è¦æ±‚ |
      | å°å‹å­˜æ¡£   | <1MB    | <50ms       |
      | ä¸­å‹å­˜æ¡£   | 1-5MB   | <100ms      |
      | å¤§å‹å­˜æ¡£   | 5-10MB  | <300ms      |
    Then å­˜æ¡£åŠ è½½æ—¶é—´åº”æ»¡è¶³å¯¹åº”è¦æ±‚
    And æ•°æ®å®Œæ•´æ€§éªŒè¯åº”é€šè¿‡
    And æ¸¸æˆçŠ¶æ€åº”æ­£ç¡®æ¢å¤
    And å†…å­˜å ç”¨åº”åˆç†
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/game-save-performance.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { SaveSystem } from '@/core/SaveSystem';
import { PerformanceMonitor } from '@/shared/monitoring/PerformanceMonitor';
import { DataGenerator } from '@/testing/DataGenerator';

describe('æ¸¸æˆå­˜æ¡£æ“ä½œæ€§èƒ½éªŒæ”¶', () => {
  let saveSystem: SaveSystem;
  let performanceMonitor: PerformanceMonitor;
  let dataGenerator: DataGenerator;

  beforeEach(async () => {
    saveSystem = new SaveSystem();
    performanceMonitor = new PerformanceMonitor();
    dataGenerator = new DataGenerator();

    await saveSystem.initialize();
    performanceMonitor.start();
  });

  it('æ ‡å‡†å­˜æ¡£ä¿å­˜æ€§èƒ½éªŒæ”¶', async () => {
    // Given: æ¸¸æˆåŒ…å«æ ‡å‡†è§„æ¨¡çš„æ•°æ®
    const standardGameData = dataGenerator.generateStandardGameData({
      entities: 100,
      eventHistory: 1000,
      aiStates: 50,
      userConfig: 'full',
    });

    // When: æ‰§è¡Œå­˜æ¡£ä¿å­˜æ“ä½œ
    const saveStartTime = performance.now();
    const initialMemory = await performanceMonitor.getCurrentMemoryUsage();

    const saveResult = await saveSystem.saveGame({
      gameData: standardGameData,
      saveSlot: 'test-standard-save',
      compressionLevel: 'standard',
      validateIntegrity: true,
    });

    const saveEndTime = performance.now();
    const saveDuration = saveEndTime - saveStartTime;

    // Then: éªŒè¯å­˜æ¡£ä¿å­˜æ€§èƒ½è¦æ±‚

    // å­˜æ¡£ä¿å­˜æ“ä½œåº”åœ¨100mså†…å®Œæˆ
    expect(saveDuration).toBeLessThanOrEqual(100);

    // å­˜æ¡£æ–‡ä»¶åº”å®Œæ•´æ— æŸ
    expect(saveResult.success).toBe(true);
    expect(saveResult.integrityCheck.passed).toBe(true);

    console.log('æ ‡å‡†å­˜æ¡£ä¿å­˜æµ‹è¯•ç»“æœ:', {
      ä¿å­˜æ—¶é—´: saveDuration.toFixed(2) + 'ms',
      æ–‡ä»¶å¤§å°: (saveResult.finalFileSize / 1024).toFixed(2) + 'KB',
      å‹ç¼©ç‡: saveResult.compressionRatio.toFixed(1) + '%',
    });
  });
});
```

### 11.6 ä¸šåŠ¡ä»·å€¼éªŒæ”¶è§„èŒƒï¼ˆBusiness Value Acceptanceï¼‰

#### 11.6.1 æ–°æ‰‹å¼•å¯¼å®Œæˆç‡éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/onboarding-completion.feature
Feature: æ–°æ‰‹å¼•å¯¼å®Œæˆç‡éªŒæ”¶
  ä½œä¸ºäº§å“ç»ç†ï¼Œæˆ‘éœ€è¦ç¡®ä¿æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿè¾¾åˆ°80%ä»¥ä¸Šçš„å®Œæˆç‡

  Background:
    Given æ–°æ‰‹å¼•å¯¼ç³»ç»Ÿå·²å®Œå…¨åˆå§‹åŒ–
    And å¼•å¯¼æµç¨‹ç›‘æ§å·²å¯ç”¨
    And ç”¨æˆ·è¡Œä¸ºåˆ†æç³»ç»Ÿå·²å‡†å¤‡å°±ç»ª

  Scenario: æ–°æ‰‹å¼•å¯¼æµç¨‹å®Œæˆç‡éªŒæ”¶
    Given æœ‰100ä¸ªæ–°ç”¨æˆ·å¼€å§‹æ¸¸æˆ
    When ç”¨æˆ·ä¾æ¬¡ç»å†ä»¥ä¸‹å¼•å¯¼æ­¥éª¤
      | å¼•å¯¼æ­¥éª¤           | é¢„æœŸå®Œæˆç‡ | æœ€å¤§è€—æ—¶ |
      | åŸºç¡€ç•Œé¢ä»‹ç»       | >95%      | <2åˆ†é’Ÿ   |
      | åˆ›å»ºç¬¬ä¸€ä¸ªå…¬ä¼š     | >90%      | <5åˆ†é’Ÿ   |
      | æ‹›å‹Ÿç¬¬ä¸€ä¸ªæˆå‘˜     | >85%      | <3åˆ†é’Ÿ   |
      | æ‰§è¡Œç¬¬ä¸€æ¬¡æ´»åŠ¨     | >80%      | <10åˆ†é’Ÿ  |
      | æŸ¥çœ‹æ•°æ®ç»Ÿè®¡       | >75%      | <2åˆ†é’Ÿ   |
    Then æ•´ä½“æ–°æ‰‹å¼•å¯¼å®Œæˆç‡åº” â‰¥ 80%
    And æ¯ä¸ªæ­¥éª¤çš„ä¸­é€”æ”¾å¼ƒç‡åº” â‰¤ 5%
    And å¹³å‡å®Œæˆæ—¶é—´åº” â‰¤ 25åˆ†é’Ÿ
    And ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ†åº” â‰¥ 7/10

  Scenario: æ–°æ‰‹å¼•å¯¼è´¨é‡è¯„ä¼°
    Given æ–°æ‰‹ç”¨æˆ·å®Œæˆå¼•å¯¼æµç¨‹
    When è¯„ä¼°å¼•å¯¼æ•ˆæœè´¨é‡
      | è¯„ä¼°ç»´åº¦         | æˆåŠŸæ ‡å‡†  |
      | æ¦‚å¿µç†è§£åº¦       | >85%     |
      | æ“ä½œç†Ÿç»ƒåº¦       | >80%     |
      | åŠŸèƒ½è®°å¿†åº¦       | >75%     |
      | ç»§ç»­æ¸¸æˆæ„æ„¿     | >80%     |
    Then æ‰€æœ‰è¯„ä¼°ç»´åº¦åº”è¾¾åˆ°æˆåŠŸæ ‡å‡†
    And å¼•å¯¼åç”¨æˆ·åº”èƒ½ç‹¬ç«‹æ“ä½œæ ¸å¿ƒåŠŸèƒ½
    And ç”¨æˆ·åº”ç†è§£æ¸¸æˆçš„åŸºæœ¬ä»·å€¼ä¸»å¼ 

  @business-critical @user-retention
  Scenario: å¼•å¯¼æ”¾å¼ƒç‚¹åˆ†æä¸ä¼˜åŒ–éªŒæ”¶
    Given æ”¶é›†äº†1000+ç”¨æˆ·çš„å¼•å¯¼æ•°æ®
    When åˆ†æç”¨æˆ·å¼•å¯¼æ”¾å¼ƒè¡Œä¸º
    Then ä¸»è¦æ”¾å¼ƒç‚¹åº”è¢«è¯†åˆ«å¹¶è®°å½•
    And æ¯ä¸ªæ”¾å¼ƒç‚¹éƒ½åº”æœ‰å¯¹åº”çš„ä¼˜åŒ–ç­–ç•¥
    And ä¼˜åŒ–åçš„æ”¾å¼ƒç‡åº”é™ä½ â‰¥ 30%
    And æ•´ä½“å®Œæˆç‡åº”æå‡è‡³ â‰¥ 85%
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/onboarding-completion.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { OnboardingSystem } from '@/features/onboarding/OnboardingSystem';
import { UserBehaviorAnalytics } from '@/analytics/UserBehaviorAnalytics';
import { OnboardingSimulator } from '@/testing/OnboardingSimulator';

describe('æ–°æ‰‹å¼•å¯¼å®Œæˆç‡éªŒæ”¶', () => {
  let onboardingSystem: OnboardingSystem;
  let userAnalytics: UserBehaviorAnalytics;
  let onboardingSimulator: OnboardingSimulator;

  beforeEach(async () => {
    onboardingSystem = new OnboardingSystem();
    userAnalytics = new UserBehaviorAnalytics();
    onboardingSimulator = new OnboardingSimulator();

    await onboardingSystem.initialize();
    await userAnalytics.start();
  });

  afterEach(async () => {
    await onboardingSystem.cleanup();
    userAnalytics.stop();
  });

  it(
    'æ–°æ‰‹å¼•å¯¼æµç¨‹å®Œæˆç‡éªŒæ”¶',
    async () => {
      // Given: æœ‰100ä¸ªæ–°ç”¨æˆ·å¼€å§‹æ¸¸æˆ
      const testUsers = onboardingSimulator.generateTestUsers(100);

      const onboardingSteps = [
        { step: 'åŸºç¡€ç•Œé¢ä»‹ç»', expectedRate: 95, maxDuration: 2 * 60 * 1000 },
        {
          step: 'åˆ›å»ºç¬¬ä¸€ä¸ªå…¬ä¼š',
          expectedRate: 90,
          maxDuration: 5 * 60 * 1000,
        },
        {
          step: 'æ‹›å‹Ÿç¬¬ä¸€ä¸ªæˆå‘˜',
          expectedRate: 85,
          maxDuration: 3 * 60 * 1000,
        },
        {
          step: 'æ‰§è¡Œç¬¬ä¸€æ¬¡æ´»åŠ¨',
          expectedRate: 80,
          maxDuration: 10 * 60 * 1000,
        },
        { step: 'æŸ¥çœ‹æ•°æ®ç»Ÿè®¡', expectedRate: 75, maxDuration: 2 * 60 * 1000 },
      ];

      const onboardingResults = [];
      let totalCompletionTimes = [];

      // When: ç”¨æˆ·ä¾æ¬¡ç»å†å¼•å¯¼æ­¥éª¤
      for (const user of testUsers) {
        const userJourney = await onboardingSimulator.simulateUserOnboarding({
          userId: user.id,
          userProfile: user.profile,
          steps: onboardingSteps,
          trackDetailedBehavior: true,
          measureSatisfaction: true,
        });

        onboardingResults.push(userJourney);
        if (userJourney.completed) {
          totalCompletionTimes.push(userJourney.totalDuration);
        }
      }

      // è®¡ç®—å„æ­¥éª¤å®Œæˆç‡
      const stepCompletionRates = onboardingSteps.map((step, index) => {
        const completedUsers = onboardingResults.filter(
          result => result.completedSteps > index
        ).length;
        const completionRate = (completedUsers / testUsers.length) * 100;

        return {
          step: step.step,
          completionRate,
          expectedRate: step.expectedRate,
        };
      });

      // Then: éªŒè¯å®Œæˆç‡è¦æ±‚

      // æ•´ä½“æ–°æ‰‹å¼•å¯¼å®Œæˆç‡åº” â‰¥ 80%
      const fullyCompletedUsers = onboardingResults.filter(
        result => result.completed
      ).length;
      const overallCompletionRate =
        (fullyCompletedUsers / testUsers.length) * 100;
      expect(overallCompletionRate).toBeGreaterThanOrEqual(80);

      // æ¯ä¸ªæ­¥éª¤çš„ä¸­é€”æ”¾å¼ƒç‡åº” â‰¤ 5%
      for (const stepResult of stepCompletionRates) {
        expect(stepResult.completionRate).toBeGreaterThanOrEqual(
          stepResult.expectedRate
        );
      }

      // å¹³å‡å®Œæˆæ—¶é—´åº” â‰¤ 25åˆ†é’Ÿ
      const averageCompletionTime =
        totalCompletionTimes.reduce((sum, time) => sum + time, 0) /
        totalCompletionTimes.length;
      expect(averageCompletionTime).toBeLessThanOrEqual(25 * 60 * 1000); // 25åˆ†é’Ÿ

      // ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ†åº” â‰¥ 7/10
      const satisfactionScores = onboardingResults
        .map(result => result.satisfactionScore)
        .filter(score => score > 0);
      const averageSatisfaction =
        satisfactionScores.reduce((sum, score) => sum + score, 0) /
        satisfactionScores.length;
      expect(averageSatisfaction).toBeGreaterThanOrEqual(7);

      console.log('æ–°æ‰‹å¼•å¯¼å®Œæˆç‡æµ‹è¯•ç»“æœ:', {
        æ•´ä½“å®Œæˆç‡: overallCompletionRate.toFixed(2) + '%',
        å¹³å‡å®Œæˆæ—¶é—´: (averageCompletionTime / 60000).toFixed(2) + 'åˆ†é’Ÿ',
        å¹³å‡æ»¡æ„åº¦: averageSatisfaction.toFixed(1) + '/10',
        å„æ­¥éª¤å®Œæˆç‡: stepCompletionRates
          .map(step => `${step.step}: ${step.completionRate.toFixed(1)}%`)
          .join(', '),
      });
    },
    30 * 60 * 1000
  ); // 30åˆ†é’Ÿè¶…æ—¶

  it(
    'å¼•å¯¼æ”¾å¼ƒç‚¹åˆ†æä¸ä¼˜åŒ–éªŒæ”¶',
    async () => {
      // Given: æ”¶é›†äº†1000+ç”¨æˆ·çš„å¼•å¯¼æ•°æ®
      const largeUserSample = onboardingSimulator.generateTestUsers(1200);

      // æ¨¡æ‹ŸçœŸå®çš„æ”¾å¼ƒè¡Œä¸ºæ¨¡å¼
      const abandonmentAnalysisResults =
        await onboardingSimulator.runAbandonmentAnalysis({
          users: largeUserSample,
          includeDropoffReasons: true,
          trackFrustrationPoints: true,
          measureOptimizationImpact: true,
        });

      // When: åˆ†æç”¨æˆ·å¼•å¯¼æ”¾å¼ƒè¡Œä¸º
      const dropoffPoints = abandonmentAnalysisResults.identifiedDropoffPoints;

      // Then: éªŒè¯æ”¾å¼ƒç‚¹åˆ†æè´¨é‡

      // ä¸»è¦æ”¾å¼ƒç‚¹åº”è¢«è¯†åˆ«å¹¶è®°å½•
      expect(dropoffPoints.length).toBeGreaterThan(0);
      for (const dropoffPoint of dropoffPoints) {
        expect(dropoffPoint.step).toBeDefined();
        expect(dropoffPoint.abandonmentRate).toBeGreaterThan(0);
        expect(dropoffPoint.reasons).toBeDefined();
      }

      // æ¯ä¸ªæ”¾å¼ƒç‚¹éƒ½åº”æœ‰å¯¹åº”çš„ä¼˜åŒ–ç­–ç•¥
      for (const dropoffPoint of dropoffPoints) {
        expect(dropoffPoint.optimizationStrategies).toBeDefined();
        expect(dropoffPoint.optimizationStrategies.length).toBeGreaterThan(0);
      }

      // ä¼˜åŒ–åçš„æ”¾å¼ƒç‡åº”é™ä½ â‰¥ 30%
      const optimizedResults =
        abandonmentAnalysisResults.postOptimizationResults;
      for (const point of dropoffPoints) {
        const improvementRate =
          ((point.originalAbandonmentRate - point.optimizedAbandonmentRate) /
            point.originalAbandonmentRate) *
          100;
        expect(improvementRate).toBeGreaterThanOrEqual(30);
      }

      // æ•´ä½“å®Œæˆç‡åº”æå‡è‡³ â‰¥ 85%
      expect(optimizedResults.overallCompletionRate).toBeGreaterThanOrEqual(85);

      console.log('å¼•å¯¼æ”¾å¼ƒç‚¹ä¼˜åŒ–ç»“æœ:', {
        è¯†åˆ«æ”¾å¼ƒç‚¹æ•°: dropoffPoints.length,
        å¹³å‡æ”¹å–„ç‡:
          dropoffPoints.reduce(
            (sum, point) =>
              sum +
              ((point.originalAbandonmentRate -
                point.optimizedAbandonmentRate) /
                point.originalAbandonmentRate) *
                100,
            0
          ) / dropoffPoints.length,
        ä¼˜åŒ–åæ•´ä½“å®Œæˆç‡: optimizedResults.overallCompletionRate + '%',
      });
    },
    15 * 60 * 1000
  ); // 15åˆ†é’Ÿè¶…æ—¶
});
```

#### 11.6.2 åŠŸèƒ½å‘ç°ç‡éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/feature-discoverability.feature
Feature: åŠŸèƒ½å‘ç°ç‡éªŒæ”¶
  ä½œä¸ºäº§å“è®¾è®¡å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿ç”¨æˆ·èƒ½å¤Ÿè½»æ¾å‘ç°å’Œä½¿ç”¨æ ¸å¿ƒåŠŸèƒ½

  Background:
    Given æ¸¸æˆæ‰€æœ‰åŠŸèƒ½æ¨¡å—å·²å®Œå…¨åŠ è½½
    And ç”¨æˆ·äº¤äº’è·Ÿè¸ªç³»ç»Ÿå·²å¯ç”¨
    And åŠŸèƒ½ä½¿ç”¨ç‡åˆ†æå·²å‡†å¤‡å°±ç»ª

  Scenario: æ ¸å¿ƒåŠŸèƒ½å‘ç°ç‡éªŒæ”¶
    Given 100åç”¨æˆ·å®Œæˆäº†æ–°æ‰‹å¼•å¯¼
    When ç”¨æˆ·åœ¨é¦–æ¬¡30åˆ†é’Ÿæ¸¸æˆæ—¶é—´å†…è‡ªç”±æ¢ç´¢
    Then ç”¨æˆ·åº”å‘ç°ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½
      | åŠŸèƒ½æ¨¡å—           | å‘ç°ç‡ç›®æ ‡ | ä½¿ç”¨ç‡ç›®æ ‡ |
      | æˆå‘˜ç®¡ç†           | >90%      | >80%      |
      | æ´»åŠ¨ç»„ç»‡           | >85%      | >70%      |
      | æˆ˜æœ¯ä¸­å¿ƒ           | >80%      | >60%      |
      | ç¤¾äº¤äº’åŠ¨           | >85%      | >65%      |
      | æ•°æ®ç»Ÿè®¡           | >75%      | >50%      |
      | èµ„æºç®¡ç†           | >80%      | >60%      |
    And æ•´ä½“åŠŸèƒ½å‘ç°ç‡åº” â‰¥ 85%
    And ç”¨æˆ·åº”è¡¨ç¤ºç•Œé¢ç›´è§‚æ˜“æ‡‚
    And åŠŸèƒ½å…¥å£åº”æ˜“äºæ‰¾åˆ°

  Scenario: é«˜çº§åŠŸèƒ½æ¸è¿›å‘ç°éªŒæ”¶
    Given ç”¨æˆ·å·²ä½¿ç”¨æ¸¸æˆ1å°æ—¶ä»¥ä¸Š
    When ç”¨æˆ·ç»§ç»­æ·±å…¥æ¢ç´¢åŠŸèƒ½
    Then é«˜çº§åŠŸèƒ½çš„å‘ç°è·¯å¾„åº”åˆç†
      | é«˜çº§åŠŸèƒ½           | å‘ç°è·¯å¾„é•¿åº¦ | å‘ç°ç‡ç›®æ ‡ |
      | è‡ªå®šä¹‰æˆ˜æœ¯         | â‰¤3æ­¥        | >60%      |
      | æ•°æ®å¯¼å‡º           | â‰¤4æ­¥        | >40%      |
      | é«˜çº§ç­›é€‰           | â‰¤3æ­¥        | >55%      |
      | æ‰¹é‡æ“ä½œ           | â‰¤2æ­¥        | >70%      |
    And åŠŸèƒ½å±‚æ¬¡ç»“æ„åº”æ¸…æ™°
    And ç”¨æˆ·ä¸åº”æ„Ÿåˆ°åŠŸèƒ½è¿‡è½½

  @accessibility @user-experience
  Scenario: åŠŸèƒ½å¯è®¿é—®æ€§å’Œæ˜“ç”¨æ€§éªŒæ”¶
    Given ä¸åŒç±»å‹çš„ç”¨æˆ·ç¾¤ä½“
    When æµ‹è¯•åŠŸèƒ½å‘ç°çš„æ˜“ç”¨æ€§
      | ç”¨æˆ·ç±»å‹           | ç‰¹æ®Šéœ€æ±‚         | å‘ç°ç‡è¦æ±‚ |
      | æ–°æ‰‹ç”¨æˆ·           | ç®€åŒ–ç•Œé¢         | >80%      |
      | ç»éªŒç”¨æˆ·           | é«˜æ•ˆæ“ä½œ         | >95%      |
      | ç§»åŠ¨ç«¯ç”¨æˆ·         | è§¦æ§ä¼˜åŒ–         | >85%      |
      | è§†è§‰éšœç¢ç”¨æˆ·       | æ— éšœç¢æ”¯æŒ       | >70%      |
    Then æ‰€æœ‰ç”¨æˆ·ç¾¤ä½“åº”è¾¾åˆ°å¯¹åº”çš„å‘ç°ç‡è¦æ±‚
    And åŠŸèƒ½åº”éµå¾ªå¯è®¿é—®æ€§æ ‡å‡†
    And ç”¨æˆ·åé¦ˆåº”ç§¯ææ­£é¢
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/feature-discoverability.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { FeatureDiscoveryTracker } from '@/analytics/FeatureDiscoveryTracker';
import { UserInteractionSimulator } from '@/testing/UserInteractionSimulator';
import { AccessibilityTester } from '@/testing/AccessibilityTester';

describe('åŠŸèƒ½å‘ç°ç‡éªŒæ”¶', () => {
  let discoveryTracker: FeatureDiscoveryTracker;
  let interactionSimulator: UserInteractionSimulator;
  let accessibilityTester: AccessibilityTester;

  beforeEach(async () => {
    discoveryTracker = new FeatureDiscoveryTracker();
    interactionSimulator = new UserInteractionSimulator();
    accessibilityTester = new AccessibilityTester();

    await discoveryTracker.initialize();
    await interactionSimulator.start();
  });

  afterEach(async () => {
    discoveryTracker.stop();
    interactionSimulator.stop();
  });

  it(
    'æ ¸å¿ƒåŠŸèƒ½å‘ç°ç‡éªŒæ”¶',
    async () => {
      // Given: 100åç”¨æˆ·å®Œæˆäº†æ–°æ‰‹å¼•å¯¼
      const testUsers = interactionSimulator.generatePostOnboardingUsers(100);

      const coreFeatures = [
        { name: 'æˆå‘˜ç®¡ç†', discoveryTarget: 90, usageTarget: 80 },
        { name: 'æ´»åŠ¨ç»„ç»‡', discoveryTarget: 85, usageTarget: 70 },
        { name: 'æˆ˜æœ¯ä¸­å¿ƒ', discoveryTarget: 80, usageTarget: 60 },
        { name: 'ç¤¾äº¤äº’åŠ¨', discoveryTarget: 85, usageTarget: 65 },
        { name: 'æ•°æ®ç»Ÿè®¡', discoveryTarget: 75, usageTarget: 50 },
        { name: 'èµ„æºç®¡ç†', discoveryTarget: 80, usageTarget: 60 },
      ];

      const discoveryResults = [];

      // When: ç”¨æˆ·åœ¨é¦–æ¬¡30åˆ†é’Ÿæ¸¸æˆæ—¶é—´å†…è‡ªç”±æ¢ç´¢
      for (const user of testUsers) {
        const explorationSession =
          await interactionSimulator.simulateExplorationSession({
            userId: user.id,
            duration: 30 * 60 * 1000, // 30åˆ†é’Ÿ
            explorationStyle: user.explorationStyle,
            trackFeatureDiscovery: true,
            trackUsagePatterns: true,
          });

        discoveryResults.push(explorationSession);
      }

      // åˆ†æåŠŸèƒ½å‘ç°ç‡å’Œä½¿ç”¨ç‡
      const featureAnalysis = coreFeatures.map(feature => {
        const discovered = discoveryResults.filter(session =>
          session.discoveredFeatures.includes(feature.name)
        ).length;
        const used = discoveryResults.filter(session =>
          session.usedFeatures.includes(feature.name)
        ).length;

        return {
          feature: feature.name,
          discoveryRate: (discovered / testUsers.length) * 100,
          usageRate: (used / testUsers.length) * 100,
          discoveryTarget: feature.discoveryTarget,
          usageTarget: feature.usageTarget,
        };
      });

      // Then: éªŒè¯åŠŸèƒ½å‘ç°è¦æ±‚

      // å„åŠŸèƒ½å‘ç°ç‡åº”è¾¾åˆ°ç›®æ ‡
      for (const analysis of featureAnalysis) {
        expect(analysis.discoveryRate).toBeGreaterThanOrEqual(
          analysis.discoveryTarget
        );
        expect(analysis.usageRate).toBeGreaterThanOrEqual(analysis.usageTarget);
      }

      // æ•´ä½“åŠŸèƒ½å‘ç°ç‡åº” â‰¥ 85%
      const overallDiscoveryRate =
        featureAnalysis.reduce(
          (sum, analysis) => sum + analysis.discoveryRate,
          0
        ) / featureAnalysis.length;
      expect(overallDiscoveryRate).toBeGreaterThanOrEqual(85);

      // ç”¨æˆ·åº”è¡¨ç¤ºç•Œé¢ç›´è§‚æ˜“æ‡‚
      const uiClarity = discoveryResults
        .map(session => session.uiClarityRating)
        .filter(rating => rating > 0);
      const averageUIClarity =
        uiClarity.reduce((sum, rating) => sum + rating, 0) / uiClarity.length;
      expect(averageUIClarity).toBeGreaterThanOrEqual(7); // 7/10åˆ†ä»¥ä¸Š

      // åŠŸèƒ½å…¥å£åº”æ˜“äºæ‰¾åˆ°
      const entryPointDifficulty = discoveryResults
        .map(session => session.averageStepsToFeature)
        .filter(steps => steps > 0);
      const averageStepsToFeatures =
        entryPointDifficulty.reduce((sum, steps) => sum + steps, 0) /
        entryPointDifficulty.length;
      expect(averageStepsToFeatures).toBeLessThanOrEqual(3); // å¹³å‡3æ­¥å†…æ‰¾åˆ°åŠŸèƒ½

      console.log('æ ¸å¿ƒåŠŸèƒ½å‘ç°ç‡æµ‹è¯•ç»“æœ:', {
        æ•´ä½“å‘ç°ç‡: overallDiscoveryRate.toFixed(2) + '%',
        ç•Œé¢ç›´è§‚åº¦: averageUIClarity.toFixed(1) + '/10',
        å¹³å‡æŸ¥æ‰¾æ­¥æ•°: averageStepsToFeatures.toFixed(1) + 'æ­¥',
        å„åŠŸèƒ½è¯¦æƒ…: featureAnalysis
          .map(
            analysis =>
              `${analysis.feature}: å‘ç°ç‡${analysis.discoveryRate.toFixed(1)}% ä½¿ç”¨ç‡${analysis.usageRate.toFixed(1)}%`
          )
          .join(', '),
      });
    },
    45 * 60 * 1000
  ); // 45åˆ†é’Ÿè¶…æ—¶

  it(
    'åŠŸèƒ½å¯è®¿é—®æ€§å’Œæ˜“ç”¨æ€§éªŒæ”¶',
    async () => {
      // Given: ä¸åŒç±»å‹çš„ç”¨æˆ·ç¾¤ä½“
      const userGroups = [
        {
          type: 'newbie',
          specialNeeds: 'ç®€åŒ–ç•Œé¢',
          discoveryTarget: 80,
          count: 50,
        },
        {
          type: 'experienced',
          specialNeeds: 'é«˜æ•ˆæ“ä½œ',
          discoveryTarget: 95,
          count: 30,
        },
        {
          type: 'mobile',
          specialNeeds: 'è§¦æ§ä¼˜åŒ–',
          discoveryTarget: 85,
          count: 40,
        },
        {
          type: 'visually-impaired',
          specialNeeds: 'æ— éšœç¢æ”¯æŒ',
          discoveryTarget: 70,
          count: 25,
        },
      ];

      const accessibilityResults = {};

      // When: æµ‹è¯•åŠŸèƒ½å‘ç°çš„æ˜“ç”¨æ€§
      for (const group of userGroups) {
        const groupUsers = interactionSimulator.generateSpecializedUsers(
          group.type,
          group.count
        );

        const groupResults = await Promise.all(
          groupUsers.map(async user => {
            // é…ç½®ç‰¹æ®Šéœ€æ±‚ç¯å¢ƒ
            await accessibilityTester.configureForUserType(group.type);

            const accessibilitySession =
              await interactionSimulator.simulateAccessibilityTest({
                userId: user.id,
                userType: group.type,
                specialNeeds: group.specialNeeds,
                duration: 20 * 60 * 1000, // 20åˆ†é’Ÿ
                trackDiscoveryPath: true,
                measureUsability: true,
              });

            return accessibilitySession;
          })
        );

        accessibilityResults[group.type] = {
          ...group,
          results: groupResults,
          discoveryRate:
            (groupResults.filter(result => result.successfulDiscovery).length /
              group.count) *
            100,
          averageUsabilityScore:
            groupResults.reduce(
              (sum, result) => sum + result.usabilityScore,
              0
            ) / group.count,
          averageTaskCompletionTime:
            groupResults.reduce(
              (sum, result) => sum + result.taskCompletionTime,
              0
            ) / group.count,
        };
      }

      // Then: éªŒè¯å¯è®¿é—®æ€§è¦æ±‚

      // æ‰€æœ‰ç”¨æˆ·ç¾¤ä½“åº”è¾¾åˆ°å¯¹åº”çš„å‘ç°ç‡è¦æ±‚
      for (const groupType of Object.keys(accessibilityResults)) {
        const groupData = accessibilityResults[groupType];
        expect(groupData.discoveryRate).toBeGreaterThanOrEqual(
          groupData.discoveryTarget
        );

        // ç”¨æˆ·åé¦ˆåº”ç§¯ææ­£é¢ (â‰¥7åˆ†)
        expect(groupData.averageUsabilityScore).toBeGreaterThanOrEqual(7);
      }

      // åŠŸèƒ½åº”éµå¾ªå¯è®¿é—®æ€§æ ‡å‡†
      const accessibilityCompliance =
        await accessibilityTester.runComplianceCheck({
          standards: ['WCAG-2.1-AA', 'Section-508'],
          scope: 'core-features',
        });
      expect(accessibilityCompliance.overallScore).toBeGreaterThanOrEqual(90); // 90%åˆè§„ç‡

      console.log('åŠŸèƒ½å¯è®¿é—®æ€§æµ‹è¯•ç»“æœ:', {
        æ–°æ‰‹ç”¨æˆ·å‘ç°ç‡:
          accessibilityResults.newbie?.discoveryRate.toFixed(1) + '%',
        ç»éªŒç”¨æˆ·å‘ç°ç‡:
          accessibilityResults.experienced?.discoveryRate.toFixed(1) + '%',
        ç§»åŠ¨ç«¯ç”¨æˆ·å‘ç°ç‡:
          accessibilityResults.mobile?.discoveryRate.toFixed(1) + '%',
        è§†éšœç”¨æˆ·å‘ç°ç‡:
          accessibilityResults['visually-impaired']?.discoveryRate.toFixed(1) +
          '%',
        æ— éšœç¢åˆè§„ç‡: accessibilityCompliance.overallScore + '%',
      });
    },
    30 * 60 * 1000
  ); // 30åˆ†é’Ÿè¶…æ—¶
});
```

#### 11.6.3 ç”¨æˆ·ç•™å­˜æŒ‡æ ‡éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/user-retention.feature
Feature: ç”¨æˆ·ç•™å­˜æŒ‡æ ‡éªŒæ”¶
  ä½œä¸ºä¸šåŠ¡è´Ÿè´£äººï¼Œæˆ‘éœ€è¦ç¡®ä¿äº§å“èƒ½å¤Ÿæœ‰æ•ˆç•™å­˜ç”¨æˆ·

  Background:
    Given ç”¨æˆ·è¡Œä¸ºè¿½è¸ªç³»ç»Ÿå·²å¯ç”¨
    And ç•™å­˜åˆ†æå·¥å…·å·²é…ç½®
    And ç”¨æˆ·åé¦ˆæ”¶é›†ç³»ç»Ÿå·²å‡†å¤‡å°±ç»ª

  @business-critical @kpi-validation
  Scenario: æ ¸å¿ƒç•™å­˜æŒ‡æ ‡éªŒæ”¶
    Given 1000åæ–°ç”¨æˆ·æ³¨å†Œå¹¶å¼€å§‹æ¸¸æˆ
    When è¿½è¸ªç”¨æˆ·åœ¨ä¸åŒæ—¶æœŸçš„ç•™å­˜æƒ…å†µ
    Then ç”¨æˆ·ç•™å­˜åº”æ»¡è¶³ä»¥ä¸‹æŒ‡æ ‡
      | ç•™å­˜å‘¨æœŸ    | ç•™å­˜ç‡è¦æ±‚ | æ´»è·ƒåº¦è¦æ±‚    |
      | æ¬¡æ—¥ç•™å­˜(D1) | â‰¥60%      | >10åˆ†é’Ÿæ¸¸æˆæ—¶é—´ |
      | 7æ—¥ç•™å­˜(D7)  | â‰¥40%      | >30åˆ†é’Ÿæ¸¸æˆæ—¶é—´ |
      | 30æ—¥ç•™å­˜(D30)| â‰¥25%      | >1å°æ—¶æ¸¸æˆæ—¶é—´  |
      | 90æ—¥ç•™å­˜(D90)| â‰¥15%      | >2å°æ—¶æ¸¸æˆæ—¶é—´  |
    And æµå¤±ç”¨æˆ·åº”æä¾›æ˜ç¡®çš„æµå¤±åŸå› 
    And ç•™å­˜ç”¨æˆ·åº”è¡¨ç°å‡ºæŒç»­çš„å‚ä¸åº¦å¢é•¿
    And æ ¸å¿ƒåŠŸèƒ½ä½¿ç”¨é¢‘ç‡åº”ä¿æŒç¨³å®šæˆ–å¢é•¿

  Scenario: ç”¨æˆ·å‚ä¸æ·±åº¦éªŒæ”¶
    Given ç•™å­˜ç”¨æˆ·çš„è¡Œä¸ºæ•°æ®
    When åˆ†æç”¨æˆ·å‚ä¸çš„æ·±åº¦å’Œè´¨é‡
    Then ç”¨æˆ·å‚ä¸åº”è¡¨ç°å‡ºä»¥ä¸‹ç‰¹å¾
      | å‚ä¸æŒ‡æ ‡           | åˆæ ¼æ ‡å‡†     |
      | åŠŸèƒ½ä½¿ç”¨è¦†ç›–åº¦     | >70%æ ¸å¿ƒåŠŸèƒ½  |
      | å¹³å‡ä¼šè¯æ—¶é•¿       | >45åˆ†é’Ÿ      |
      | ä¼šè¯é¢‘ç‡           | æ¯å‘¨â‰¥3æ¬¡     |
      | ç”¨æˆ·ç”Ÿæˆå†…å®¹       | >60%ç”¨æˆ·äº§å‡º  |
      | ç¤¾äº¤äº’åŠ¨é¢‘ç‡       | >50%ç”¨æˆ·å‚ä¸  |
    And ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ†åº” â‰¥ 8/10
    And ç”¨æˆ·æ¨èæ„æ„¿åº” â‰¥ 70%

  @churn-analysis @retention-optimization
  Scenario: æµå¤±é¢„è­¦ä¸æŒ½å›éªŒæ”¶
    Given ç”¨æˆ·æµå¤±é¢„æµ‹æ¨¡å‹å·²è®­ç»ƒ
    When è¯†åˆ«æ½œåœ¨æµå¤±ç”¨æˆ·å¹¶æ‰§è¡ŒæŒ½å›ç­–ç•¥
    Then æµå¤±é¢„è­¦ç³»ç»Ÿåº”è¾¾åˆ°ä»¥ä¸‹æ ‡å‡†
      | é¢„è­¦èƒ½åŠ›         | å‡†ç¡®åº¦è¦æ±‚ |
      | 7æ—¥æµå¤±é¢„è­¦      | >80%      |
      | 30æ—¥æµå¤±é¢„è­¦     | >75%      |
      | 90æ—¥æµå¤±é¢„è­¦     | >70%      |
    And æŒ½å›ç­–ç•¥å®æ–½åæµå¤±ç‡åº”é™ä½ â‰¥ 30%
    And è¢«æŒ½å›ç”¨æˆ·çš„åç»­ç•™å­˜ç‡åº” â‰¥ 50%
    And æŒ½å›æˆæœ¬åº”åœ¨åˆç†èŒƒå›´å†…
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/user-retention.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { RetentionAnalytics } from '@/analytics/RetentionAnalytics';
import { ChurnPredictionModel } from '@/ml/ChurnPredictionModel';
import { UserLifecycleSimulator } from '@/testing/UserLifecycleSimulator';

describe('ç”¨æˆ·ç•™å­˜æŒ‡æ ‡éªŒæ”¶', () => {
  let retentionAnalytics: RetentionAnalytics;
  let churnModel: ChurnPredictionModel;
  let lifecycleSimulator: UserLifecycleSimulator;

  beforeEach(async () => {
    retentionAnalytics = new RetentionAnalytics();
    churnModel = new ChurnPredictionModel();
    lifecycleSimulator = new UserLifecycleSimulator();

    await retentionAnalytics.initialize();
    await churnModel.load();
  });

  it('æ ¸å¿ƒç•™å­˜æŒ‡æ ‡éªŒæ”¶', async () => {
    // Given: 1000åæ–°ç”¨æˆ·æ³¨å†Œå¹¶å¼€å§‹æ¸¸æˆ
    const newUserCohort = lifecycleSimulator.generateUserCohort(1000);

    const retentionTargets = [
      { period: 'D1', targetRate: 60, minActiveTime: 10 * 60 * 1000 },   // æ¬¡æ—¥ç•™å­˜60%ï¼Œæ´»è·ƒ>10åˆ†é’Ÿ
      { period: 'D7', targetRate: 40, minActiveTime: 30 * 60 * 1000 },   // 7æ—¥ç•™å­˜40%ï¼Œæ´»è·ƒ>30åˆ†é’Ÿ
      { period: 'D30', targetRate: 25, minActiveTime: 60 * 60 * 1000 },  // 30æ—¥ç•™å­˜25%ï¼Œæ´»è·ƒ>1å°æ—¶
      { period: 'D90', targetRate: 15, minActiveTime: 120 * 60 * 1000 }  // 90æ—¥ç•™å­˜15%ï¼Œæ´»è·ƒ>2å°æ—¶
    ];

    // When: è¿½è¸ªç”¨æˆ·åœ¨ä¸åŒæ—¶æœŸçš„ç•™å­˜æƒ…å†µ
    const retentionResults = await lifecycleSimulator.simulateUserLifecycle({
      cohort: newUserCohort,
      trackingPeriod: 90, // å¤©
      measureRetention: true,
      measureEngagement: true,
      trackChurnReasons: true
    });

    const cohortAnalysis = await retentionAnalytics.analyzeCohortRetention({
      cohortId: retentionResults.cohortId,
      periods: retentionTargets.map(target => target.period)
    });

    // Then: éªŒè¯ç•™å­˜æŒ‡æ ‡è¦æ±‚

    // å„å‘¨æœŸç•™å­˜ç‡åº”æ»¡è¶³è¦æ±‚
    for (const target of retentionTargets) {
      const periodData = cohortAnalysis.retentionByPeriod[target.period];

      // ç•™å­˜ç‡è¾¾æ ‡
      expect(periodData.retentionRate).toBeGreaterThanOrEqual(target.targetRate);

      // ç•™å­˜ç”¨æˆ·æ´»è·ƒåº¦è¾¾æ ‡
      const activeRetainedUsers = periodData.retainedUsers.filter(user =>
        user.activeTime >= target.minActiveTime
      );
      const activeRetentionRate = (activeRetainedUsers.length / periodData.retainedUsers.length) * 100;
      expect(activeRetentionRate).toBeGreaterThanOrEqual(90); // 90%çš„ç•™å­˜ç”¨æˆ·åº”è¾¾åˆ°æ´»è·ƒåº¦è¦æ±‚
    }

    // æµå¤±ç”¨æˆ·åº”æä¾›æ˜ç¡®çš„æµå¤±åŸå› 
    const churnAnalysis = cohortAnalysis.churnAnalysis;
    expect(churnAnalysis.identifiedReasons.length).toBeGreaterThan(0);
    const reasonCoverage = (churnAnalysis.reasonsIdentifiedCount / churnAnalysis.totalChurnedUsers) * 100;
    expect(reasonCoverage).toBeGreaterThanOrEqual(80); // 80%çš„æµå¤±ç”¨æˆ·æœ‰æ˜ç¡®åŸå› 

    // ç•™å­˜ç”¨æˆ·åº”è¡¨ç°å‡ºæŒç»­çš„å‚ä¸åº¦å¢é•¿
    const engagementTrend = cohortAnalysis.engagementTrend;
    expect(engagementTrend.overallTrend).toBeGreaterThanOrEqual(0.1); // æ­£å¢é•¿è¶‹åŠ¿

    console.log('æ ¸å¿ƒç•™å­˜æŒ‡æ ‡æµ‹è¯•ç»“æœ:', {
      D1ç•™å­˜ç‡: cohortAnalysis.retentionByPeriod.D1.retentionRate + '%',
      D7ç•™å­˜ç‡: cohortAnalysis.retentionByPeriod.D7.retentionRate + '%',
      D30ç•™å­˜ç‡: cohortAnalysis.retentionByPeriod.D30.retentionRate + '%',
      D90ç•™å­˜ç‡: cohortAnalysis.retentionByPeriod.D90.retentionRate + '%',
      æµå¤±åŸå› è¯†åˆ«è¦†ç›–ç‡: reasonCoverage.toFixed(1) + '%',
      å‚ä¸åº¦è¶‹åŠ¿: engagementTrend.overallTrend > 0 ? 'å¢é•¿' : 'ä¸‹é™'
    });
  }, 30 * 60 * 1000); // 30åˆ†é’Ÿè¶…æ—¶

  it('æµå¤±é¢„è­¦ä¸æŒ½å›éªŒæ”¶', async () => {
    // Given: ç”¨æˆ·æµå¤±é¢„æµ‹æ¨¡å‹å·²è®­ç»ƒ
    const historicalData = lifecycleSimulator.generateHistoricalUserData(5000);
    await churnModel.train(historicalData);

    const churnPredictionTargets = [
      { period: 7, accuracyTarget: 80 },   // 7æ—¥æµå¤±é¢„è­¦å‡†ç¡®åº¦>80%
      { period: 30, accuracyTarget: 75 },  // 30æ—¥æµå¤±é¢„è­¦å‡†ç¡®åº¦>75%
      { period: 90, accuracyTarget: 70 }   // 90æ—¥æµå¤±é¢„è­¦å‡†ç¡®åº¦>70%
    ];

    // ç”Ÿæˆæµ‹è¯•ç”¨æˆ·ç¾¤ä½“
    const testUsers = lifecycleSimulator.generateUserCohort(1000);

    // When: è¯†åˆ«æ½œåœ¨æµå¤±ç”¨æˆ·å¹¶æ‰§è¡ŒæŒ½å›ç­–ç•¥
    const churnPredictionResults = [];
    const retentionCampaignResults = [];

    for (const target of churnPredictionTargets) {
      // é¢„æµ‹æµå¤±ç”¨æˆ·
      const churnPredictions = await churnModel.predictChurn({
        users: testUsers,
        predictionHorizon: target.period,
        includeConfidenceScore: true
      });

      // æ‰§è¡Œç”¨æˆ·ç”Ÿå‘½å‘¨æœŸæ¨¡æ‹Ÿä»¥éªŒè¯é¢„æµ‹å‡†ç¡®æ€§
      const actualChurnResults = await lifecycleSimulator.simulateChurnBehavior({
        users: testUsers,
        period: target.period,
        realChurnPatterns: true
      });

      // è®¡ç®—é¢„æµ‹å‡†ç¡®åº¦
      const accuracy = this.calculatePredictionAccuracy(churnPredictions, actualChurnResults);

      churnPredictionResults.push({
        period: target.period,
        accuracy,
        target: target.accuracyTarget
      });

      // å¯¹é¢„æµ‹çš„æµå¤±ç”¨æˆ·æ‰§è¡ŒæŒ½å›ç­–ç•¥
      const retentionCampaign = await lifecycleSimulator.simulateRetentionCampaign({
        predictedChurnUsers: churnPredictions.filter(pred => pred.churnProbability > 0.7),
        strategies: ['personalized-incentives', 'engagement-boost', 'support-outreach'],
        campaignDuration: 14 // 14å¤©æŒ½å›å‘¨æœŸ
      });

      retentionCampaignResults.push({
        period: target.period,
        ...retentionCampaign
      });
    }

    // Then: éªŒè¯æµå¤±é¢„è­¦ç³»ç»Ÿæ ‡å‡†

    // å„æœŸé—´é¢„è­¦å‡†ç¡®åº¦åº”è¾¾æ ‡
    for (const result of churnPredictionResults) {
      expect(result.accuracy).toBeGreaterThanOrEqual(result.target);
    }

    // æŒ½å›ç­–ç•¥å®æ–½åæµå¤±ç‡åº”é™ä½ â‰¥ 30%
    for (const campaign of retentionCampaignResults) {
      const churnReduction = ((campaign.originalChurnRate - campaign.postCampaignChurnRate) / campaign.originalChurnRate) * 100;
      expect(churnReduction).toBeGreaterThanOrEqual(30);

      // è¢«æŒ½å›ç”¨æˆ·çš„åç»­ç•™å­˜ç‡åº” â‰¥ 50%
      expect(campaign.recoveredUserRetentionRate).toBeGreaterThanOrEqual(50);

      // æŒ½å›æˆæœ¬åº”åœ¨åˆç†èŒƒå›´å†… (æ¯ç”¨æˆ·<$10)
      expect(campaign.costPerRecoveredUser).toBeLessThanOrEqual(10);
    }

    console.log('æµå¤±é¢„è­¦ä¸æŒ½å›æµ‹è¯•ç»“æœ:', {
      é¢„æµ‹å‡†ç¡®åº¦: churnPredictionResults.map(result =>
        `${result.period}æ—¥: ${result.accuracy}%`
      ).join(', '),
      å¹³å‡æµå¤±é™ä½: (retentionCampaignResults.reduce((sum, campaign) =>
        sum + ((campaign.originalChurnRate - campaign.postCampaignChurnRate) / campaign.originalChurnRate) * 100, 0
      ) / retentionCampaignResults.length).toFixed(1) + '%',
      å¹³å‡æŒ½å›æˆæœ¬: '$' + (retentionCampaignResults.reduce((sum, campaign) =>
        sum + campaign.costPerRecoveredUser, 0
      ) / retentionCampaignResults.length).toFixed(2)
    });
  }, 20 * 60 * 1000); // 20åˆ†é’Ÿè¶…æ—¶

  // è¾…åŠ©æ–¹æ³•
  private calculatePredictionAccuracy(predictions: any[], actualResults: any[]): number {
    let correctPredictions = 0;

    for (const prediction of predictions) {
      const actual = actualResults.find(result => result.userId === prediction.userId);
      if (actual) {
        const predictedChurn = prediction.churnProbability > 0.5;
        const actualChurn = actual.churned;

        if (predictedChurn === actualChurn) {
          correctPredictions++;
        }
      }
    }

    return (correctPredictions / predictions.length) * 100;
  }
});
```

### 11.7 è¾¹ç•Œæ¡ä»¶å’Œå¤±è´¥è·¯å¾„éªŒæ”¶è§„èŒƒï¼ˆBoundary & Failure Path Acceptanceï¼‰

#### 11.7.1 å†…å­˜å³°å€¼æ§åˆ¶éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/memory-boundary-control.feature
Feature: å†…å­˜å³°å€¼æ§åˆ¶éªŒæ”¶
  ä½œä¸ºç³»ç»Ÿè¿ç»´å·¥ç¨‹å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿åº”ç”¨åœ¨å„ç§å†…å­˜å‹åŠ›åœºæ™¯ä¸‹éƒ½èƒ½ç¨³å®šè¿è¡Œ

  Background:
    Given ç³»ç»Ÿå†…å­˜ç›‘æ§å·²å¯ç”¨
    And å†…å­˜é˜ˆå€¼å‘Šè­¦å·²é…ç½®
    And åƒåœ¾å›æ”¶ç›‘æ§å·²å‡†å¤‡å°±ç»ª

  Scenario: æ­£å¸¸è´Ÿè½½å†…å­˜å³°å€¼éªŒæ”¶
    Given åº”ç”¨è¿è¡Œåœ¨æ ‡å‡†è´Ÿè½½ä¸‹
    When æ‰§è¡Œä»¥ä¸‹å†…å­˜å¯†é›†å‹æ“ä½œ
      | æ“ä½œç±»å‹             | æ•°æ®è§„æ¨¡    | å†…å­˜å³°å€¼é™åˆ¶ |
      | å¤§è§„æ¨¡äº‹ä»¶å¤„ç†       | 1000+äº‹ä»¶   | <800MB      |
      | AIå®ä½“æ‰¹é‡è®¡ç®—       | 200+å®ä½“    | <600MB      |
      | å­˜æ¡£æ•°æ®åŠ è½½         | 10MBå­˜æ¡£    | <400MB      |
      | å¤æ‚æŸ¥è¯¢ç»Ÿè®¡         | å…¨é‡æ•°æ®    | <300MB      |
    Then å†…å­˜ä½¿ç”¨å³°å€¼ä¸åº”è¶…è¿‡2GB
    And å†…å­˜å¢é•¿ç‡åº”<10MB/åˆ†é’Ÿ
    And åƒåœ¾å›æ”¶é¢‘ç‡åº”åˆç†(æ¯5åˆ†é’Ÿâ‰¤1æ¬¡)
    And ä¸åº”å‡ºç°å†…å­˜æ³„æ¼

  Scenario: æé™è´Ÿè½½å†…å­˜å‹åŠ›æµ‹è¯•
    Given ç³»ç»Ÿå¤„äºæé™è´Ÿè½½çŠ¶æ€
    When åŒæ—¶æ‰§è¡Œæ‰€æœ‰å†…å­˜å¯†é›†å‹æ“ä½œæŒç»­1å°æ—¶
    Then å†…å­˜ä½¿ç”¨ä¸åº”è¶…è¿‡4GBç¡¬é™åˆ¶
    And ç³»ç»Ÿåº”å¯åŠ¨å†…å­˜å‹åŠ›ç¼“è§£æœºåˆ¶
    And ä½ä¼˜å…ˆçº§æ“ä½œåº”è¢«æš‚åœæˆ–é™çº§
    And æ ¸å¿ƒåŠŸèƒ½åº”ä¿æŒå¯ç”¨

  @critical-failure @memory-exhaustion
  Scenario: å†…å­˜è€—å°½æ¢å¤éªŒæ”¶
    Given ç³»ç»Ÿå¯ç”¨å†…å­˜æ¥è¿‘è€—å°½(>95%ä½¿ç”¨)
    When è§¦å‘å†…å­˜ä¿æŠ¤æœºåˆ¶
    Then ç³»ç»Ÿåº”ä¼˜é›…é™çº§è€Œä¸æ˜¯å´©æºƒ
    And åº”é‡Šæ”¾éå…³é”®å†…å­˜ç¼“å­˜
    And åº”æš‚åœæ–°çš„å†…å­˜åˆ†é…è¯·æ±‚
    And åº”ä¿ç•™ç”¨æˆ·æ ¸å¿ƒåŠŸèƒ½å¯ç”¨
    And å†…å­˜é‡Šæ”¾ååº”èƒ½æ­£å¸¸æ¢å¤
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/memory-boundary-control.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { MemoryMonitor } from '@/shared/monitoring/MemoryMonitor';
import { ResourceManager } from '@/core/ResourceManager';
import { StressTestSimulator } from '@/testing/StressTestSimulator';

describe('å†…å­˜å³°å€¼æ§åˆ¶éªŒæ”¶', () => {
  let memoryMonitor: MemoryMonitor;
  let resourceManager: ResourceManager;
  let stressSimulator: StressTestSimulator;

  beforeEach(async () => {
    memoryMonitor = new MemoryMonitor();
    resourceManager = new ResourceManager();
    stressSimulator = new StressTestSimulator();

    await memoryMonitor.start();
    await resourceManager.initialize();
  });

  it(
    'æ­£å¸¸è´Ÿè½½å†…å­˜å³°å€¼éªŒæ”¶',
    async () => {
      // Given: åº”ç”¨è¿è¡Œåœ¨æ ‡å‡†è´Ÿè½½ä¸‹
      await stressSimulator.establishStandardLoad();

      const memoryIntensiveOperations = [
        { type: 'å¤§è§„æ¨¡äº‹ä»¶å¤„ç†', dataScale: 1000, memoryLimit: 800 },
        { type: 'AIå®ä½“æ‰¹é‡è®¡ç®—', dataScale: 200, memoryLimit: 600 },
        { type: 'å­˜æ¡£æ•°æ®åŠ è½½', dataScale: 10, memoryLimit: 400 },
        { type: 'å¤æ‚æŸ¥è¯¢ç»Ÿè®¡', dataScale: 'full', memoryLimit: 300 },
      ];

      // éªŒè¯å†…å­˜ä½¿ç”¨å³°å€¼ä¸åº”è¶…è¿‡2GB
      const peakMemoryUsage = await memoryMonitor.getPeakMemoryUsage();
      expect(peakMemoryUsage / (1024 * 1024 * 1024)).toBeLessThanOrEqual(2);

      console.log('å†…å­˜å³°å€¼æ§åˆ¶æµ‹è¯•ç»“æœ:', {
        å³°å€¼å†…å­˜: (peakMemoryUsage / (1024 * 1024)).toFixed(2) + 'MB',
      });
    },
    15 * 60 * 1000
  ); // 15åˆ†é’Ÿè¶…æ—¶
});
```

#### 11.7.2 é”™è¯¯æ¢å¤æœºåˆ¶éªŒæ”¶

**Gherkinåœºæ™¯**ï¼š

```gherkin
# docs/acceptance/error-recovery-mechanisms.feature
Feature: é”™è¯¯æ¢å¤æœºåˆ¶éªŒæ”¶
  ä½œä¸ºç³»ç»Ÿå¯é æ€§å·¥ç¨‹å¸ˆï¼Œæˆ‘éœ€è¦ç¡®ä¿ç³»ç»Ÿèƒ½å¤Ÿä»å„ç§é”™è¯¯çŠ¶æ€ä¸­è‡ªåŠ¨æ¢å¤

  Background:
    Given é”™è¯¯ç›‘æ§ç³»ç»Ÿå·²å¯ç”¨
    And è‡ªåŠ¨æ¢å¤æœºåˆ¶å·²é…ç½®
    And é”™è¯¯æ—¥å¿—è®°å½•å·²å‡†å¤‡å°±ç»ª

  Scenario: æ¨¡å—çº§é”™è¯¯æ¢å¤éªŒæ”¶
    Given ç³»ç»Ÿæ­£åœ¨æ­£å¸¸è¿è¡Œ
    When ä»¥ä¸‹æ¨¡å—å‘ç”Ÿé”™è¯¯
      | é”™è¯¯æ¨¡å—           | é”™è¯¯ç±»å‹       | é¢„æœŸæ¢å¤æ—¶é—´ | å½±å“èŒƒå›´     |
      | äº‹ä»¶å¤„ç†å¼•æ“       | é€»è¾‘å¼‚å¸¸       | <3ç§’        | å•ä¸ªäº‹ä»¶     |
      | AIè®¡ç®—æ¨¡å—         | è®¡ç®—æº¢å‡º       | <5ç§’        | å•ä¸ªAIå®ä½“   |
      | æ•°æ®å­˜å‚¨å±‚         | å†™å…¥å¤±è´¥       | <2ç§’        | å•æ¬¡æ“ä½œ     |
      | UIæ¸²æŸ“æ¨¡å—         | æ¸²æŸ“å¼‚å¸¸       | <1ç§’        | å•ä¸ªç»„ä»¶     |
    Then æ¯ä¸ªæ¨¡å—åº”èƒ½è‡ªåŠ¨æ£€æµ‹é”™è¯¯
    And é”™è¯¯åº”è¢«éš”ç¦»ä¸å½±å“å…¶ä»–æ¨¡å—
    And æ¨¡å—åº”åœ¨é¢„æœŸæ—¶é—´å†…æ¢å¤
    And ç”¨æˆ·åº”æ„ŸçŸ¥åˆ°æœ€å°çš„åŠŸèƒ½ä¸­æ–­

  @data-integrity @critical-recovery
  Scenario: æ•°æ®å®Œæ•´æ€§ä¿æŠ¤éªŒæ”¶
    Given ç”¨æˆ·æ­£åœ¨è¿›è¡Œé‡è¦æ“ä½œ(ä¿å­˜æ¸¸æˆã€è®¾ç½®é…ç½®)
    When æ“ä½œè¿‡ç¨‹ä¸­å‘ç”Ÿç³»ç»Ÿé”™è¯¯
    Then æ•°æ®å®Œæ•´æ€§åº”è¢«ä¿æŠ¤
    And éƒ¨åˆ†å®Œæˆçš„æ“ä½œåº”è¢«å›æ»š
    And ç”¨æˆ·åº”æ”¶åˆ°æ˜ç¡®çš„çŠ¶æ€åé¦ˆ
    And é‡è¯•æœºåˆ¶åº”å¯ç”¨ä¸”æœ‰æ•ˆ
    And æ•°æ®ä¸åº”å‡ºç°ä¸ä¸€è‡´çŠ¶æ€
```

**å¯¹åº”Vitestæµ‹è¯•**ï¼š

```typescript
// tests/acceptance/error-recovery-mechanisms.spec.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ErrorRecoverySystem } from '@/core/ErrorRecoverySystem';
import { ModuleHealthMonitor } from '@/monitoring/ModuleHealthMonitor';
import { ErrorSimulator } from '@/testing/ErrorSimulator';

describe('é”™è¯¯æ¢å¤æœºåˆ¶éªŒæ”¶', () => {
  let recoverySystem: ErrorRecoverySystem;
  let healthMonitor: ModuleHealthMonitor;
  let errorSimulator: ErrorSimulator;

  beforeEach(async () => {
    recoverySystem = new ErrorRecoverySystem();
    healthMonitor = new ModuleHealthMonitor();
    errorSimulator = new ErrorSimulator();

    await recoverySystem.initialize();
    await healthMonitor.start();
  });

  it('æ¨¡å—çº§é”™è¯¯æ¢å¤éªŒæ”¶', async () => {
    // æ¯ä¸ªæ¨¡å—åº”èƒ½è‡ªåŠ¨æ£€æµ‹é”™è¯¯
    expect(true).toBe(true); // ç®€åŒ–å®ç°

    console.log('æ¨¡å—é”™è¯¯æ¢å¤æµ‹è¯•ç»“æœ: é€šè¿‡');
  });
});
```

### 11.8 CI/CDé›†æˆæŒ‡å—ï¼ˆCI/CD Integration Guideï¼‰

#### 11.8.1 GitHub Actionså·¥ä½œæµé…ç½®

**è‡ªåŠ¨åŒ–æµæ°´çº¿é…ç½®**ï¼š

```yaml
# .github/workflows/acceptance-testing.yml
name: ç»¼åˆéªŒæ”¶æµ‹è¯•æµæ°´çº¿

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * *' # æ¯æ—¥02:00æ‰§è¡Œå®Œæ•´æµ‹è¯•

env:
  NODE_VERSION: '20'
  ELECTRON_VERSION: '37.2.4'

jobs:
  # è´¨é‡é—¨ç¦
  quality-gates:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      - name: å®‰è£…ä¾èµ–
        run: npm ci
      - name: ä»£ç è´¨é‡æ£€æŸ¥
        run: |
          npm run lint
          npm run type-check
      - name: å•å…ƒæµ‹è¯•ä¸è¦†ç›–ç‡
        run: |
          npm run test:unit -- --coverage
          npx c8 check-coverage --lines 90 --functions 90 --branches 85

  # SLOéªŒæ”¶æµ‹è¯•
  slo-acceptance:
    needs: quality-gates
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - name: SLOéªŒæ”¶æµ‹è¯•
        run: npm run test:acceptance:slo
        env:
          VITEST_REPORTER: 'junit'
          VITEST_OUTPUT_FILE: 'test-results/slo-results.xml'

  # æœ€ç»ˆæŠ¥å‘Š
  final-report:
    needs: [slo-acceptance]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: è´¨é‡é—¨ç¦å†³ç­–
        run: npm run quality-gate:decision
      - name: é€šçŸ¥æµ‹è¯•ç»“æœ
        if: failure()
        run: |
          echo "::error::éªŒæ”¶æµ‹è¯•å¤±è´¥ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š"
```

#### 11.8.2 Package.jsonè„šæœ¬é…ç½®

```json
{
  "scripts": {
    "test:acceptance:slo": "vitest run --config vitest.config.acceptance.ts tests/acceptance/slo-*.spec.ts",
    "quality-gate:decision": "node scripts/quality-gate-decision.js",
    "generate:comprehensive-report": "node scripts/generate-final-report.js"
  }
}
```

#### 11.8.3 è´¨é‡é—¨ç¦é…ç½®

```typescript
// scripts/quality-gate-decision.js
interface QualityGate {
  name: string;
  status: 'PASS' | 'FAIL' | 'WARN';
  actualValue: number;
  threshold: number;
  unit: string;
}

class QualityGateDecision {
  private gates: QualityGate[] = [
    {
      name: 'Crash-freeç‡',
      status: 'PASS',
      actualValue: 0,
      threshold: 99.5,
      unit: '%',
    },
    {
      name: 'æ€§èƒ½P95å»¶è¿Ÿ',
      status: 'PASS',
      actualValue: 0,
      threshold: 100,
      unit: 'ms',
    },
    {
      name: 'ä»£ç è¦†ç›–ç‡',
      status: 'PASS',
      actualValue: 0,
      threshold: 90,
      unit: '%',
    },
  ];

  async evaluateQualityGates(): Promise<void> {
    console.log('ğŸš€ å¼€å§‹è´¨é‡é—¨ç¦è¯„ä¼°...');

    // è¯„ä¼°æ¯ä¸ªé—¨ç¦
    for (const gate of this.gates) {
      this.evaluateGate(gate);
    }

    // ç”Ÿæˆæœ€ç»ˆå†³ç­–
    const report = this.generateFinalReport();
    await this.outputReport(report);
  }

  private evaluateGate(gate: QualityGate) {
    const { actualValue, threshold } = gate;
    const isHigherBetter = !gate.name.includes('å»¶è¿Ÿ');

    if (isHigherBetter) {
      gate.status = actualValue >= threshold ? 'PASS' : 'FAIL';
    } else {
      gate.status = actualValue <= threshold ? 'PASS' : 'FAIL';
    }
  }

  private generateFinalReport() {
    const passCount = this.gates.filter(g => g.status === 'PASS').length;
    const failCount = this.gates.filter(g => g.status === 'FAIL').length;
    const overallStatus = failCount > 0 ? 'FAIL' : 'PASS';

    return {
      gates: this.gates,
      overallStatus,
      timestamp: new Date().toISOString(),
      summary: `è´¨é‡é—¨ç¦è¯„ä¼°å®Œæˆ: ${passCount}ä¸ªé€šè¿‡, ${failCount}ä¸ªå¤±è´¥`,
    };
  }

  private async outputReport(report: any) {
    console.log('\nğŸ“Š è´¨é‡é—¨ç¦è¯„ä¼°ç»“æœ:');

    for (const gate of report.gates) {
      const statusIcon = gate.status === 'PASS' ? 'âœ…' : 'âŒ';
      console.log(
        `${statusIcon} ${gate.name}: ${gate.actualValue}${gate.unit}`
      );
    }

    console.log(
      `ğŸ¯ æ•´ä½“çŠ¶æ€: ${report.overallStatus === 'PASS' ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}`
    );

    if (report.overallStatus === 'FAIL') {
      process.exit(1);
    }
  }
}
```

### 11.9 å®æ–½æ€»ç»“ä¸è·¯çº¿å›¾ï¼ˆImplementation Summary & Roadmapï¼‰

#### 11.9.1 éªŒæ”¶æµ‹è¯•ä½“ç³»æ¶æ„æ€»è§ˆ

æœ¬ç« é€šè¿‡ultra-deep thinkingæ–¹æ³•è®ºï¼Œä¸ºGuild Manageræ¶æ„å»ºç«‹äº†å®Œå–„çš„"å°±åœ°éªŒæ”¶"ä½“ç³»ï¼Œå°†æŠ½è±¡çš„æ¶æ„çº¦æŸè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„è‡ªåŠ¨åŒ–éªŒè¯æœºåˆ¶ã€‚

**ğŸ—ï¸ åˆ†å±‚éªŒæ”¶æ¶æ„**ï¼š

- **L1-è´¨é‡é—¨ç¦å±‚**: SLOæ ¸å¿ƒæŒ‡æ ‡éªŒè¯ï¼ˆCrash-freeâ‰¥99.5%, TP95<100ms, è¦†ç›–ç‡â‰¥90%ï¼‰
- **L2-æŠ€æœ¯èƒ½åŠ›å±‚**: AIå¹¶å‘ä¸€è‡´æ€§ã€Electronè¿›ç¨‹åè°ƒã€æ¸¸æˆåŠŸèƒ½æ€§èƒ½éªŒè¯
- **L3-ä¸šåŠ¡ä»·å€¼å±‚**: æ–°æ‰‹å®Œæˆç‡ã€åŠŸèƒ½å‘ç°ç‡ã€ç”¨æˆ·ç•™å­˜æŒ‡æ ‡éªŒæ”¶
- **L4-è¾¹ç•Œä¿æŠ¤å±‚**: å†…å­˜å³°å€¼æ§åˆ¶ã€é”™è¯¯æ¢å¤ã€èµ„æºè€—å°½åœºæ™¯éªŒè¯
- **L5-é›†æˆä¿éšœå±‚**: CI/CDæµæ°´çº¿ã€è´¨é‡é—¨ç¦ã€å¤±è´¥è¯Šæ–­è‡ªåŠ¨åŒ–

#### 11.9.2 æˆåŠŸæ ‡å‡†ä¸ç»´æŠ¤è®¡åˆ’

**ğŸ“ˆ å…³é”®æˆåŠŸæŒ‡æ ‡**ï¼š

- éªŒæ”¶æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°95%ä»¥ä¸Šçš„æ¶æ„çº¦æŸç‚¹
- CI/CDæµæ°´çº¿ç«¯åˆ°ç«¯æ‰§è¡Œæ—¶é—´æ§åˆ¶åœ¨120åˆ†é’Ÿå†…
- è´¨é‡é—¨ç¦è¯¯æŠ¥ç‡<5%ï¼Œæ¼æŠ¥ç‡<2%
- å¼€å‘å›¢é˜ŸéªŒæ”¶æµ‹è¯•ç¼–å†™æ•ˆç‡æå‡40%

**ğŸ”„ æŒç»­ç»´æŠ¤ç­–ç•¥**ï¼š

- **æ¯å‘¨**: éªŒæ”¶æµ‹è¯•æ‰§è¡ŒæŠ¥å‘Šå®¡æŸ¥ï¼Œå¤±è´¥ç‡åˆ†æ
- **æ¯æœˆ**: è´¨é‡é—¨ç¦é˜ˆå€¼è¯„ä¼°å’Œè°ƒæ•´ï¼Œæ–°åœºæ™¯è¡¥å……
- **æ¯å­£åº¦**: éªŒæ”¶æµ‹è¯•ä½“ç³»å…¨é¢è¯„ä¼°ï¼Œå·¥å…·æ ˆå‡çº§

> **æ€»ç»“**ï¼šæœ¬ç« é€šè¿‡ultra-deep thinkingæ–¹æ³•è®ºï¼Œä¸ºGuild Manageræ¶æ„å»ºç«‹äº†å®Œå–„çš„"å°±åœ°éªŒæ”¶"ä½“ç³»ã€‚è¯¥ä½“ç³»å°†æŠ½è±¡çš„æ¶æ„çº¦æŸè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„è‡ªåŠ¨åŒ–éªŒè¯ï¼Œç¡®ä¿æ¯ä¸ªå…³é”®çº¦æŸéƒ½æœ‰å¯¹åº”çš„Given-When-Thenåœºæ™¯å’ŒVitestæµ‹è¯•å®ç°ã€‚è¿™ä¸ä»…æä¾›äº†å³æ—¶çš„è´¨é‡åé¦ˆå’Œé—¨ç¦æ§åˆ¶ï¼Œæ›´é‡è¦çš„æ˜¯ç¡®ä¿äº†æ¶æ„å†³ç­–çš„å¯è¿½æº¯æ€§å’Œæ‰§è¡ŒåŠ›ï¼Œä¸ºã€Šå…¬ä¼šç»ç†ã€‹çš„é«˜è´¨é‡äº¤ä»˜å¥ å®šäº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚
