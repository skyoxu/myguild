# 05 数据模型与存储端口（先接口后实现）
> 以 **端口/适配器** 思路定义领域接口，先内存适配，后续可替换 SQLite/文件/云。

---

## 1 领域驱动设计(DDD)模型架构

> **设计原则**: 基于Domain-Driven Design理论，采用聚合根、值对象、领域服务等核心概念，确保业务逻辑封装和事务一致性

### 1.1 DDD核心概念概述

#### 1.1.1 聚合(Aggregate)与聚合根(Aggregate Root)

**聚合**是DDD中最重要的设计模式，它定义了数据修改的事务边界。每个聚合都有一个聚合根实体，外部只能通过聚合根来访问和修改聚合内的数据。

**核心原则**：
- **事务一致性边界**：聚合内的数据修改必须在同一个事务中完成
- **业务完整性保障**：聚合负责维护其内部的业务不变量
- **性能优化考虑**：聚合大小应该适中，避免加载过多数据

#### 1.1.2 值对象(Value Objects)

值对象是没有标识符的不可变对象，通过属性值来确定相等性。它们封装了业务概念和验证逻辑。

**核心特征**：
- **不可变性**：创建后不能修改，修改需要创建新实例
- **相等性**：通过值比较而非引用比较
- **验证封装**：在构造函数中进行业务规则验证

#### 1.1.3 领域服务(Domain Services)

当业务逻辑不适合放在任何单一聚合中时，使用领域服务来处理跨聚合的复杂业务逻辑。

### 1.2 《公会经理》游戏领域模型设计

#### 1.2.1 核心聚合架构

基于游戏业务特点，我们设计了三个核心聚合：

```typescript
// ============================================================================
// 核心值对象定义
// ============================================================================

/** 强类型ID值对象基类 */
abstract class TypedId {
  constructor(protected readonly value: string) {
    if (!value || value.trim().length === 0) {
      throw new Error(`Invalid ${this.constructor.name}: empty value`);
    }
  }

  toString(): string {
    return this.value;
  }

  equals(other: TypedId): boolean {
    return this.value === other.value;
  }
}

/** 角色ID */
class CharacterId extends TypedId {
  static generate(): CharacterId {
    return new CharacterId(crypto.randomUUID());
  }
}

/** 公会ID */
class GuildId extends TypedId {
  static generate(): GuildId {
    return new GuildId(crypto.randomUUID());
  }
}

/** 战斗ID */
class BattleId extends TypedId {
  static generate(): BattleId {
    return new BattleId(crypto.randomUUID());
  }
}

/** 金钱值对象 - 确保货币计算精度 */
class Money {
  private readonly amount: number; // 以分为单位存储，确保精度

  constructor(amount: number) {
    if (amount < 0) {
      throw new Error('Money amount cannot be negative');
    }
    // 使用整数存储，避免浮点精度问题（以分为单位）
    this.amount = Math.round(amount * 100);
  }

  /** 从分创建Money对象 - 用于内部计算和数据库映射 */
  static fromCents(cents: number): Money {
    if (cents < 0) {
      throw new Error('Money amount cannot be negative');
    }
    const money = Object.create(Money.prototype);
    money.amount = Math.round(cents);
    return money;
  }

  /** 获取分值 - 用于数据库存储 */
  toCents(): number {
    return this.amount;
  }

  add(other: Money): Money {
    return Money.fromCents(this.amount + other.amount);
  }

  subtract(other: Money): Money {
    if (this.amount < other.amount) {
      throw new Error('Insufficient funds');
    }
    return Money.fromCents(this.amount - other.amount);
  }

  multiply(factor: number): Money {
    return Money.fromCents(Math.round(this.amount * factor));
  }

  /** 获取元值 - 用于显示 */
  getValue(): number {
    return this.amount / 100;
  }

  isGreaterThan(other: Money): boolean {
    return this.amount > other.amount;
  }

  equals(other: Money): boolean {
    return this.amount === other.amount;
  }
}

/** 公会成员角色枚举 */
enum GuildRole {
  LEADER = 'leader',           // 会长
  VICE_LEADER = 'vice_leader', // 副会长  
  OFFICER = 'officer',         // 干事
  ELITE = 'elite',             // 精英
  MEMBER = 'member'            // 普通成员
}

/** 公会成员资格值对象 */
class GuildMembership {
  constructor(
    public readonly guildId: GuildId,
    public readonly role: GuildRole,
    public readonly joinedAt: Date,
    public readonly contributions: number = 0
  ) {}

  /** 升级角色 */
  promoteToRole(newRole: GuildRole): GuildMembership {
    return new GuildMembership(
      this.guildId,
      newRole,
      this.joinedAt,
      this.contributions
    );
  }

  /** 增加贡献度 */
  addContribution(amount: number): GuildMembership {
    return new GuildMembership(
      this.guildId,
      this.role,
      this.joinedAt,
      this.contributions + amount
    );
  }

  /** 检查权限 */
  hasPermission(requiredRole: GuildRole): boolean {
    const roleHierarchy = {
      [GuildRole.MEMBER]: 1,
      [GuildRole.ELITE]: 2,
      [GuildRole.OFFICER]: 3,
      [GuildRole.VICE_LEADER]: 4,
      [GuildRole.LEADER]: 5
    };
    
    return roleHierarchy[this.role] >= roleHierarchy[requiredRole];
  }
}
```

#### 1.2.2 Character聚合 - 核心聚合根

```typescript
// ============================================================================
// Character聚合 - 游戏角色聚合根
// ============================================================================

/** 角色属性值对象 */
class CharacterStats {
  constructor(
    public readonly attack: number,
    public readonly defense: number,
    public readonly health: number,
    public readonly magic: number,
    public readonly level: number
  ) {
    this.validateStats();
  }

  private validateStats(): void {
    if (this.attack < 0 || this.defense < 0 || this.health < 0 || this.magic < 0) {
      throw new Error('Character stats cannot be negative');
    }
    if (this.level < 1 || this.level > 100) {
      throw new Error('Character level must be between 1 and 100');
    }
  }

  /** 升级属性 */
  levelUp(): CharacterStats {
    const newLevel = Math.min(this.level + 1, 100);
    return new CharacterStats(
      this.attack + 5,
      this.defense + 3,
      this.health + 10,
      this.magic + 2,
      newLevel
    );
  }

  /** 计算战斗力 */
  calculatePower(): number {
    return this.attack * 2 + this.defense * 1.5 + this.health * 0.5 + this.magic * 1.8;
  }
}

/** 领域事件基类 */
abstract class DomainEvent {
  public readonly occurredAt: Date = new Date();
  abstract readonly eventType: string;
}

/** 角色加入公会事件 */
class CharacterJoinedGuildEvent extends DomainEvent {
  readonly eventType = 'CharacterJoinedGuild';
  
  constructor(
    public readonly characterId: CharacterId,
    public readonly guildId: GuildId,
    public readonly role: GuildRole
  ) {
    super();
  }
}

/** 角色聚合根 */
class CharacterAggregate {
  private domainEvents: DomainEvent[] = [];

  constructor(
    public readonly id: CharacterId,
    public readonly name: string,
    private stats: CharacterStats,
    private guildMembership: GuildMembership | null = null,
    private wallet: Money = new Money(0),
    public readonly createdAt: Date = new Date(),
    private version: number = 1
  ) {
    this.validateCharacterName(name);
  }

  private validateCharacterName(name: string): void {
    if (!name || name.trim().length < 2 || name.trim().length > 20) {
      throw new Error('Character name must be between 2 and 20 characters');
    }
  }

  // ========== 公会相关业务方法 ==========

  /** 加入公会 */
  joinGuild(guildId: GuildId, role: GuildRole = GuildRole.MEMBER): void {
    if (this.guildMembership) {
      throw new Error('Character is already in a guild');
    }

    this.guildMembership = new GuildMembership(guildId, role, new Date());
    this.addDomainEvent(new CharacterJoinedGuildEvent(this.id, guildId, role));
    this.incrementVersion();
  }

  /** 离开公会 */
  leaveGuild(): void {
    if (!this.guildMembership) {
      throw new Error('Character is not in any guild');
    }

    this.guildMembership = null;
    this.incrementVersion();
  }

  /** 升级公会角色 */
  promoteInGuild(newRole: GuildRole): void {
    if (!this.guildMembership) {
      throw new Error('Character is not in any guild');
    }

    this.guildMembership = this.guildMembership.promoteToRole(newRole);
    this.incrementVersion();
  }

  /** 增加公会贡献度 */
  addGuildContribution(amount: number): void {
    if (!this.guildMembership) {
      throw new Error('Character is not in any guild');
    }

    this.guildMembership = this.guildMembership.addContribution(amount);
    this.incrementVersion();
  }

  // ========== 角色成长业务方法 ==========

  /** 角色升级 */
  levelUp(): void {
    this.stats = this.stats.levelUp();
    this.incrementVersion();
  }

  /** 获得金币 */
  earnMoney(amount: Money): void {
    this.wallet = this.wallet.add(amount);
    this.incrementVersion();
  }

  /** 消费金币 */
  spendMoney(amount: Money): void {
    this.wallet = this.wallet.subtract(amount); // 会抛出异常如果余额不足
    this.incrementVersion();
  }

  // ========== 查询方法 ==========

  getStats(): CharacterStats {
    return this.stats;
  }

  getGuildMembership(): GuildMembership | null {
    return this.guildMembership;
  }

  getWallet(): Money {
    return this.wallet;
  }

  isInGuild(): boolean {
    return this.guildMembership !== null;
  }

  hasGuildPermission(requiredRole: GuildRole): boolean {
    return this.guildMembership?.hasPermission(requiredRole) ?? false;
  }

  // ========== 领域事件处理 ==========

  private addDomainEvent(event: DomainEvent): void {
    this.domainEvents.push(event);
  }

  collectDomainEvents(): DomainEvent[] {
    return [...this.domainEvents];
  }

  clearDomainEvents(): void {
    this.domainEvents = [];
  }

  // ========== 并发控制 ==========

  private incrementVersion(): void {
    this.version++;
  }

  getVersion(): number {
    return this.version;
  }
}
```

#### 1.2.3 Guild聚合 - 优化后的轻量级聚合

```typescript
// ============================================================================
// Guild聚合 - 优化后的轻量级公会聚合根
// ============================================================================

/** 公会金库值对象 */
class GuildTreasury {
  constructor(
    private readonly gold: Money,
    private readonly resources: Map<string, number> = new Map()
  ) {}

  /** 存入金币 */
  depositGold(amount: Money): GuildTreasury {
    return new GuildTreasury(
      this.gold.add(amount),
      new Map(this.resources)
    );
  }

  /** 提取金币 */
  withdrawGold(amount: Money): GuildTreasury {
    return new GuildTreasury(
      this.gold.subtract(amount), // 会检查余额
      new Map(this.resources)
    );
  }

  /** 存入资源 */
  depositResource(resourceType: string, amount: number): GuildTreasury {
    const newResources = new Map(this.resources);
    const currentAmount = newResources.get(resourceType) || 0;
    newResources.set(resourceType, currentAmount + amount);
    
    return new GuildTreasury(this.gold, newResources);
  }

  /** 提取资源 */
  withdrawResource(resourceType: string, amount: number): GuildTreasury {
    const currentAmount = this.resources.get(resourceType) || 0;
    if (currentAmount < amount) {
      throw new Error(`Insufficient ${resourceType}: need ${amount}, have ${currentAmount}`);
    }

    const newResources = new Map(this.resources);
    newResources.set(resourceType, currentAmount - amount);
    
    return new GuildTreasury(this.gold, newResources);
  }

  getGold(): Money {
    return this.gold;
  }

  getResource(resourceType: string): number {
    return this.resources.get(resourceType) || 0;
  }

  getAllResources(): Map<string, number> {
    return new Map(this.resources);
  }
}

/** 公会成员权限映射 */
class GuildMembershipRegistry {
  private readonly members: Map<string, GuildRole>;

  constructor(members: Map<string, GuildRole> = new Map()) {
    this.members = new Map(members);
  }

  /** 添加成员 */
  addMember(characterId: CharacterId, role: GuildRole): GuildMembershipRegistry {
    if (this.members.has(characterId.toString())) {
      throw new Error('Character is already a guild member');
    }

    const newMembers = new Map(this.members);
    newMembers.set(characterId.toString(), role);
    return new GuildMembershipRegistry(newMembers);
  }

  /** 移除成员 */
  removeMember(characterId: CharacterId): GuildMembershipRegistry {
    if (!this.members.has(characterId.toString())) {
      throw new Error('Character is not a guild member');
    }

    const newMembers = new Map(this.members);
    newMembers.delete(characterId.toString());
    return new GuildMembershipRegistry(newMembers);
  }

  /** 更新成员角色 */
  updateMemberRole(characterId: CharacterId, newRole: GuildRole): GuildMembershipRegistry {
    if (!this.members.has(characterId.toString())) {
      throw new Error('Character is not a guild member');
    }

    const newMembers = new Map(this.members);
    newMembers.set(characterId.toString(), newRole);
    return new GuildMembershipRegistry(newMembers);
  }

  /** 检查成员权限 */
  hasPermission(characterId: CharacterId, requiredRole: GuildRole): boolean {
    const memberRole = this.members.get(characterId.toString());
    if (!memberRole) return false;

    const roleHierarchy = {
      [GuildRole.MEMBER]: 1,
      [GuildRole.ELITE]: 2, 
      [GuildRole.OFFICER]: 3,
      [GuildRole.VICE_LEADER]: 4,
      [GuildRole.LEADER]: 5
    };

    return roleHierarchy[memberRole] >= roleHierarchy[requiredRole];
  }

  getMemberRole(characterId: CharacterId): GuildRole | null {
    return this.members.get(characterId.toString()) || null;
  }

  getMemberCount(): number {
    return this.members.size;
  }

  getLeaders(): CharacterId[] {
    const leaders: CharacterId[] = [];
    for (const [charId, role] of this.members) {
      if (role === GuildRole.LEADER || role === GuildRole.VICE_LEADER) {
        leaders.push(new CharacterId(charId));
      }
    }
    return leaders;
  }

  /** 按角色统计成员数量 - 用于不变量检查 */
  countByRole(role: GuildRole): number {
    let count = 0;
    for (const memberRole of this.members.values()) {
      if (memberRole === role) {
        count++;
      }
    }
    return count;
  }
}

/** 公会升级事件 */
class GuildLevelUpEvent extends DomainEvent {
  readonly eventType = 'GuildLevelUp';
  
  constructor(
    public readonly guildId: GuildId,
    public readonly oldLevel: number,
    public readonly newLevel: number
  ) {
    super();
  }
}

/** 公会聚合根 - 优化后的轻量级设计 */
class GuildAggregate {
  private domainEvents: DomainEvent[] = [];

  constructor(
    public readonly id: GuildId,
    public readonly name: string,
    public readonly description: string,
    private level: number,
    private experience: number,
    private treasury: GuildTreasury,
    private membershipRegistry: GuildMembershipRegistry,
    private readonly memberLimit: number,
    public readonly createdAt: Date = new Date(),
    private version: number = 1
  ) {
    this.validateGuildData();
  }

  private validateGuildData(): void {
    if (!this.name || this.name.trim().length < 2 || this.name.trim().length > 50) {
      throw new Error('Guild name must be between 2 and 50 characters');
    }
    if (this.level < 1 || this.level > 50) {
      throw new Error('Guild level must be between 1 and 50');
    }
    if (this.memberLimit < 10 || this.memberLimit > 200) {
      throw new Error('Guild member limit must be between 10 and 200');
    }
  }

  // ========== 成员管理业务方法 ==========

  /** 招募成员 */
  recruitMember(characterId: CharacterId, role: GuildRole = GuildRole.MEMBER): void {
    // 业务不变量检查
    if (this.membershipRegistry.getMemberCount() >= this.memberLimit) {
      throw new Error('Guild has reached member limit');
    }

    this.membershipRegistry = this.membershipRegistry.addMember(characterId, role);
    this.incrementVersion();
  }

  /** 移除成员 */
  removeMember(characterId: CharacterId, removedBy: CharacterId): void {
    // 权限检查
    if (!this.membershipRegistry.hasPermission(removedBy, GuildRole.OFFICER)) {
      throw new Error('Only officers and above can remove members');
    }

    // 不能移除会长
    const targetRole = this.membershipRegistry.getMemberRole(characterId);
    if (targetRole === GuildRole.LEADER) {
      throw new Error('Cannot remove guild leader');
    }

    this.membershipRegistry = this.membershipRegistry.removeMember(characterId);
    this.incrementVersion();
  }

  /** 升级成员角色 */
  promoteMember(characterId: CharacterId, newRole: GuildRole, promotedBy: CharacterId): void {
    // 权限检查
    if (!this.membershipRegistry.hasPermission(promotedBy, GuildRole.VICE_LEADER)) {
      throw new Error('Only vice leaders and above can promote members');
    }

    // 不能提升为会长（会长只能通过转让产生）
    if (newRole === GuildRole.LEADER) {
      throw new Error('Cannot promote to leader role directly');
    }

    this.membershipRegistry = this.membershipRegistry.updateMemberRole(characterId, newRole);
    this.incrementVersion();
  }

  // ========== 公会金库管理 ==========

  /** 存入金币到金库 */
  depositToTreasury(amount: Money, depositor: CharacterId): void {
    // 检查存入权限
    if (!this.membershipRegistry.hasPermission(depositor, GuildRole.MEMBER)) {
      throw new Error('Only guild members can deposit to treasury');
    }

    this.treasury = this.treasury.depositGold(amount);
    this.incrementVersion();
  }

  /** 从金库提取金币 */
  withdrawFromTreasury(amount: Money, withdrawer: CharacterId): void {
    // 检查提取权限
    if (!this.membershipRegistry.hasPermission(withdrawer, GuildRole.OFFICER)) {
      throw new Error('Only officers and above can withdraw from treasury');
    }

    this.treasury = this.treasury.withdrawGold(amount);
    this.incrementVersion();
  }

  /** 存入资源到金库 */
  depositResource(resourceType: string, amount: number, depositor: CharacterId): void {
    if (!this.membershipRegistry.hasPermission(depositor, GuildRole.MEMBER)) {
      throw new Error('Only guild members can deposit resources');
    }

    this.treasury = this.treasury.depositResource(resourceType, amount);
    this.incrementVersion();
  }

  /** 从金库提取资源 */
  withdrawResource(resourceType: string, amount: number, withdrawer: CharacterId): void {
    if (!this.membershipRegistry.hasPermission(withdrawer, GuildRole.OFFICER)) {
      throw new Error('Only officers and above can withdraw resources');
    }

    this.treasury = this.treasury.withdrawResource(resourceType, amount);
    this.incrementVersion();
  }

  // ========== 公会成长业务方法 ==========

  /** 获得经验值 */
  gainExperience(amount: number): void {
    this.experience += amount;
    
    // 检查是否可以升级
    const requiredExp = this.getRequiredExperienceForNextLevel();
    if (this.experience >= requiredExp && this.level < 50) {
      const oldLevel = this.level;
      this.level++;
      this.addDomainEvent(new GuildLevelUpEvent(this.id, oldLevel, this.level));
    }

    this.incrementVersion();
  }

  private getRequiredExperienceForNextLevel(): number {
    return this.level * 1000; // 简单的经验计算公式
  }

  // ========== 查询方法 ==========

  getLevel(): number {
    return this.level;
  }

  getExperience(): number {
    return this.experience;
  }

  getMemberCount(): number {
    return this.membershipRegistry.getMemberCount();
  }

  /** 按角色统计成员数量 - 用于不变量检查 */
  countMembersByRole(role: GuildRole): number {
    return this.membershipRegistry.countByRole(role);
  }

  getMemberLimit(): number {
    return this.memberLimit;
  }

  getTreasury(): GuildTreasury {
    return this.treasury;
  }

  hasMember(characterId: CharacterId): boolean {
    return this.membershipRegistry.getMemberRole(characterId) !== null;
  }

  getMemberRole(characterId: CharacterId): GuildRole | null {
    return this.membershipRegistry.getMemberRole(characterId);
  }

  // ========== 领域事件处理 ==========

  private addDomainEvent(event: DomainEvent): void {
    this.domainEvents.push(event);
  }

  collectDomainEvents(): DomainEvent[] {
    return [...this.domainEvents];
  }

  clearDomainEvents(): void {
    this.domainEvents = [];
  }

  // ========== 并发控制 ==========

  private incrementVersion(): void {
    this.version++;
  }

  getVersion(): number {
    return this.version;
  }
}
```

#### 1.2.4 Battle聚合 - 战斗系统聚合

```typescript
// ============================================================================
// Battle聚合 - 战斗系统聚合根
// ============================================================================

/** 战斗类型枚举 */
enum BattleType {
  PVP = 'pvp',           // 玩家对战
  PVE = 'pve',           // 打怪
  GUILD_WAR = 'guild_war', // 公会战
  WORLD_BOSS = 'world_boss' // 世界Boss
}

/** 战斗状态枚举 */
enum BattleStatus {
  PREPARING = 'preparing',   // 准备中
  ACTIVE = 'active',         // 进行中
  COMPLETED = 'completed',   // 已完成
  CANCELLED = 'cancelled'    // 已取消
}

/** 战斗配置值对象 */
class BattleConfiguration {
  constructor(
    public readonly maxRounds: number,
    public readonly timeLimit: number, // 秒
    public readonly allowAutoPlay: boolean,
    public readonly rewardMultiplier: number
  ) {
    this.validateConfiguration();
  }

  private validateConfiguration(): void {
    if (this.maxRounds < 1 || this.maxRounds > 50) {
      throw new Error('Max rounds must be between 1 and 50');
    }
    if (this.timeLimit < 30 || this.timeLimit > 3600) {
      throw new Error('Time limit must be between 30 and 3600 seconds');
    }
    if (this.rewardMultiplier < 0.1 || this.rewardMultiplier > 5.0) {
      throw new Error('Reward multiplier must be between 0.1 and 5.0');
    }
  }
}

/** 战斗队伍值对象 */
class BattleParty {
  constructor(
    public readonly guildId: GuildId,
    public readonly memberIds: CharacterId[],
    public readonly formation: string, // 阵型配置
    private totalPower: number
  ) {
    this.validateParty();
  }

  private validateParty(): void {
    if (this.memberIds.length < 1 || this.memberIds.length > 10) {
      throw new Error('Battle party must have 1-10 members');
    }
    if (this.totalPower <= 0) {
      throw new Error('Total power must be positive');
    }
  }

  getTotalPower(): number {
    return this.totalPower;
  }

  getMemberCount(): number {
    return this.memberIds.length;
  }

  /** 更新战斗力（当成员状态变化时） */
  updateTotalPower(newPower: number): BattleParty {
    return new BattleParty(
      this.guildId,
      this.memberIds,
      this.formation,
      newPower
    );
  }
}

/** 战斗回合结果值对象 */
class BattleRoundResult {
  constructor(
    public readonly roundNumber: number,
    public readonly attackerDamage: number,
    public readonly defenderDamage: number,
    public readonly attackerRemainingPower: number,
    public readonly defenderRemainingPower: number,
    public readonly events: string[] // 战斗事件描述
  ) {}
}

/** 战斗最终结果值对象 */
class BattleResult {
  constructor(
    public readonly winner: 'attacker' | 'defender' | 'draw',
    public readonly rounds: BattleRoundResult[],
    public readonly duration: number, // 战斗持续时间（秒）
    public readonly rewards: Map<CharacterId, BattleReward>
  ) {}

  getTotalRounds(): number {
    return this.rounds.length;
  }

  getWinnerGuildId(): GuildId | null {
    // 这里需要通过其他方式获取获胜方的公会ID
    // 在实际实现中，可能需要额外的上下文信息
    return null;
  }
}

/** 战斗奖励值对象 */
class BattleReward {
  constructor(
    public readonly experience: number,
    public readonly gold: Money,
    public readonly items: Map<string, number>
  ) {}
}

/** 战斗开始事件 */
class BattleStartedEvent extends DomainEvent {
  readonly eventType = 'BattleStarted';
  
  constructor(
    public readonly battleId: BattleId,
    public readonly attackerGuildId: GuildId,
    public readonly defenderGuildId: GuildId,
    public readonly battleType: BattleType
  ) {
    super();
  }
}

/** 战斗结束事件 */
class BattleCompletedEvent extends DomainEvent {
  readonly eventType = 'BattleCompleted';
  
  constructor(
    public readonly battleId: BattleId,
    public readonly result: BattleResult
  ) {
    super();
  }
}

/** 战斗聚合根 */
class BattleAggregate {
  private domainEvents: DomainEvent[] = [];

  constructor(
    public readonly id: BattleId,
    public readonly type: BattleType,
    private status: BattleStatus,
    private readonly configuration: BattleConfiguration,
    private readonly attackingParty: BattleParty,
    private readonly defendingParty: BattleParty,
    private rounds: BattleRoundResult[] = [],
    private result: BattleResult | null = null,
    public readonly startedAt: Date = new Date(),
    private endedAt: Date | null = null,
    private version: number = 1
  ) {
    this.validateBattleSetup();
  }

  private validateBattleSetup(): void {
    if (this.attackingParty.guildId.equals(this.defendingParty.guildId)) {
      throw new Error('Cannot battle against the same guild');
    }
  }

  // ========== 战斗控制业务方法 ==========

  /** 开始战斗 */
  startBattle(): void {
    if (this.status !== BattleStatus.PREPARING) {
      throw new Error('Battle can only be started from preparing status');
    }

    this.status = BattleStatus.ACTIVE;
    this.addDomainEvent(new BattleStartedEvent(
      this.id,
      this.attackingParty.guildId,
      this.defendingParty.guildId,
      this.type
    ));
    this.incrementVersion();
  }

  /** 执行战斗回合 */
  executeRound(): void {
    if (this.status !== BattleStatus.ACTIVE) {
      throw new Error('Cannot execute round when battle is not active');
    }

    if (this.rounds.length >= this.configuration.maxRounds) {
      throw new Error('Maximum rounds reached');
    }

    // 简化的战斗逻辑计算
    const currentRound = this.rounds.length + 1;
    const attackerPower = this.getAttackerRemainingPower();
    const defenderPower = this.getDefenderRemainingPower();

    // 伤害计算（简化版本）
    const attackerDamage = this.calculateDamage(attackerPower, defenderPower);
    const defenderDamage = this.calculateDamage(defenderPower, attackerPower);

    const newAttackerPower = Math.max(0, attackerPower - defenderDamage);
    const newDefenderPower = Math.max(0, defenderPower - attackerDamage);

    const roundResult = new BattleRoundResult(
      currentRound,
      attackerDamage,
      defenderDamage,
      newAttackerPower,
      newDefenderPower,
      [`Round ${currentRound}: Attacker deals ${attackerDamage}, Defender deals ${defenderDamage}`]
    );

    this.rounds.push(roundResult);

    // 检查战斗是否结束
    if (newAttackerPower === 0 || newDefenderPower === 0 || currentRound >= this.configuration.maxRounds) {
      this.completeBattle();
    }

    this.incrementVersion();
  }

  private calculateDamage(attackerPower: number, defenderPower: number): number {
    // 简化的伤害计算公式
    const baseDamage = attackerPower * 0.1;
    const randomFactor = 0.8 + Math.random() * 0.4; // 80%-120%随机
    const defenseReduction = Math.max(0.1, 1 - (defenderPower * 0.001));
    return Math.round(baseDamage * randomFactor * defenseReduction);
  }

  private getAttackerRemainingPower(): number {
    if (this.rounds.length === 0) {
      return this.attackingParty.getTotalPower();
    }
    return this.rounds[this.rounds.length - 1].attackerRemainingPower;
  }

  private getDefenderRemainingPower(): number {
    if (this.rounds.length === 0) {
      return this.defendingParty.getTotalPower();
    }
    return this.rounds[this.rounds.length - 1].defenderRemainingPower;
  }

  /** 完成战斗 */
  private completeBattle(): void {
    const finalAttackerPower = this.getAttackerRemainingPower();
    const finalDefenderPower = this.getDefenderRemainingPower();

    let winner: 'attacker' | 'defender' | 'draw';
    if (finalAttackerPower > finalDefenderPower) {
      winner = 'attacker';
    } else if (finalDefenderPower > finalAttackerPower) {
      winner = 'defender';
    } else {
      winner = 'draw';
    }

    const duration = (new Date().getTime() - this.startedAt.getTime()) / 1000;
    const rewards = this.calculateRewards(winner);

    this.result = new BattleResult(winner, [...this.rounds], duration, rewards);
    this.status = BattleStatus.COMPLETED;
    this.endedAt = new Date();

    this.addDomainEvent(new BattleCompletedEvent(this.id, this.result));
    this.incrementVersion();
  }

  private calculateRewards(winner: 'attacker' | 'defender' | 'draw'): Map<CharacterId, BattleReward> {
    const rewards = new Map<CharacterId, BattleReward>();
    
    // 为获胜方计算奖励
    const winnerParty = winner === 'attacker' ? this.attackingParty : 
                       winner === 'defender' ? this.defendingParty : null;
    
    if (winnerParty) {
      const baseGold = new Money(100 * this.configuration.rewardMultiplier);
      const baseExp = Math.round(50 * this.configuration.rewardMultiplier);
      
      winnerParty.memberIds.forEach(memberId => {
        rewards.set(memberId, new BattleReward(
          baseExp,
          baseGold,
          new Map([['battle_token', 1]])
        ));
      });
    }

    return rewards;
  }

  /** 取消战斗 */
  cancelBattle(reason: string): void {
    if (this.status === BattleStatus.COMPLETED) {
      throw new Error('Cannot cancel completed battle');
    }

    this.status = BattleStatus.CANCELLED;
    this.endedAt = new Date();
    this.incrementVersion();
  }

  // ========== 查询方法 ==========

  getStatus(): BattleStatus {
    return this.status;
  }

  getCurrentRound(): number {
    return this.rounds.length;
  }

  getRounds(): BattleRoundResult[] {
    return [...this.rounds];
  }

  getResult(): BattleResult | null {
    return this.result;
  }

  isActive(): boolean {
    return this.status === BattleStatus.ACTIVE;
  }

  isCompleted(): boolean {
    return this.status === BattleStatus.COMPLETED;
  }

  getDuration(): number | null {
    if (!this.endedAt) return null;
    return (this.endedAt.getTime() - this.startedAt.getTime()) / 1000;
  }

  // ========== 领域事件处理 ==========

  private addDomainEvent(event: DomainEvent): void {
    this.domainEvents.push(event);
  }

  collectDomainEvents(): DomainEvent[] {
    return [...this.domainEvents];
  }

  clearDomainEvents(): void {
    this.domainEvents = [];
  }

  // ========== 并发控制 ==========

  private incrementVersion(): void {
    this.version++;
  }

  getVersion(): number {
    return this.version;
  }
}
```

### 1.3 领域不变量(Domain Invariants)设计

#### 1.3.1 核心业务不变量

```typescript
// ============================================================================
// 领域不变量定义和验证
// ============================================================================

/** 领域不变量验证器 */
class DomainInvariantValidator {
  
  /** 公会相关不变量 */
  static validateGuildInvariants(guild: GuildAggregate): void {
    // 不变量1: 公会必须有且仅有一个会长
    const leaderCount = guild.countMembersByRole(GuildRole.LEADER);
    if (leaderCount !== 1) {
      throw new Error(`Guild must have exactly one leader, but found ${leaderCount}. Guild ID: ${guild.id.toString()}`);
    }
    
    // 不变量2: 公会成员数不能超过等级限制
    if (guild.getMemberCount() > guild.getMemberLimit()) {
      throw new Error('Guild member count exceeds limit');
    }

    // 不变量3: 公会等级必须在有效范围内
    if (guild.getLevel() < 1 || guild.getLevel() > 50) {
      throw new Error('Guild level must be between 1 and 50');
    }
  }

  /** 角色相关不变量 */
  static validateCharacterInvariants(character: CharacterAggregate): void {
    // 不变量1: 角色只能属于一个公会
    if (character.isInGuild()) {
      const membership = character.getGuildMembership()!;
      if (!membership.guildId) {
        throw new Error('Invalid guild membership state');
      }
    }

    // 不变量2: 角色的金币不能为负
    if (character.getWallet().getValue() < 0) {
      throw new Error('Character wallet cannot have negative balance');
    }

    // 不变量3: 角色等级必须在有效范围内
    const level = character.getStats().level;
    if (level < 1 || level > 100) {
      throw new Error('Character level must be between 1 and 100');
    }
  }

  /** 战斗相关不变量 */
  static validateBattleInvariants(battle: BattleAggregate): void {
    // 不变量1: 战斗双方不能是同一个公会
    // 这个已经在BattleAggregate构造函数中验证

    // 不变量2: 已完成的战斗不能再修改
    if (battle.isCompleted() && battle.getCurrentRound() < 1) {
      throw new Error('Completed battle must have at least one round');
    }

    // 不变量3: 活跃战斗必须有有效的配置
    if (battle.isActive()) {
      // 验证战斗配置的有效性
      // 这里可以添加更多的战斗状态验证
    }
  }

  /** 经济系统不变量 */
  static validateEconomicInvariants(
    totalSystemGold: Money,
    totalPlayerGold: Money,
    totalGuildGold: Money
  ): void {
    // 不变量: 系统总金币 = 玩家金币 + 公会金币
    const calculatedTotal = totalPlayerGold.add(totalGuildGold);
    if (!totalSystemGold.equals(calculatedTotal)) {
      throw new Error('Economic invariant violated: total gold mismatch');
    }
  }
}

/** 聚合边界执行器 - 确保操作在正确的聚合边界内执行 */
class AggregateBoundaryEnforcer {
  
  /** 确保公会操作在正确的权限边界内 */
  static enforceGuildOperationBoundary(
    guild: GuildAggregate,
    operator: CharacterId,
    requiredRole: GuildRole,
    operation: string
  ): void {
    if (!guild.hasMember(operator)) {
      throw new Error(`Operation '${operation}' requires guild membership`);
    }

    const memberRole = guild.getMemberRole(operator);
    if (!memberRole) {
      throw new Error(`Member not found in guild for operation '${operation}'`);
    }

    // 使用GuildMembership来检查权限
    const membership = new GuildMembership(guild.id, memberRole, new Date());
    if (!membership.hasPermission(requiredRole)) {
      throw new Error(`Operation '${operation}' requires role ${requiredRole} or higher`);
    }
  }

  /** 确保跨聚合操作的一致性 */
  static enforceConsistencyBoundary<T>(
    operation: () => T,
    invariantChecks: (() => void)[]
  ): T {
    // 执行操作
    const result = operation();
    
    // 验证所有不变量
    invariantChecks.forEach(check => check());
    
    return result;
  }
}
```

### 1.4 领域服务(Domain Services)设计

#### 1.4.1 跨聚合业务逻辑处理

```typescript
// ============================================================================
// 领域服务 - 处理跨聚合的复杂业务逻辑
// ============================================================================

/** 公会管理领域服务 */
class GuildManagementService {
  
  /** 角色加入公会的完整流程 */
  async joinGuild(
    character: CharacterAggregate,
    guild: GuildAggregate,
    joinerRole: GuildRole = GuildRole.MEMBER
  ): Promise<{character: CharacterAggregate, guild: GuildAggregate}> {
    
    // 前置条件检查
    if (character.isInGuild()) {
      throw new Error('Character is already in a guild');
    }

    if (guild.getMemberCount() >= guild.getMemberLimit()) {
      throw new Error('Guild is full');
    }

    // 在聚合边界内执行操作
    return AggregateBoundaryEnforcer.enforceConsistencyBoundary(
      () => {
        // 更新角色聚合
        character.joinGuild(guild.id, joinerRole);
        
        // 更新公会聚合
        guild.recruitMember(character.id, joinerRole);
        
        return { character, guild };
      },
      [
        () => DomainInvariantValidator.validateCharacterInvariants(character),
        () => DomainInvariantValidator.validateGuildInvariants(guild)
      ]
    );
  }

  /** 转让公会会长职位 */
  async transferLeadership(
    guild: GuildAggregate,
    currentLeader: CharacterId,
    newLeader: CharacterId
  ): Promise<GuildAggregate> {
    
    // 验证当前会长权限
    AggregateBoundaryEnforcer.enforceGuildOperationBoundary(
      guild, currentLeader, GuildRole.LEADER, 'transfer leadership'
    );

    // 验证新会长是公会成员
    if (!guild.hasMember(newLeader)) {
      throw new Error('New leader must be a guild member');
    }

    return AggregateBoundaryEnforcer.enforceConsistencyBoundary(
      () => {
        // 降级当前会长为副会长
        guild.promoteMember(currentLeader, GuildRole.VICE_LEADER, currentLeader);
        
        // 提升新会长
        guild.promoteMember(newLeader, GuildRole.LEADER, currentLeader);
        
        return guild;
      },
      [() => DomainInvariantValidator.validateGuildInvariants(guild)]
    );
  }

  /** 计算公会成员贡献度排名 */
  calculateMemberContributionRanking(
    characters: CharacterAggregate[],
    guildId: GuildId
  ): Array<{characterId: CharacterId, contribution: number, rank: number}> {
    
    const guildMembers = characters
      .filter(char => {
        const membership = char.getGuildMembership();
        return membership && membership.guildId.equals(guildId);
      })
      .map(char => ({
        characterId: char.id,
        contribution: char.getGuildMembership()!.contributions
      }))
      .sort((a, b) => b.contribution - a.contribution)
      .map((member, index) => ({
        ...member,
        rank: index + 1
      }));

    return guildMembers;
  }
}

/** 战斗系统领域服务 */
class BattleSystemService {
  
  /** 创建公会战 */
  async createGuildBattle(
    attackingGuild: GuildAggregate,
    defendingGuild: GuildAggregate,
    attackingMembers: CharacterAggregate[],
    defendingMembers: CharacterAggregate[],
    initiator: CharacterId
  ): Promise<BattleAggregate> {
    
    // 验证发起者权限
    AggregateBoundaryEnforcer.enforceGuildOperationBoundary(
      attackingGuild, initiator, GuildRole.OFFICER, 'initiate guild battle'
    );

    // 验证参战成员都属于对应公会
    this.validateBattleParticipants(attackingMembers, attackingGuild.id);
    this.validateBattleParticipants(defendingMembers, defendingGuild.id);

    // 计算队伍战斗力
    const attackingPower = this.calculatePartyPower(attackingMembers);
    const defendingPower = this.calculatePartyPower(defendingMembers);

    // 创建战斗队伍
    const attackingParty = new BattleParty(
      attackingGuild.id,
      attackingMembers.map(char => char.id),
      'default', // 默认阵型
      attackingPower
    );

    const defendingParty = new BattleParty(
      defendingGuild.id,
      defendingMembers.map(char => char.id),
      'default',
      defendingPower
    );

    // 创建战斗配置
    const configuration = new BattleConfiguration(
      20,    // 最多20回合
      1800,  // 30分钟时限
      true,  // 允许自动战斗
      1.5    // 1.5倍奖励
    );

    // 创建战斗聚合
    const battle = new BattleAggregate(
      BattleId.generate(),
      BattleType.GUILD_WAR,
      BattleStatus.PREPARING,
      configuration,
      attackingParty,
      defendingParty
    );

    return battle;
  }

  private validateBattleParticipants(members: CharacterAggregate[], expectedGuildId: GuildId): void {
    members.forEach(member => {
      const membership = member.getGuildMembership();
      if (!membership || !membership.guildId.equals(expectedGuildId)) {
        throw new Error(`Character ${member.id} is not a member of the expected guild`);
      }
    });
  }

  private calculatePartyPower(members: CharacterAggregate[]): number {
    return members.reduce((total, member) => {
      return total + member.getStats().calculatePower();
    }, 0);
  }

  /** 处理战斗结果并分发奖励 */
  async processBattleRewards(
    battle: BattleAggregate,
    participants: CharacterAggregate[]
  ): Promise<CharacterAggregate[]> {
    
    if (!battle.isCompleted()) {
      throw new Error('Cannot process rewards for incomplete battle');
    }

    const result = battle.getResult()!;
    const updatedCharacters: CharacterAggregate[] = [];

    participants.forEach(character => {
      const reward = result.rewards.get(character.id);
      if (reward) {
        // 分发奖励
        character.earnMoney(reward.gold);
        character.addGuildContribution(reward.experience);
        
        updatedCharacters.push(character);
      }
    });

    return updatedCharacters;
  }
}

/** 经济系统领域服务 */
class EconomicSystemService {
  
  /** 执行安全的金币转账 */
  async transferMoney(
    from: CharacterAggregate,
    to: CharacterAggregate,
    amount: Money,
    reason: string
  ): Promise<{from: CharacterAggregate, to: CharacterAggregate}> {
    
    // 验证转账金额
    if (amount.getValue() <= 0) {
      throw new Error('Transfer amount must be positive');
    }

    // 验证发送方余额
    if (!from.getWallet().isGreaterThan(amount) && !from.getWallet().equals(amount)) {
      throw new Error('Insufficient funds');
    }

    return AggregateBoundaryEnforcer.enforceConsistencyBoundary(
      () => {
        // 执行转账
        from.spendMoney(amount);
        to.earnMoney(amount);
        
        return { from, to };
      },
      [
        () => DomainInvariantValidator.validateCharacterInvariants(from),
        () => DomainInvariantValidator.validateCharacterInvariants(to)
      ]
    );
  }

  /** 计算公会税收 */
  calculateGuildTax(transactionAmount: Money, guildLevel: number): Money {
    // 根据公会等级计算税率
    const baseTaxRate = 0.05; // 5%基础税率
    const levelBonus = (guildLevel - 1) * 0.001; // 每级降低0.1%税率
    const finalTaxRate = Math.max(0.01, baseTaxRate - levelBonus); // 最低1%税率
    
    return transactionAmount.multiply(finalTaxRate);
  }

  /** 处理公会资源分配 */
  async distributeGuildResources(
    guild: GuildAggregate,
    resourceType: string,
    totalAmount: number,
    recipients: Array<{characterId: CharacterId, percentage: number}>,
    distributor: CharacterId
  ): Promise<{guild: GuildAggregate, distributions: Array<{characterId: CharacterId, amount: number}>}> {
    
    // 验证分配者权限
    AggregateBoundaryEnforcer.enforceGuildOperationBoundary(
      guild, distributor, GuildRole.OFFICER, 'distribute resources'
    );

    // 验证百分比总和
    const totalPercentage = recipients.reduce((sum, r) => sum + r.percentage, 0);
    if (Math.abs(totalPercentage - 1.0) > 0.001) {
      throw new Error('Distribution percentages must sum to 100%');
    }

    // 验证公会有足够资源
    const availableAmount = guild.getTreasury().getResource(resourceType);
    if (availableAmount < totalAmount) {
      throw new Error('Insufficient guild resources');
    }

    return AggregateBoundaryEnforcer.enforceConsistencyBoundary(
      () => {
        // 从公会金库提取资源
        guild.withdrawResource(resourceType, totalAmount, distributor);
        
        // 计算每个接收者的分配量
        const distributions = recipients.map(recipient => ({
          characterId: recipient.characterId,
          amount: Math.floor(totalAmount * recipient.percentage)
        }));
        
        return { guild, distributions };
      },
      [() => DomainInvariantValidator.validateGuildInvariants(guild)]
    );
  }
}
```

### 1.5 事件驱动架构与上下文通信

#### 1.5.1 跨聚合通信模式

```typescript
// ============================================================================
// 事件驱动架构 - 跨聚合通信
// ============================================================================

/** 领域事件总线接口 */
interface IDomainEventBus {
  publish(event: DomainEvent): Promise<void>;
  subscribe<T extends DomainEvent>(
    eventType: string, 
    handler: (event: T) => Promise<void>
  ): void;
}

/** 事件处理器基类 */
abstract class DomainEventHandler<T extends DomainEvent> {
  abstract handle(event: T): Promise<void>;
  abstract getEventType(): string;
}

/** 任务完成事件 */
class QuestCompletedEvent extends DomainEvent {
  readonly eventType = 'QuestCompleted';
  
  constructor(
    public readonly characterId: CharacterId,
    public readonly questId: string,
    public readonly rewards: {
      experience: number;
      gold: Money;
      guildResources: Map<string, number>;
    }
  ) {
    super();
  }
}

/** 公会经验获得事件处理器 */
class GuildExperienceHandler extends DomainEventHandler<QuestCompletedEvent> {
  
  constructor(
    private guildRepository: IGuildRepository,
    private characterRepository: ICharacterRepository
  ) {
    super();
  }

  getEventType(): string {
    return 'QuestCompleted';
  }

  async handle(event: QuestCompletedEvent): Promise<void> {
    // 1. 获取角色信息
    const character = await this.characterRepository.findById(event.characterId);
    if (!character || !character.isInGuild()) {
      return; // 角色不存在或不在公会中
    }

    // 2. 获取公会信息
    const guildMembership = character.getGuildMembership()!;
    const guild = await this.guildRepository.findById(guildMembership.guildId);
    if (!guild) {
      return; // 公会不存在
    }

    // 3. 为公会增加经验
    guild.gainExperience(event.rewards.experience);

    // 4. 为公会金库添加资源
    for (const [resourceType, amount] of event.rewards.guildResources) {
      guild.depositResource(resourceType, amount, character.id);
    }

    // 5. 更新角色贡献度
    character.addGuildContribution(event.rewards.experience);

    // 6. 保存更改
    await this.guildRepository.save(guild);
    await this.characterRepository.save(character);
  }
}

/** 跨上下文工作流示例：角色完成任务获得公会奖励 */
class QuestRewardWorkflow {
  
  constructor(
    private eventBus: IDomainEventBus,
    private questService: IQuestService,
    private characterRepository: ICharacterRepository
  ) {}

  /** 完成任务的完整工作流 */
  async completeQuest(characterId: CharacterId, questId: string): Promise<void> {
    // 1. 任务系统上下文：完成任务
    const questRewards = await this.questService.completeQuest(characterId, questId);
    
    // 2. 角色系统上下文：更新角色状态
    const character = await this.characterRepository.findById(characterId);
    if (!character) {
      throw new Error('Character not found');
    }

    // 角色获得个人奖励
    character.earnMoney(questRewards.personalGold);
    character.levelUp(); // 如果满足升级条件

    await this.characterRepository.save(character);

    // 3. 发布领域事件，触发跨上下文通信
    const event = new QuestCompletedEvent(
      characterId,
      questId,
      {
        experience: questRewards.guildExperience,
        gold: questRewards.guildGold,
        guildResources: questRewards.guildResources
      }
    );

    await this.eventBus.publish(event);
    
    // 4. 事件总线会异步调用 GuildExperienceHandler.handle()
    // 这实现了任务系统与公会系统之间的松耦合通信
  }
}
```

#### 1.5.2 上下文边界映射(Context Map)

```typescript
// ============================================================================
// 上下文边界映射 - 定义各个Bounded Context之间的关系
// ============================================================================

/** 上下文关系类型 */
enum ContextRelationship {
  UPSTREAM_DOWNSTREAM = 'upstream_downstream',   // 上游-下游
  PARTNERSHIP = 'partnership',                  // 伙伴关系
  SHARED_KERNEL = 'shared_kernel',              // 共享内核
  CUSTOMER_SUPPLIER = 'customer_supplier',       // 客户-供应商
  ANTI_CORRUPTION_LAYER = 'anti_corruption_layer' // 防腐层
}

/** 上下文边界定义 */
interface BoundedContext {
  name: string;
  description: string;
  aggregates: string[];
  domainEvents: string[];
}

/** 上下文映射配置 */
class ContextMap {
  private static readonly contexts: BoundedContext[] = [
    {
      name: 'GuildManagement',
      description: '公会管理上下文',
      aggregates: ['Guild', 'Character'],
      domainEvents: ['GuildLevelUp', 'CharacterJoinedGuild', 'CharacterLeftGuild']
    },
    {
      name: 'BattleSystem', 
      description: '战斗系统上下文',
      aggregates: ['Battle'],
      domainEvents: ['BattleStarted', 'BattleCompleted', 'BattleRoundExecuted']
    },
    {
      name: 'QuestSystem',
      description: '任务系统上下文', 
      aggregates: ['Quest'],
      domainEvents: ['QuestCompleted', 'QuestAccepted', 'QuestExpired']
    },
    {
      name: 'EconomicSystem',
      description: '经济系统上下文',
      aggregates: ['Auction', 'Trade', 'Market'],
      domainEvents: ['AuctionCompleted', 'TradeExecuted', 'PriceChanged']
    }
  ];

  /** 定义上下文之间的关系 */
  private static readonly relationships = new Map<string, {
    downstream: string;
    upstream: string;
    relationship: ContextRelationship;
    description: string;
  }>([
    ['quest_to_guild', {
      downstream: 'GuildManagement',
      upstream: 'QuestSystem', 
      relationship: ContextRelationship.UPSTREAM_DOWNSTREAM,
      description: '任务系统发布QuestCompleted事件，公会管理系统监听并更新公会经验'
    }],
    ['battle_to_guild', {
      downstream: 'GuildManagement',
      upstream: 'BattleSystem',
      relationship: ContextRelationship.UPSTREAM_DOWNSTREAM, 
      description: '战斗系统发布BattleCompleted事件，公会管理系统监听并更新成员统计'
    }],
    ['guild_economy_partnership', {
      downstream: 'EconomicSystem',
      upstream: 'GuildManagement',
      relationship: ContextRelationship.PARTNERSHIP,
      description: '公会管理与经济系统紧密合作，共同管理公会金库和资源交易'
    }]
  ]);

  /** 获取所有上下文定义 */
  static getContexts(): BoundedContext[] {
    return [...this.contexts];
  }

  /** 获取上下文关系 */
  static getRelationships() {
    return new Map(this.relationships);
  }

  /** 获取特定上下文的信息 */
  static getContext(name: string): BoundedContext | undefined {
    return this.contexts.find(ctx => ctx.name === name);
  }
}

/** 防腐层(Anti-Corruption Layer)示例 */
class BattleSystemACL {
  
  /** 将公会管理上下文的数据转换为战斗系统需要的格式 */
  static adaptGuildForBattle(guild: GuildAggregate): BattleGuildView {
    return {
      id: guild.id.toString(),
      name: guild.name,
      level: guild.getLevel(),
      memberCount: guild.getMemberCount(),
      averagePower: 0 // 需要从其他地方计算
    };
  }

  /** 将角色数据转换为战斗成员格式 */
  static adaptCharacterForBattle(character: CharacterAggregate): BattleMemberView {
    const stats = character.getStats();
    return {
      id: character.id.toString(),
      name: character.name,
      power: stats.calculatePower(),
      level: stats.level,
      role: character.getGuildMembership()?.role || GuildRole.MEMBER
    };
  }
}

/** 战斗系统的公会视图（防腐层接口） */
interface BattleGuildView {
  id: string;
  name: string;
  level: number;
  memberCount: number;
  averagePower: number;
}

/** 战斗系统的成员视图 */
interface BattleMemberView {
  id: string;
  name: string;
  power: number;
  level: number;
  role: GuildRole;
}
```

### 1.6 实现最佳实践与设计原则

#### 1.6.1 DDD设计原则总结

1. **聚合边界原则**：
   - 每个聚合维护自己的业务不变量
   - 聚合根是唯一的外部访问入口
   - 聚合大小适中，避免性能问题

2. **事务一致性原则**：
   - 聚合内强一致性，聚合间最终一致性
   - 通过领域事件实现跨聚合通信
   - 使用乐观锁处理并发冲突

3. **值对象封装原则**：
   - 不可变性确保数据安全
   - 业务规则验证在构造时进行
   - 通过值比较确定相等性

4. **领域服务使用原则**：
   - 处理跨聚合的复杂业务逻辑
   - 不包含状态，只包含行为
   - 协调多个聚合的交互

#### 1.6.2 性能优化考虑

```typescript
// ============================================================================
// 性能优化策略
// ============================================================================

/** 聚合加载策略 */
class AggregateLoadingStrategy {
  
  /** 懒加载策略 - 只加载聚合根，关联数据按需加载 */
  static async loadGuildLazy(
    guildId: GuildId,
    repository: IGuildRepository
  ): Promise<GuildAggregate> {
    // 只加载公会基本信息，成员列表按需加载
    return await repository.findByIdLazy(guildId);
  }

  /** 预加载策略 - 一次性加载所有相关数据 */
  static async loadGuildEager(
    guildId: GuildId,
    repository: IGuildRepository
  ): Promise<GuildAggregate> {
    // 加载公会及所有相关数据
    return await repository.findByIdEager(guildId);
  }
}

/** 事件处理优化 */
class EventProcessingOptimizer {
  
  /** 批量处理领域事件 */
  static async processBatch(
    events: DomainEvent[],
    eventBus: IDomainEventBus
  ): Promise<void> {
    // 按事件类型分组
    const eventGroups = new Map<string, DomainEvent[]>();
    
    events.forEach(event => {
      const eventType = event.eventType;
      if (!eventGroups.has(eventType)) {
        eventGroups.set(eventType, []);
      }
      eventGroups.get(eventType)!.push(event);
    });

    // 并行处理不同类型的事件
    const processingPromises: Promise<void>[] = [];
    
    eventGroups.forEach((eventList, eventType) => {
      processingPromises.push(
        this.processEventGroup(eventList, eventBus)
      );
    });

    await Promise.all(processingPromises);
  }

  private static async processEventGroup(
    events: DomainEvent[],
    eventBus: IDomainEventBus
  ): Promise<void> {
    for (const event of events) {
      await eventBus.publish(event);
    }
  }
}
```

这个完整的DDD领域模型设计为《公会经理》游戏提供了：

1. **清晰的聚合边界**：Character、Guild、Battle三个核心聚合，职责明确
2. **完整的值对象体系**：类型安全的ID、Money、Stats等值对象
3. **严格的不变量保护**：确保业务规则的一致性
4. **灵活的事件驱动架构**：支持跨聚合的松耦合通信
5. **实用的领域服务**：处理复杂的跨聚合业务逻辑
6. **清晰的上下文边界**：定义了各个子系统之间的关系

这个设计既符合DDD理论最佳实践，又考虑了游戏业务的特殊需求，为后续的开发提供了坚实的领域模型基础。

---

## 2 六边形架构存储端口设计

> **设计原则**: 基于Hexagonal Architecture(六边形架构)理论，采用Ports and Adapters模式，确保业务逻辑与基础设施技术完全解耦，实现高度可测试和可维护的存储层架构

### 2.1 六边形架构核心概念

#### 2.1.1 六边形架构在游戏项目中的应用

六边形架构(Hexagonal Architecture)，也称为端口和适配器架构(Ports and Adapters)，是由Alistair Cockburn提出的架构模式。Martin Fowler在其著作中进一步阐述了这一架构的重要性。该架构的核心思想是：**让应用程序与外部世界的交互通过明确定义的端口进行，而具体的技术实现则通过适配器来完成**。

**核心组件**：
- **应用核心(Application Core)**：包含业务逻辑和领域模型，不依赖任何外部技术
- **端口(Ports)**：定义应用程序与外界交互的契约接口
- **适配器(Adapters)**：实现端口契约的具体技术实现

**端口分类**：
- **主端口(Primary/Driving Ports)**：用于驱动应用程序的接口(如Web API、CLI)
- **次端口(Secondary/Driven Ports)**：用于被应用程序驱动的接口(如数据库、外部服务)

```typescript
// ============================================================================
// 六边形架构层次结构
// ============================================================================

/**
 * 应用核心层 - 包含业务逻辑，不依赖外部技术
 * │
 * ├── 领域模型 (Domain Models)
 * ├── 聚合根 (Aggregate Roots)
 * ├── 值对象 (Value Objects)
 * ├── 领域服务 (Domain Services)
 * └── 端口接口 (Port Interfaces)
 *
 * 适配器层 - 具体技术实现
 * │
 * ├── 主适配器 (Primary Adapters)
 * │   ├── Web API 适配器
 * │   ├── CLI 适配器
 * │   └── 事件监听器适配器
 * │
 * └── 次适配器 (Secondary Adapters)
 *     ├── SQLite 存储适配器
 *     ├── 内存存储适配器
 *     ├── 云服务适配器
 *     └── 外部API适配器
 */

/** 端口标记接口 - 用于标识端口类型 */
interface Port {
  readonly portType: 'primary' | 'secondary';
  readonly portName: string;
}

/** 主端口标记 - 用于标识驱动应用程序的端口 */
interface PrimaryPort extends Port {
  readonly portType: 'primary';
}

/** 次端口标记 - 用于标识被应用程序驱动的端口 */
interface SecondaryPort extends Port {
  readonly portType: 'secondary';
}
```

#### 2.1.2 六边形架构的优势

1. **技术无关性**: 业务逻辑完全独立于具体技术实现
2. **可测试性**: 通过Mock适配器可以轻松进行单元测试
3. **可替换性**: 可以无缝切换不同的技术实现
4. **可维护性**: 清晰的边界降低了维护复杂度
5. **可扩展性**: 易于添加新的端口和适配器

### 2.2 存储端口(Repository Ports)设计

#### 2.2.1 基础Repository端口接口

基于DDD的Repository模式，我们为每个聚合根设计专用的存储端口。这些端口定义了存储操作的契约，而不涉及具体的存储技术。

```typescript
// ============================================================================
// 基础Repository端口定义
// ============================================================================

/** 基础Repository端口接口 */
interface IRepository<TAggregateRoot, TId> extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: string;
  
  /** 根据ID查找聚合根 */
  findById(id: TId): Promise<TAggregateRoot | null>;
  
  /** 保存聚合根 */
  save(aggregate: TAggregateRoot): Promise<void>;
  
  /** 删除聚合根 */
  delete(id: TId): Promise<void>;
  
  /** 检查聚合根是否存在 */
  exists(id: TId): Promise<boolean>;
  
  /** 获取所有聚合根(分页) */
  findAll(offset?: number, limit?: number): Promise<TAggregateRoot[]>;
  
  /** 获取聚合根总数 */
  count(): Promise<number>;
}

/** 工作单元模式接口 - 管理事务边界 */
interface IUnitOfWork extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'UnitOfWork';
  
  /** 开始事务 */
  begin(): Promise<void>;
  
  /** 提交事务 */
  commit(): Promise<void>;
  
  /** 回滚事务 */
  rollback(): Promise<void>;
  
  /** 执行事务操作 */
  execute<T>(operation: () => Promise<T>): Promise<T>;
}

/** Repository工厂接口 */
interface IRepositoryFactory extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'RepositoryFactory';
  
  /** 获取角色Repository */
  getCharacterRepository(): ICharacterRepository;
  
  /** 获取公会Repository */
  getGuildRepository(): IGuildRepository;
  
  /** 获取战斗Repository */
  getBattleRepository(): IBattleRepository;
  
  /** 获取工作单元 */
  getUnitOfWork(): IUnitOfWork;
}
```

#### 2.2.2 专用Repository端口实现

为每个聚合根定义专用的Repository端口，包含该聚合特有的查询方法。

```typescript
// ============================================================================
// 专用Repository端口接口
// ============================================================================

/** 角色Repository端口 */
interface ICharacterRepository extends IRepository<CharacterAggregate, CharacterId> {
  readonly portName: 'CharacterRepository';
  
  /** 根据公会ID查找角色列表 */
  findByGuildId(guildId: GuildId): Promise<CharacterAggregate[]>;
  
  /** 根据角色名查找角色 */
  findByName(name: string): Promise<CharacterAggregate | null>;
  
  /** 查找等级范围内的角色 */
  findByLevelRange(minLevel: number, maxLevel: number): Promise<CharacterAggregate[]>;
  
  /** 根据战斗力排序查找角色 */
  findByPowerRanking(limit: number): Promise<CharacterAggregate[]>;
  
  /** 查找在线角色 */
  findOnlineCharacters(): Promise<CharacterAggregate[]>;
}

/** 公会Repository端口 */
interface IGuildRepository extends IRepository<GuildAggregate, GuildId> {
  readonly portName: 'GuildRepository';
  
  /** 根据公会名查找公会 */
  findByName(name: string): Promise<GuildAggregate | null>;
  
  /** 根据会长ID查找公会 */
  findByLeader(leaderId: CharacterId): Promise<GuildAggregate[]>;
  
  /** 根据等级范围查找公会 */
  findByLevelRange(minLevel: number, maxLevel: number): Promise<GuildAggregate[]>;
  
  /** 查找活跃公会(按成员数排序) */
  findActiveGuilds(limit: number): Promise<GuildAggregate[]>;
  
  /** 搜索公会(模糊匹配名称和描述) */
  search(keyword: string, limit: number): Promise<GuildAggregate[]>;
}

/** 战斗Repository端口 */
interface IBattleRepository extends IRepository<BattleAggregate, BattleId> {
  readonly portName: 'BattleRepository';
  
  /** 根据公会ID查找战斗记录 */
  findByGuildId(guildId: GuildId): Promise<BattleAggregate[]>;
  
  /** 根据战斗状态查找战斗 */
  findByStatus(status: BattleStatus): Promise<BattleAggregate[]>;
  
  /** 查找正在进行的战斗 */
  findActiveBattles(): Promise<BattleAggregate[]>;
  
  /** 根据时间范围查找战斗 */
  findByDateRange(startDate: Date, endDate: Date): Promise<BattleAggregate[]>;
  
  /** 查找角色参与的战斗历史 */
  findByParticipant(characterId: CharacterId): Promise<BattleAggregate[]>;
}
```

#### 2.2.3 Repository端口实现的规约模式

为了处理复杂查询，我们引入规约模式(Specification Pattern)来封装查询逻辑。

```typescript
// ============================================================================
// 规约模式实现
// ============================================================================

/** 规约接口 */
interface ISpecification<T> {
  /** 检查实体是否满足规约 */
  isSatisfiedBy(entity: T): boolean;
  
  /** 与其他规约进行AND操作 */
  and(other: ISpecification<T>): ISpecification<T>;
  
  /** 与其他规约进行OR操作 */
  or(other: ISpecification<T>): ISpecification<T>;
  
  /** 规约取反 */
  not(): ISpecification<T>;
}

/** 规约基类 */
abstract class Specification<T> implements ISpecification<T> {
  abstract isSatisfiedBy(entity: T): boolean;
  
  and(other: ISpecification<T>): ISpecification<T> {
    return new AndSpecification(this, other);
  }
  
  or(other: ISpecification<T>): ISpecification<T> {
    return new OrSpecification(this, other);
  }
  
  not(): ISpecification<T> {
    return new NotSpecification(this);
  }
}

/** AND规约 */
class AndSpecification<T> extends Specification<T> {
  constructor(
    private readonly left: ISpecification<T>,
    private readonly right: ISpecification<T>
  ) {
    super();
  }
  
  isSatisfiedBy(entity: T): boolean {
    return this.left.isSatisfiedBy(entity) && this.right.isSatisfiedBy(entity);
  }
}

/** OR规约 */
class OrSpecification<T> extends Specification<T> {
  constructor(
    private readonly left: ISpecification<T>,
    private readonly right: ISpecification<T>
  ) {
    super();
  }
  
  isSatisfiedBy(entity: T): boolean {
    return this.left.isSatisfiedBy(entity) || this.right.isSatisfiedBy(entity);
  }
}

/** NOT规约 */
class NotSpecification<T> extends Specification<T> {
  constructor(private readonly spec: ISpecification<T>) {
    super();
  }
  
  isSatisfiedBy(entity: T): boolean {
    return !this.spec.isSatisfiedBy(entity);
  }
}

/** 角色相关规约示例 */
class CharacterInGuildSpecification extends Specification<CharacterAggregate> {
  constructor(private readonly guildId: GuildId) {
    super();
  }
  
  isSatisfiedBy(character: CharacterAggregate): boolean {
    const membership = character.getGuildMembership();
    return membership !== null && membership.guildId.equals(this.guildId);
  }
}

class CharacterLevelRangeSpecification extends Specification<CharacterAggregate> {
  constructor(
    private readonly minLevel: number,
    private readonly maxLevel: number
  ) {
    super();
  }
  
  isSatisfiedBy(character: CharacterAggregate): boolean {
    const level = character.getStats().level;
    return level >= this.minLevel && level <= this.maxLevel;
  }
}

/** 扩展Repository接口支持规约 */
interface ISpecificationRepository<TAggregateRoot, TId> 
  extends IRepository<TAggregateRoot, TId> {
  
  /** 根据规约查找实体 */
  findBySpecification(
    specification: ISpecification<TAggregateRoot>
  ): Promise<TAggregateRoot[]>;
  
  /** 根据规约统计数量 */
  countBySpecification(
    specification: ISpecification<TAggregateRoot>
  ): Promise<number>;
}
```

### 2.3 事件存储端口(Event Store Ports)设计

#### 2.3.1 事件存储核心接口

事件存储是支持事件驱动架构和Event Sourcing的关键组件。

```typescript
// ============================================================================
// 事件存储端口设计
// ============================================================================

/** 事件流标识符 */
class EventStreamId {
  constructor(private readonly value: string) {
    if (!value || value.trim().length === 0) {
      throw new Error('EventStreamId cannot be empty');
    }
  }
  
  toString(): string {
    return this.value;
  }
  
  equals(other: EventStreamId): boolean {
    return this.value === other.value;
  }
  
  static fromAggregateId<T extends TypedId>(aggregateId: T): EventStreamId {
    return new EventStreamId(aggregateId.toString());
  }
}

/** 事件元数据 */
interface EventMetadata {
  readonly eventId: string;
  readonly eventType: string;
  readonly aggregateId: string;
  readonly aggregateVersion: number;
  readonly occurredAt: Date;
  readonly correlationId?: string;
  readonly causationId?: string;
}

/** 存储的事件记录 */
interface StoredEvent {
  readonly metadata: EventMetadata;
  readonly data: any;
}

/** 事件存储端口接口 */
interface IEventStore extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'EventStore';
  
  /** 追加事件到流 */
  appendToStream(
    streamId: EventStreamId,
    expectedVersion: number,
    events: DomainEvent[]
  ): Promise<void>;
  
  /** 读取事件流 */
  readStream(
    streamId: EventStreamId,
    fromVersion?: number
  ): Promise<StoredEvent[]>;
  
  /** 读取所有事件 */
  readAllEvents(
    fromPosition?: number,
    maxCount?: number
  ): Promise<StoredEvent[]>;
  
  /** 订阅事件流 */
  subscribeToStream(
    streamId: EventStreamId,
    handler: (event: StoredEvent) => Promise<void>
  ): Promise<void>;
  
  /** 订阅所有事件 */
  subscribeToAll(
    handler: (event: StoredEvent) => Promise<void>
  ): Promise<void>;
  
  /** 创建快照 */
  saveSnapshot(
    streamId: EventStreamId,
    aggregateVersion: number,
    snapshot: any
  ): Promise<void>;
  
  /** 读取快照 */
  loadSnapshot(streamId: EventStreamId): Promise<any | null>;
}

/** 事件总线端口接口 */
interface IEventBus extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'EventBus';
  
  /** 发布单个事件 */
  publish(event: DomainEvent): Promise<void>;
  
  /** 批量发布事件 */
  publishBatch(events: DomainEvent[]): Promise<void>;
  
  /** 订阅事件类型 */
  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: (event: T) => Promise<void>
  ): void;
  
  /** 取消订阅 */
  unsubscribe(eventType: string, handler: Function): void;
}

/** 事件处理器注册表 */
interface IEventHandlerRegistry extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'EventHandlerRegistry';
  
  /** 注册事件处理器 */
  register<T extends DomainEvent>(
    eventType: string,
    handler: (event: T) => Promise<void>
  ): void;
  
  /** 获取事件处理器 */
  getHandlers(eventType: string): Array<(event: DomainEvent) => Promise<void>>;
  
  /** 清除所有处理器 */
  clear(): void;
}
```

#### 2.3.2 Event Sourcing支持

为支持Event Sourcing模式，我们设计了聚合重建和快照机制。

```typescript
// ============================================================================
// Event Sourcing支持
// ============================================================================

/** 聚合重建器接口 */
interface IAggregateRebuilder<TAggregateRoot> {
  /** 从事件流重建聚合 */
  rebuildFromEvents(
    events: DomainEvent[],
    snapshot?: any
  ): TAggregateRoot;
  
  /** 获取聚合类型 */
  getAggregateType(): string;
}

/** 角色聚合重建器 */
class CharacterAggregateRebuilder implements IAggregateRebuilder<CharacterAggregate> {
  rebuildFromEvents(
    events: DomainEvent[],
    snapshot?: any
  ): CharacterAggregate {
    let character: CharacterAggregate;
    
    if (snapshot) {
      // 从快照开始重建
      character = this.fromSnapshot(snapshot);
    } else {
      // 从第一个事件开始重建
      const creationEvent = events[0] as CharacterCreatedEvent;
      character = new CharacterAggregate(
        creationEvent.characterId,
        creationEvent.name,
        creationEvent.initialStats
      );
    }
    
    // 应用后续事件
    events.forEach(event => {
      this.applyEvent(character, event);
    });
    
    return character;
  }
  
  private applyEvent(character: CharacterAggregate, event: DomainEvent): void {
    switch (event.eventType) {
      case 'CharacterJoinedGuild':
        const joinEvent = event as CharacterJoinedGuildEvent;
        character.joinGuild(joinEvent.guildId, joinEvent.role);
        break;
      case 'CharacterLeveledUp':
        character.levelUp();
        break;
      // 其他事件处理...
    }
  }
  
  private fromSnapshot(snapshot: any): CharacterAggregate {
    return new CharacterAggregate(
      new CharacterId(snapshot.id),
      snapshot.name,
      new CharacterStats(
        snapshot.stats.attack,
        snapshot.stats.defense,
        snapshot.stats.health,
        snapshot.stats.magic,
        snapshot.stats.level
      ),
      snapshot.guildMembership ? new GuildMembership(
        new GuildId(snapshot.guildMembership.guildId),
        snapshot.guildMembership.role,
        new Date(snapshot.guildMembership.joinedAt),
        snapshot.guildMembership.contributions
      ) : null,
      new Money(snapshot.wallet),
      new Date(snapshot.createdAt),
      snapshot.version
    );
  }
  
  getAggregateType(): string {
    return 'Character';
  }
}

/** Event Sourcing Repository */
class EventSourcingRepository<TAggregateRoot, TId> 
  implements IRepository<TAggregateRoot, TId> {
  
  readonly portType = 'secondary' as const;
  readonly portName: string;
  
  constructor(
    private readonly eventStore: IEventStore,
    private readonly rebuilder: IAggregateRebuilder<TAggregateRoot>,
    portName: string
  ) {
    this.portName = portName;
  }
  
  async findById(id: TId): Promise<TAggregateRoot | null> {
    const streamId = EventStreamId.fromAggregateId(id as any);
    
    try {
      // 尝试加载快照
      const snapshot = await this.eventStore.loadSnapshot(streamId);
      
      // 读取事件流
      const events = await this.eventStore.readStream(streamId);
      
      if (events.length === 0 && !snapshot) {
        return null;
      }
      
      // 重建聚合
      const domainEvents = events.map(e => this.deserializeEvent(e));
      return this.rebuilder.rebuildFromEvents(domainEvents, snapshot);
      
    } catch (error) {
      console.error(`Failed to load aggregate ${id}:`, error);
      return null;
    }
  }
  
  async save(aggregate: TAggregateRoot): Promise<void> {
    const aggregateRoot = aggregate as any;
    const streamId = EventStreamId.fromAggregateId(aggregateRoot.id);
    
    // 获取待提交的事件
    const events = aggregateRoot.collectDomainEvents();
    
    if (events.length === 0) {
      return; // 没有变更
    }
    
    try {
      // 追加事件到流
      await this.eventStore.appendToStream(
        streamId,
        aggregateRoot.getVersion() - events.length,
        events
      );
      
      // 清除已提交的事件
      aggregateRoot.clearDomainEvents();
      
      // 考虑创建快照（每100个事件）
      if (aggregateRoot.getVersion() % 100 === 0) {
        await this.eventStore.saveSnapshot(
          streamId,
          aggregateRoot.getVersion(),
          this.createSnapshot(aggregate)
        );
      }
      
    } catch (error) {
      console.error(`Failed to save aggregate:`, error);
      throw error;
    }
  }
  
  async delete(id: TId): Promise<void> {
    // Event Sourcing中通常不删除事件，而是添加删除事件
    throw new Error('Deletion not supported in Event Sourcing. Use soft delete events instead.');
  }
  
  async exists(id: TId): Promise<boolean> {
    const aggregate = await this.findById(id);
    return aggregate !== null;
  }
  
  async findAll(offset?: number, limit?: number): Promise<TAggregateRoot[]> {
    // 这个方法在Event Sourcing中实现成本较高，建议使用读模型
    throw new Error('findAll not efficiently supported in Event Sourcing. Use read models instead.');
  }
  
  async count(): Promise<number> {
    // 同样，建议使用读模型
    throw new Error('count not efficiently supported in Event Sourcing. Use read models instead.');
  }
  
  private deserializeEvent(storedEvent: StoredEvent): DomainEvent {
    // 根据事件类型反序列化事件
    const eventType = storedEvent.metadata.eventType;
    
    // 这里应该有一个事件类型注册表来映射事件类型到具体类
    switch (eventType) {
      case 'CharacterJoinedGuild':
        return new CharacterJoinedGuildEvent(
          new CharacterId(storedEvent.data.characterId),
          new GuildId(storedEvent.data.guildId),
          storedEvent.data.role
        );
      // 其他事件类型...
      default:
        throw new Error(`Unknown event type: ${eventType}`);
    }
  }
  
  private createSnapshot(aggregate: TAggregateRoot): any {
    // 创建聚合快照
    const aggregateRoot = aggregate as any;
    return {
      id: aggregateRoot.id.toString(),
      version: aggregateRoot.getVersion(),
      // 其他状态字段...
    };
  }
}
```

### 2.4 外部服务端口(External Service Ports)设计

#### 2.4.1 支付服务端口

游戏中的付费功能需要与外部支付系统集成。

```typescript
// ============================================================================
// 外部服务端口设计
// ============================================================================

/** 支付结果值对象 */
class PaymentResult {
  constructor(
    public readonly success: boolean,
    public readonly transactionId: string,
    public readonly amount: Money,
    public readonly message: string,
    public readonly timestamp: Date = new Date()
  ) {}
}

/** 退款结果值对象 */
class RefundResult {
  constructor(
    public readonly success: boolean,
    public readonly refundId: string,
    public readonly originalTransactionId: string,
    public readonly amount: Money,
    public readonly message: string,
    public readonly timestamp: Date = new Date()
  ) {}
}

/** 支付方式枚举 */
enum PaymentMethod {
  CREDIT_CARD = 'credit_card',
  PAYPAL = 'paypal',
  ALIPAY = 'alipay',
  WECHAT_PAY = 'wechat_pay',
  APPLE_PAY = 'apple_pay',
  GOOGLE_PAY = 'google_pay'
}

/** 支付服务端口 */
interface IPaymentService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'PaymentService';
  
  /** 处理支付 */
  processPayment(
    amount: Money,
    method: PaymentMethod,
    customerInfo: CustomerInfo,
    metadata?: Record<string, any>
  ): Promise<PaymentResult>;
  
  /** 验证支付 */
  verifyPayment(transactionId: string): Promise<PaymentResult>;
  
  /** 退款 */
  refund(
    transactionId: string,
    amount?: Money,
    reason?: string
  ): Promise<RefundResult>;
  
  /** 获取支付状态 */
  getPaymentStatus(transactionId: string): Promise<string>;
  
  /** 获取支持的支付方式 */
  getSupportedMethods(): Promise<PaymentMethod[]>;
}

/** 客户信息值对象 */
class CustomerInfo {
  constructor(
    public readonly customerId: string,
    public readonly email: string,
    public readonly name?: string,
    public readonly phoneNumber?: string
  ) {
    this.validateEmail(email);
  }
  
  private validateEmail(email: string): void {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new Error('Invalid email address');
    }
  }
}
```

#### 2.4.2 通知服务端口

游戏需要向玩家发送各种通知。

```typescript
// ============================================================================
// 通知服务端口设计
// ============================================================================

/** 通知类型枚举 */
enum NotificationType {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  SUCCESS = 'success',
  GUILD_INVITATION = 'guild_invitation',
  BATTLE_STARTED = 'battle_started',
  BATTLE_COMPLETED = 'battle_completed',
  LEVEL_UP = 'level_up',
  QUEST_COMPLETED = 'quest_completed'
}

/** 通知渠道枚举 */
enum NotificationChannel {
  IN_GAME = 'in_game',
  EMAIL = 'email',
  PUSH = 'push',
  SMS = 'sms',
  WEBHOOK = 'webhook'
}

/** 通知消息值对象 */
class NotificationMessage {
  constructor(
    public readonly type: NotificationType,
    public readonly title: string,
    public readonly content: string,
    public readonly metadata: Record<string, any> = {},
    public readonly expiresAt?: Date
  ) {
    this.validateMessage();
  }
  
  private validateMessage(): void {
    if (!this.title || this.title.trim().length === 0) {
      throw new Error('Notification title cannot be empty');
    }
    if (!this.content || this.content.trim().length === 0) {
      throw new Error('Notification content cannot be empty');
    }
  }
}

/** 通知结果值对象 */
class NotificationResult {
  constructor(
    public readonly success: boolean,
    public readonly messageId: string,
    public readonly channel: NotificationChannel,
    public readonly message: string,
    public readonly timestamp: Date = new Date()
  ) {}
}

/** 通知服务端口 */
interface INotificationService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'NotificationService';
  
  /** 发送给单个角色的通知 */
  sendToCharacter(
    characterId: CharacterId,
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]>;
  
  /** 发送给公会的通知 */
  sendToGuild(
    guildId: GuildId,
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]>;
  
  /** 发送给多个角色的通知 */
  sendToCharacters(
    characterIds: CharacterId[],
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]>;
  
  /** 发送系统广播 */
  broadcast(
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]>;
  
  /** 获取角色的未读通知 */
  getUnreadNotifications(
    characterId: CharacterId
  ): Promise<StoredNotification[]>;
  
  /** 标记通知为已读 */
  markAsRead(
    characterId: CharacterId,
    notificationIds: string[]
  ): Promise<void>;
  
  /** 删除过期通知 */
  cleanupExpiredNotifications(): Promise<number>;
}

/** 存储的通知记录 */
interface StoredNotification {
  readonly id: string;
  readonly recipientId: string;
  readonly message: NotificationMessage;
  readonly channel: NotificationChannel;
  readonly sentAt: Date;
  readonly readAt?: Date;
  readonly deliveredAt?: Date;
}
```

#### 2.4.3 排行榜服务端口

游戏需要维护各种排行榜数据。

```typescript
// ============================================================================
// 排行榜服务端口设计
// ============================================================================

/** 排行榜类型枚举 */
enum LeaderboardType {
  CHARACTER_LEVEL = 'character_level',
  CHARACTER_POWER = 'character_power',
  GUILD_LEVEL = 'guild_level',
  GUILD_MEMBER_COUNT = 'guild_member_count',
  BATTLE_WINS = 'battle_wins',
  WEALTH_RANKING = 'wealth_ranking'
}

/** 排行榜条目值对象 */
class LeaderboardEntry {
  constructor(
    public readonly rank: number,
    public readonly entityId: string,
    public readonly entityName: string,
    public readonly score: number,
    public readonly metadata: Record<string, any> = {}
  ) {
    if (rank < 1) {
      throw new Error('Rank must be positive');
    }
    if (score < 0) {
      throw new Error('Score cannot be negative');
    }
  }
}

/** 排行榜查询选项 */
interface LeaderboardQuery {
  readonly type: LeaderboardType;
  readonly limit?: number;
  readonly offset?: number;
  readonly timeRange?: {
    start: Date;
    end: Date;
  };
}

/** 排行榜服务端口 */
interface ILeaderboardService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'LeaderboardService';
  
  /** 更新排行榜条目 */
  updateEntry(
    type: LeaderboardType,
    entityId: string,
    entityName: string,
    score: number,
    metadata?: Record<string, any>
  ): Promise<void>;
  
  /** 获取排行榜 */
  getLeaderboard(
    query: LeaderboardQuery
  ): Promise<LeaderboardEntry[]>;
  
  /** 获取实体在排行榜中的排名 */
  getRankOf(
    type: LeaderboardType,
    entityId: string
  ): Promise<number | null>;
  
  /** 获取实体周围的排名 */
  getRankingsAround(
    type: LeaderboardType,
    entityId: string,
    range: number
  ): Promise<LeaderboardEntry[]>;
  
  /** 重置排行榜 */
  resetLeaderboard(type: LeaderboardType): Promise<void>;
  
  /** 归档排行榜(用于赛季结算) */
  archiveLeaderboard(
    type: LeaderboardType,
    seasonId: string
  ): Promise<void>;
}
```

### 2.5 查询端口(Query Ports)设计 - CQRS支持

#### 2.5.1 读模型查询服务

为了支持CQRS模式，我们设计专门的查询服务来处理复杂的读操作。

```typescript
// ============================================================================
// CQRS查询端口设计
// ============================================================================

/** 查询结果包装器 */
class QueryResult<T> {
  constructor(
    public readonly data: T,
    public readonly totalCount: number,
    public readonly hasMore: boolean = false,
    public readonly metadata?: Record<string, any>
  ) {}
  
  static empty<T>(): QueryResult<T[]> {
    return new QueryResult<T[]>([], 0, false);
  }
  
  static single<T>(item: T): QueryResult<T> {
    return new QueryResult<T>(item, 1, false);
  }
}

/** 分页查询参数 */
interface PaginationQuery {
  readonly page: number;
  readonly pageSize: number;
  readonly sortBy?: string;
  readonly sortOrder?: 'asc' | 'desc';
}

/** 角色查询服务端口 */
interface ICharacterQueryService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'CharacterQueryService';
  
  /** 查询角色详细信息 */
  getCharacterDetails(
    characterId: CharacterId
  ): Promise<CharacterDetailsView | null>;
  
  /** 查询公会成员列表 */
  getGuildMembers(
    guildId: GuildId,
    pagination: PaginationQuery
  ): Promise<QueryResult<CharacterSummaryView[]>>;
  
  /** 搜索角色 */
  searchCharacters(
    criteria: CharacterSearchCriteria,
    pagination: PaginationQuery
  ): Promise<QueryResult<CharacterSummaryView[]>>;
  
  /** 获取角色统计数据 */
  getCharacterStatistics(
    characterId: CharacterId
  ): Promise<CharacterStatisticsView>;
  
  /** 获取在线角色列表 */
  getOnlineCharacters(
    pagination: PaginationQuery
  ): Promise<QueryResult<CharacterSummaryView[]>>;
}

/** 角色详细信息视图 */
interface CharacterDetailsView {
  readonly id: string;
  readonly name: string;
  readonly level: number;
  readonly power: number;
  readonly guild: {
    id: string;
    name: string;
    role: string;
  } | null;
  readonly stats: {
    attack: number;
    defense: number;
    health: number;
    magic: number;
  };
  readonly wallet: {
    gold: number;
  };
  readonly createdAt: Date;
  readonly lastActiveAt: Date;
}

/** 角色摘要视图 */
interface CharacterSummaryView {
  readonly id: string;
  readonly name: string;
  readonly level: number;
  readonly power: number;
  readonly guildName?: string;
  readonly isOnline: boolean;
}

/** 角色统计视图 */
interface CharacterStatisticsView {
  readonly battlesWon: number;
  readonly battlesLost: number;
  readonly totalBattles: number;
  readonly winRate: number;
  readonly questsCompleted: number;
  readonly guildContributions: number;
  readonly totalPlayTime: number;
  readonly achievements: string[];
}

/** 角色搜索条件 */
interface CharacterSearchCriteria {
  readonly namePattern?: string;
  readonly levelRange?: {
    min: number;
    max: number;
  };
  readonly powerRange?: {
    min: number;
    max: number;
  };
  readonly guildId?: string;
  readonly isOnline?: boolean;
}

/** 公会查询服务端口 */
interface IGuildQueryService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'GuildQueryService';
  
  /** 查询公会详细信息 */
  getGuildDetails(
    guildId: GuildId
  ): Promise<GuildDetailsView | null>;
  
  /** 查询公会列表 */
  getGuildList(
    criteria: GuildSearchCriteria,
    pagination: PaginationQuery
  ): Promise<QueryResult<GuildSummaryView[]>>;
  
  /** 获取公会排行榜 */
  getGuildRankings(
    type: 'level' | 'memberCount' | 'totalPower',
    pagination: PaginationQuery
  ): Promise<QueryResult<GuildRankingView[]>>;
  
  /** 获取公会活动历史 */
  getGuildActivityHistory(
    guildId: GuildId,
    dateRange: { start: Date; end: Date },
    pagination: PaginationQuery
  ): Promise<QueryResult<GuildActivityView[]>>;
}

/** 公会详细信息视图 */
interface GuildDetailsView {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly level: number;
  readonly experience: number;
  readonly memberCount: number;
  readonly memberLimit: number;
  readonly createdAt: Date;
  readonly leader: {
    id: string;
    name: string;
  };
  readonly treasury: {
    gold: number;
    resources: Record<string, number>;
  };
  readonly totalPower: number;
  readonly achievements: string[];
}

/** 公会摘要视图 */
interface GuildSummaryView {
  readonly id: string;
  readonly name: string;
  readonly level: number;
  readonly memberCount: number;
  readonly memberLimit: number;
  readonly leaderName: string;
  readonly totalPower: number;
  readonly isRecruiting: boolean;
}

/** 公会排行视图 */
interface GuildRankingView {
  readonly rank: number;
  readonly guild: GuildSummaryView;
  readonly score: number;
}

/** 公会活动视图 */
interface GuildActivityView {
  readonly id: string;
  readonly type: string;
  readonly description: string;
  readonly actorName: string;
  readonly timestamp: Date;
  readonly metadata: Record<string, any>;
}

/** 公会搜索条件 */
interface GuildSearchCriteria {
  readonly namePattern?: string;
  readonly levelRange?: {
    min: number;
    max: number;
  };
  readonly memberCountRange?: {
    min: number;
    max: number;
  };
  readonly isRecruiting?: boolean;
}
```

#### 2.5.2 战斗查询服务

```typescript
// ============================================================================
// 战斗查询服务端口
// ============================================================================

/** 战斗查询服务端口 */
interface IBattleQueryService extends SecondaryPort {
  readonly portType: 'secondary';
  readonly portName: 'BattleQueryService';
  
  /** 查询战斗详细信息 */
  getBattleDetails(
    battleId: BattleId
  ): Promise<BattleDetailsView | null>;
  
  /** 查询角色的战斗历史 */
  getCharacterBattleHistory(
    characterId: CharacterId,
    pagination: PaginationQuery
  ): Promise<QueryResult<BattleSummaryView[]>>;
  
  /** 查询公会的战斗历史 */
  getGuildBattleHistory(
    guildId: GuildId,
    pagination: PaginationQuery
  ): Promise<QueryResult<BattleSummaryView[]>>;
  
  /** 查询正在进行的战斗 */
  getActiveBattles(
    pagination: PaginationQuery
  ): Promise<QueryResult<BattleSummaryView[]>>;
  
  /** 获取战斗统计 */
  getBattleStatistics(
    entityId: string,
    entityType: 'character' | 'guild'
  ): Promise<BattleStatisticsView>;
}

/** 战斗详细信息视图 */
interface BattleDetailsView {
  readonly id: string;
  readonly type: string;
  readonly status: string;
  readonly startedAt: Date;
  readonly endedAt?: Date;
  readonly duration?: number;
  readonly attackingParty: BattlePartyView;
  readonly defendingParty: BattlePartyView;
  readonly rounds: BattleRoundView[];
  readonly result?: {
    winner: 'attacker' | 'defender' | 'draw';
    rewards: Record<string, any>;
  };
}

/** 战斗队伍视图 */
interface BattlePartyView {
  readonly guildId: string;
  readonly guildName: string;
  readonly members: Array<{
    id: string;
    name: string;
    level: number;
    power: number;
  }>;
  readonly totalPower: number;
  readonly formation: string;
}

/** 战斗回合视图 */
interface BattleRoundView {
  readonly roundNumber: number;
  readonly attackerDamage: number;
  readonly defenderDamage: number;
  readonly attackerRemainingPower: number;
  readonly defenderRemainingPower: number;
  readonly events: string[];
}

/** 战斗摘要视图 */
interface BattleSummaryView {
  readonly id: string;
  readonly type: string;
  readonly status: string;
  readonly startedAt: Date;
  readonly duration?: number;
  readonly attackingGuildName: string;
  readonly defendingGuildName: string;
  readonly winner?: 'attacker' | 'defender' | 'draw';
}

/** 战斗统计视图 */
interface BattleStatisticsView {
  readonly totalBattles: number;
  readonly wins: number;
  readonly losses: number;
  readonly draws: number;
  readonly winRate: number;
  readonly averageDuration: number;
  readonly totalDamageDealt: number;
  readonly totalDamageReceived: number;
  readonly longestBattle: number;
  readonly shortestBattle: number;
}
```

### 2.6 适配器模式实现

#### 2.6.1 SQLite存储适配器实现

```typescript
// ============================================================================
// SQLite存储适配器实现
// ============================================================================

import Database from 'better-sqlite3';

/** SQLite适配器基类 */
abstract class SqliteAdapterBase {
  protected constructor(protected readonly db: Database.Database) {}
  
  protected executeInTransaction<T>(operation: () => T): T {
    const transaction = this.db.transaction(operation);
    return transaction();
  }
  
  protected mapRowToEntity<T>(
    row: any,
    mapper: (row: any) => T
  ): T {
    return mapper(row);
  }
}

/** SQLite角色Repository适配器 */
class SqliteCharacterRepository 
  extends SqliteAdapterBase 
  implements ICharacterRepository {
  
  readonly portType = 'secondary' as const;
  readonly portName = 'CharacterRepository';
  
  constructor(db: Database.Database) {
    super(db);
    this.initializeSchema();
  }
  
  private initializeSchema(): void {
    const createTableSql = `
      CREATE TABLE IF NOT EXISTS characters (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        level INTEGER NOT NULL,
        attack INTEGER NOT NULL,
        defense INTEGER NOT NULL,
        health INTEGER NOT NULL,
        magic INTEGER NOT NULL,
        gold INTEGER NOT NULL,
        guild_id TEXT,
        guild_role TEXT,
        guild_joined_at TEXT,
        guild_contributions INTEGER DEFAULT 0,
        created_at TEXT NOT NULL,
        version INTEGER NOT NULL DEFAULT 1,
        
        CONSTRAINT fk_guild
          FOREIGN KEY (guild_id)
          REFERENCES guilds (id)
          ON DELETE SET NULL
      )
    `;
    
    this.db.exec(createTableSql);
    
    // 创建索引
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_characters_guild_id ON characters(guild_id)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_characters_level ON characters(level)');
    this.db.exec('CREATE INDEX IF NOT EXISTS idx_characters_name ON characters(name)');
  }
  
  async findById(id: CharacterId): Promise<CharacterAggregate | null> {
    const query = this.db.prepare(`
      SELECT * FROM characters WHERE id = ?
    `);
    
    const row = query.get(id.toString());
    
    if (!row) {
      return null;
    }
    
    return this.mapRowToCharacterAggregate(row);
  }
  
  async save(character: CharacterAggregate): Promise<void> {
    const characterData = this.mapCharacterToRow(character);
    
    this.executeInTransaction(() => {
      const existsQuery = this.db.prepare('SELECT 1 FROM characters WHERE id = ?');
      const exists = existsQuery.get(character.id.toString());
      
      if (exists) {
        // 更新
        const updateQuery = this.db.prepare(`
          UPDATE characters SET
            name = ?,
            level = ?,
            attack = ?,
            defense = ?,
            health = ?,
            magic = ?,
            gold = ?,
            guild_id = ?,
            guild_role = ?,
            guild_joined_at = ?,
            guild_contributions = ?,
            version = ?
          WHERE id = ? AND version = ?
        `);
        
        const result = updateQuery.run(
          characterData.name,
          characterData.level,
          characterData.attack,
          characterData.defense,
          characterData.health,
          characterData.magic,
          characterData.gold,
          characterData.guild_id,
          characterData.guild_role,
          characterData.guild_joined_at,
          characterData.guild_contributions,
          characterData.version,
          characterData.id,
          characterData.version - 1 // 乐观锁
        );
        
        if (result.changes === 0) {
          throw new Error('Optimistic lock failed: Character was modified by another process');
        }
      } else {
        // 插入
        const insertQuery = this.db.prepare(`
          INSERT INTO characters (
            id, name, level, attack, defense, health, magic, gold,
            guild_id, guild_role, guild_joined_at, guild_contributions,
            created_at, version
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        insertQuery.run(
          characterData.id,
          characterData.name,
          characterData.level,
          characterData.attack,
          characterData.defense,
          characterData.health,
          characterData.magic,
          characterData.gold,
          characterData.guild_id,
          characterData.guild_role,
          characterData.guild_joined_at,
          characterData.guild_contributions,
          characterData.created_at,
          characterData.version
        );
      }
    });
  }
  
  async delete(id: CharacterId): Promise<void> {
    const query = this.db.prepare('DELETE FROM characters WHERE id = ?');
    const result = query.run(id.toString());
    
    if (result.changes === 0) {
      throw new Error(`Character with id ${id} not found`);
    }
  }
  
  async exists(id: CharacterId): Promise<boolean> {
    const query = this.db.prepare('SELECT 1 FROM characters WHERE id = ?');
    return query.get(id.toString()) !== undefined;
  }
  
  async findAll(offset: number = 0, limit: number = 50): Promise<CharacterAggregate[]> {
    const query = this.db.prepare(`
      SELECT * FROM characters 
      ORDER BY created_at DESC 
      LIMIT ? OFFSET ?
    `);
    
    const rows = query.all(limit, offset);
    return rows.map(row => this.mapRowToCharacterAggregate(row));
  }
  
  async count(): Promise<number> {
    const query = this.db.prepare('SELECT COUNT(*) as count FROM characters');
    const result = query.get() as { count: number };
    return result.count;
  }
  
  async findByGuildId(guildId: GuildId): Promise<CharacterAggregate[]> {
    const query = this.db.prepare(`
      SELECT * FROM characters 
      WHERE guild_id = ? 
      ORDER BY guild_contributions DESC
    `);
    
    const rows = query.all(guildId.toString());
    return rows.map(row => this.mapRowToCharacterAggregate(row));
  }
  
  async findByName(name: string): Promise<CharacterAggregate | null> {
    const query = this.db.prepare('SELECT * FROM characters WHERE name = ?');
    const row = query.get(name);
    
    return row ? this.mapRowToCharacterAggregate(row) : null;
  }
  
  async findByLevelRange(
    minLevel: number, 
    maxLevel: number
  ): Promise<CharacterAggregate[]> {
    const query = this.db.prepare(`
      SELECT * FROM characters 
      WHERE level BETWEEN ? AND ? 
      ORDER BY level DESC
    `);
    
    const rows = query.all(minLevel, maxLevel);
    return rows.map(row => this.mapRowToCharacterAggregate(row));
  }
  
  async findByPowerRanking(limit: number): Promise<CharacterAggregate[]> {
    const query = this.db.prepare(`
      SELECT * FROM characters 
      ORDER BY (attack * 2 + defense * 1.5 + health * 0.5 + magic * 1.8) DESC 
      LIMIT ?
    `);
    
    const rows = query.all(limit);
    return rows.map(row => this.mapRowToCharacterAggregate(row));
  }
  
  async findOnlineCharacters(): Promise<CharacterAggregate[]> {
    // 这里需要额外的在线状态表或者Redis缓存
    // 为了示例，我们返回最近活跃的角色
    const query = this.db.prepare(`
      SELECT c.* FROM characters c
      LEFT JOIN character_sessions s ON c.id = s.character_id
      WHERE s.ended_at IS NULL
      ORDER BY s.started_at DESC
    `);
    
    const rows = query.all();
    return rows.map(row => this.mapRowToCharacterAggregate(row));
  }
  
  private mapRowToCharacterAggregate(row: any): CharacterAggregate {
    const stats = new CharacterStats(
      row.attack,
      row.defense,
      row.health,
      row.magic,
      row.level
    );
    
    let guildMembership: GuildMembership | null = null;
    if (row.guild_id) {
      guildMembership = new GuildMembership(
        new GuildId(row.guild_id),
        row.guild_role as GuildRole,
        new Date(row.guild_joined_at),
        row.guild_contributions
      );
    }
    
    return new CharacterAggregate(
      new CharacterId(row.id),
      row.name,
      stats,
      guildMembership,
      Money.fromCents(row.gold), // 从数据库读取分值
      new Date(row.created_at),
      row.version
    );
  }
  
  private mapCharacterToRow(character: CharacterAggregate): any {
    const stats = character.getStats();
    const membership = character.getGuildMembership();
    
    return {
      id: character.id.toString(),
      name: character.name,
      level: stats.level,
      attack: stats.attack,
      defense: stats.defense,
      health: stats.health,
      magic: stats.magic,
      gold: character.getWallet().toCents(), // 存储分值到数据库
      guild_id: membership?.guildId.toString() || null,
      guild_role: membership?.role || null,
      guild_joined_at: membership?.joinedAt.toISOString() || null,
      guild_contributions: membership?.contributions || 0,
      created_at: character.createdAt.toISOString(),
      version: character.getVersion()
    };
  }
}
```

#### 2.6.2 内存存储适配器实现

```typescript
// ============================================================================
// 内存存储适配器实现 - 用于测试和开发
// ============================================================================

/** 内存角色Repository适配器 */
class InMemoryCharacterRepository implements ICharacterRepository {
  readonly portType = 'secondary' as const;
  readonly portName = 'CharacterRepository';
  
  private characters = new Map<string, CharacterAggregate>();
  
  async findById(id: CharacterId): Promise<CharacterAggregate | null> {
    return this.characters.get(id.toString()) || null;
  }
  
  async save(character: CharacterAggregate): Promise<void> {
    // 深度克隆以避免引用问题
    const cloned = this.deepClone(character);
    this.characters.set(character.id.toString(), cloned);
  }
  
  async delete(id: CharacterId): Promise<void> {
    if (!this.characters.has(id.toString())) {
      throw new Error(`Character with id ${id} not found`);
    }
    this.characters.delete(id.toString());
  }
  
  async exists(id: CharacterId): Promise<boolean> {
    return this.characters.has(id.toString());
  }
  
  async findAll(offset: number = 0, limit: number = 50): Promise<CharacterAggregate[]> {
    const allCharacters = Array.from(this.characters.values());
    return allCharacters
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(offset, offset + limit)
      .map(char => this.deepClone(char));
  }
  
  async count(): Promise<number> {
    return this.characters.size;
  }
  
  async findByGuildId(guildId: GuildId): Promise<CharacterAggregate[]> {
    return Array.from(this.characters.values())
      .filter(char => {
        const membership = char.getGuildMembership();
        return membership && membership.guildId.equals(guildId);
      })
      .sort((a, b) => {
        const aContrib = a.getGuildMembership()!.contributions;
        const bContrib = b.getGuildMembership()!.contributions;
        return bContrib - aContrib;
      })
      .map(char => this.deepClone(char));
  }
  
  async findByName(name: string): Promise<CharacterAggregate | null> {
    for (const character of this.characters.values()) {
      if (character.name === name) {
        return this.deepClone(character);
      }
    }
    return null;
  }
  
  async findByLevelRange(
    minLevel: number, 
    maxLevel: number
  ): Promise<CharacterAggregate[]> {
    return Array.from(this.characters.values())
      .filter(char => {
        const level = char.getStats().level;
        return level >= minLevel && level <= maxLevel;
      })
      .sort((a, b) => b.getStats().level - a.getStats().level)
      .map(char => this.deepClone(char));
  }
  
  async findByPowerRanking(limit: number): Promise<CharacterAggregate[]> {
    return Array.from(this.characters.values())
      .sort((a, b) => {
        const aPower = a.getStats().calculatePower();
        const bPower = b.getStats().calculatePower();
        return bPower - aPower;
      })
      .slice(0, limit)
      .map(char => this.deepClone(char));
  }
  
  async findOnlineCharacters(): Promise<CharacterAggregate[]> {
    // 在内存实现中，我们模拟所有角色都在线
    return Array.from(this.characters.values())
      .map(char => this.deepClone(char));
  }
  
  /** 清空所有数据 - 仅用于测试 */
  clear(): void {
    this.characters.clear();
  }
  
  /** 正确重建CharacterAggregate，保持类型不丢失 */
  private deepClone(character: CharacterAggregate): CharacterAggregate {
    // 获取角色基础信息
    const stats = character.getStats();
    const guildMembership = character.getGuildMembership();
    
    // 重建金钱对象（保持精度）
    const wallet = Money.fromCents(character.getWallet().toCents());
    
    // 使用构造函数重建聚合根，确保所有方法和原型链完整
    return new CharacterAggregate(
      character.id,
      character.name,
      stats,
      guildMembership ? {
        guildId: guildMembership.guildId,
        role: guildMembership.role,
        joinedAt: new Date(guildMembership.joinedAt.getTime()), // 重建Date对象
        contributions: guildMembership.contributions
      } : null,
      wallet,
      new Date(character.createdAt.getTime()), // 重建Date对象
      character.getVersion()
    );
  }
}

/** 内存工作单元实现 */
class InMemoryUnitOfWork implements IUnitOfWork {
  readonly portType = 'secondary' as const;
  readonly portName = 'UnitOfWork';
  
  private transactionActive = false;
  private rollbackActions: Array<() => void> = [];
  
  async begin(): Promise<void> {
    if (this.transactionActive) {
      throw new Error('Transaction already active');
    }
    this.transactionActive = true;
    this.rollbackActions = [];
  }
  
  async commit(): Promise<void> {
    if (!this.transactionActive) {
      throw new Error('No active transaction');
    }
    this.transactionActive = false;
    this.rollbackActions = [];
  }
  
  async rollback(): Promise<void> {
    if (!this.transactionActive) {
      throw new Error('No active transaction');
    }
    
    // 执行回滚操作
    for (const action of this.rollbackActions.reverse()) {
      action();
    }
    
    this.transactionActive = false;
    this.rollbackActions = [];
  }
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    await this.begin();
    
    try {
      const result = await operation();
      await this.commit();
      return result;
    } catch (error) {
      await this.rollback();
      throw error;
    }
  }
  
  addRollbackAction(action: () => void): void {
    if (this.transactionActive) {
      this.rollbackActions.push(action);
    }
  }
}
```

### 2.7 依赖注入容器配置

#### 2.7.1 IoC容器设计

```typescript
// ============================================================================
// 依赖注入容器实现
// ============================================================================

/** 服务生命周期类型 */
enum ServiceLifetime {
  SINGLETON = 'singleton',
  TRANSIENT = 'transient',
  SCOPED = 'scoped'
}

/** 服务描述符 */
interface ServiceDescriptor {
  token: string;
  implementation?: new (...args: any[]) => any;
  factory?: (...args: any[]) => any;
  instance?: any;
  lifetime: ServiceLifetime;
  dependencies?: string[];
}

/** 依赖注入容器 */
class DIContainer {
  private services = new Map<string, ServiceDescriptor>();
  private instances = new Map<string, any>();
  private scopedInstances = new Map<string, any>();
  
  /** 注册单例服务 */
  singleton<T>(
    token: string,
    implementation: new (...args: any[]) => T,
    dependencies: string[] = []
  ): void {
    this.services.set(token, {
      token,
      implementation,
      lifetime: ServiceLifetime.SINGLETON,
      dependencies
    });
  }
  
  /** 注册瞬态服务 */
  transient<T>(
    token: string,
    implementation: new (...args: any[]) => T,
    dependencies: string[] = []
  ): void {
    this.services.set(token, {
      token,
      implementation,
      lifetime: ServiceLifetime.TRANSIENT,
      dependencies
    });
  }
  
  /** 注册作用域服务 */
  scoped<T>(
    token: string,
    implementation: new (...args: any[]) => T,
    dependencies: string[] = []
  ): void {
    this.services.set(token, {
      token,
      implementation,
      lifetime: ServiceLifetime.SCOPED,
      dependencies
    });
  }
  
  /** 注册工厂服务 */
  factory<T>(
    token: string,
    factory: (...args: any[]) => T,
    lifetime: ServiceLifetime = ServiceLifetime.TRANSIENT,
    dependencies: string[] = []
  ): void {
    this.services.set(token, {
      token,
      factory,
      lifetime,
      dependencies
    });
  }
  
  /** 注册实例 */
  instance<T>(token: string, instance: T): void {
    this.services.set(token, {
      token,
      instance,
      lifetime: ServiceLifetime.SINGLETON
    });
  }
  
  /** 解析服务 */
  resolve<T>(token: string): T {
    const descriptor = this.services.get(token);
    if (!descriptor) {
      throw new Error(`Service ${token} not registered`);
    }
    
    // 检查是否有现成的实例
    if (descriptor.lifetime === ServiceLifetime.SINGLETON) {
      if (this.instances.has(token)) {
        return this.instances.get(token);
      }
    } else if (descriptor.lifetime === ServiceLifetime.SCOPED) {
      if (this.scopedInstances.has(token)) {
        return this.scopedInstances.get(token);
      }
    }
    
    // 创建新实例
    let instance: T;
    
    if (descriptor.instance) {
      instance = descriptor.instance;
    } else if (descriptor.factory) {
      const dependencies = this.resolveDependencies(descriptor.dependencies || []);
      instance = descriptor.factory(...dependencies);
    } else if (descriptor.implementation) {
      const dependencies = this.resolveDependencies(descriptor.dependencies || []);
      instance = new descriptor.implementation(...dependencies);
    } else {
      throw new Error(`Invalid service descriptor for ${token}`);
    }
    
    // 缓存实例
    if (descriptor.lifetime === ServiceLifetime.SINGLETON) {
      this.instances.set(token, instance);
    } else if (descriptor.lifetime === ServiceLifetime.SCOPED) {
      this.scopedInstances.set(token, instance);
    }
    
    return instance;
  }
  
  /** 清除作用域实例 */
  clearScope(): void {
    this.scopedInstances.clear();
  }
  
  /** 解析依赖项 */
  private resolveDependencies(dependencies: string[]): any[] {
    return dependencies.map(dep => this.resolve(dep));
  }
  
  /** 检查循环依赖 */
  private checkCircularDependency(token: string, visited: Set<string> = new Set()): void {
    if (visited.has(token)) {
      throw new Error(`Circular dependency detected: ${Array.from(visited).join(' -> ')} -> ${token}`);
    }
    
    visited.add(token);
    
    const descriptor = this.services.get(token);
    if (descriptor && descriptor.dependencies) {
      for (const dep of descriptor.dependencies) {
        this.checkCircularDependency(dep, new Set(visited));
      }
    }
  }
  
  /** 验证所有服务配置 */
  validate(): void {
    for (const [token] of this.services) {
      this.checkCircularDependency(token);
    }
  }
}

/** 服务令牌常量 */
const ServiceTokens = {
  // Repository服务
  CHARACTER_REPOSITORY: 'ICharacterRepository',
  GUILD_REPOSITORY: 'IGuildRepository',
  BATTLE_REPOSITORY: 'IBattleRepository',
  
  // 查询服务
  CHARACTER_QUERY_SERVICE: 'ICharacterQueryService',
  GUILD_QUERY_SERVICE: 'IGuildQueryService',
  BATTLE_QUERY_SERVICE: 'IBattleQueryService',
  
  // 事件服务
  EVENT_STORE: 'IEventStore',
  EVENT_BUS: 'IEventBus',
  EVENT_HANDLER_REGISTRY: 'IEventHandlerRegistry',
  
  // 外部服务
  PAYMENT_SERVICE: 'IPaymentService',
  NOTIFICATION_SERVICE: 'INotificationService',
  LEADERBOARD_SERVICE: 'ILeaderboardService',
  
  // 基础设施
  DATABASE: 'Database',
  UNIT_OF_WORK: 'IUnitOfWork',
  REPOSITORY_FACTORY: 'IRepositoryFactory'
} as const;
```

#### 2.7.2 配置模块

```typescript
// ============================================================================
// 依赖注入配置
// ============================================================================

/** 环境配置 */
interface EnvironmentConfig {
  readonly isProduction: boolean;
  readonly databasePath: string;
  readonly logLevel: 'debug' | 'info' | 'warn' | 'error';
  readonly enableEventSourcing: boolean;
  readonly enableQueryOptimization: boolean;
}

/** 容器配置器 */
class ContainerConfigurator {
  
  /** 配置开发环境容器 */
  static configureDevelopment(container: DIContainer): void {
    // 使用内存存储用于快速开发
    container.singleton(
      ServiceTokens.CHARACTER_REPOSITORY,
      InMemoryCharacterRepository
    );
    
    container.singleton(
      ServiceTokens.GUILD_REPOSITORY,
      InMemoryGuildRepository
    );
    
    container.singleton(
      ServiceTokens.BATTLE_REPOSITORY,
      InMemoryBattleRepository
    );
    
    // 简单的内存事件总线
    container.singleton(
      ServiceTokens.EVENT_BUS,
      InMemoryEventBus
    );
    
    container.singleton(
      ServiceTokens.EVENT_STORE,
      InMemoryEventStore
    );
    
    // Mock外部服务
    container.singleton(
      ServiceTokens.PAYMENT_SERVICE,
      MockPaymentService
    );
    
    container.singleton(
      ServiceTokens.NOTIFICATION_SERVICE,
      MockNotificationService
    );
    
    container.singleton(
      ServiceTokens.LEADERBOARD_SERVICE,
      MockLeaderboardService
    );
    
    // 工作单元
    container.singleton(
      ServiceTokens.UNIT_OF_WORK,
      InMemoryUnitOfWork
    );
  }
  
  /** 配置生产环境容器 */
  static configureProduction(
    container: DIContainer,
    config: EnvironmentConfig
  ): void {
    // 数据库连接
    container.instance(
      ServiceTokens.DATABASE,
      new Database(config.databasePath)
    );
    
    // SQLite存储
    container.singleton(
      ServiceTokens.CHARACTER_REPOSITORY,
      SqliteCharacterRepository,
      [ServiceTokens.DATABASE]
    );
    
    container.singleton(
      ServiceTokens.GUILD_REPOSITORY,
      SqliteGuildRepository,
      [ServiceTokens.DATABASE]
    );
    
    container.singleton(
      ServiceTokens.BATTLE_REPOSITORY,
      SqliteBattleRepository,
      [ServiceTokens.DATABASE]
    );
    
    // Event Sourcing (如果启用)
    if (config.enableEventSourcing) {
      container.singleton(
        ServiceTokens.EVENT_STORE,
        SqliteEventStore,
        [ServiceTokens.DATABASE]
      );
    } else {
      container.singleton(
        ServiceTokens.EVENT_STORE,
        InMemoryEventStore
      );
    }
    
    // 事件总线
    container.singleton(
      ServiceTokens.EVENT_BUS,
      DefaultEventBus,
      [ServiceTokens.EVENT_HANDLER_REGISTRY]
    );
    
    container.singleton(
      ServiceTokens.EVENT_HANDLER_REGISTRY,
      DefaultEventHandlerRegistry
    );
    
    // 查询服务 (如果启用优化)
    if (config.enableQueryOptimization) {
      container.singleton(
        ServiceTokens.CHARACTER_QUERY_SERVICE,
        OptimizedCharacterQueryService,
        [ServiceTokens.DATABASE]
      );
      
      container.singleton(
        ServiceTokens.GUILD_QUERY_SERVICE,
        OptimizedGuildQueryService,
        [ServiceTokens.DATABASE]
      );
      
      container.singleton(
        ServiceTokens.BATTLE_QUERY_SERVICE,
        OptimizedBattleQueryService,
        [ServiceTokens.DATABASE]
      );
    } else {
      container.singleton(
        ServiceTokens.CHARACTER_QUERY_SERVICE,
        BasicCharacterQueryService,
        [ServiceTokens.CHARACTER_REPOSITORY]
      );
      
      container.singleton(
        ServiceTokens.GUILD_QUERY_SERVICE,
        BasicGuildQueryService,
        [ServiceTokens.GUILD_REPOSITORY]
      );
      
      container.singleton(
        ServiceTokens.BATTLE_QUERY_SERVICE,
        BasicBattleQueryService,
        [ServiceTokens.BATTLE_REPOSITORY]
      );
    }
    
    // 外部服务 (生产实现)
    container.singleton(
      ServiceTokens.PAYMENT_SERVICE,
      StripePaymentService // 或其他真实的支付服务
    );
    
    container.singleton(
      ServiceTokens.NOTIFICATION_SERVICE,
      ElectronNotificationService
    );
    
    container.singleton(
      ServiceTokens.LEADERBOARD_SERVICE,
      RedisLeaderboardService // 或其他高性能实现
    );
    
    // SQLite工作单元
    container.singleton(
      ServiceTokens.UNIT_OF_WORK,
      SqliteUnitOfWork,
      [ServiceTokens.DATABASE]
    );
  }
  
  /** 配置测试环境容器 */
  static configureTest(container: DIContainer): void {
    // 使用Mock实现便于测试
    container.transient(
      ServiceTokens.CHARACTER_REPOSITORY,
      MockCharacterRepository
    );
    
    container.transient(
      ServiceTokens.GUILD_REPOSITORY,
      MockGuildRepository
    );
    
    container.transient(
      ServiceTokens.BATTLE_REPOSITORY,
      MockBattleRepository
    );
    
    // 可控制的事件总线
    container.transient(
      ServiceTokens.EVENT_BUS,
      TestEventBus
    );
    
    container.transient(
      ServiceTokens.EVENT_STORE,
      TestEventStore
    );
    
    // 完全可控的外部服务Mock
    container.transient(
      ServiceTokens.PAYMENT_SERVICE,
      ControllablePaymentService
    );
    
    container.transient(
      ServiceTokens.NOTIFICATION_SERVICE,
      ControllableNotificationService
    );
    
    container.transient(
      ServiceTokens.LEADERBOARD_SERVICE,
      ControllableLeaderboardService
    );
    
    // 测试工作单元
    container.transient(
      ServiceTokens.UNIT_OF_WORK,
      TestUnitOfWork
    );
  }
}

/** 全局容器实例 */
export const AppContainer = new DIContainer();

/** 初始化容器 */
export function initializeContainer(environment: 'development' | 'production' | 'test', config?: EnvironmentConfig): void {
  switch (environment) {
    case 'development':
      ContainerConfigurator.configureDevelopment(AppContainer);
      break;
    case 'production':
      if (!config) {
        throw new Error('Production environment requires configuration');
      }
      ContainerConfigurator.configureProduction(AppContainer, config);
      break;
    case 'test':
      ContainerConfigurator.configureTest(AppContainer);
      break;
    default:
      throw new Error(`Unknown environment: ${environment}`);
  }
  
  // 验证容器配置
  AppContainer.validate();
}
```

### 2.8 测试策略和Mock实现

#### 2.8.1 测试基础设施

```typescript
// ============================================================================
// 测试基础设施和Mock实现
// ============================================================================

/** 测试基类 */
abstract class TestBase {
  protected container: DIContainer;
  
  constructor() {
    this.container = new DIContainer();
    ContainerConfigurator.configureTest(this.container);
  }
  
  /** 设置测试 */
  protected setup(): void {
    // 子类可以覆盖此方法进行特定设置
  }
  
  /** 清理测试 */
  protected teardown(): void {
    this.container.clearScope();
  }
  
  /** 获取服务 */
  protected getService<T>(token: string): T {
    return this.container.resolve<T>(token);
  }
}

/** Repository契约测试基类 */
abstract class RepositoryContractTest<TAggregateRoot, TId> extends TestBase {
  
  protected abstract getRepository(): IRepository<TAggregateRoot, TId>;
  protected abstract createTestAggregate(): TAggregateRoot;
  protected abstract getAggregateId(aggregate: TAggregateRoot): TId;
  
  /** 测试基本CRUD操作 */
  async testCrudOperations(): Promise<void> {
    const repository = this.getRepository();
    const aggregate = this.createTestAggregate();
    const id = this.getAggregateId(aggregate);
    
    // 测试保存
    await repository.save(aggregate);
    
    // 测试查找
    const found = await repository.findById(id);
    this.assertNotNull(found, 'Aggregate should be found after save');
    
    // 测试存在性检查
    const exists = await repository.exists(id);
    this.assertTrue(exists, 'Aggregate should exist after save');
    
    // 测试删除
    await repository.delete(id);
    
    // 测试删除后查找
    const notFound = await repository.findById(id);
    this.assertNull(notFound, 'Aggregate should not be found after delete');
    
    // 测试删除后存在性检查
    const notExists = await repository.exists(id);
    this.assertFalse(notExists, 'Aggregate should not exist after delete');
  }
  
  /** 测试并发访问 */
  async testConcurrentAccess(): Promise<void> {
    const repository = this.getRepository();
    const aggregate = this.createTestAggregate();
    
    await repository.save(aggregate);
    
    // 模拟并发修改
    const promises = Array.from({ length: 10 }, async (_, i) => {
      const id = this.getAggregateId(aggregate);
      const found = await repository.findById(id);
      if (found) {
        // 修改聚合状态
        this.modifyAggregate(found, i);
        await repository.save(found);
      }
    });
    
    // 某些操作可能失败（乐观锁），这是预期的
    const results = await Promise.allSettled(promises);
    
    // 至少应该有一些操作成功
    const successCount = results.filter(r => r.status === 'fulfilled').length;
    this.assertTrue(successCount > 0, 'At least some concurrent operations should succeed');
  }
  
  /** 修改聚合状态 - 子类实现 */
  protected abstract modifyAggregate(aggregate: TAggregateRoot, iteration: number): void;
  
  // 断言方法
  protected assertNotNull<T>(value: T | null, message: string): void {
    if (value === null) {
      throw new Error(message);
    }
  }
  
  protected assertNull<T>(value: T | null, message: string): void {
    if (value !== null) {
      throw new Error(message);
    }
  }
  
  protected assertTrue(condition: boolean, message: string): void {
    if (!condition) {
      throw new Error(message);
    }
  }
  
  protected assertFalse(condition: boolean, message: string): void {
    if (condition) {
      throw new Error(message);
    }
  }
}

/** 角色Repository契约测试 */
class CharacterRepositoryContractTest extends RepositoryContractTest<CharacterAggregate, CharacterId> {
  
  protected getRepository(): ICharacterRepository {
    return this.getService<ICharacterRepository>(ServiceTokens.CHARACTER_REPOSITORY);
  }
  
  protected createTestAggregate(): CharacterAggregate {
    const stats = new CharacterStats(10, 8, 100, 5, 1);
    return new CharacterAggregate(
      CharacterId.generate(),
      'TestCharacter',
      stats
    );
  }
  
  protected getAggregateId(aggregate: CharacterAggregate): CharacterId {
    return aggregate.id;
  }
  
  protected modifyAggregate(aggregate: CharacterAggregate, iteration: number): void {
    // 模拟升级
    aggregate.levelUp();
  }
  
  /** 测试角色特定功能 */
  async testCharacterSpecificFeatures(): Promise<void> {
    const repository = this.getRepository();
    const character = this.createTestAggregate();
    
    await repository.save(character);
    
    // 测试按名称查找
    const foundByName = await repository.findByName(character.name);
    this.assertNotNull(foundByName, 'Character should be found by name');
    
    // 测试按等级范围查找
    const inLevelRange = await repository.findByLevelRange(1, 10);
    this.assertTrue(
      inLevelRange.some(c => c.id.equals(character.id)),
      'Character should be in level range'
    );
  }
}
```

#### 2.8.2 可控制的Mock服务

```typescript
// ============================================================================
// 可控制的Mock服务实现
// ============================================================================

/** 可控制的支付服务Mock */
class ControllablePaymentService implements IPaymentService {
  readonly portType = 'secondary' as const;
  readonly portName = 'PaymentService';
  
  private shouldSucceed = true;
  private simulatedDelay = 0;
  private paymentResults: PaymentResult[] = [];
  
  /** 设置下次操作是否成功 */
  setShouldSucceed(succeed: boolean): void {
    this.shouldSucceed = succeed;
  }
  
  /** 设置模拟延迟 */
  setSimulatedDelay(delayMs: number): void {
    this.simulatedDelay = delayMs;
  }
  
  /** 获取所有支付记录 */
  getPaymentHistory(): PaymentResult[] {
    return [...this.paymentResults];
  }
  
  /** 清除支付记录 */
  clearHistory(): void {
    this.paymentResults = [];
  }
  
  async processPayment(
    amount: Money,
    method: PaymentMethod,
    customerInfo: CustomerInfo,
    metadata?: Record<string, any>
  ): Promise<PaymentResult> {
    await this.delay();
    
    const result = new PaymentResult(
      this.shouldSucceed,
      `txn_${Date.now()}`,
      amount,
      this.shouldSucceed ? 'Payment successful' : 'Payment failed'
    );
    
    this.paymentResults.push(result);
    
    if (!this.shouldSucceed) {
      throw new Error('Payment processing failed');
    }
    
    return result;
  }
  
  async verifyPayment(transactionId: string): Promise<PaymentResult> {
    await this.delay();
    
    const existing = this.paymentResults.find(p => p.transactionId === transactionId);
    if (existing) {
      return existing;
    }
    
    throw new Error(`Transaction ${transactionId} not found`);
  }
  
  async refund(
    transactionId: string,
    amount?: Money,
    reason?: string
  ): Promise<RefundResult> {
    await this.delay();
    
    const payment = this.paymentResults.find(p => p.transactionId === transactionId);
    if (!payment) {
      throw new Error(`Transaction ${transactionId} not found`);
    }
    
    const refundAmount = amount || payment.amount;
    
    return new RefundResult(
      this.shouldSucceed,
      `rfnd_${Date.now()}`,
      transactionId,
      refundAmount,
      this.shouldSucceed ? 'Refund successful' : 'Refund failed'
    );
  }
  
  async getPaymentStatus(transactionId: string): Promise<string> {
    await this.delay();
    
    const payment = this.paymentResults.find(p => p.transactionId === transactionId);
    return payment ? (payment.success ? 'completed' : 'failed') : 'not_found';
  }
  
  async getSupportedMethods(): Promise<PaymentMethod[]> {
    return [
      PaymentMethod.CREDIT_CARD,
      PaymentMethod.PAYPAL,
      PaymentMethod.ALIPAY
    ];
  }
  
  private async delay(): Promise<void> {
    if (this.simulatedDelay > 0) {
      await new Promise(resolve => setTimeout(resolve, this.simulatedDelay));
    }
  }
}

/** 可控制的通知服务Mock */
class ControllableNotificationService implements INotificationService {
  readonly portType = 'secondary' as const;
  readonly portName = 'NotificationService';
  
  private sentNotifications: Array<{
    recipientId: string;
    message: NotificationMessage;
    channels: NotificationChannel[];
    timestamp: Date;
  }> = [];
  
  private shouldSucceed = true;
  private simulatedDelay = 0;
  
  /** 设置下次操作是否成功 */
  setShouldSucceed(succeed: boolean): void {
    this.shouldSucceed = succeed;
  }
  
  /** 设置模拟延迟 */
  setSimulatedDelay(delayMs: number): void {
    this.simulatedDelay = delayMs;
  }
  
  /** 获取已发送的通知 */
  getSentNotifications(): Array<{
    recipientId: string;
    message: NotificationMessage;
    channels: NotificationChannel[];
    timestamp: Date;
  }> {
    return [...this.sentNotifications];
  }
  
  /** 清除通知历史 */
  clearHistory(): void {
    this.sentNotifications = [];
  }
  
  async sendToCharacter(
    characterId: CharacterId,
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]> {
    await this.delay();
    
    this.sentNotifications.push({
      recipientId: characterId.toString(),
      message,
      channels,
      timestamp: new Date()
    });
    
    return channels.map(channel => new NotificationResult(
      this.shouldSucceed,
      `msg_${Date.now()}_${channel}`,
      channel,
      this.shouldSucceed ? 'Sent successfully' : 'Failed to send'
    ));
  }
  
  async sendToGuild(
    guildId: GuildId,
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]> {
    await this.delay();
    
    this.sentNotifications.push({
      recipientId: `guild_${guildId.toString()}`,
      message,
      channels,
      timestamp: new Date()
    });
    
    return channels.map(channel => new NotificationResult(
      this.shouldSucceed,
      `msg_${Date.now()}_${channel}`,
      channel,
      this.shouldSucceed ? 'Sent successfully' : 'Failed to send'
    ));
  }
  
  async sendToCharacters(
    characterIds: CharacterId[],
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]> {
    const results: NotificationResult[] = [];
    
    for (const characterId of characterIds) {
      const characterResults = await this.sendToCharacter(characterId, message, channels);
      results.push(...characterResults);
    }
    
    return results;
  }
  
  async broadcast(
    message: NotificationMessage,
    channels: NotificationChannel[]
  ): Promise<NotificationResult[]> {
    await this.delay();
    
    this.sentNotifications.push({
      recipientId: 'broadcast',
      message,
      channels,
      timestamp: new Date()
    });
    
    return channels.map(channel => new NotificationResult(
      this.shouldSucceed,
      `broadcast_${Date.now()}_${channel}`,
      channel,
      this.shouldSucceed ? 'Broadcast successful' : 'Broadcast failed'
    ));
  }
  
  async getUnreadNotifications(
    characterId: CharacterId
  ): Promise<StoredNotification[]> {
    // 返回该角色相关的通知
    return this.sentNotifications
      .filter(n => n.recipientId === characterId.toString())
      .map(n => ({
        id: `notif_${Date.now()}`,
        recipientId: n.recipientId,
        message: n.message,
        channel: n.channels[0],
        sentAt: n.timestamp
      }));
  }
  
  async markAsRead(
    characterId: CharacterId,
    notificationIds: string[]
  ): Promise<void> {
    // Mock实现，不需要实际操作
  }
  
  async cleanupExpiredNotifications(): Promise<number> {
    // Mock实现，返回清理的数量
    return 0;
  }
  
  private async delay(): Promise<void> {
    if (this.simulatedDelay > 0) {
      await new Promise(resolve => setTimeout(resolve, this.simulatedDelay));
    }
  }
}

/** 测试事件总线 */
class TestEventBus implements IEventBus {
  readonly portType = 'secondary' as const;
  readonly portName = 'EventBus';
  
  private publishedEvents: DomainEvent[] = [];
  private handlers = new Map<string, Array<(event: DomainEvent) => Promise<void>>>();
  
  /** 获取已发布的事件 */
  getPublishedEvents(): DomainEvent[] {
    return [...this.publishedEvents];
  }
  
  /** 清除事件历史 */
  clearEvents(): void {
    this.publishedEvents = [];
  }
  
  /** 获取特定类型的事件 */
  getEventsOfType<T extends DomainEvent>(eventType: string): T[] {
    return this.publishedEvents
      .filter(e => e.eventType === eventType) as T[];
  }
  
  async publish(event: DomainEvent): Promise<void> {
    this.publishedEvents.push(event);
    
    const eventHandlers = this.handlers.get(event.eventType) || [];
    
    // 并行执行所有处理器
    await Promise.all(
      eventHandlers.map(handler => handler(event))
    );
  }
  
  async publishBatch(events: DomainEvent[]): Promise<void> {
    for (const event of events) {
      await this.publish(event);
    }
  }
  
  subscribe<T extends DomainEvent>(
    eventType: string,
    handler: (event: T) => Promise<void>
  ): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler as any);
  }
  
  unsubscribe(eventType: string, handler: Function): void {
    const eventHandlers = this.handlers.get(eventType);
    if (eventHandlers) {
      const index = eventHandlers.indexOf(handler as any);
      if (index > -1) {
        eventHandlers.splice(index, 1);
      }
    }
  }
}
```

### 2.9 架构验证和最佳实践

#### 2.9.1 架构合规性验证

```typescript
// ============================================================================
// 架构合规性验证
// ============================================================================

/** 架构验证器 */
class ArchitectureValidator {
  
  /** 验证端口契约合规性 */
  static validatePortCompliance(portInstance: any): ValidationResult {
    const errors: string[] = [];
    
    // 检查是否实现了Port接口
    if (!portInstance.portType) {
      errors.push('Port must have portType property');
    }
    
    if (!portInstance.portName) {
      errors.push('Port must have portName property');
    }
    
    // 检查端口类型是否有效
    if (portInstance.portType && !['primary', 'secondary'].includes(portInstance.portType)) {
      errors.push('Port type must be either "primary" or "secondary"');
    }
    
    return new ValidationResult(errors.length === 0, errors);
  }
  
  /** 验证Repository实现合规性 */
  static validateRepositoryCompliance(repository: any): ValidationResult {
    const errors: string[] = [];
    
    // 检查基本方法
    const requiredMethods = ['findById', 'save', 'delete', 'exists', 'findAll', 'count'];
    
    for (const method of requiredMethods) {
      if (typeof repository[method] !== 'function') {
        errors.push(`Repository must implement ${method} method`);
      }
    }
    
    // 检查端口合规性
    const portResult = this.validatePortCompliance(repository);
    if (!portResult.isValid) {
      errors.push(...portResult.errors);
    }
    
    return new ValidationResult(errors.length === 0, errors);
  }
  
  /** 验证适配器实现合规性 */
  static validateAdapterCompliance(
    adapter: any,
    expectedPortInterface: string
  ): ValidationResult {
    const errors: string[] = [];
    
    // 检查适配器是否正确实现了端口接口
    if (adapter.portName !== expectedPortInterface) {
      errors.push(`Adapter portName should be ${expectedPortInterface}`);
    }
    
    // 检查适配器类型
    if (adapter.portType !== 'secondary') {
      errors.push('Adapters should typically implement secondary ports');
    }
    
    return new ValidationResult(errors.length === 0, errors);
  }
  
  /** 验证依赖注入配置 */
  static validateDIConfiguration(container: DIContainer): ValidationResult {
    const errors: string[] = [];
    
    try {
      container.validate();
    } catch (error: any) {
      errors.push(`DI Configuration error: ${error.message}`);
    }
    
    // 检查关键服务是否已注册
    const requiredServices = [
      ServiceTokens.CHARACTER_REPOSITORY,
      ServiceTokens.GUILD_REPOSITORY,
      ServiceTokens.BATTLE_REPOSITORY,
      ServiceTokens.EVENT_BUS,
      ServiceTokens.UNIT_OF_WORK
    ];
    
    for (const service of requiredServices) {
      try {
        container.resolve(service);
      } catch {
        errors.push(`Required service ${service} is not registered`);
      }
    }
    
    return new ValidationResult(errors.length === 0, errors);
  }
  
  /** 验证事件驱动架构合规性 */
  static validateEventDrivenArchitecture(
    eventBus: IEventBus,
    eventStore: IEventStore
  ): ValidationResult {
    const errors: string[] = [];
    
    // 检查事件总线合规性
    const eventBusResult = this.validatePortCompliance(eventBus);
    if (!eventBusResult.isValid) {
      errors.push('Event bus compliance issues:', ...eventBusResult.errors);
    }
    
    // 检查事件存储合规性
    const eventStoreResult = this.validatePortCompliance(eventStore);
    if (!eventStoreResult.isValid) {
      errors.push('Event store compliance issues:', ...eventStoreResult.errors);
    }
    
    return new ValidationResult(errors.length === 0, errors);
  }
}

/** 验证结果 */
class ValidationResult {
  constructor(
    public readonly isValid: boolean,
    public readonly errors: string[] = []
  ) {}
  
  toString(): string {
    if (this.isValid) {
      return 'Validation passed';
    }
    
    return `Validation failed:\n${this.errors.map(e => `  - ${e}`).join('\n')}`;
  }
}

/** 架构测试套件 */
class ArchitectureTestSuite {
  
  /** 运行所有架构验证测试 */
  static async runAllTests(container: DIContainer): Promise<void> {
    console.log('🏗️ Running Architecture Compliance Tests...');
    
    // 1. 验证DI配置
    console.log('\n📦 Validating DI Configuration...');
    const diResult = ArchitectureValidator.validateDIConfiguration(container);
    console.log(diResult.toString());
    
    // 2. 验证Repository实现
    console.log('\n🗄️ Validating Repository Implementations...');
    await this.testRepositoryImplementations(container);
    
    // 3. 验证事件架构
    console.log('\n📡 Validating Event-Driven Architecture...');
    await this.testEventArchitecture(container);
    
    // 4. 验证外部服务端口
    console.log('\n🔌 Validating External Service Ports...');
    await this.testExternalServicePorts(container);
    
    console.log('\n✅ Architecture validation completed!');
  }
  
  private static async testRepositoryImplementations(container: DIContainer): Promise<void> {
    const repositoryTokens = [
      ServiceTokens.CHARACTER_REPOSITORY,
      ServiceTokens.GUILD_REPOSITORY,
      ServiceTokens.BATTLE_REPOSITORY
    ];
    
    for (const token of repositoryTokens) {
      const repository = container.resolve(token);
      const result = ArchitectureValidator.validateRepositoryCompliance(repository);
      console.log(`  ${token}: ${result.isValid ? '✅' : '❌'} ${result.toString()}`);
    }
  }
  
  private static async testEventArchitecture(container: DIContainer): Promise<void> {
    const eventBus = container.resolve<IEventBus>(ServiceTokens.EVENT_BUS);
    const eventStore = container.resolve<IEventStore>(ServiceTokens.EVENT_STORE);
    
    const result = ArchitectureValidator.validateEventDrivenArchitecture(eventBus, eventStore);
    console.log(`  Event Architecture: ${result.isValid ? '✅' : '❌'} ${result.toString()}`);
  }
  
  private static async testExternalServicePorts(container: DIContainer): Promise<void> {
    const serviceTokens = [
      ServiceTokens.PAYMENT_SERVICE,
      ServiceTokens.NOTIFICATION_SERVICE,
      ServiceTokens.LEADERBOARD_SERVICE
    ];
    
    for (const token of serviceTokens) {
      const service = container.resolve(token);
      const result = ArchitectureValidator.validatePortCompliance(service);
      console.log(`  ${token}: ${result.isValid ? '✅' : '❌'} ${result.toString()}`);
    }
  }
}
```

#### 2.9.2 性能监控和指标

```typescript
// ============================================================================
// 性能监控和指标收集
// ============================================================================

/** 性能指标收集器 */
class PerformanceMetricsCollector {
  private metrics = new Map<string, PerformanceMetric>();
  
  /** 记录操作性能 */
  async measureOperation<T>(
    operationName: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const startTime = performance.now();
    
    try {
      const result = await operation();
      
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.recordMetric(operationName, duration, true);
      
      return result;
    } catch (error) {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.recordMetric(operationName, duration, false);
      
      throw error;
    }
  }
  
  private recordMetric(operationName: string, duration: number, success: boolean): void {
    let metric = this.metrics.get(operationName);
    
    if (!metric) {
      metric = new PerformanceMetric(operationName);
      this.metrics.set(operationName, metric);
    }
    
    metric.addMeasurement(duration, success);
  }
  
  /** 获取性能报告 */
  getPerformanceReport(): PerformanceReport {
    const operationReports = Array.from(this.metrics.values())
      .map(metric => metric.getReport());
    
    return new PerformanceReport(operationReports);
  }
  
  /** 重置指标 */
  reset(): void {
    this.metrics.clear();
  }
}

/** 性能指标 */
class PerformanceMetric {
  private measurements: Array<{ duration: number; success: boolean; timestamp: Date }> = [];
  
  constructor(public readonly operationName: string) {}
  
  addMeasurement(duration: number, success: boolean): void {
    this.measurements.push({
      duration,
      success,
      timestamp: new Date()
    });
    
    // 保持最近1000次测量
    if (this.measurements.length > 1000) {
      this.measurements.shift();
    }
  }
  
  getReport(): OperationReport {
    if (this.measurements.length === 0) {
      return new OperationReport(
        this.operationName,
        0, 0, 0, 0, 0, 0, 100
      );
    }
    
    const durations = this.measurements.map(m => m.duration);
    const successCount = this.measurements.filter(m => m.success).length;
    
    const totalCount = this.measurements.length;
    const averageDuration = durations.reduce((sum, d) => sum + d, 0) / totalCount;
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    
    // 计算P95和P99
    const sortedDurations = durations.sort((a, b) => a - b);
    const p95Index = Math.floor(totalCount * 0.95);
    const p99Index = Math.floor(totalCount * 0.99);
    const p95Duration = sortedDurations[p95Index] || 0;
    const p99Duration = sortedDurations[p99Index] || 0;
    
    const successRate = (successCount / totalCount) * 100;
    
    return new OperationReport(
      this.operationName,
      totalCount,
      averageDuration,
      minDuration,
      maxDuration,
      p95Duration,
      p99Duration,
      successRate
    );
  }
}

/** 操作报告 */
class OperationReport {
  constructor(
    public readonly operationName: string,
    public readonly totalCount: number,
    public readonly averageDuration: number,
    public readonly minDuration: number,
    public readonly maxDuration: number,
    public readonly p95Duration: number,
    public readonly p99Duration: number,
    public readonly successRate: number
  ) {}
  
  toString(): string {
    return [
      `Operation: ${this.operationName}`,
      `  Total Calls: ${this.totalCount}`,
      `  Success Rate: ${this.successRate.toFixed(2)}%`,
      `  Average Duration: ${this.averageDuration.toFixed(2)}ms`,
      `  Min Duration: ${this.minDuration.toFixed(2)}ms`,
      `  Max Duration: ${this.maxDuration.toFixed(2)}ms`,
      `  P95 Duration: ${this.p95Duration.toFixed(2)}ms`,
      `  P99 Duration: ${this.p99Duration.toFixed(2)}ms`
    ].join('\n');
  }
}

/** 性能报告 */
class PerformanceReport {
  constructor(public readonly operations: OperationReport[]) {}
  
  toString(): string {
    const header = '📊 Performance Report';
    const separator = '='.repeat(50);
    
    const operationReports = this.operations
      .map(op => op.toString())
      .join('\n\n');
    
    return [header, separator, operationReports, separator].join('\n');
  }
  
  /** 获取有性能问题的操作 */
  getSlowOperations(thresholdMs: number = 1000): OperationReport[] {
    return this.operations.filter(op => op.averageDuration > thresholdMs);
  }
  
  /** 获取错误率高的操作 */
  getUnreliableOperations(thresholdPercent: number = 95): OperationReport[] {
    return this.operations.filter(op => op.successRate < thresholdPercent);
  }
}

/** 性能监控装饰器 */
function MonitorPerformance(operationName?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    const finalOperationName = operationName || `${target.constructor.name}.${propertyName}`;
    
    descriptor.value = async function (...args: any[]) {
      const collector = PerformanceMetricsCollector.getInstance();
      return await collector.measureOperation(finalOperationName, () => method.apply(this, args));
    };
    
    return descriptor;
  };
}

// 扩展PerformanceMetricsCollector为单例
namespace PerformanceMetricsCollector {
  let instance: PerformanceMetricsCollector;
  
  export function getInstance(): PerformanceMetricsCollector {
    if (!instance) {
      instance = new PerformanceMetricsCollector();
    }
    return instance;
  }
}
```

### 2.10 总结

通过本章的六边形架构存储端口设计，我们为《公会经理》游戏构建了一个完整、灵活、可测试的基础设施架构。这个设计具有以下关键特征：

### 2.10.1 核心优势

1. **技术无关性**：业务逻辑完全独立于具体的存储技术
2. **高度可测试性**：通过Mock适配器实现完整的单元测试覆盖
3. **完全可替换性**：可以无缝切换不同的存储和外部服务实现
4. **清晰的边界**：端口和适配器模式确保了明确的架构边界
5. **事件驱动支持**：完整的事件存储和CQRS查询支持

### 2.10.2 实施建议

1. **渐进式实施**：先从内存适配器开始开发，逐步切换到生产适配器
2. **契约测试优先**：使用Repository契约测试确保所有适配器的一致性
3. **性能监控**：从开发阶段就集成性能监控，及早发现性能问题
4. **架构验证**：定期运行架构合规性测试，确保代码质量

### 2.10.3 扩展方向

1. **云服务集成**：可以轻松添加云数据库、云存储等适配器
2. **缓存层支持**：在Repository适配器中集成Redis等缓存解决方案
3. **读写分离**：通过CQRS查询端口实现读写分离架构
4. **微服务演进**：端口设计为未来的微服务拆分提供了清晰的边界

这个六边形架构存储端口设计为游戏项目提供了企业级的技术基础，既满足了当前的开发需求，又为未来的扩展留下了充足的空间。通过严格遵循端口和适配器模式，我们确保了代码的长期可维护性和业务逻辑的纯净性。

---

## 3 适配器策略（InMemory → SQLite；数据根路径）

> **核心策略**: 采用端口-适配器模式实现存储层可替换性，支持从内存存储平滑迁移到 SQLite，确保开发期灵活性和生产环境性能。

---

### 3.1 端口-适配器策略架构概述

#### 3.1.1 设计理念

基于六边形架构（Hexagonal Architecture）思想，将存储访问抽象为端口接口，通过适配器模式实现不同存储后端的无缝切换。这种设计确保：

- **开发期灵活性**：使用内存存储快速迭代
- **生产环境性能**：SQLite 提供持久化和查询优化
- **测试友好**：Mock 适配器支持单元测试
- **技术栈演进**：未来可扩展到 PostgreSQL 等

#### 3.1.2 存储层架构设计

```typescript
// ============================================================================
// 存储端口接口定义（核心抽象层）
// ============================================================================

/** 通用存储端口 - 所有存储实现的契约 */
interface StoragePort<TEntity, TId> {
  /** 根据ID获取实体 */
  findById(id: TId): Promise<TEntity | null>;
  
  /** 保存实体（新增或更新） */
  save(entity: TEntity): Promise<void>;
  
  /** 删除实体 */
  delete(id: TId): Promise<void>;
  
  /** 查询实体列表 */
  findMany(criteria: QueryCriteria<TEntity>): Promise<TEntity[]>;
  
  /** 事务执行 */
  transaction<T>(operation: (tx: TransactionContext) => Promise<T>): Promise<T>;
}

/** 查询条件接口 */
interface QueryCriteria<T> {
  filters?: Partial<T>;
  sortBy?: keyof T;
  sortOrder?: 'asc' | 'desc';
  limit?: number;
  offset?: number;
}

/** 事务上下文 */
interface TransactionContext {
  /** 在事务中执行存储操作 */
  execute<T>(operation: () => Promise<T>): Promise<T>;
}
```

#### 3.1.3 领域特定存储端口

```typescript
/** 角色存储端口 */
interface CharacterRepository extends StoragePort<Character, CharacterId> {
  /** 按公会ID查找角色 */
  findByGuildId(guildId: GuildId): Promise<Character[]>;
  
  /** 按技能等级范围查找 */
  findBySkillLevel(skill: SkillType, minLevel: number, maxLevel: number): Promise<Character[]>;
}

/** 公会存储端口 */
interface GuildRepository extends StoragePort<Guild, GuildId> {
  /** 按声望排序获取公会排行榜 */
  findTopByReputation(limit: number): Promise<Guild[]>;
  
  /** 搜索公会名称 */
  searchByName(pattern: string): Promise<Guild[]>;
}

/** 战斗存储端口 */
interface BattleRepository extends StoragePort<Battle, BattleId> {
  /** 获取进行中的战斗 */
  findActiveBattles(): Promise<Battle[]>;
  
  /** 按时间范围查找历史战斗 */
  findBattleHistory(startDate: Date, endDate: Date): Promise<Battle[]>;
}
```

---

### 3.2 InMemory → SQLite 迁移策略

#### 3.2.1 渐进式迁移路径

我们采用分阶段迁移策略，确保开发流程平滑过渡：

##### 阶段1：内存原型期（开发初期）
- **目标**：快速功能验证，无持久化需求
- **适配器**：`InMemoryStorageAdapter`
- **优势**：零配置、快速重启、易于调试

##### 阶段2：混合验证期（功能稳定期）
- **目标**：保留开发便利性，增加数据持久化
- **策略**：内存+文件备份，或内存+SQLite 双写
- **验证点**：数据一致性、性能对比

##### 阶段3：生产就绪期（发布前）
- **目标**：完全切换到 SQLite，优化性能
- **适配器**：`SQLiteStorageAdapter`
- **重点**：事务处理、并发控制、备份恢复

#### 3.2.2 内存存储适配器实现

```typescript
// ============================================================================
// 内存存储适配器 - 开发期使用
// ============================================================================

class InMemoryStorageAdapter<TEntity, TId> implements StoragePort<TEntity, TId> {
  private entities = new Map<string, TEntity>();
  private idExtractor: (entity: TEntity) => TId;
  
  constructor(idExtractor: (entity: TEntity) => TId) {
    this.idExtractor = idExtractor;
  }

  async findById(id: TId): Promise<TEntity | null> {
    const entity = this.entities.get(String(id));
    return entity ? this.deepClone(entity) : null;
  }

  async save(entity: TEntity): Promise<void> {
    const id = this.idExtractor(entity);
    this.entities.set(String(id), this.deepClone(entity));
  }

  async delete(id: TId): Promise<void> {
    this.entities.delete(String(id));
  }

  async findMany(criteria: QueryCriteria<TEntity>): Promise<TEntity[]> {
    let results = Array.from(this.entities.values());
    
    // 应用过滤条件
    if (criteria.filters) {
      results = results.filter(entity => 
        Object.entries(criteria.filters!).every(([key, value]) => 
          entity[key as keyof TEntity] === value
        )
      );
    }
    
    // 应用排序
    if (criteria.sortBy) {
      results.sort((a, b) => {
        const aVal = a[criteria.sortBy!];
        const bVal = b[criteria.sortBy!];
        const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        return criteria.sortOrder === 'desc' ? -comparison : comparison;
      });
    }
    
    // 应用分页
    if (criteria.offset !== undefined) {
      results = results.slice(criteria.offset);
    }
    if (criteria.limit !== undefined) {
      results = results.slice(0, criteria.limit);
    }
    
    return results.map(entity => this.deepClone(entity));
  }

  async transaction<T>(operation: (tx: TransactionContext) => Promise<T>): Promise<T> {
    // 内存存储简单实现：直接执行，真实环境中需要快照/回滚机制
    const tx: TransactionContext = {
      execute: async <U>(op: () => Promise<U>) => op()
    };
    
    return operation(tx);
  }

  /** 结构化深拷贝，保持对象类型不丢失 */
  private deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }

    // 处理Date对象
    if (obj instanceof Date) {
      return new Date(obj.getTime()) as T;
    }

    // 处理Map对象
    if (obj instanceof Map) {
      const clonedMap = new Map();
      for (const [key, value] of obj) {
        clonedMap.set(this.deepClone(key), this.deepClone(value));
      }
      return clonedMap as T;
    }

    // 处理Set对象
    if (obj instanceof Set) {
      const clonedSet = new Set();
      for (const value of obj) {
        clonedSet.add(this.deepClone(value));
      }
      return clonedSet as T;
    }

    // 处理数组
    if (Array.isArray(obj)) {
      return obj.map(item => this.deepClone(item)) as T;
    }

    // 处理普通对象，保持原型链
    const clonedObj = Object.create(Object.getPrototypeOf(obj));
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = this.deepClone(obj[key]);
      }
    }
    return clonedObj;
  }
}
```

#### 3.2.3 适配器工厂与依赖注入

```typescript
// ============================================================================
// 存储适配器工厂 - 统一创建和切换逻辑
// ============================================================================

type StorageType = 'memory' | 'sqlite' | 'hybrid';

interface StorageConfig {
  type: StorageType;
  sqliteConfig?: SQLiteConfig;
  enableLogging?: boolean;
}

class StorageAdapterFactory {
  static createCharacterRepository(config: StorageConfig): CharacterRepository {
    switch (config.type) {
      case 'memory':
        return new InMemoryCharacterRepository();
      case 'sqlite':
        return new SQLiteCharacterRepository(config.sqliteConfig!);
      case 'hybrid':
        return new HybridCharacterRepository(config);
      default:
        throw new Error(`Unsupported storage type: ${config.type}`);
    }
  }
  
  static createGuildRepository(config: StorageConfig): GuildRepository {
    // 类似实现...
  }
  
  static createBattleRepository(config: StorageConfig): BattleRepository {
    // 类似实现...
  }
}

/** 依赖注入容器 */
class StorageContainer {
  private static instance: StorageContainer;
  private repositories = new Map<string, any>();
  
  static getInstance(): StorageContainer {
    if (!this.instance) {
      this.instance = new StorageContainer();
    }
    return this.instance;
  }
  
  configure(config: StorageConfig): void {
    this.repositories.set('character', StorageAdapterFactory.createCharacterRepository(config));
    this.repositories.set('guild', StorageAdapterFactory.createGuildRepository(config));
    this.repositories.set('battle', StorageAdapterFactory.createBattleRepository(config));
  }
  
  getCharacterRepository(): CharacterRepository {
    return this.repositories.get('character');
  }
  
  // ... 其他仓储获取方法
}
```

---

### 3.3 Electron 数据根路径策略

#### 3.3.1 跨平台数据路径管理

Electron 应用需要合理管理用户数据存储位置，确保跨平台兼容性和数据安全性：

```typescript
// ============================================================================
// Electron 数据路径管理器
// ============================================================================

import { app } from 'electron';
import { join, dirname } from 'path';
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';

/** 跨平台数据路径管理 */
class ElectronDataPathManager {
  private static instance: ElectronDataPathManager;
  
  /** 应用数据根目录 */
  private readonly appDataRoot: string;
  
  /** 数据库文件路径 */
  private readonly databasePath: string;
  
  /** 日志文件目录 */
  private readonly logsDirectory: string;
  
  /** 配置文件路径 */
  private readonly configPath: string;
  
  /** 备份目录 */
  private readonly backupDirectory: string;

  private constructor() {
    // 获取平台特定的用户数据目录
    // Windows: C:\Users\{user}\AppData\Roaming\{appName}
    // macOS: ~/Library/Application Support/{appName}
    // Linux: ~/.config/{appName}
    this.appDataRoot = app.getPath('userData');
    
    // 定义各类数据存储路径
    this.databasePath = join(this.appDataRoot, 'data', 'guild-manager.db');
    this.logsDirectory = join(this.appDataRoot, 'logs');
    this.configPath = join(this.appDataRoot, 'config', 'app-config.json');
    this.backupDirectory = join(this.appDataRoot, 'backups');
    
    // 确保目录结构存在
    this.ensureDirectoriesExist();
  }
  
  static getInstance(): ElectronDataPathManager {
    if (!this.instance) {
      this.instance = new ElectronDataPathManager();
    }
    return this.instance;
  }
  
  /** 获取数据库文件完整路径 */
  getDatabasePath(): string {
    return this.databasePath;
  }
  
  /** 获取日志目录路径 */
  getLogsDirectory(): string {
    return this.logsDirectory;
  }
  
  /** 获取配置文件路径 */
  getConfigPath(): string {
    return this.configPath;
  }
  
  /** 获取备份目录路径 */
  getBackupDirectory(): string {
    return this.backupDirectory;
  }
  
  /** 生成时间戳备份文件路径 */
  generateBackupPath(suffix: string = ''): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `backup-${timestamp}${suffix}.db`;
    return join(this.backupDirectory, filename);
  }
  
  /** 确保所有必要目录存在 */
  private ensureDirectoriesExist(): void {
    const directories = [
      dirname(this.databasePath),
      this.logsDirectory,
      dirname(this.configPath),
      this.backupDirectory
    ];
    
    directories.forEach(dir => {
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }
    });
  }
  
  /** 获取平台特定的临时目录 */
  getTempDirectory(): string {
    return join(app.getPath('temp'), 'guild-manager-temp');
  }
  
  /** 数据迁移支持：从旧版本路径迁移数据 */
  migrateFromLegacyPaths(): void {
    // 检查是否存在旧版本数据路径
    const legacyPaths = [
      join(app.getPath('home'), '.guild-manager'),  // 旧版本路径
      join(app.getPath('documents'), 'GuildManager')  // 可能的用户自定义路径
    ];
    
    legacyPaths.forEach(legacyPath => {
      if (existsSync(legacyPath)) {
        console.log(`Detected legacy data at: ${legacyPath}`);
        // 实现数据迁移逻辑...
      }
    });
  }
}
```

#### 3.3.2 数据路径配置与验证

```typescript
/** 数据路径验证器 */
class DataPathValidator {
  /** 验证数据库路径的有效性 */
  static validateDatabasePath(path: string): ValidationResult {
    const issues: string[] = [];
    
    // 检查路径长度（Windows 路径长度限制）
    if (path.length > 260) {
      issues.push('Database path exceeds Windows maximum path length (260 characters)');
    }
    
    // 检查磁盘空间
    const directory = dirname(path);
    try {
      const stats = require('fs').statSync(directory);
      // 检查可用空间（至少需要 100MB）
      if (this.getAvailableSpace(directory) < 100 * 1024 * 1024) {
        issues.push('Insufficient disk space (minimum 100MB required)');
      }
    } catch (error) {
      issues.push(`Cannot access directory: ${error.message}`);
    }
    
    // 检查写入权限
    try {
      const testFile = join(directory, '.write-test');
      writeFileSync(testFile, 'test');
      require('fs').unlinkSync(testFile);
    } catch (error) {
      issues.push(`No write permission in directory: ${directory}`);
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      path
    };
  }
  
  private static getAvailableSpace(path: string): number {
    // 实现获取可用磁盘空间的逻辑
    // 在实际项目中可以使用 node-disk-usage 等库
    return 1024 * 1024 * 1024; // 临时返回 1GB
  }
}

interface ValidationResult {
  isValid: boolean;
  issues: string[];
  path: string;
}
```

---

### 3.4 better-sqlite3 WAL 模式与性能优化

#### 3.4.1 SQLite 配置策略

```typescript
// ============================================================================
// SQLite 数据库配置与优化
// ============================================================================

import Database from 'better-sqlite3';
import { ElectronDataPathManager } from './electron-data-path-manager';

interface SQLiteConfig {
  /** 数据库文件路径 */
  databasePath?: string;
  
  /** 是否启用 WAL 模式 */
  enableWAL?: boolean;
  
  /** 连接池大小 */
  poolSize?: number;
  
  /** 查询超时时间（毫秒） */
  queryTimeout?: number;
  
  /** 是否启用外键约束 */
  enableForeignKeys?: boolean;

  /** 忙碌超时时间（毫秒） - 处理SQLITE_BUSY错误 */
  busyTimeout?: number;
  
  /** 页面大小（字节） */
  pageSize?: number;
  
  /** 缓存大小（页数） */
  cacheSize?: number;
}

class SQLiteConnectionManager {
  private static instance: SQLiteConnectionManager;
  private database: Database.Database | null = null;
  private config: Required<SQLiteConfig>;
  
  private constructor() {
    // 默认配置
    this.config = {
      databasePath: ElectronDataPathManager.getInstance().getDatabasePath(),
      enableWAL: true,           // 启用 Write-Ahead Logging
      poolSize: 5,
      queryTimeout: 5000,        // 5 秒超时
      enableForeignKeys: true,
      busyTimeout: 5000,         // 5 秒忙碌超时，处理并发写冲突
      pageSize: 4096,            // 4KB 页面大小
      cacheSize: 2000            // 约 8MB 缓存
    };
  }
  
  static getInstance(): SQLiteConnectionManager {
    if (!this.instance) {
      this.instance = new SQLiteConnectionManager();
    }
    return this.instance;
  }
  
  /** 初始化数据库连接 */
  async initialize(config: Partial<SQLiteConfig> = {}): Promise<void> {
    this.config = { ...this.config, ...config };
    
    try {
      // 创建数据库连接
      this.database = new Database(this.config.databasePath, {
        verbose: process.env.NODE_ENV === 'development' ? console.log : undefined,
        fileMustExist: false,
        timeout: this.config.queryTimeout
      });
      
      // 立即设置忙碌超时，防止SQLITE_BUSY错误
      this.database.pragma(`busy_timeout = ${this.config.busyTimeout}`);
      
      // 应用 WAL 模式配置
      if (this.config.enableWAL) {
        this.enableWALMode();
      }
      
      // 应用性能优化配置
      this.applyPerformanceOptimizations();
      
      // 创建数据库表结构
      await this.createSchema();
      
      console.log('SQLite database initialized successfully');
      console.log(`Database path: ${this.config.databasePath}`);
      console.log(`WAL mode: ${this.config.enableWAL ? 'enabled' : 'disabled'}`);
      console.log(`Busy timeout: ${this.config.busyTimeout}ms (并发写冲突处理)`);
      
    } catch (error) {
      console.error('Failed to initialize SQLite database:', error);
      throw new Error(`Database initialization failed: ${error.message}`);
    }
  }
  
  /** 启用 WAL (Write-Ahead Logging) 模式 */
  private enableWALMode(): void {
    if (!this.database) throw new Error('Database not initialized');
    
    // 设置 WAL 模式 - 允许并发读写
    this.database.pragma('journal_mode = WAL');
    
    // WAL 模式优化配置
    this.database.pragma('synchronous = NORMAL');     // 平衡性能和安全性
    this.database.pragma('wal_autocheckpoint = 1000'); // 自动检查点频率
    this.database.pragma('journal_size_limit = 67108864'); // WAL 文件大小限制 (64MB)
    
    // 注意：busy_timeout已在initialize()中设置，与WAL模式配合处理并发写冲突
    
    console.log('WAL mode enabled with optimized settings');
  }
  
  /** 应用性能优化配置 */
  private applyPerformanceOptimizations(): void {
    if (!this.database) throw new Error('Database not initialized');
    
    // 页面大小优化
    this.database.pragma(`page_size = ${this.config.pageSize}`);
    
    // 缓存大小优化
    this.database.pragma(`cache_size = ${this.config.cacheSize}`);
    
    // 启用外键约束
    if (this.config.enableForeignKeys) {
      this.database.pragma('foreign_keys = ON');
    }
    
    // 内存映射I/O优化 (256MB)
    this.database.pragma('mmap_size = 268435456');
    
    // 临时存储使用内存
    this.database.pragma('temp_store = MEMORY');
    
    // 启用查询规划器优化
    this.database.pragma('optimize');
    
    console.log('Performance optimizations applied');
  }
  
  /** 获取数据库连接 */
  getConnection(): Database.Database {
    if (!this.database) {
      throw new Error('Database not initialized. Call initialize() first.');
    }
    return this.database;
  }
  
  /** 创建数据库表结构 */
  private async createSchema(): Promise<void> {
    if (!this.database) throw new Error('Database not initialized');
    
    // 角色表
    this.database.exec(`
      CREATE TABLE IF NOT EXISTS characters (
        id TEXT PRIMARY KEY,
        guild_id TEXT,
        name TEXT NOT NULL,
        level INTEGER NOT NULL DEFAULT 1,
        experience INTEGER NOT NULL DEFAULT 0,
        attributes TEXT NOT NULL, -- JSON 存储属性
        skills TEXT NOT NULL,     -- JSON 存储技能
        equipment TEXT,           -- JSON 存储装备
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (guild_id) REFERENCES guilds(id) ON DELETE SET NULL
      )
    `);
    
    // 公会表
    this.database.exec(`
      CREATE TABLE IF NOT EXISTS guilds (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        reputation INTEGER NOT NULL DEFAULT 0,
        treasury TEXT NOT NULL,   -- JSON 存储财务信息
        settings TEXT,            -- JSON 存储公会设置
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `);
    
    // 战斗表
    this.database.exec(`
      CREATE TABLE IF NOT EXISTS battles (
        id TEXT PRIMARY KEY,
        attacker_guild_id TEXT NOT NULL,
        defender_guild_id TEXT NOT NULL,
        status TEXT NOT NULL,     -- 'pending', 'active', 'completed', 'cancelled'
        battle_data TEXT NOT NULL, -- JSON 存储战斗详情
        result TEXT,              -- JSON 存储战斗结果
        started_at INTEGER,
        completed_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (attacker_guild_id) REFERENCES guilds(id),
        FOREIGN KEY (defender_guild_id) REFERENCES guilds(id)
      )
    `);
    
    // 创建索引优化查询性能
    this.createIndexes();
  }
  
  /** 创建数据库索引 */
  private createIndexes(): void {
    if (!this.database) throw new Error('Database not initialized');
    
    // 角色相关索引
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_characters_guild_id ON characters(guild_id)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_characters_level ON characters(level)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_characters_created_at ON characters(created_at)');
    
    // 公会相关索引
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_guilds_reputation ON guilds(reputation DESC)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_guilds_name ON guilds(name)');
    
    // 战斗相关索引
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_battles_status ON battles(status)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_battles_attacker ON battles(attacker_guild_id)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_battles_defender ON battles(defender_guild_id)');
    this.database.exec('CREATE INDEX IF NOT EXISTS idx_battles_started_at ON battles(started_at)');
    
    console.log('Database indexes created successfully');
  }
  
  /** 数据库备份 */
  async createBackup(): Promise<string> {
    if (!this.database) throw new Error('Database not initialized');
    
    const backupPath = ElectronDataPathManager.getInstance().generateBackupPath();
    
    // 执行 WAL 检查点，确保数据写入主数据库文件
    this.database.pragma('wal_checkpoint(TRUNCATE)');
    
    // 使用 SQLite VACUUM INTO 创建压缩备份
    this.database.exec(`VACUUM INTO '${backupPath}'`);
    
    console.log(`Database backup created: ${backupPath}`);
    return backupPath;
  }
  
  /** 关闭数据库连接 */
  async close(): Promise<void> {
    if (this.database) {
      // 执行最终的 WAL 检查点
      this.database.pragma('wal_checkpoint(TRUNCATE)');
      
      // 优化数据库
      this.database.pragma('optimize');
      
      // 关闭连接
      this.database.close();
      this.database = null;
      
      console.log('Database connection closed');
    }
  }
}
```

#### 3.4.2 WAL 模式的优势与配置

WAL (Write-Ahead Logging) 模式是 SQLite 的高级特性，特别适合读多写少的应用场景：

**核心优势**：
- **并发读取**：多个读事务可以与一个写事务并发执行
- **写入性能**：写操作不需要等待读事务完成
- **崩溃恢复**：提供更好的数据完整性保障
- **检查点控制**：可以控制何时将 WAL 内容合并到主数据库

**配置要点**：
```sql
-- 启用 WAL 模式
PRAGMA journal_mode = WAL;

-- 同步模式设置（平衡性能与安全）
PRAGMA synchronous = NORMAL;  -- 可选：OFF, NORMAL, FULL

-- WAL 自动检查点设置
PRAGMA wal_autocheckpoint = 1000;  -- 每1000页自动执行检查点

-- WAL 文件大小限制
PRAGMA journal_size_limit = 67108864;  -- WAL文件大小限制 64MB
```

---

### 3.5 Worker 线程分离与异步处理策略

#### 3.5.1 数据库操作的线程分离架构

为了避免数据库操作阻塞 UI 线程，我们将复杂的数据库操作分离到 Worker 线程中：

```typescript
// ============================================================================
// 数据库 Worker 线程管理器
// ============================================================================

import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import { join } from 'path';

/** Worker 线程任务类型 */
type WorkerTaskType = 
  | 'query'           // 普通查询
  | 'transaction'     // 事务操作
  | 'backup'          // 数据库备份
  | 'maintenance'     // 维护操作（VACUUM, ANALYZE）
  | 'export'          // 数据导出
  | 'import';         // 数据导入

/** Worker 任务定义 */
interface WorkerTask {
  id: string;
  type: WorkerTaskType;
  payload: any;
  timeout?: number;
}

/** Worker 响应 */
interface WorkerResponse {
  taskId: string;
  success: boolean;
  result?: any;
  error?: string;
  duration: number;
}

class DatabaseWorkerManager {
  private static instance: DatabaseWorkerManager;
  private workers: Worker[] = [];
  private currentWorkerIndex = 0;
  private pendingTasks = new Map<string, {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
    timeout?: NodeJS.Timeout;
  }>();
  
  private readonly maxWorkers: number;
  private readonly workerScriptPath: string;
  
  private constructor() {
    this.maxWorkers = Math.min(4, require('os').cpus().length); // 最多4个Worker
    this.workerScriptPath = join(__dirname, 'database-worker.js');
    this.initializeWorkers();
  }
  
  static getInstance(): DatabaseWorkerManager {
    if (!this.instance) {
      this.instance = new DatabaseWorkerManager();
    }
    return this.instance;
  }
  
  /** 初始化 Worker 线程池 */
  private initializeWorkers(): void {
    for (let i = 0; i < this.maxWorkers; i++) {
      this.createWorker();
    }
    console.log(`Initialized ${this.maxWorkers} database worker threads`);
  }
  
  /** 创建单个 Worker 线程 */
  private createWorker(): void {
    const worker = new Worker(this.workerScriptPath, {
      workerData: {
        databasePath: ElectronDataPathManager.getInstance().getDatabasePath()
      }
    });
    
    worker.on('message', (response: WorkerResponse) => {
      this.handleWorkerResponse(response);
    });
    
    worker.on('error', (error) => {
      console.error('Database worker error:', error);
      this.handleWorkerError(error);
    });
    
    worker.on('exit', (code) => {
      if (code !== 0) {
        console.warn(`Database worker exited with code ${code}, restarting...`);
        this.restartWorker(worker);
      }
    });
    
    this.workers.push(worker);
  }
  
  /** 执行数据库任务 */
  async executeTask<T>(task: Omit<WorkerTask, 'id'>): Promise<T> {
    const taskId = crypto.randomUUID();
    const fullTask: WorkerTask = { id: taskId, ...task };
    
    return new Promise<T>((resolve, reject) => {
      // 设置任务超时
      let timeout: NodeJS.Timeout | undefined;
      if (task.timeout) {
        timeout = setTimeout(() => {
          this.pendingTasks.delete(taskId);
          reject(new Error(`Task ${taskId} timed out after ${task.timeout}ms`));
        }, task.timeout);
      }
      
      // 注册任务回调
      this.pendingTasks.set(taskId, { resolve, reject, timeout });
      
      // 选择Worker执行任务（轮询策略）
      const worker = this.selectWorker();
      worker.postMessage(fullTask);
    });
  }
  
  /** 选择 Worker（轮询策略） */
  private selectWorker(): Worker {
    const worker = this.workers[this.currentWorkerIndex];
    this.currentWorkerIndex = (this.currentWorkerIndex + 1) % this.workers.length;
    return worker;
  }
  
  /** 处理 Worker 响应 */
  private handleWorkerResponse(response: WorkerResponse): void {
    const task = this.pendingTasks.get(response.taskId);
    if (!task) {
      console.warn(`Received response for unknown task: ${response.taskId}`);
      return;
    }
    
    // 清理超时定时器
    if (task.timeout) {
      clearTimeout(task.timeout);
    }
    
    this.pendingTasks.delete(response.taskId);
    
    if (response.success) {
      task.resolve(response.result);
    } else {
      task.reject(new Error(response.error || 'Unknown worker error'));
    }
  }
  
  /** 处理 Worker 错误 */
  private handleWorkerError(error: Error): void {
    // 拒绝所有待处理的任务
    this.pendingTasks.forEach(({ reject, timeout }) => {
      if (timeout) clearTimeout(timeout);
      reject(error);
    });
    this.pendingTasks.clear();
  }
  
  /** 重启 Worker */
  private restartWorker(failedWorker: Worker): void {
    const index = this.workers.indexOf(failedWorker);
    if (index !== -1) {
      failedWorker.terminate();
      this.workers[index] = this.createWorker();
    }
  }
  
  /** 关闭所有 Worker */
  async shutdown(): Promise<void> {
    const shutdownPromises = this.workers.map(worker => 
      worker.terminate().then(() => console.log('Worker terminated'))
    );
    
    await Promise.all(shutdownPromises);
    this.workers = [];
    this.pendingTasks.clear();
    
    console.log('All database workers shut down');
  }
}
```

#### 3.5.2 Worker 线程实现

```typescript
// ============================================================================
// database-worker.js - Worker 线程中的数据库操作实现
// ============================================================================

import { parentPort, workerData } from 'worker_threads';
import Database from 'better-sqlite3';

let database: Database.Database;

/** 初始化 Worker 中的数据库连接 */
function initializeDatabase(): void {
  try {
    database = new Database(workerData.databasePath, {
      readonly: false,
      fileMustExist: true
    });
    
    // 立即设置忙碌超时，防止Worker线程中的SQLITE_BUSY错误
    database.pragma('busy_timeout = 5000');
    
    // 应用 WAL 模式和优化配置
    database.pragma('journal_mode = WAL');
    database.pragma('synchronous = NORMAL');
    database.pragma('cache_size = 2000');
    database.pragma('foreign_keys = ON');
    
    console.log('Database worker initialized successfully');
  } catch (error) {
    console.error('Failed to initialize database in worker:', error);
    process.exit(1);
  }
}

/** 处理来自主线程的任务 */
async function handleTask(task: WorkerTask): Promise<void> {
  const startTime = Date.now();
  
  try {
    let result: any;
    
    switch (task.type) {
      case 'query':
        result = await executeQuery(task.payload);
        break;
        
      case 'transaction':
        result = await executeTransaction(task.payload);
        break;
        
      case 'backup':
        result = await createBackup(task.payload);
        break;
        
      case 'maintenance':
        result = await performMaintenance(task.payload);
        break;
        
      case 'export':
        result = await exportData(task.payload);
        break;
        
      case 'import':
        result = await importData(task.payload);
        break;
        
      default:
        throw new Error(`Unknown task type: ${task.type}`);
    }
    
    const duration = Date.now() - startTime;
    
    parentPort!.postMessage({
      taskId: task.id,
      success: true,
      result,
      duration
    } as WorkerResponse);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    
    parentPort!.postMessage({
      taskId: task.id,
      success: false,
      error: error.message,
      duration
    } as WorkerResponse);
  }
}

/** 执行查询操作 */
async function executeQuery(payload: any): Promise<any> {
  const { sql, params = [] } = payload;
  
  if (sql.trim().toUpperCase().startsWith('SELECT')) {
    // 查询操作
    const stmt = database.prepare(sql);
    return stmt.all(params);
  } else {
    // 修改操作
    const stmt = database.prepare(sql);
    return stmt.run(params);
  }
}

/** 执行事务操作 */
async function executeTransaction(payload: any): Promise<any> {
  const { operations } = payload;
  
  const transaction = database.transaction(() => {
    const results = [];
    
    for (const operation of operations) {
      try {
        const stmt = database.prepare(operation.sql);
        const result = stmt.run(operation.params || []);
        results.push(result);
      } catch (error) {
        // 记录详细错误信息，包括SQL和参数
        console.error(`Transaction operation failed: ${operation.sql}`, {
          error: error.message,
          params: operation.params
        });
        throw error; // 重新抛出以触发事务回滚
      }
    }
    
    return results;
  });
  
  try {
    return transaction();
  } catch (error) {
    // 事务失败，可能是由于并发冲突或其他数据库错误
    console.error('Transaction execution failed:', error.message);
    throw new Error(`Transaction failed: ${error.message}`);
  }
}

/** 创建数据库备份 */
async function createBackup(payload: any): Promise<string> {
  const { backupPath } = payload;
  
  // 执行 WAL 检查点
  database.pragma('wal_checkpoint(TRUNCATE)');
  
  // 创建备份
  database.exec(`VACUUM INTO '${backupPath}'`);
  
  return backupPath;
}

/** 执行数据库维护 */
async function performMaintenance(payload: any): Promise<void> {
  const { operations = ['ANALYZE', 'VACUUM'] } = payload;
  
  for (const operation of operations) {
    database.exec(operation);
  }
}

/** 导出数据 */
async function exportData(payload: any): Promise<string> {
  const { format, tables, outputPath } = payload;
  
  // 实现数据导出逻辑
  // 这里可以导出为 JSON、CSV 等格式
  throw new Error('Export functionality not implemented yet');
}

/** 导入数据 */
async function importData(payload: any): Promise<void> {
  const { format, inputPath, options } = payload;
  
  // 实现数据导入逻辑
  throw new Error('Import functionality not implemented yet');
}

// Worker 线程入口点
if (parentPort) {
  initializeDatabase();
  
  parentPort.on('message', (task: WorkerTask) => {
    handleTask(task);
  });
}
```

#### 3.5.3 同步 API 与异步 API 适配

```typescript
// ============================================================================
// 同步/异步适配器 - 为不同场景提供合适的接口
// ============================================================================

/** SQLite 存储适配器 - 主线程接口 */
class SQLiteStorageAdapter<TEntity, TId> implements StoragePort<TEntity, TId> {
  private workerManager = DatabaseWorkerManager.getInstance();
  private idExtractor: (entity: TEntity) => TId;
  private tableName: string;
  
  constructor(tableName: string, idExtractor: (entity: TEntity) => TId) {
    this.tableName = tableName;
    this.idExtractor = idExtractor;
  }
  
  async findById(id: TId): Promise<TEntity | null> {
    const result = await this.workerManager.executeTask<any[]>({
      type: 'query',
      payload: {
        sql: `SELECT * FROM ${this.tableName} WHERE id = ?`,
        params: [String(id)]
      }
    });
    
    return result.length > 0 ? this.deserializeEntity(result[0]) : null;
  }
  
  async save(entity: TEntity): Promise<void> {
    const serialized = this.serializeEntity(entity);
    const id = this.idExtractor(entity);
    
    await this.workerManager.executeTask({
      type: 'query',
      payload: {
        sql: `INSERT OR REPLACE INTO ${this.tableName} VALUES (?, ?, ?, ?)`,
        params: [String(id), ...Object.values(serialized)]
      }
    });
  }
  
  async delete(id: TId): Promise<void> {
    await this.workerManager.executeTask({
      type: 'query',
      payload: {
        sql: `DELETE FROM ${this.tableName} WHERE id = ?`,
        params: [String(id)]
      }
    });
  }
  
  async findMany(criteria: QueryCriteria<TEntity>): Promise<TEntity[]> {
    const { sql, params } = this.buildQuery(criteria);
    
    const results = await this.workerManager.executeTask<any[]>({
      type: 'query',
      payload: { sql, params }
    });
    
    return results.map(row => this.deserializeEntity(row));
  }
  
  async transaction<T>(operation: (tx: TransactionContext) => Promise<T>): Promise<T> {
    // 复杂事务操作需要特殊处理
    throw new Error('Complex transactions not yet implemented in worker adapter');
  }
  
  /** 序列化实体为数据库行 */
  private serializeEntity(entity: TEntity): any {
    // 实现实体到数据库行的转换
    return entity;
  }
  
  /** 反序列化数据库行为实体 */
  private deserializeEntity(row: any): TEntity {
    // 实现数据库行到实体的转换
    return row as TEntity;
  }
  
  /** 构建查询SQL */
  private buildQuery(criteria: QueryCriteria<TEntity>): { sql: string; params: any[] } {
    let sql = `SELECT * FROM ${this.tableName}`;
    const params: any[] = [];
    
    if (criteria.filters) {
      const conditions = Object.entries(criteria.filters)
        .map(([key, value]) => {
          params.push(value);
          return `${key} = ?`;
        });
      
      if (conditions.length > 0) {
        sql += ` WHERE ${conditions.join(' AND ')}`;
      }
    }
    
    if (criteria.sortBy) {
      sql += ` ORDER BY ${String(criteria.sortBy)} ${criteria.sortOrder || 'asc'}`;
    }
    
    if (criteria.limit) {
      sql += ` LIMIT ${criteria.limit}`;
      if (criteria.offset) {
        sql += ` OFFSET ${criteria.offset}`;
      }
    }
    
    return { sql, params };
  }
}
```

---

### 3.6 配置管理与环境切换

#### 3.6.1 环境配置策略

```typescript
// ============================================================================
// 环境配置管理 - 开发/测试/生产环境适配
// ============================================================================

type Environment = 'development' | 'testing' | 'production';

interface EnvironmentConfig {
  environment: Environment;
  storage: StorageConfig;
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error';
    enableFileLogging: boolean;
    maxLogSize: number;
  };
  performance: {
    enableMetrics: boolean;
    metricsInterval: number;
  };
}

class EnvironmentConfigManager {
  private static instance: EnvironmentConfigManager;
  private currentConfig: EnvironmentConfig;
  
  private constructor() {
    this.currentConfig = this.loadConfiguration();
  }
  
  static getInstance(): EnvironmentConfigManager {
    if (!this.instance) {
      this.instance = new EnvironmentConfigManager();
    }
    return this.instance;
  }
  
  /** 加载环境配置 */
  private loadConfiguration(): EnvironmentConfig {
    const env = (process.env.NODE_ENV as Environment) || 'development';
    
    const baseConfig: EnvironmentConfig = {
      environment: env,
      storage: this.getStorageConfig(env),
      logging: this.getLoggingConfig(env),
      performance: this.getPerformanceConfig(env)
    };
    
    // 尝试从配置文件加载用户自定义配置
    try {
      const userConfigPath = ElectronDataPathManager.getInstance().getConfigPath();
      if (require('fs').existsSync(userConfigPath)) {
        const userConfig = JSON.parse(require('fs').readFileSync(userConfigPath, 'utf8'));
        return { ...baseConfig, ...userConfig };
      }
    } catch (error) {
      console.warn('Failed to load user configuration:', error.message);
    }
    
    return baseConfig;
  }
  
  /** 获取存储配置 */
  private getStorageConfig(env: Environment): StorageConfig {
    switch (env) {
      case 'development':
        return {
          type: 'memory',    // 开发期使用内存存储
          enableLogging: true
        };
        
      case 'testing':
        return {
          type: 'memory',    // 测试期使用内存存储
          enableLogging: false
        };
        
      case 'production':
        return {
          type: 'sqlite',    // 生产环境使用 SQLite
          sqliteConfig: {
            enableWAL: true,
            poolSize: 5,
            queryTimeout: 5000,
            enableForeignKeys: true,
            pageSize: 4096,
            cacheSize: 2000
          },
          enableLogging: false
        };
        
      default:
        throw new Error(`Unknown environment: ${env}`);
    }
  }
  
  /** 获取日志配置 */
  private getLoggingConfig(env: Environment) {
    switch (env) {
      case 'development':
        return {
          level: 'debug' as const,
          enableFileLogging: true,
          maxLogSize: 10 * 1024 * 1024  // 10MB
        };
        
      case 'testing':
        return {
          level: 'warn' as const,
          enableFileLogging: false,
          maxLogSize: 1 * 1024 * 1024   // 1MB
        };
        
      case 'production':
        return {
          level: 'info' as const,
          enableFileLogging: true,
          maxLogSize: 50 * 1024 * 1024  // 50MB
        };
    }
  }
  
  /** 获取性能配置 */
  private getPerformanceConfig(env: Environment) {
    return {
      enableMetrics: env !== 'testing',
      metricsInterval: env === 'development' ? 1000 : 5000
    };
  }
  
  /** 获取当前配置 */
  getConfig(): EnvironmentConfig {
    return this.currentConfig;
  }
  
  /** 保存用户自定义配置 */
  async saveUserConfig(partialConfig: Partial<EnvironmentConfig>): Promise<void> {
    const configPath = ElectronDataPathManager.getInstance().getConfigPath();
    
    try {
      const configData = JSON.stringify(partialConfig, null, 2);
      require('fs').writeFileSync(configPath, configData, 'utf8');
      
      // 重新加载配置
      this.currentConfig = { ...this.currentConfig, ...partialConfig };
      
      console.log('User configuration saved successfully');
    } catch (error) {
      console.error('Failed to save user configuration:', error);
      throw new Error(`Configuration save failed: ${error.message}`);
    }
  }
}
```

#### 3.6.2 存储适配器的统一初始化

```typescript
// ============================================================================
// 应用程序存储初始化器
// ============================================================================

class ApplicationStorageInitializer {
  /** 初始化整个存储层 */
  static async initialize(): Promise<void> {
    const configManager = EnvironmentConfigManager.getInstance();
    const config = configManager.getConfig();
    
    console.log(`Initializing storage for environment: ${config.environment}`);
    
    try {
      // 初始化数据路径
      const pathManager = ElectronDataPathManager.getInstance();
      pathManager.migrateFromLegacyPaths();
      
      // 根据环境配置初始化存储
      const storageContainer = StorageContainer.getInstance();
      storageContainer.configure(config.storage);
      
      // 如果是 SQLite 模式，初始化数据库
      if (config.storage.type === 'sqlite') {
        const sqliteManager = SQLiteConnectionManager.getInstance();
        await sqliteManager.initialize(config.storage.sqliteConfig);
        
        // 初始化 Worker 线程池
        const workerManager = DatabaseWorkerManager.getInstance();
        console.log('Database worker pool initialized');
      }
      
      // 验证存储层
      await this.validateStorage();
      
      console.log('Storage layer initialized successfully');
      
    } catch (error) {
      console.error('Failed to initialize storage layer:', error);
      throw error;
    }
  }
  
  /** 验证存储层功能 */
  private static async validateStorage(): Promise<void> {
    const container = StorageContainer.getInstance();
    
    try {
      // 简单的读写测试
      const guildRepo = container.getGuildRepository();
      
      // 尝试查询（应该返回空结果而不是错误）
      const guilds = await guildRepo.findMany({ limit: 1 });
      console.log(`Storage validation passed: found ${guilds.length} existing guilds`);
      
    } catch (error) {
      throw new Error(`Storage validation failed: ${error.message}`);
    }
  }
  
  /** 应用程序关闭时的清理 */
  static async cleanup(): Promise<void> {
    console.log('Cleaning up storage layer...');
    
    try {
      // 关闭 Worker 线程池
      const workerManager = DatabaseWorkerManager.getInstance();
      await workerManager.shutdown();
      
      // 关闭 SQLite 连接
      const sqliteManager = SQLiteConnectionManager.getInstance();
      await sqliteManager.close();
      
      console.log('Storage cleanup completed');
      
    } catch (error) {
      console.error('Error during storage cleanup:', error);
    }
  }
}

// 导出初始化器供主应用使用
export { ApplicationStorageInitializer };
```

---

### 3.7 总结与实施路线图

#### 3.7.1 架构优势总结

通过实施端口-适配器策略，我们实现了：

1. **开发灵活性**：内存存储支持快速迭代，零配置启动
2. **生产性能**：SQLite WAL 模式提供高性能持久化存储
3. **线程分离**：Worker 线程避免数据库操作阻塞 UI
4. **跨平台支持**：Electron 数据路径自动适配不同操作系统
5. **可测试性**：端口接口支持 Mock 实现，便于单元测试
6. **可扩展性**：未来可轻松切换到其他存储后端

#### 3.7.2 实施路线图

##### 第一阶段：基础架构（Week 1-2）
- [ ] 实现端口接口定义
- [ ] 创建内存存储适配器
- [ ] 建立依赖注入容器
- [ ] 配置环境管理器

##### 第二阶段：SQLite 集成（Week 3-4）
- [ ] 集成 better-sqlite3
- [ ] 实现 WAL 模式配置
- [ ] 创建数据库表结构
- [ ] 建立索引优化策略

##### 第三阶段：Worker 线程（Week 5-6）
- [ ] 实现 Worker 线程池
- [ ] 创建异步任务调度器
- [ ] 建立错误处理机制
- [ ] 实现性能监控

##### 第四阶段：生产优化（Week 7-8）
- [ ] 数据路径管理完善
- [ ] 备份恢复机制
- [ ] 性能调优
- [ ] 压力测试

#### 3.7.3 性能监控指标

```typescript
interface StorageMetrics {
  /** 查询性能指标 */
  queryPerformance: {
    averageQueryTime: number;    // 平均查询时间
    slowQueryCount: number;      // 慢查询计数
    queriesPerSecond: number;    // 每秒查询数
  };
  
  /** 存储资源指标 */
  resourceUsage: {
    databaseSize: number;        // 数据库文件大小
    walFileSize: number;         // WAL 文件大小
    memoryUsage: number;         // 内存使用量
  };
  
  /** Worker 线程指标 */
  workerMetrics: {
    activeWorkers: number;       // 活跃 Worker 数量
    pendingTasks: number;        // 待处理任务数
    averageTaskDuration: number; // 平均任务执行时间
  };
}
```

通过这套完整的存储端口-适配器策略，我们确保了游戏在整个开发周期中的存储层稳定性和性能表现，同时为未来的技术演进留下了充分的扩展空间。

---

## 4 Schema & 迁移

### 4.1 SQLite 迁移最佳实践

> **核心目标**: 建立稳健的SQLite数据库版本管理与迁移系统，确保数据完整性、向后兼容性和无缝升级体验。

#### 4.1.1 PRAGMA user_version 版本管理

SQLite 提供 `user_version` pragma 来存储应用程序定义的数据库版本号，这是管理数据库 schema 演进的最佳实践：

```typescript
// ============================================================================
// 数据库版本管理器 - 基于 PRAGMA user_version
// ============================================================================

interface DatabaseVersion {
  /** 当前数据库版本号 */
  current: number;
  
  /** 目标版本号（应用程序期望的版本） */
  target: number;
  
  /** 版本兼容性信息 */
  compatibility: {
    minimumSupported: number;  // 应用支持的最低数据库版本
    maximumSupported: number;  // 应用支持的最高数据库版本
  };
}

class DatabaseVersionManager {
  private static instance: DatabaseVersionManager;
  private database: Database.Database;
  
  /** 当前应用程序期望的数据库版本 */
  private static readonly TARGET_VERSION = 12;
  
  /** 应用程序支持的最低数据库版本 */
  private static readonly MINIMUM_SUPPORTED_VERSION = 8;
  
  constructor(database: Database.Database) {
    this.database = database;
  }
  
  static getInstance(database: Database.Database): DatabaseVersionManager {
    if (!this.instance) {
      this.instance = new DatabaseVersionManager(database);
    }
    return this.instance;
  }
  
  /** 获取当前数据库版本信息 */
  getVersion(): DatabaseVersion {
    const currentVersion = this.getCurrentDatabaseVersion();
    
    return {
      current: currentVersion,
      target: DatabaseVersionManager.TARGET_VERSION,
      compatibility: {
        minimumSupported: DatabaseVersionManager.MINIMUM_SUPPORTED_VERSION,
        maximumSupported: DatabaseVersionManager.TARGET_VERSION
      }
    };
  }
  
  /** 检查数据库版本兼容性 */
  checkCompatibility(): {
    compatible: boolean;
    action: 'none' | 'upgrade' | 'downgrade' | 'incompatible';
    reason?: string;
  } {
    const version = this.getVersion();
    
    if (version.current === version.target) {
      return { compatible: true, action: 'none' };
    }
    
    if (version.current < version.compatibility.minimumSupported) {
      return {
        compatible: false,
        action: 'incompatible',
        reason: `Database version ${version.current} is too old. Minimum supported: ${version.compatibility.minimumSupported}`
      };
    }
    
    if (version.current > version.compatibility.maximumSupported) {
      return {
        compatible: false,
        action: 'incompatible',
        reason: `Database version ${version.current} is too new. Maximum supported: ${version.compatibility.maximumSupported}`
      };
    }
    
    if (version.current < version.target) {
      return { compatible: true, action: 'upgrade' };
    } else {
      return { compatible: true, action: 'downgrade' };
    }
  }
  
  /** 获取当前数据库版本号 */
  private getCurrentDatabaseVersion(): number {
    const result = this.database.pragma('user_version', { simple: true });
    return Number(result) || 0;
  }
  
  /** 设置数据库版本号 */
  setDatabaseVersion(version: number): void {
    this.database.pragma(`user_version = ${version}`);
    console.log(`Database version updated to: ${version}`);
  }
  
  /** 验证版本号的有效性 */
  validateVersion(version: number): boolean {
    return Number.isInteger(version) && version >= 0 && version <= 999999;
  }
}
```

#### 4.1.2 迁移脚本管理架构

```typescript
// ============================================================================
// 迁移脚本定义与管理
// ============================================================================

/** 迁移脚本类型 */
type MigrationType = 'schema' | 'data' | 'index' | 'cleanup';

/** 迁移方向 */
type MigrationDirection = 'up' | 'down';

/** 迁移脚本接口 */
interface Migration {
  /** 版本号（必须唯一且递增） */
  version: number;
  
  /** 迁移描述 */
  description: string;
  
  /** 迁移类型 */
  type: MigrationType;
  
  /** 依赖的前置版本 */
  dependencies: number[];
  
  /** 升级脚本 */
  up: (db: Database.Database) => void;
  
  /** 回滚脚本 */
  down: (db: Database.Database) => void;
  
  /** 验证脚本（可选） */
  validate?: (db: Database.Database) => boolean;
  
  /** 迁移元数据 */
  metadata: {
    author: string;
    createdAt: string;
    estimatedDuration: string;  // 预估执行时间
    breakingChange: boolean;    // 是否为破坏性变更
  };
}

/** 迁移记录 */
interface MigrationRecord {
  id: number;
  version: number;
  description: string;
  type: MigrationType;
  direction: MigrationDirection;
  appliedAt: string;
  executionTime: number;  // 执行时间（毫秒）
  checksum: string;       // 脚本内容校验和
  success: boolean;
  errorMessage?: string;
}

class MigrationRegistry {
  private migrations = new Map<number, Migration>();
  private database: Database.Database;
  
  constructor(database: Database.Database) {
    this.database = database;
    this.initializeMigrationTable();
  }
  
  /** 注册迁移脚本 */
  register(migration: Migration): void {
    // 验证迁移脚本
    this.validateMigration(migration);
    
    // 检查版本冲突
    if (this.migrations.has(migration.version)) {
      throw new Error(`Migration version ${migration.version} already exists`);
    }
    
    // 验证依赖关系
    this.validateDependencies(migration);
    
    this.migrations.set(migration.version, migration);
    console.log(`Registered migration ${migration.version}: ${migration.description}`);
  }
  
  /** 批量注册迁移脚本 */
  registerAll(migrations: Migration[]): void {
    // 按版本号排序
    const sortedMigrations = migrations.sort((a, b) => a.version - b.version);
    
    for (const migration of sortedMigrations) {
      this.register(migration);
    }
  }
  
  /** 获取指定版本范围的迁移脚本 */
  getMigrationsInRange(fromVersion: number, toVersion: number): Migration[] {
    const migrations: Migration[] = [];
    
    if (fromVersion < toVersion) {
      // 升级：获取 (fromVersion, toVersion] 范围的迁移
      for (const [version, migration] of this.migrations) {
        if (version > fromVersion && version <= toVersion) {
          migrations.push(migration);
        }
      }
    } else {
      // 降级：获取 (toVersion, fromVersion] 范围的迁移，逆序
      for (const [version, migration] of this.migrations) {
        if (version > toVersion && version <= fromVersion) {
          migrations.push(migration);
        }
      }
      migrations.reverse();
    }
    
    return migrations.sort((a, b) => a.version - b.version);
  }
  
  /** 获取已应用的迁移记录 */
  getAppliedMigrations(): MigrationRecord[] {
    const stmt = this.database.prepare(`
      SELECT * FROM migration_history 
      ORDER BY applied_at DESC
    `);
    
    return stmt.all() as MigrationRecord[];
  }
  
  /** 记录迁移执行结果 */
  recordMigration(
    migration: Migration,
    direction: MigrationDirection,
    executionTime: number,
    success: boolean,
    errorMessage?: string
  ): void {
    const stmt = this.database.prepare(`
      INSERT INTO migration_history (
        version, description, type, direction, 
        applied_at, execution_time, checksum, 
        success, error_message
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    const checksum = this.calculateChecksum(migration);
    
    stmt.run([
      migration.version,
      migration.description,
      migration.type,
      direction,
      new Date().toISOString(),
      executionTime,
      checksum,
      success ? 1 : 0,
      errorMessage || null
    ]);
  }
  
  /** 验证迁移脚本的有效性 */
  private validateMigration(migration: Migration): void {
    // 检查必需字段
    if (!migration.version || migration.version <= 0) {
      throw new Error('Migration version must be a positive integer');
    }
    
    if (!migration.description?.trim()) {
      throw new Error('Migration description is required');
    }
    
    if (typeof migration.up !== 'function') {
      throw new Error('Migration up function is required');
    }
    
    if (typeof migration.down !== 'function') {
      throw new Error('Migration down function is required');
    }
    
    // 验证依赖关系
    if (!Array.isArray(migration.dependencies)) {
      throw new Error('Migration dependencies must be an array');
    }
    
    // 验证元数据
    if (!migration.metadata?.author?.trim()) {
      throw new Error('Migration author is required');
    }
  }
  
  /** 验证依赖关系 */
  private validateDependencies(migration: Migration): void {
    for (const depVersion of migration.dependencies) {
      if (!this.migrations.has(depVersion)) {
        throw new Error(
          `Migration ${migration.version} depends on version ${depVersion} which is not registered`
        );
      }
    }
  }
  
  /** 计算迁移脚本校验和 */
  private calculateChecksum(migration: Migration): string {
    const content = JSON.stringify({
      version: migration.version,
      up: migration.up.toString(),
      down: migration.down.toString()
    });
    
    // 简单的校验和实现（实际项目中建议使用 crypto.createHash）
    return Buffer.from(content).toString('base64').slice(0, 32);
  }
  
  /** 初始化迁移历史表 */
  private initializeMigrationTable(): void {
    this.database.exec(`
      CREATE TABLE IF NOT EXISTS migration_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        version INTEGER NOT NULL,
        description TEXT NOT NULL,
        type TEXT NOT NULL,
        direction TEXT NOT NULL,
        applied_at TEXT NOT NULL,
        execution_time INTEGER NOT NULL,
        checksum TEXT NOT NULL,
        success INTEGER NOT NULL,
        error_message TEXT
      )
    `);
    
    // 创建索引
    this.database.exec(`
      CREATE INDEX IF NOT EXISTS idx_migration_history_version 
      ON migration_history(version)
    `);
    
    this.database.exec(`
      CREATE INDEX IF NOT EXISTS idx_migration_history_applied_at 
      ON migration_history(applied_at)
    `);
  }
}
```

#### 4.1.3 事务性迁移执行引擎

```typescript
// ============================================================================
// 迁移执行引擎 - 支持事务性操作和自动回滚
// ============================================================================

interface MigrationExecutionOptions {
  /** 是否启用事务 */
  useTransaction: boolean;
  
  /** 执行超时时间（毫秒） */
  timeout: number;
  
  /** 失败时是否自动回滚 */
  autoRollback: boolean;
  
  /** 是否验证迁移结果 */
  validateResult: boolean;
  
  /** 备份选项 */
  backup: {
    enabled: boolean;
    path?: string;
  };
}

interface MigrationExecutionResult {
  success: boolean;
  version: number;
  executionTime: number;
  affectedMigrations: Migration[];
  errorMessage?: string;
  backupPath?: string;
}

class MigrationExecutor {
  private database: Database.Database;
  private registry: MigrationRegistry;
  private versionManager: DatabaseVersionManager;
  
  constructor(
    database: Database.Database,
    registry: MigrationRegistry,
    versionManager: DatabaseVersionManager
  ) {
    this.database = database;
    this.registry = registry;
    this.versionManager = versionManager;
  }
  
  /** 执行数据库迁移 */
  async migrate(
    targetVersion: number,
    options: Partial<MigrationExecutionOptions> = {}
  ): Promise<MigrationExecutionResult> {
    const opts: MigrationExecutionOptions = {
      useTransaction: true,
      timeout: 30000,
      autoRollback: true,
      validateResult: true,
      backup: { enabled: true },
      ...options
    };
    
    const startTime = Date.now();
    let backupPath: string | undefined;
    
    try {
      // 检查版本兼容性
      const compatibility = this.versionManager.checkCompatibility();
      if (!compatibility.compatible && compatibility.action === 'incompatible') {
        throw new Error(compatibility.reason);
      }
      
      const currentVersion = this.versionManager.getVersion().current;
      
      if (currentVersion === targetVersion) {
        return {
          success: true,
          version: targetVersion,
          executionTime: Date.now() - startTime,
          affectedMigrations: []
        };
      }
      
      // 创建备份
      if (opts.backup.enabled) {
        backupPath = await this.createBackup(opts.backup.path);
        console.log(`Database backup created: ${backupPath}`);
      }
      
      // 获取需要执行的迁移
      const migrations = this.registry.getMigrationsInRange(currentVersion, targetVersion);
      
      if (migrations.length === 0) {
        throw new Error(`No migrations found between version ${currentVersion} and ${targetVersion}`);
      }
      
      console.log(`Starting migration from version ${currentVersion} to ${targetVersion}`);
      console.log(`Migrations to execute: ${migrations.map(m => m.version).join(', ')}`);
      
      // 执行迁移
      const result = await this.executeMigrations(migrations, currentVersion < targetVersion, opts);
      
      if (result.success) {
        // 更新数据库版本
        this.versionManager.setDatabaseVersion(targetVersion);
        console.log(`Migration completed successfully. Database is now at version ${targetVersion}`);
      }
      
      return {
        ...result,
        backupPath
      };
      
    } catch (error) {
      console.error('Migration failed:', error);
      
      const result: MigrationExecutionResult = {
        success: false,
        version: this.versionManager.getVersion().current,
        executionTime: Date.now() - startTime,
        affectedMigrations: [],
        errorMessage: error.message,
        backupPath
      };
      
      // 自动回滚（如果启用）
      if (opts.autoRollback && backupPath) {
        try {
          await this.restoreFromBackup(backupPath);
          console.log('Database restored from backup due to migration failure');
        } catch (restoreError) {
          console.error('Failed to restore from backup:', restoreError);
          result.errorMessage += `\nRestore failed: ${restoreError.message}`;
        }
      }
      
      return result;
    }
  }
  
  /** 执行迁移列表 */
  private async executeMigrations(
    migrations: Migration[],
    isUpgrade: boolean,
    options: MigrationExecutionOptions
  ): Promise<Omit<MigrationExecutionResult, 'backupPath'>> {
    const startTime = Date.now();
    const affectedMigrations: Migration[] = [];
    
    const executeInTransaction = (callback: () => void) => {
      if (options.useTransaction) {
        const transaction = this.database.transaction(callback);
        return transaction();
      } else {
        return callback();
      }
    };
    
    try {
      executeInTransaction(() => {
        for (const migration of migrations) {
          const migrationStartTime = Date.now();
          
          try {
            console.log(`Executing migration ${migration.version}: ${migration.description}`);
            
            // 执行迁移脚本
            if (isUpgrade) {
              migration.up(this.database);
            } else {
              migration.down(this.database);
            }
            
            // 验证迁移结果（如果提供了验证函数）
            if (options.validateResult && migration.validate) {
              const isValid = migration.validate(this.database);
              if (!isValid) {
                throw new Error(`Migration ${migration.version} validation failed`);
              }
            }
            
            const executionTime = Date.now() - migrationStartTime;
            
            // 记录迁移历史
            this.registry.recordMigration(
              migration,
              isUpgrade ? 'up' : 'down',
              executionTime,
              true
            );
            
            affectedMigrations.push(migration);
            
            console.log(`Migration ${migration.version} completed in ${executionTime}ms`);
            
          } catch (error) {
            const executionTime = Date.now() - migrationStartTime;
            
            // 记录失败的迁移
            this.registry.recordMigration(
              migration,
              isUpgrade ? 'up' : 'down',
              executionTime,
              false,
              error.message
            );
            
            throw new Error(`Migration ${migration.version} failed: ${error.message}`);
          }
        }
      });
      
      return {
        success: true,
        version: migrations[migrations.length - 1]?.version || 0,
        executionTime: Date.now() - startTime,
        affectedMigrations
      };
      
    } catch (error) {
      return {
        success: false,
        version: this.versionManager.getVersion().current,
        executionTime: Date.now() - startTime,
        affectedMigrations,
        errorMessage: error.message
      };
    }
  }
  
  /** 创建数据库备份 */
  private async createBackup(customPath?: string): Promise<string> {
    const pathManager = ElectronDataPathManager.getInstance();
    const backupPath = customPath || pathManager.generateBackupPath('-before-migration');
    
    // 执行 WAL 检查点确保数据完整性
    this.database.pragma('wal_checkpoint(TRUNCATE)');
    
    // 创建备份
    this.database.exec(`VACUUM INTO '${backupPath}'`);
    
    return backupPath;
  }
  
  /** 从备份恢复数据库 */
  private async restoreFromBackup(backupPath: string): Promise<void> {
    // 注意：这里是简化实现，实际项目中需要更复杂的恢复逻辑
    console.log(`Restoring database from backup: ${backupPath}`);
    
    // 关闭当前连接
    this.database.close();
    
    // 复制备份文件到原位置
    const currentDbPath = ElectronDataPathManager.getInstance().getDatabasePath();
    require('fs').copyFileSync(backupPath, currentDbPath);
    
    // 重新打开连接
    this.database = new Database(currentDbPath);
    
    console.log('Database restore completed');
  }
  
  /** 检查迁移脚本完整性 */
  checkMigrationIntegrity(): {
    valid: boolean;
    issues: string[];
  } {
    const issues: string[] = [];
    
    // 检查迁移历史表的完整性
    try {
      const appliedMigrations = this.registry.getAppliedMigrations();
      
      for (const record of appliedMigrations) {
        // 验证校验和（如果迁移脚本仍然存在）
        // 这里可以添加更多完整性检查
      }
      
    } catch (error) {
      issues.push(`Migration history integrity check failed: ${error.message}`);
    }
    
    return {
      valid: issues.length === 0,
      issues
    };
  }
}
```

---

### 4.2 版本化迁移脚本系统

#### 4.2.1 迁移脚本定义标准

```typescript
// ============================================================================
// 《公会经理》游戏的具体迁移脚本定义
// ============================================================================

/** 迁移脚本基类 */
abstract class BaseMigration implements Migration {
  abstract version: number;
  abstract description: string;
  abstract type: MigrationType;
  abstract dependencies: number[];
  abstract metadata: Migration['metadata'];
  
  abstract up(db: Database.Database): void;
  abstract down(db: Database.Database): void;
  
  /** 通用的表存在性检查 */
  protected tableExists(db: Database.Database, tableName: string): boolean {
    const result = db.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name=?
    `).get(tableName);
    
    return !!result;
  }
  
  /** 通用的列存在性检查 */
  protected columnExists(db: Database.Database, tableName: string, columnName: string): boolean {
    const result = db.prepare(`PRAGMA table_info(${tableName})`).all();
    return result.some((col: any) => col.name === columnName);
  }
  
  /** 通用的索引存在性检查 */
  protected indexExists(db: Database.Database, indexName: string): boolean {
    const result = db.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='index' AND name=?
    `).get(indexName);
    
    return !!result;
  }
  
  /** 安全地添加列（如果不存在） */
  protected addColumnIfNotExists(
    db: Database.Database, 
    tableName: string, 
    columnName: string, 
    columnDefinition: string
  ): void {
    if (!this.columnExists(db, tableName, columnName)) {
      db.exec(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${columnDefinition}`);
      console.log(`Added column ${columnName} to table ${tableName}`);
    } else {
      console.log(`Column ${columnName} already exists in table ${tableName}`);
    }
  }
  
  /** 安全地创建索引（如果不存在） */
  protected createIndexIfNotExists(
    db: Database.Database,
    indexName: string,
    tableName: string,
    columns: string[]
  ): void {
    if (!this.indexExists(db, indexName)) {
      const columnList = columns.join(', ');
      db.exec(`CREATE INDEX ${indexName} ON ${tableName}(${columnList})`);
      console.log(`Created index ${indexName} on ${tableName}(${columnList})`);
    } else {
      console.log(`Index ${indexName} already exists`);
    }
  }
}

/** 示例：初始数据库结构创建 */
class Migration001_InitialSchema extends BaseMigration {
  version = 1;
  description = 'Create initial database schema for guild management';
  type: MigrationType = 'schema';
  dependencies = [];
  
  metadata = {
    author: 'system',
    createdAt: '2024-01-01T00:00:00Z',
    estimatedDuration: '< 1s',
    breakingChange: false
  };
  
  up(db: Database.Database): void {
    // 创建公会表
    db.exec(`
      CREATE TABLE guilds (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        reputation INTEGER NOT NULL DEFAULT 0,
        treasury TEXT NOT NULL DEFAULT '{}',
        settings TEXT DEFAULT '{}',
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `);
    
    // 创建角色表
    db.exec(`
      CREATE TABLE characters (
        id TEXT PRIMARY KEY,
        guild_id TEXT,
        name TEXT NOT NULL,
        level INTEGER NOT NULL DEFAULT 1,
        experience INTEGER NOT NULL DEFAULT 0,
        attributes TEXT NOT NULL DEFAULT '{}',
        skills TEXT NOT NULL DEFAULT '{}',
        equipment TEXT DEFAULT '{}',
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (guild_id) REFERENCES guilds(id) ON DELETE SET NULL
      )
    `);
    
    // 创建基础索引
    this.createIndexIfNotExists(db, 'idx_characters_guild_id', 'characters', ['guild_id']);
    this.createIndexIfNotExists(db, 'idx_guilds_reputation', 'guilds', ['reputation DESC']);
  }
  
  down(db: Database.Database): void {
    db.exec('DROP TABLE IF EXISTS characters');
    db.exec('DROP TABLE IF EXISTS guilds');
  }
  
  validate(db: Database.Database): boolean {
    return this.tableExists(db, 'guilds') && 
           this.tableExists(db, 'characters') &&
           this.indexExists(db, 'idx_characters_guild_id');
  }
}

/** 示例：添加战斗系统表 */
class Migration002_AddBattleSystem extends BaseMigration {
  version = 2;
  description = 'Add battle system tables and relationships';
  type: MigrationType = 'schema';
  dependencies = [1];
  
  metadata = {
    author: 'game-dev-team',
    createdAt: '2024-01-15T00:00:00Z',
    estimatedDuration: '< 2s',
    breakingChange: false
  };
  
  up(db: Database.Database): void {
    // 创建战斗表
    db.exec(`
      CREATE TABLE battles (
        id TEXT PRIMARY KEY,
        attacker_guild_id TEXT NOT NULL,
        defender_guild_id TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        battle_data TEXT NOT NULL DEFAULT '{}',
        result TEXT,
        started_at INTEGER,
        completed_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (attacker_guild_id) REFERENCES guilds(id),
        FOREIGN KEY (defender_guild_id) REFERENCES guilds(id)
      )
    `);
    
    // 创建战斗参与者表
    db.exec(`
      CREATE TABLE battle_participants (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        battle_id TEXT NOT NULL,
        character_id TEXT NOT NULL,
        side TEXT NOT NULL, -- 'attacker' or 'defender'
        position INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'ready',
        FOREIGN KEY (battle_id) REFERENCES battles(id) ON DELETE CASCADE,
        FOREIGN KEY (character_id) REFERENCES characters(id)
      )
    `);
    
    // 创建索引
    this.createIndexIfNotExists(db, 'idx_battles_status', 'battles', ['status']);
    this.createIndexIfNotExists(db, 'idx_battles_attacker', 'battles', ['attacker_guild_id']);
    this.createIndexIfNotExists(db, 'idx_battles_defender', 'battles', ['defender_guild_id']);
    this.createIndexIfNotExists(db, 'idx_battle_participants_battle', 'battle_participants', ['battle_id']);
  }
  
  down(db: Database.Database): void {
    db.exec('DROP TABLE IF EXISTS battle_participants');
    db.exec('DROP TABLE IF EXISTS battles');
  }
  
  validate(db: Database.Database): boolean {
    return this.tableExists(db, 'battles') && 
           this.tableExists(db, 'battle_participants');
  }
}

/** 示例：添加用户配置表 */
class Migration003_AddUserPreferences extends BaseMigration {
  version = 3;
  description = 'Add user preferences and settings table';
  type: MigrationType = 'schema';
  dependencies = [1];
  
  metadata = {
    author: 'ui-team',
    createdAt: '2024-02-01T00:00:00Z',
    estimatedDuration: '< 1s',
    breakingChange: false
  };
  
  up(db: Database.Database): void {
    db.exec(`
      CREATE TABLE user_preferences (
        id INTEGER PRIMARY KEY,
        user_id TEXT UNIQUE,
        ui_settings TEXT NOT NULL DEFAULT '{}',
        game_settings TEXT NOT NULL DEFAULT '{}',
        notification_settings TEXT NOT NULL DEFAULT '{}',
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `);
    
    this.createIndexIfNotExists(db, 'idx_user_preferences_user', 'user_preferences', ['user_id']);
  }
  
  down(db: Database.Database): void {
    db.exec('DROP TABLE IF EXISTS user_preferences');
  }
}

/** 示例：数据迁移 - 角色属性重构 */
class Migration004_RefactorCharacterAttributes extends BaseMigration {
  version = 4;
  description = 'Refactor character attributes structure for better performance';
  type: MigrationType = 'data';
  dependencies = [1];
  
  metadata = {
    author: 'game-balance-team',
    createdAt: '2024-02-15T00:00:00Z',
    estimatedDuration: '5-10s',
    breakingChange: true
  };
  
  up(db: Database.Database): void {
    // 添加新的属性列
    this.addColumnIfNotExists(db, 'characters', 'strength', 'INTEGER DEFAULT 10');
    this.addColumnIfNotExists(db, 'characters', 'agility', 'INTEGER DEFAULT 10');
    this.addColumnIfNotExists(db, 'characters', 'intelligence', 'INTEGER DEFAULT 10');
    this.addColumnIfNotExists(db, 'characters', 'vitality', 'INTEGER DEFAULT 10');
    
    // 迁移现有数据
    const characters = db.prepare('SELECT id, attributes FROM characters WHERE attributes != "{}"').all();
    
    const updateStmt = db.prepare(`
      UPDATE characters 
      SET strength = ?, agility = ?, intelligence = ?, vitality = ?
      WHERE id = ?
    `);
    
    const updateTransaction = db.transaction((chars: any[]) => {
      for (const char of chars) {
        try {
          const attributes = JSON.parse(char.attributes);
          updateStmt.run([
            attributes.strength || 10,
            attributes.agility || 10,
            attributes.intelligence || 10,
            attributes.vitality || 10,
            char.id
          ]);
        } catch (error) {
          console.warn(`Failed to parse attributes for character ${char.id}, using defaults`);
          updateStmt.run([10, 10, 10, 10, char.id]);
        }
      }
    });
    
    updateTransaction(characters);
    
    console.log(`Migrated attributes for ${characters.length} characters`);
  }
  
  down(db: Database.Database): void {
    // 由于这是破坏性变更，回滚时重建 attributes JSON
    const characters = db.prepare(`
      SELECT id, strength, agility, intelligence, vitality 
      FROM characters
    `).all();
    
    const updateStmt = db.prepare('UPDATE characters SET attributes = ? WHERE id = ?');
    
    const rollbackTransaction = db.transaction((chars: any[]) => {
      for (const char of chars) {
        const attributes = {
          strength: char.strength,
          agility: char.agility,
          intelligence: char.intelligence,
          vitality: char.vitality
        };
        updateStmt.run([JSON.stringify(attributes), char.id]);
      }
    });
    
    rollbackTransaction(characters);
    
    // 删除单独的属性列（SQLite 不支持 DROP COLUMN，需要重建表）
    this.recreateTableWithoutColumns(db, 'characters', ['strength', 'agility', 'intelligence', 'vitality']);
  }
  
  /** 重建表以移除指定列 */
  private recreateTableWithoutColumns(db: Database.Database, tableName: string, columnsToRemove: string[]): void {
    // 获取表结构
    const tableInfo = db.prepare(`PRAGMA table_info(${tableName})`).all() as any[];
    const remainingColumns = tableInfo.filter(col => !columnsToRemove.includes(col.name));
    
    // 构建新表结构
    const columnDefs = remainingColumns.map(col => {
      let def = `${col.name} ${col.type}`;
      if (col.notnull) def += ' NOT NULL';
      if (col.dflt_value !== null) def += ` DEFAULT ${col.dflt_value}`;
      if (col.pk) def += ' PRIMARY KEY';
      return def;
    }).join(', ');
    
    const columnNames = remainingColumns.map(col => col.name).join(', ');
    
    // 执行表重建
    db.exec(`
      BEGIN TRANSACTION;
      
      CREATE TABLE ${tableName}_backup (${columnDefs});
      
      INSERT INTO ${tableName}_backup (${columnNames})
      SELECT ${columnNames} FROM ${tableName};
      
      DROP TABLE ${tableName};
      
      ALTER TABLE ${tableName}_backup RENAME TO ${tableName};
      
      COMMIT;
    `);
    
    console.log(`Recreated table ${tableName} without columns: ${columnsToRemove.join(', ')}`);
  }
  
  validate(db: Database.Database): boolean {
    return this.columnExists(db, 'characters', 'strength') &&
           this.columnExists(db, 'characters', 'agility') &&
           this.columnExists(db, 'characters', 'intelligence') &&
           this.columnExists(db, 'characters', 'vitality');
  }
}
```

#### 4.2.2 迁移脚本自动发现与加载

```typescript
// ============================================================================
// 迁移脚本自动发现系统
// ============================================================================

interface MigrationModuleInfo {
  path: string;
  version: number;
  className: string;
  migration: Migration;
}

class MigrationLoader {
  private loadedModules = new Map<number, MigrationModuleInfo>();
  
  /** 从指定目录加载所有迁移脚本 */
  async loadMigrationsFromDirectory(migrationDir: string): Promise<Migration[]> {
    const path = require('path');
    const fs = require('fs');
    
    const migrations: Migration[] = [];
    
    try {
      const files = fs.readdirSync(migrationDir);
      const migrationFiles = files.filter((file: string) => 
        file.endsWith('.ts') || file.endsWith('.js')
      ).sort();
      
      for (const file of migrationFiles) {
        const filePath = path.join(migrationDir, file);
        
        try {
          const migration = await this.loadMigrationFromFile(filePath);
          if (migration) {
            migrations.push(migration);
            
            this.loadedModules.set(migration.version, {
              path: filePath,
              version: migration.version,
              className: migration.constructor.name,
              migration
            });
          }
        } catch (error) {
          console.error(`Failed to load migration from ${file}:`, error);
        }
      }
      
      console.log(`Loaded ${migrations.length} migrations from ${migrationDir}`);
      return migrations.sort((a, b) => a.version - b.version);
      
    } catch (error) {
      console.error(`Failed to read migration directory ${migrationDir}:`, error);
      return [];
    }
  }
  
  /** 从单个文件加载迁移脚本 */
  private async loadMigrationFromFile(filePath: string): Promise<Migration | null> {
    try {
      // 动态导入模块
      const module = require(filePath);
      
      // 查找导出的迁移类
      for (const [exportName, exportValue] of Object.entries(module)) {
        if (this.isMigrationClass(exportValue)) {
          const MigrationClass = exportValue as new() => Migration;
          const migration = new MigrationClass();
          
          // 验证迁移脚本
          this.validateLoadedMigration(migration, filePath);
          
          return migration;
        }
      }
      
      console.warn(`No valid migration class found in ${filePath}`);
      return null;
      
    } catch (error) {
      console.error(`Error loading migration from ${filePath}:`, error);
      return null;
    }
  }
  
  /** 检查是否为有效的迁移类 */
  private isMigrationClass(value: any): boolean {
    return typeof value === 'function' && 
           value.prototype &&
           typeof value.prototype.up === 'function' &&
           typeof value.prototype.down === 'function';
  }
  
  /** 验证加载的迁移脚本 */
  private validateLoadedMigration(migration: Migration, filePath: string): void {
    if (!migration.version || typeof migration.version !== 'number') {
      throw new Error(`Invalid version in migration ${filePath}`);
    }
    
    if (!migration.description || typeof migration.description !== 'string') {
      throw new Error(`Invalid description in migration ${filePath}`);
    }
    
    if (typeof migration.up !== 'function') {
      throw new Error(`Missing or invalid up method in migration ${filePath}`);
    }
    
    if (typeof migration.down !== 'function') {
      throw new Error(`Missing or invalid down method in migration ${filePath}`);
    }
  }
  
  /** 获取已加载的迁移信息 */
  getLoadedMigrationInfo(): MigrationModuleInfo[] {
    return Array.from(this.loadedModules.values()).sort((a, b) => a.version - b.version);
  }
  
  /** 重新加载指定版本的迁移脚本 */
  async reloadMigration(version: number): Promise<Migration | null> {
    const moduleInfo = this.loadedModules.get(version);
    if (!moduleInfo) {
      throw new Error(`Migration version ${version} not found`);
    }
    
    // 清除 require 缓存
    delete require.cache[require.resolve(moduleInfo.path)];
    
    // 重新加载
    const migration = await this.loadMigrationFromFile(moduleInfo.path);
    if (migration) {
      this.loadedModules.set(version, {
        ...moduleInfo,
        migration
      });
    }
    
    return migration;
  }
}

/** 内置迁移脚本注册 */
class BuiltInMigrations {
  /** 获取所有内置迁移脚本 */
  static getAllMigrations(): Migration[] {
    return [
      new Migration001_InitialSchema(),
      new Migration002_AddBattleSystem(),
      new Migration003_AddUserPreferences(),
      new Migration004_RefactorCharacterAttributes(),
      // 在这里添加更多迁移脚本...
    ];
  }
  
  /** 按版本范围获取迁移脚本 */
  static getMigrationsByVersionRange(minVersion: number, maxVersion: number): Migration[] {
    return this.getAllMigrations().filter(
      migration => migration.version >= minVersion && migration.version <= maxVersion
    );
  }
}
```

---

### 4.3 回滚策略与事务性DDL

#### 4.3.1 回滚策略设计

```typescript
// ============================================================================
// 回滚策略管理器
// ============================================================================

interface RollbackOptions {
  /** 目标版本 */
  targetVersion: number;
  
  /** 是否创建回滚前备份 */
  createBackup: boolean;
  
  /** 回滚策略 */
  strategy: 'safe' | 'force' | 'dry-run';
  
  /** 数据保护选项 */
  dataProtection: {
    /** 是否保护用户数据 */
    preserveUserData: boolean;
    
    /** 需要保护的表列表 */
    protectedTables: string[];
    
    /** 数据导出路径 */
    exportPath?: string;
  };
}

interface RollbackPlan {
  /** 当前版本 */
  currentVersion: number;
  
  /** 目标版本 */
  targetVersion: number;
  
  /** 需要回滚的迁移列表 */
  migrationsToRollback: Migration[];
  
  /** 风险评估 */
  riskAssessment: {
    /** 是否为破坏性回滚 */
    destructive: boolean;
    
    /** 风险等级 */
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    
    /** 风险描述 */
    risks: string[];
    
    /** 数据丢失风险 */
    dataLossRisk: boolean;
  };
  
  /** 预估执行时间 */
  estimatedDuration: string;
}

class RollbackManager {
  private database: Database.Database;
  private registry: MigrationRegistry;
  private versionManager: DatabaseVersionManager;
  
  constructor(
    database: Database.Database,
    registry: MigrationRegistry,
    versionManager: DatabaseVersionManager
  ) {
    this.database = database;
    this.registry = registry;
    this.versionManager = versionManager;
  }
  
  /** 创建回滚计划 */
  createRollbackPlan(targetVersion: number): RollbackPlan {
    const currentVersion = this.versionManager.getVersion().current;
    
    if (targetVersion >= currentVersion) {
      throw new Error(`Target version ${targetVersion} must be less than current version ${currentVersion}`);
    }
    
    // 获取需要回滚的迁移
    const migrationsToRollback = this.registry.getMigrationsInRange(targetVersion, currentVersion);
    
    // 风险评估
    const riskAssessment = this.assessRollbackRisk(migrationsToRollback);
    
    // 估算执行时间
    const estimatedDuration = this.estimateRollbackDuration(migrationsToRollback);
    
    return {
      currentVersion,
      targetVersion,
      migrationsToRollback,
      riskAssessment,
      estimatedDuration
    };
  }
  
  /** 执行回滚计划 */
  async executeRollback(options: RollbackOptions): Promise<MigrationExecutionResult> {
    const plan = this.createRollbackPlan(options.targetVersion);
    
    // 安全性检查
    if (plan.riskAssessment.riskLevel === 'critical' && options.strategy !== 'force') {
      throw new Error(
        `Rollback to version ${options.targetVersion} is considered critical risk. ` +
        `Use strategy 'force' to proceed anyway. Risks: ${plan.riskAssessment.risks.join(', ')}`
      );
    }
    
    console.log(`Starting rollback from version ${plan.currentVersion} to ${plan.targetVersion}`);
    console.log(`Risk level: ${plan.riskAssessment.riskLevel}`);
    console.log(`Estimated duration: ${plan.estimatedDuration}`);
    
    if (options.strategy === 'dry-run') {
      return this.performDryRun(plan);
    }
    
    const startTime = Date.now();
    let backupPath: string | undefined;
    
    try {
      // 创建回滚前备份
      if (options.createBackup) {
        backupPath = await this.createPreRollbackBackup();
        console.log(`Pre-rollback backup created: ${backupPath}`);
      }
      
      // 导出受保护的数据
      let exportPath: string | undefined;
      if (options.dataProtection.preserveUserData) {
        exportPath = await this.exportProtectedData(options.dataProtection);
        console.log(`Protected data exported to: ${exportPath}`);
      }
      
      // 执行回滚
      const result = await this.performRollback(plan, options);
      
      // 重新导入受保护的数据
      if (exportPath && result.success) {
        await this.reimportProtectedData(exportPath, options.dataProtection);
        console.log('Protected data reimported successfully');
      }
      
      if (result.success) {
        this.versionManager.setDatabaseVersion(options.targetVersion);
        console.log(`Rollback completed successfully. Database is now at version ${options.targetVersion}`);
      }
      
      return {
        ...result,
        backupPath
      };
      
    } catch (error) {
      console.error('Rollback failed:', error);
      
      // 如果有备份，尝试恢复
      if (backupPath && options.strategy !== 'dry-run') {
        try {
          await this.restoreFromBackup(backupPath);
          console.log('Database restored from pre-rollback backup');
        } catch (restoreError) {
          console.error('Failed to restore from backup:', restoreError);
        }
      }
      
      return {
        success: false,
        version: plan.currentVersion,
        executionTime: Date.now() - startTime,
        affectedMigrations: [],
        errorMessage: error.message,
        backupPath
      };
    }
  }
  
  /** 评估回滚风险 */
  private assessRollbackRisk(migrations: Migration[]): RollbackPlan['riskAssessment'] {
    const risks: string[] = [];
    let destructive = false;
    let dataLossRisk = false;
    let riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';
    
    for (const migration of migrations) {
      if (migration.metadata.breakingChange) {
        destructive = true;
        risks.push(`Migration ${migration.version} contains breaking changes`);
      }
      
      if (migration.type === 'data') {
        dataLossRisk = true;
        risks.push(`Migration ${migration.version} involves data transformation`);
      }
      
      if (migration.type === 'schema') {
        risks.push(`Migration ${migration.version} involves schema changes`);
      }
    }
    
    // 评估整体风险等级
    if (destructive && dataLossRisk) {
      riskLevel = 'critical';
    } else if (destructive || dataLossRisk) {
      riskLevel = 'high';
    } else if (migrations.some(m => m.type === 'schema')) {
      riskLevel = 'medium';
    }
    
    return {
      destructive,
      riskLevel,
      risks,
      dataLossRisk
    };
  }
  
  /** 估算回滚执行时间 */
  private estimateRollbackDuration(migrations: Migration[]): string {
    // 基于迁移类型和数量的简单估算
    let totalSeconds = 0;
    
    for (const migration of migrations) {
      switch (migration.type) {
        case 'schema':
          totalSeconds += 2;
          break;
        case 'data':
          totalSeconds += 10;
          break;
        case 'index':
          totalSeconds += 5;
          break;
        default:
          totalSeconds += 1;
      }
    }
    
    if (totalSeconds < 60) {
      return `${totalSeconds}s`;
    } else if (totalSeconds < 3600) {
      return `${Math.ceil(totalSeconds / 60)}m`;
    } else {
      return `${Math.ceil(totalSeconds / 3600)}h`;
    }
  }
  
  /** 执行干跑（不实际修改数据库） */
  private async performDryRun(plan: RollbackPlan): Promise<MigrationExecutionResult> {
    console.log('Performing rollback dry-run...');
    
    for (const migration of plan.migrationsToRollback) {
      console.log(`Would rollback migration ${migration.version}: ${migration.description}`);
      
      // 检查回滚脚本的有效性
      if (typeof migration.down !== 'function') {
        throw new Error(`Migration ${migration.version} has no valid down method`);
      }
    }
    
    console.log('Dry-run completed successfully. No changes were made to the database.');
    
    return {
      success: true,
      version: plan.targetVersion,
      executionTime: 0,
      affectedMigrations: plan.migrationsToRollback
    };
  }
  
  /** 执行实际回滚 */
  private async performRollback(
    plan: RollbackPlan, 
    options: RollbackOptions
  ): Promise<Omit<MigrationExecutionResult, 'backupPath'>> {
    const startTime = Date.now();
    const affectedMigrations: Migration[] = [];
    
    try {
      // 在事务中执行回滚
      const rollbackTransaction = this.database.transaction(() => {
        for (const migration of plan.migrationsToRollback) {
          const migrationStartTime = Date.now();
          
          try {
            console.log(`Rolling back migration ${migration.version}: ${migration.description}`);
            
            // 执行回滚脚本
            migration.down(this.database);
            
            const executionTime = Date.now() - migrationStartTime;
            
            // 记录回滚历史
            this.registry.recordMigration(
              migration,
              'down',
              executionTime,
              true
            );
            
            affectedMigrations.push(migration);
            
            console.log(`Migration ${migration.version} rolled back in ${executionTime}ms`);
            
          } catch (error) {
            const executionTime = Date.now() - migrationStartTime;
            
            // 记录失败的回滚
            this.registry.recordMigration(
              migration,
              'down',
              executionTime,
              false,
              error.message
            );
            
            throw new Error(`Rollback of migration ${migration.version} failed: ${error.message}`);
          }
        }
      });
      
      rollbackTransaction();
      
      return {
        success: true,
        version: plan.targetVersion,
        executionTime: Date.now() - startTime,
        affectedMigrations
      };
      
    } catch (error) {
      return {
        success: false,
        version: plan.currentVersion,
        executionTime: Date.now() - startTime,
        affectedMigrations,
        errorMessage: error.message
      };
    }
  }
  
  /** 创建回滚前备份 */
  private async createPreRollbackBackup(): Promise<string> {
    const pathManager = ElectronDataPathManager.getInstance();
    const backupPath = pathManager.generateBackupPath('-before-rollback');
    
    // 执行 WAL 检查点确保数据完整性
    this.database.pragma('wal_checkpoint(TRUNCATE)');
    
    // 创建备份
    this.database.exec(`VACUUM INTO '${backupPath}'`);
    
    return backupPath;
  }
  
  /** 导出受保护的数据 */
  private async exportProtectedData(
    dataProtection: RollbackOptions['dataProtection']
  ): Promise<string> {
    const pathManager = ElectronDataPathManager.getInstance();
    const exportPath = dataProtection.exportPath || 
                      pathManager.generateBackupPath('-protected-data.json');
    
    const protectedData: Record<string, any[]> = {};
    
    for (const tableName of dataProtection.protectedTables) {
      try {
        const rows = this.database.prepare(`SELECT * FROM ${tableName}`).all();
        protectedData[tableName] = rows;
        console.log(`Exported ${rows.length} rows from table ${tableName}`);
      } catch (error) {
        console.warn(`Failed to export data from table ${tableName}:`, error);
      }
    }
    
    // 写入文件
    require('fs').writeFileSync(exportPath, JSON.stringify(protectedData, null, 2));
    
    return exportPath;
  }
  
  /** 重新导入受保护的数据 */
  private async reimportProtectedData(
    exportPath: string,
    dataProtection: RollbackOptions['dataProtection']
  ): Promise<void> {
    try {
      const protectedData = JSON.parse(require('fs').readFileSync(exportPath, 'utf8'));
      
      for (const [tableName, rows] of Object.entries(protectedData)) {
        if (!dataProtection.protectedTables.includes(tableName)) {
          continue;
        }
        
        // 检查表是否仍然存在
        if (!this.tableExists(tableName)) {
          console.warn(`Table ${tableName} no longer exists, skipping data import`);
          continue;
        }
        
        // 重新导入数据
        await this.reimportTableData(tableName, rows as any[]);
      }
      
    } catch (error) {
      console.error('Failed to reimport protected data:', error);
      throw error;
    }
  }
  
  /** 重新导入单个表的数据 */
  private async reimportTableData(tableName: string, rows: any[]): Promise<void> {
    if (!Array.isArray(rows) || rows.length === 0) {
      return;
    }
    
    // 获取表结构
    const tableInfo = this.database.prepare(`PRAGMA table_info(${tableName})`).all() as any[];
    const columnNames = tableInfo.map(col => col.name);
    
    // 准备插入语句
    const placeholders = columnNames.map(() => '?').join(', ');
    const insertStmt = this.database.prepare(`
      INSERT OR REPLACE INTO ${tableName} (${columnNames.join(', ')}) 
      VALUES (${placeholders})
    `);
    
    const importTransaction = this.database.transaction((data: any[]) => {
      for (const row of data) {
        const values = columnNames.map(col => row[col]);
        insertStmt.run(values);
      }
    });
    
    importTransaction(rows);
    
    console.log(`Reimported ${rows.length} rows into table ${tableName}`);
  }
  
  /** 检查表是否存在 */
  private tableExists(tableName: string): boolean {
    const result = this.database.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name=?
    `).get(tableName);
    
    return !!result;
  }
  
  /** 从备份恢复数据库 */
  private async restoreFromBackup(backupPath: string): Promise<void> {
    console.log(`Restoring database from backup: ${backupPath}`);
    
    // 关闭当前连接
    this.database.close();
    
    // 复制备份文件到原位置
    const currentDbPath = ElectronDataPathManager.getInstance().getDatabasePath();
    require('fs').copyFileSync(backupPath, currentDbPath);
    
    console.log('Database restore completed');
  }
}
```

---

### 4.4 索引管理与完整性约束

#### 4.4.1 索引管理策略

```typescript
// ============================================================================
// 数据库索引管理器
// ============================================================================

interface IndexDefinition {
  /** 索引名称 */
  name: string;
  
  /** 表名 */
  tableName: string;
  
  /** 索引列 */
  columns: string[];
  
  /** 是否为唯一索引 */
  unique: boolean;
  
  /** 是否为部分索引 */
  partial?: {
    condition: string;
  };
  
  /** 索引类型提示 */
  type: 'btree' | 'hash' | 'covering';
  
  /** 索引用途描述 */
  purpose: string;
  
  /** 预估性能影响 */
  performance: {
    /** 查询性能提升程度 */
    queryImprovement: 'low' | 'medium' | 'high';
    
    /** 写入性能影响 */
    writeImpact: 'low' | 'medium' | 'high';
    
    /** 存储空间开销 */
    storageOverhead: 'low' | 'medium' | 'high';
  };
}

interface IndexAnalysis {
  /** 索引名称 */
  name: string;
  
  /** 索引统计信息 */
  stats: {
    /** 表中的行数 */
    tableRows: number;
    
    /** 索引中的唯一值数量 */
    uniqueValues: number;
    
    /** 索引选择性（0-1，越接近1越好） */
    selectivity: number;
    
    /** 索引大小（页数） */
    sizeInPages: number;
  };
  
  /** 使用情况分析 */
  usage: {
    /** 是否被使用 */
    isUsed: boolean;
    
    /** 推荐操作 */
    recommendation: 'keep' | 'optimize' | 'remove';
    
    /** 原因说明 */
    reason: string;
  };
}

class IndexManager {
  private database: Database.Database;
  
  constructor(database: Database.Database) {
    this.database = database;
  }
  
  /** 创建索引 */
  createIndex(definition: IndexDefinition): void {
    try {
      // 检查索引是否已存在
      if (this.indexExists(definition.name)) {
        console.log(`Index ${definition.name} already exists`);
        return;
      }
      
      // 构建 CREATE INDEX 语句
      let sql = `CREATE ${definition.unique ? 'UNIQUE ' : ''}INDEX ${definition.name} `;
      sql += `ON ${definition.tableName}(${definition.columns.join(', ')})`;
      
      // 添加部分索引条件
      if (definition.partial) {
        sql += ` WHERE ${definition.partial.condition}`;
      }
      
      // 执行创建索引
      this.database.exec(sql);
      
      console.log(`Created index ${definition.name} on ${definition.tableName}(${definition.columns.join(', ')})`);
      
      // 记录索引创建信息
      this.recordIndexOperation('create', definition);
      
    } catch (error) {
      console.error(`Failed to create index ${definition.name}:`, error);
      throw error;
    }
  }
  
  /** 删除索引 */
  dropIndex(indexName: string): void {
    try {
      if (!this.indexExists(indexName)) {
        console.log(`Index ${indexName} does not exist`);
        return;
      }
      
      this.database.exec(`DROP INDEX ${indexName}`);
      console.log(`Dropped index ${indexName}`);
      
      // 记录索引删除信息
      this.recordIndexOperation('drop', { name: indexName } as IndexDefinition);
      
    } catch (error) {
      console.error(`Failed to drop index ${indexName}:`, error);
      throw error;
    }
  }
  
  /** 重建索引 */
  rebuildIndex(indexName: string): void {
    try {
      // 获取索引定义
      const indexInfo = this.getIndexDefinition(indexName);
      if (!indexInfo) {
        throw new Error(`Index ${indexName} not found`);
      }
      
      // 删除现有索引
      this.dropIndex(indexName);
      
      // 重新创建索引
      this.createIndex(indexInfo);
      
      console.log(`Rebuilt index ${indexName}`);
      
    } catch (error) {
      console.error(`Failed to rebuild index ${indexName}:`, error);
      throw error;
    }
  }
  
  /** 分析索引性能 */
  analyzeIndex(indexName: string): IndexAnalysis {
    const indexInfo = this.getIndexDefinition(indexName);
    if (!indexInfo) {
      throw new Error(`Index ${indexName} not found`);
    }
    
    // 获取表统计信息
    const tableStats = this.getTableStats(indexInfo.tableName);
    
    // 计算索引选择性
    const selectivity = this.calculateIndexSelectivity(indexInfo);
    
    // 获取索引大小
    const sizeInPages = this.getIndexSize(indexName);
    
    // 分析使用情况
    const usage = this.analyzeIndexUsage(indexInfo);
    
    return {
      name: indexName,
      stats: {
        tableRows: tableStats.rowCount,
        uniqueValues: selectivity.uniqueValues,
        selectivity: selectivity.ratio,
        sizeInPages
      },
      usage
    };
  }
  
  /** 获取所有索引的性能分析报告 */
  generateIndexReport(): {
    totalIndexes: number;
    recommendations: {
      toOptimize: IndexAnalysis[];
      toRemove: IndexAnalysis[];
      toKeep: IndexAnalysis[];
    };
    summary: {
      totalSize: number;
      unusedIndexes: number;
      lowSelectivityIndexes: number;
    };
  } {
    const allIndexes = this.getAllIndexes();
    const analyses = allIndexes.map(idx => this.analyzeIndex(idx.name));
    
    const recommendations = {
      toOptimize: analyses.filter(a => a.usage.recommendation === 'optimize'),
      toRemove: analyses.filter(a => a.usage.recommendation === 'remove'),
      toKeep: analyses.filter(a => a.usage.recommendation === 'keep')
    };
    
    const summary = {
      totalSize: analyses.reduce((sum, a) => sum + a.stats.sizeInPages, 0),
      unusedIndexes: analyses.filter(a => !a.usage.isUsed).length,
      lowSelectivityIndexes: analyses.filter(a => a.stats.selectivity < 0.1).length
    };
    
    return {
      totalIndexes: allIndexes.length,
      recommendations,
      summary
    };
  }
  
  /** 检查索引是否存在 */
  private indexExists(indexName: string): boolean {
    const result = this.database.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='index' AND name=?
    `).get(indexName);
    
    return !!result;
  }
  
  /** 获取索引定义 */
  private getIndexDefinition(indexName: string): IndexDefinition | null {
    const result = this.database.prepare(`
      SELECT name, tbl_name, sql 
      FROM sqlite_master 
      WHERE type='index' AND name=?
    `).get(indexName) as any;
    
    if (!result) {
      return null;
    }
    
    // 解析 SQL 语句获取索引定义（简化实现）
    const sql = result.sql;
    const unique = sql.includes('UNIQUE');
    const tableName = result.tbl_name;
    
    // 提取列名（简化的正则表达式）
    const columnMatch = sql.match(/\(([^)]+)\)/);
    const columns = columnMatch ? columnMatch[1].split(',').map((col: string) => col.trim()) : [];
    
    return {
      name: indexName,
      tableName,
      columns,
      unique,
      type: 'btree',
      purpose: 'Performance optimization',
      performance: {
        queryImprovement: 'medium',
        writeImpact: 'low',
        storageOverhead: 'low'
      }
    };
  }
  
  /** 获取表统计信息 */
  private getTableStats(tableName: string): { rowCount: number } {
    const result = this.database.prepare(`SELECT COUNT(*) as count FROM ${tableName}`).get() as any;
    return { rowCount: result.count || 0 };
  }
  
  /** 计算索引选择性 */
  private calculateIndexSelectivity(indexInfo: IndexDefinition): { uniqueValues: number; ratio: number } {
    try {
      const totalRows = this.getTableStats(indexInfo.tableName).rowCount;
      if (totalRows === 0) {
        return { uniqueValues: 0, ratio: 0 };
      }
      
      // 计算第一列的唯一值数量
      const firstColumn = indexInfo.columns[0];
      const result = this.database.prepare(`
        SELECT COUNT(DISTINCT ${firstColumn}) as unique_count 
        FROM ${indexInfo.tableName}
      `).get() as any;
      
      const uniqueValues = result.unique_count || 0;
      const ratio = uniqueValues / totalRows;
      
      return { uniqueValues, ratio };
      
    } catch (error) {
      console.warn(`Failed to calculate selectivity for index ${indexInfo.name}:`, error);
      return { uniqueValues: 0, ratio: 0 };
    }
  }
  
  /** 获取索引大小 */
  private getIndexSize(indexName: string): number {
    try {
      // SQLite 没有直接的索引大小查询，使用 PRAGMA page_count 的近似值
      // 这是一个简化实现，实际项目中可能需要更精确的方法
      const result = this.database.prepare(`
        SELECT COUNT(*) as pages 
        FROM sqlite_master 
        WHERE type='index' AND name=?
      `).get(indexName) as any;
      
      return result?.pages || 1;
      
    } catch (error) {
      console.warn(`Failed to get size for index ${indexName}:`, error);
      return 1;
    }
  }
  
  /** 分析索引使用情况 */
  private analyzeIndexUsage(indexInfo: IndexDefinition): IndexAnalysis['usage'] {
    // 简化的使用情况分析
    // 实际项目中可能需要查询计划分析或使用统计
    
    const selectivity = this.calculateIndexSelectivity(indexInfo);
    
    let recommendation: 'keep' | 'optimize' | 'remove' = 'keep';
    let reason = 'Index appears to be useful';
    let isUsed = true;
    
    // 基于选择性的简单启发式规则
    if (selectivity.ratio < 0.01) {
      recommendation = 'remove';
      reason = 'Very low selectivity (< 1%), consider removing';
      isUsed = false;
    } else if (selectivity.ratio < 0.1) {
      recommendation = 'optimize';
      reason = 'Low selectivity (< 10%), consider optimizing or adding WHERE clause';
    }
    
    // 如果是复合索引但只有一列，可能需要优化
    if (indexInfo.columns.length === 1 && indexInfo.columns[0].includes(',')) {
      recommendation = 'optimize';
      reason = 'Single column index might benefit from being composite';
    }
    
    return {
      isUsed,
      recommendation,
      reason
    };
  }
  
  /** 获取所有索引 */
  private getAllIndexes(): { name: string; tableName: string }[] {
    return this.database.prepare(`
      SELECT name, tbl_name as tableName 
      FROM sqlite_master 
      WHERE type='index' AND sql IS NOT NULL
      ORDER BY name
    `).all() as any[];
  }
  
  /** 记录索引操作 */
  private recordIndexOperation(operation: 'create' | 'drop', definition: IndexDefinition): void {
    // 这里可以记录到操作日志或审计表
    console.log(`Index operation logged: ${operation} ${definition.name}`);
  }
}
```

#### 4.4.2 完整性约束管理

```typescript
// ============================================================================
// 数据完整性约束管理器
// ============================================================================

interface ConstraintDefinition {
  /** 约束名称 */
  name: string;
  
  /** 约束类型 */
  type: 'primary_key' | 'foreign_key' | 'unique' | 'check' | 'not_null';
  
  /** 表名 */
  tableName: string;
  
  /** 涉及的列 */
  columns: string[];
  
  /** 约束的 SQL 定义 */
  definition: string;
  
  /** 外键约束特定配置 */
  foreignKey?: {
    referencedTable: string;
    referencedColumns: string[];
    onDelete: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';
    onUpdate: 'CASCADE' | 'SET NULL' | 'RESTRICT' | 'NO ACTION';
  };
  
  /** 检查约束特定配置 */
  check?: {
    condition: string;
  };
}

interface ConstraintViolation {
  /** 违反约束的类型 */
  constraintType: string;
  
  /** 违反约束的表 */
  tableName: string;
  
  /** 违反约束的列 */
  columns: string[];
  
  /** 违反的行标识 */
  rowId?: any;
  
  /** 错误描述 */
  description: string;
  
  /** 建议的修复方案 */
  suggestedFix: string;
}

class ConstraintManager {
  private database: Database.Database;
  
  constructor(database: Database.Database) {
    this.database = database;
  }
  
  /** 启用外键约束 */
  enableForeignKeys(): void {
    this.database.pragma('foreign_keys = ON');
    console.log('Foreign key constraints enabled');
  }
  
  /** 禁用外键约束 */
  disableForeignKeys(): void {
    this.database.pragma('foreign_keys = OFF');
    console.log('Foreign key constraints disabled');
  }
  
  /** 检查外键约束状态 */
  getForeignKeyStatus(): boolean {
    const result = this.database.pragma('foreign_keys', { simple: true });
    return Boolean(result);
  }
  
  /** 验证所有外键约束 */
  validateForeignKeys(): ConstraintViolation[] {
    const violations: ConstraintViolation[] = [];
    
    try {
      // 使用 PRAGMA foreign_key_check 检查所有外键违规
      const fkViolations = this.database.pragma('foreign_key_check') as any[];
      
      for (const violation of fkViolations) {
        violations.push({
          constraintType: 'foreign_key',
          tableName: violation.table,
          columns: [violation.fkid], // SQLite 返回的外键ID
          rowId: violation.rowid,
          description: `Foreign key violation in table ${violation.table}, row ${violation.rowid}`,
          suggestedFix: `Update or delete row ${violation.rowid} in table ${violation.table}`
        });
      }
      
    } catch (error) {
      console.error('Failed to validate foreign keys:', error);
    }
    
    return violations;
  }
  
  /** 验证指定表的外键约束 */
  validateTableForeignKeys(tableName: string): ConstraintViolation[] {
    const violations: ConstraintViolation[] = [];
    
    try {
      const fkViolations = this.database.pragma(`foreign_key_check(${tableName})`) as any[];
      
      for (const violation of fkViolations) {
        violations.push({
          constraintType: 'foreign_key',
          tableName: violation.table,
          columns: [violation.fkid],
          rowId: violation.rowid,
          description: `Foreign key violation in table ${violation.table}, row ${violation.rowid}`,
          suggestedFix: `Update or delete row ${violation.rowid} in table ${violation.table}`
        });
      }
      
    } catch (error) {
      console.error(`Failed to validate foreign keys for table ${tableName}:`, error);
    }
    
    return violations;
  }
  
  /** 检查数据库完整性 */
  checkDatabaseIntegrity(): {
    passed: boolean;
    results: string[];
    violations: ConstraintViolation[];
  } {
    const results: string[] = [];
    const violations: ConstraintViolation[] = [];
    
    try {
      // 运行 PRAGMA integrity_check
      const integrityResults = this.database.pragma('integrity_check') as string[];
      results.push(...integrityResults);
      
      // 检查外键约束
      const fkViolations = this.validateForeignKeys();
      violations.push(...fkViolations);
      
      // 检查是否有任何问题
      const passed = integrityResults.length === 1 && 
                    integrityResults[0] === 'ok' && 
                    violations.length === 0;
      
      return { passed, results, violations };
      
    } catch (error) {
      console.error('Failed to check database integrity:', error);
      return {
        passed: false,
        results: [`Error during integrity check: ${error.message}`],
        violations
      };
    }
  }
  
  /** 获取表的约束信息 */
  getTableConstraints(tableName: string): ConstraintDefinition[] {
    const constraints: ConstraintDefinition[] = [];
    
    try {
      // 获取表结构信息
      const tableInfo = this.database.pragma(`table_info(${tableName})`) as any[];
      
      // 处理列级约束
      for (const column of tableInfo) {
        // 主键约束
        if (column.pk) {
          constraints.push({
            name: `pk_${tableName}_${column.name}`,
            type: 'primary_key',
            tableName,
            columns: [column.name],
            definition: `PRIMARY KEY (${column.name})`
          });
        }
        
        // 非空约束
        if (column.notnull) {
          constraints.push({
            name: `nn_${tableName}_${column.name}`,
            type: 'not_null',
            tableName,
            columns: [column.name],
            definition: `${column.name} NOT NULL`
          });
        }
        
        // 默认值约束（如果有）
        if (column.dflt_value !== null) {
          // 可以在这里添加默认值约束处理
        }
      }
      
      // 获取外键约束
      const foreignKeys = this.database.pragma(`foreign_key_list(${tableName})`) as any[];
      
      for (const fk of foreignKeys) {
        constraints.push({
          name: `fk_${tableName}_${fk.from}_${fk.table}_${fk.to}`,
          type: 'foreign_key',
          tableName,
          columns: [fk.from],
          definition: `FOREIGN KEY (${fk.from}) REFERENCES ${fk.table}(${fk.to})`,
          foreignKey: {
            referencedTable: fk.table,
            referencedColumns: [fk.to],
            onDelete: fk.on_delete,
            onUpdate: fk.on_update
          }
        });
      }
      
      // 获取索引约束（唯一索引）
      const indexes = this.database.pragma(`index_list(${tableName})`) as any[];
      
      for (const index of indexes) {
        if (index.unique) {
          const indexInfo = this.database.pragma(`index_info(${index.name})`) as any[];
          const columns = indexInfo.map(col => col.name);
          
          constraints.push({
            name: index.name,
            type: 'unique',
            tableName,
            columns,
            definition: `UNIQUE (${columns.join(', ')})`
          });
        }
      }
      
    } catch (error) {
      console.error(`Failed to get constraints for table ${tableName}:`, error);
    }
    
    return constraints;
  }
  
  /** 修复外键约束违规 */
  async fixForeignKeyViolations(
    violations: ConstraintViolation[],
    strategy: 'delete_orphans' | 'update_references' | 'disable_constraints'
  ): Promise<{
    fixed: number;
    failed: number;
    errors: string[];
  }> {
    let fixed = 0;
    let failed = 0;
    const errors: string[] = [];
    
    try {
      if (strategy === 'disable_constraints') {
        this.disableForeignKeys();
        console.log('Foreign key constraints disabled to bypass violations');
        return { fixed: violations.length, failed: 0, errors: [] };
      }
      
      const fixTransaction = this.database.transaction(() => {
        for (const violation of violations) {
          try {
            if (strategy === 'delete_orphans') {
              // 删除孤立记录
              const deleteStmt = this.database.prepare(`
                DELETE FROM ${violation.tableName} WHERE rowid = ?
              `);
              deleteStmt.run(violation.rowId);
              fixed++;
              
            } else if (strategy === 'update_references') {
              // 更新引用（这里需要更具体的逻辑）
              // 这是一个示例，实际实现需要根据具体的业务逻辑
              console.warn(`Manual intervention required for violation in ${violation.tableName}`);
              failed++;
            }
            
          } catch (error) {
            errors.push(`Failed to fix violation in ${violation.tableName}: ${error.message}`);
            failed++;
          }
        }
      });
      
      fixTransaction();
      
    } catch (error) {
      errors.push(`Transaction failed: ${error.message}`);
      failed = violations.length;
    }
    
    return { fixed, failed, errors };
  }
  
  /** 创建约束验证报告 */
  generateConstraintReport(): {
    summary: {
      totalTables: number;
      totalConstraints: number;
      violationCount: number;
    };
    tableDetails: Array<{
      tableName: string;
      constraints: ConstraintDefinition[];
      violations: ConstraintViolation[];
    }>;
    recommendations: string[];
  } {
    const allTables = this.getAllTables();
    const tableDetails: any[] = [];
    let totalConstraints = 0;
    let violationCount = 0;
    const recommendations: string[] = [];
    
    for (const tableName of allTables) {
      const constraints = this.getTableConstraints(tableName);
      const violations = this.validateTableForeignKeys(tableName);
      
      tableDetails.push({
        tableName,
        constraints,
        violations
      });
      
      totalConstraints += constraints.length;
      violationCount += violations.length;
    }
    
    // 生成建议
    if (violationCount > 0) {
      recommendations.push(`Found ${violationCount} constraint violations that need attention`);
    }
    
    if (!this.getForeignKeyStatus()) {
      recommendations.push('Consider enabling foreign key constraints for better data integrity');
    }
    
    const tablesWithoutFK = tableDetails.filter(t => 
      !t.constraints.some(c => c.type === 'foreign_key')
    );
    
    if (tablesWithoutFK.length > 0) {
      recommendations.push(`${tablesWithoutFK.length} tables have no foreign key constraints`);
    }
    
    return {
      summary: {
        totalTables: allTables.length,
        totalConstraints,
        violationCount
      },
      tableDetails,
      recommendations
    };
  }
  
  /** 获取所有表名 */
  private getAllTables(): string[] {
    const result = this.database.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name NOT LIKE 'sqlite_%'
      ORDER BY name
    `).all() as any[];
    
    return result.map(row => row.name);
  }
}
```

---

### 4.5 迁移系统集成与使用示例

#### 4.5.1 完整的迁移系统初始化

```typescript
// ============================================================================
// 迁移系统统一初始化器
// ============================================================================

class DatabaseMigrationSystem {
  private database: Database.Database;
  private versionManager: DatabaseVersionManager;
  private migrationRegistry: MigrationRegistry;
  private migrationExecutor: MigrationExecutor;
  private rollbackManager: RollbackManager;
  private indexManager: IndexManager;
  private constraintManager: ConstraintManager;
  
  constructor(database: Database.Database) {
    this.database = database;
    this.versionManager = DatabaseVersionManager.getInstance(database);
    this.migrationRegistry = new MigrationRegistry(database);
    this.migrationExecutor = new MigrationExecutor(database, this.migrationRegistry, this.versionManager);
    this.rollbackManager = new RollbackManager(database, this.migrationRegistry, this.versionManager);
    this.indexManager = new IndexManager(database);
    this.constraintManager = new ConstraintManager(database);
    
    this.initialize();
  }
  
  /** 初始化迁移系统 */
  private initialize(): void {
    // 启用外键约束
    this.constraintManager.enableForeignKeys();
    
    // 注册所有内置迁移脚本
    const builtInMigrations = BuiltInMigrations.getAllMigrations();
    this.migrationRegistry.registerAll(builtInMigrations);
    
    console.log('Database migration system initialized');
  }
  
  /** 执行数据库迁移到最新版本 */
  async migrateToLatest(): Promise<MigrationExecutionResult> {
    const targetVersion = DatabaseVersionManager.TARGET_VERSION;
    
    console.log(`Migrating database to latest version: ${targetVersion}`);
    
    return this.migrationExecutor.migrate(targetVersion, {
      useTransaction: true,
      timeout: 60000,
      autoRollback: true,
      validateResult: true,
      backup: { enabled: true }
    });
  }
  
  /** 迁移到指定版本 */
  async migrateToVersion(version: number): Promise<MigrationExecutionResult> {
    return this.migrationExecutor.migrate(version, {
      useTransaction: true,
      timeout: 60000,
      autoRollback: true,
      validateResult: true,
      backup: { enabled: true }
    });
  }
  
  /** 回滚到指定版本 */
  async rollbackToVersion(version: number): Promise<MigrationExecutionResult> {
    return this.rollbackManager.executeRollback({
      targetVersion: version,
      createBackup: true,
      strategy: 'safe',
      dataProtection: {
        preserveUserData: true,
        protectedTables: ['user_preferences', 'characters', 'guilds']
      }
    });
  }
  
  /** 检查数据库状态 */
  checkDatabaseHealth(): {
    version: DatabaseVersion;
    compatibility: ReturnType<DatabaseVersionManager['checkCompatibility']>;
    integrity: ReturnType<ConstraintManager['checkDatabaseIntegrity']>;
    indexReport: ReturnType<IndexManager['generateIndexReport']>;
    constraintReport: ReturnType<ConstraintManager['generateConstraintReport']>;
  } {
    const version = this.versionManager.getVersion();
    const compatibility = this.versionManager.checkCompatibility();
    const integrity = this.constraintManager.checkDatabaseIntegrity();
    const indexReport = this.indexManager.generateIndexReport();
    const constraintReport = this.constraintManager.generateConstraintReport();
    
    return {
      version,
      compatibility,
      integrity,
      indexReport,
      constraintReport
    };
  }
  
  /** 生成迁移状态报告 */
  generateMigrationReport(): {
    currentStatus: {
      currentVersion: number;
      targetVersion: number;
      migrationNeeded: boolean;
    };
    history: MigrationRecord[];
    pendingMigrations: Migration[];
    recommendations: string[];
  } {
    const version = this.versionManager.getVersion();
    const migrationNeeded = version.current !== version.target;
    const history = this.migrationRegistry.getAppliedMigrations();
    
    let pendingMigrations: Migration[] = [];
    if (migrationNeeded) {
      pendingMigrations = this.migrationRegistry.getMigrationsInRange(
        version.current,
        version.target
      );
    }
    
    const recommendations: string[] = [];
    
    if (migrationNeeded) {
      recommendations.push(`Database migration needed: ${version.current} → ${version.target}`);
    }
    
    const health = this.checkDatabaseHealth();
    if (!health.integrity.passed) {
      recommendations.push('Database integrity issues detected');
    }
    
    if (health.indexReport.summary.unusedIndexes > 0) {
      recommendations.push(`${health.indexReport.summary.unusedIndexes} unused indexes found`);
    }
    
    return {
      currentStatus: {
        currentVersion: version.current,
        targetVersion: version.target,
        migrationNeeded
      },
      history,
      pendingMigrations,
      recommendations
    };
  }
}
```

#### 4.5.2 使用示例

```typescript
// ============================================================================
// 《公会经理》游戏中的使用示例
// ============================================================================

async function initializeGameDatabase(): Promise<void> {
  try {
    // 创建数据库连接
    const databasePath = ElectronDataPathManager.getInstance().getDatabasePath();
    const database = new Database(databasePath, {
      verbose: process.env.NODE_ENV === 'development' ? console.log : undefined
    });
    
    // 初始化迁移系统
    const migrationSystem = new DatabaseMigrationSystem(database);
    
    // 检查数据库健康状态
    const health = migrationSystem.checkDatabaseHealth();
    
    console.log('Database Health Check:');
    console.log(`Current Version: ${health.version.current}`);
    console.log(`Target Version: ${health.version.target}`);
    console.log(`Compatibility: ${health.compatibility.action}`);
    console.log(`Integrity: ${health.integrity.passed ? 'OK' : 'ISSUES FOUND'}`);
    
    // 如果需要迁移，执行迁移
    if (health.compatibility.action === 'upgrade') {
      console.log('Starting database migration...');
      
      const migrationResult = await migrationSystem.migrateToLatest();
      
      if (migrationResult.success) {
        console.log(`Migration completed successfully in ${migrationResult.executionTime}ms`);
        console.log(`Applied ${migrationResult.affectedMigrations.length} migrations`);
      } else {
        console.error('Migration failed:', migrationResult.errorMessage);
        throw new Error(`Database migration failed: ${migrationResult.errorMessage}`);
      }
    }
    
    // 验证最终状态
    const finalHealth = migrationSystem.checkDatabaseHealth();
    if (!finalHealth.integrity.passed) {
      console.warn('Database integrity issues detected after migration');
      console.warn('Issues:', finalHealth.integrity.violations);
    }
    
    console.log('Database initialization completed successfully');
    
  } catch (error) {
    console.error('Failed to initialize database:', error);
    throw error;
  }
}

// 在应用启动时调用
async function startApplication(): Promise<void> {
  try {
    // 初始化数据库
    await initializeGameDatabase();
    
    // 初始化存储层
    await ApplicationStorageInitializer.initialize();
    
    console.log('Application started successfully');
    
  } catch (error) {
    console.error('Failed to start application:', error);
    process.exit(1);
  }
}

// 导出迁移系统供开发和运维使用
export {
  DatabaseMigrationSystem,
  Migration001_InitialSchema,
  Migration002_AddBattleSystem,
  Migration003_AddUserPreferences,
  Migration004_RefactorCharacterAttributes,
  BuiltInMigrations
};
```

---

### 4.6 总结

通过本章节的Schema & 迁移系统设计，我们为《公会经理》游戏建立了一套完整、稳健的数据库版本管理方案：

#### 4.6.1 核心特性

1. **版本化管理**：基于 `PRAGMA user_version` 的版本控制
2. **事务性迁移**：确保数据一致性的事务性操作
3. **安全回滚**：支持数据保护的回滚策略
4. **索引优化**：自动化索引分析和优化建议
5. **完整性保障**：全面的约束验证和修复机制

#### 4.6.2 操作优势

- **零停机迁移**：WAL模式支持在线迁移
- **自动备份**：迁移前自动创建安全备份
- **风险评估**：智能分析迁移风险等级
- **数据保护**：用户数据的专门保护机制
- **可观测性**：详细的迁移历史和性能分析

#### 4.6.3 开发体验

- **类型安全**：TypeScript强类型迁移脚本
- **自动发现**：支持迁移脚本的自动加载
- **干跑模式**：安全的迁移预演功能
- **详细报告**：全面的数据库健康状态报告

这套迁移系统确保了游戏数据库在整个生命周期中的稳定性和可靠性，为游戏的长期运营提供了坚实的技术基础。

---

## 5 数据模型与存储端口-就地验收

> **核心策略**: 采用Playwright + Electron的端到端测试框架，在真实应用环境中验证数据模型完整性、存储端口契约合规性和数据库迁移正确性，确保生产环境数据安全。

### 5.1 就地验收测试架构概述

#### 5.1.1 测试层次设计

**就地验收测试**不同于传统的单元测试或集成测试，它在**真实的Electron应用环境**中运行，能够：

- **验证完整的技术栈**：从React UI → EventBus → Repository → SQLite的完整数据流
- **检测环境差异**：发现开发环境与生产环境的配置差异
- **确保数据安全**：验证数据库迁移和备份机制的正确性
- **测试跨进程通信**：Electron主进程与渲染进程的数据交互

```typescript
// ============================================================================
// 就地验收测试架构定义
// ============================================================================

/** 测试执行环境配置 */
interface InPlaceTestEnvironment {
  readonly testType: 'smoke' | 'contract' | 'migration' | 'performance';
  readonly electronAppPath: string;
  readonly userDataPath: string;
  readonly databasePath: string;
  readonly enableDevTools: boolean;
  readonly headless: boolean;
}

/** 验收测试结果 */
interface AcceptanceTestResult {
  readonly testSuite: string;
  readonly passed: boolean;
  readonly duration: number;
  readonly assertions: TestAssertion[];
  readonly artifacts: TestArtifact[];
  readonly coverage: TestCoverage;
}

/** 测试断言结果 */
interface TestAssertion {
  readonly description: string;
  readonly passed: boolean;
  readonly actual: any;
  readonly expected: any;
  readonly stackTrace?: string;
}

/** 测试产物 */
interface TestArtifact {
  readonly type: 'screenshot' | 'database_dump' | 'log_file' | 'performance_report';
  readonly path: string;
  readonly size: number;
  readonly timestamp: Date;
}

/** 测试覆盖率报告 */
interface TestCoverage {
  readonly repositoryContracts: number;  // Repository契约覆盖率
  readonly databaseTables: number;       // 数据库表覆盖率
  readonly migrationScripts: number;     // 迁移脚本覆盖率
  readonly dataModels: number;          // 数据模型覆盖率
}
```

#### 5.1.2 Playwright + Electron测试基础设施

```typescript
// ============================================================================
// Playwright + Electron测试基础设施
// ============================================================================

import { _electron as electron } from 'playwright';
import type { ElectronApplication, Page } from 'playwright';
import Database from 'better-sqlite3';
import path from 'path';
import fs from 'fs/promises';

/** Electron应用测试控制器 */
class ElectronTestController {
  private app: ElectronApplication | null = null;
  private mainWindow: Page | null = null;
  private testEnvironment: InPlaceTestEnvironment;
  
  constructor(environment: InPlaceTestEnvironment) {
    this.testEnvironment = environment;
  }
  
  /** 启动Electron应用 */
  async launchApp(): Promise<void> {
    try {
      console.log('🚀 启动Electron应用进行就地验收测试...');
      
      // 清理测试环境
      await this.cleanupTestEnvironment();
      
      // 启动Electron应用
      this.app = await electron.launch({
        args: [this.testEnvironment.electronAppPath],
        env: {
          ...process.env,
          NODE_ENV: 'test',
          ELECTRON_USER_DATA: this.testEnvironment.userDataPath,
          ELECTRON_ENABLE_LOGGING: 'true'
        },
        recordVideo: {
          dir: path.join(this.testEnvironment.userDataPath, 'test-videos'),
          size: { width: 1280, height: 720 }
        }
      });
      
      // 等待主窗口创建
      this.mainWindow = await this.app.firstWindow();
      
      // 等待应用初始化完成
      await this.waitForAppInitialization();
      
      console.log('✅ Electron应用启动成功');
      
    } catch (error) {
      console.error('❌ Electron应用启动失败:', error);
      throw error;
    }
  }
  
  /** 等待应用初始化完成 */
  private async waitForAppInitialization(): Promise<void> {
    if (!this.mainWindow) throw new Error('主窗口未创建');
    
    // 等待数据库初始化完成的信号
    await this.mainWindow.waitForFunction(
      () => (window as any).electronAPI?.isDatabaseReady?.() === true,
      undefined,
      { timeout: 10000 }
    );
    
    // 等待React应用渲染完成
    await this.mainWindow.waitForSelector('[data-testid="app-ready"]', {
      timeout: 15000
    });
    
    console.log('✅ 应用初始化完成');
  }
  
  /** 清理测试环境 */
  private async cleanupTestEnvironment(): Promise<void> {
    try {
      // 删除测试用户数据目录
      await fs.rm(this.testEnvironment.userDataPath, { 
        recursive: true, 
        force: true 
      });
      
      // 重新创建目录
      await fs.mkdir(this.testEnvironment.userDataPath, { 
        recursive: true 
      });
      
    } catch (error) {
      console.warn('清理测试环境时发生错误:', error);
    }
  }
  
  /** 关闭应用 */
  async closeApp(): Promise<void> {
    if (this.app) {
      await this.app.close();
      this.app = null;
      this.mainWindow = null;
    }
  }
  
  /** 获取主窗口页面对象 */
  getMainWindow(): Page {
    if (!this.mainWindow) {
      throw new Error('主窗口未初始化');
    }
    return this.mainWindow;
  }
  
  /** 获取Electron应用对象 */
  getApp(): ElectronApplication {
    if (!this.app) {
      throw new Error('Electron应用未启动');
    }
    return this.app;
  }
}
```

### 5.2 数据库迁移验收测试

#### 5.2.1 PRAGMA user_version验证

```typescript
// ============================================================================
// 数据库迁移验收测试框架
// ============================================================================

/** 数据库迁移验证器 */
class DatabaseMigrationValidator {
  private electronController: ElectronTestController;
  private databasePath: string;
  
  constructor(electronController: ElectronTestController) {
    this.electronController = electronController;
    this.databasePath = path.join(
      electronController.testEnvironment.userDataPath,
      'game.db'
    );
  }
  
  /** 执行迁移验收测试 */
  async validateDatabaseMigrations(): Promise<AcceptanceTestResult> {
    console.log('🗄️ 开始数据库迁移验收测试...');
    
    const startTime = Date.now();
    const assertions: TestAssertion[] = [];
    const artifacts: TestArtifact[] = [];
    
    try {
      // 1. 验证数据库文件创建
      await this.validateDatabaseFileCreation(assertions);
      
      // 2. 验证用户数据目录路径
      await this.validateUserDataPath(assertions);
      
      // 3. 验证PRAGMA user_version
      await this.validateUserVersion(assertions);
      
      // 4. 验证表结构创建
      await this.validateTableSchemas(assertions);
      
      // 5. 验证索引创建
      await this.validateIndexes(assertions);
      
      // 6. 创建数据库转储文件
      await this.createDatabaseDump(artifacts);
      
    } catch (error) {
      assertions.push({
        description: '数据库迁移验证过程中不应该抛出异常',
        passed: false,
        actual: error.message,
        expected: '无异常',
        stackTrace: error.stack
      });
    }
    
    const duration = Date.now() - startTime;
    const passed = assertions.every(a => a.passed);
    
    console.log(`✅ 数据库迁移验收测试完成 (${duration}ms, ${assertions.filter(a => a.passed).length}/${assertions.length} passed)`);
    
    return {
      testSuite: 'Database-Migration-Validation',
      passed,
      duration,
      assertions,
      artifacts,
      coverage: { repositoryContracts: 0.7, databaseTables: 1.0, migrationScripts: 1.0, dataModels: 0.8 }
    };
  }
  
  /** 验证PRAGMA user_version */
  private async validateUserVersion(assertions: TestAssertion[]): Promise<void> {
    console.log('  验证PRAGMA user_version...');
    
    try {
      const db = new Database(this.databasePath, { readonly: true });
      
      // 获取数据库版本
      const versionResult = db.prepare('PRAGMA user_version').get() as { user_version: number };
      const currentVersion = versionResult.user_version;
      
      // 预期的版本号（应该从迁移配置中获取）
      const expectedVersion = 1; // 这应该是从配置中读取的最新迁移版本
      
      assertions.push({
        description: '数据库版本应该匹配最新迁移版本',
        passed: currentVersion === expectedVersion,
        actual: currentVersion,
        expected: expectedVersion
      });
      
      assertions.push({
        description: '数据库版本应该大于0',
        passed: currentVersion > 0,
        actual: currentVersion,
        expected: '>0'
      });
      
      db.close();
      
    } catch (error) {
      assertions.push({
        description: '验证数据库版本时不应该抛出异常',
        passed: false,
        actual: error.message,
        expected: '无异常'
      });
    }
  }
  
  /** 验证用户数据目录路径 */
  private async validateUserDataPath(assertions: TestAssertion[]): Promise<void> {
    console.log('  验证用户数据目录路径...');
    
    try {
      const window = this.electronController.getMainWindow();
      
      // 通过Electron API获取用户数据路径
      const actualUserDataPath = await window.evaluate(async () => {
        return await (window as any).electronAPI.getUserDataPath();
      });
      
      assertions.push({
        description: '用户数据路径应该匹配预期路径',
        passed: actualUserDataPath === this.electronController.testEnvironment.userDataPath,
        actual: actualUserDataPath,
        expected: this.electronController.testEnvironment.userDataPath
      });
      
      // 验证数据库路径是否在用户数据目录下
      const expectedDbPath = path.join(actualUserDataPath, 'game.db');
      assertions.push({
        description: '数据库应该位于用户数据目录下',
        passed: this.databasePath === expectedDbPath,
        actual: this.databasePath,
        expected: expectedDbPath
      });
      
    } catch (error) {
      assertions.push({
        description: '验证用户数据路径时不应该抛出异常',
        passed: false,
        actual: error.message,
        expected: '无异常'
      });
    }
  }
}
```

### 5.3 Repository契约验收测试

#### 5.3.1 真实环境契约验证

```typescript
// ============================================================================
// Repository契约验收测试框架
// ============================================================================

/** Repository契约验收测试基类 */
abstract class RepositoryContractAcceptanceTest {
  protected electronController: ElectronTestController;
  protected testResults: AcceptanceTestResult[] = [];
  
  constructor(electronController: ElectronTestController) {
    this.electronController = electronController;
  }
  
  /** 执行所有契约测试 */
  async executeAllContractTests(): Promise<AcceptanceTestResult[]> {
    console.log('🧪 开始Repository契约验收测试...');
    
    try {
      // 1. 基础CRUD操作测试
      await this.testBasicCrudOperations();
      
      // 2. 查询功能测试
      await this.testQueryOperations();
      
      // 3. 事务操作测试
      await this.testTransactionOperations();
      
      // 4. 并发访问测试
      await this.testConcurrentAccess();
      
      // 5. 错误处理测试
      await this.testErrorHandling();
      
      console.log('✅ Repository契约验收测试完成');
      return this.testResults;
      
    } catch (error) {
      console.error('❌ Repository契约测试失败:', error);
      throw error;
    }
  }
  
  /** 测试基础CRUD操作 */
  private async testBasicCrudOperations(): Promise<void> {
    const startTime = Date.now();
    const assertions: TestAssertion[] = [];
    
    try {
      const window = this.electronController.getMainWindow();
      
      // 1. 测试角色创建
      console.log('  测试角色创建...');
      const createResult = await window.evaluate(async () => {
        const { characterService } = (window as any).electronAPI;
        return await characterService.createCharacter({
          name: 'TestHero',
          stats: { attack: 10, defense: 8, health: 100, magic: 5, level: 1 }
        });
      });
      
      assertions.push({
        description: '角色创建应该成功',
        passed: createResult.success === true,
        actual: createResult.success,
        expected: true
      });
      
      assertions.push({
        description: '创建的角色应该有有效ID',
        passed: typeof createResult.character?.id === 'string',
        actual: typeof createResult.character?.id,
        expected: 'string'
      });
      
      // 2. 测试角色查询
      console.log('  测试角色查询...');
      const findResult = await window.evaluate(async (characterId) => {
        const { characterService } = (window as any).electronAPI;
        return await characterService.findCharacterById(characterId);
      }, createResult.character.id);
      
      assertions.push({
        description: '应该能够找到创建的角色',
        passed: findResult.character?.id === createResult.character.id,
        actual: findResult.character?.id,
        expected: createResult.character.id
      });
      
      // 3. 测试角色更新
      console.log('  测试角色更新...');
      const updateResult = await window.evaluate(async (characterId) => {
        const { characterService } = (window as any).electronAPI;
        return await characterService.updateCharacter(characterId, {
          stats: { attack: 15, defense: 10, health: 120, magic: 8, level: 2 }
        });
      }, createResult.character.id);
      
      assertions.push({
        description: '角色更新应该成功',
        passed: updateResult.success === true,
        actual: updateResult.success,
        expected: true
      });
      
      // 4. 测试角色删除
      console.log('  测试角色删除...');
      const deleteResult = await window.evaluate(async (characterId) => {
        const { characterService } = (window as any).electronAPI;
        return await characterService.deleteCharacter(characterId);
      }, createResult.character.id);
      
      assertions.push({
        description: '角色删除应该成功',
        passed: deleteResult.success === true,
        actual: deleteResult.success,
        expected: true
      });
      
    } catch (error) {
      assertions.push({
        description: 'CRUD操作执行过程中不应该抛出异常',
        passed: false,
        actual: error.message,
        expected: '无异常',
        stackTrace: error.stack
      });
    }
    
    // 记录测试结果
    const duration = Date.now() - startTime;
    const passed = assertions.every(a => a.passed);
    
    this.testResults.push({
      testSuite: 'Repository-CRUD-Operations',
      passed,
      duration,
      assertions,
      artifacts: [],
      coverage: { repositoryContracts: 0.8, databaseTables: 0.6, migrationScripts: 0.5, dataModels: 0.7 }
    });
    
    console.log(`  ✅ CRUD操作测试完成 (${duration}ms, ${assertions.filter(a => a.passed).length}/${assertions.length} passed)`);
  }
}
```

### 5.4 数据完整性烟雾测试

#### 5.4.1 端到端数据流验证

```typescript
// ============================================================================
// 数据完整性烟雾测试框架
// ============================================================================

/** 数据完整性烟雾测试套件 */
class DataIntegritySmokeTest {
  private electronController: ElectronTestController;
  
  constructor(electronController: ElectronTestController) {
    this.electronController = electronController;
  }
  
  /** 执行数据完整性烟雾测试 */
  async executeDataIntegritySmokeTests(): Promise<AcceptanceTestResult> {
    console.log('💨 开始数据完整性烟雾测试...');
    
    const startTime = Date.now();
    const assertions: TestAssertion[] = [];
    const artifacts: TestArtifact[] = [];
    
    try {
      // 1. 测试完整的角色生命周期
      await this.testCharacterLifecycle(assertions);
      
      // 2. 测试公会管理流程
      await this.testGuildManagementFlow(assertions);
      
      // 3. 测试数据一致性
      await this.testDataConsistency(assertions);
      
      // 4. 创建测试报告
      await this.createTestReport(artifacts);
      
    } catch (error) {
      assertions.push({
        description: '数据完整性烟雾测试过程中不应该抛出异常',
        passed: false,
        actual: error.message,
        expected: '无异常',
        stackTrace: error.stack
      });
    }
    
    const duration = Date.now() - startTime;
    const passed = assertions.every(a => a.passed);
    
    console.log(`✅ 数据完整性烟雾测试完成 (${duration}ms, ${assertions.filter(a => a.passed).length}/${assertions.length} passed)`);
    
    return {
      testSuite: 'Data-Integrity-Smoke-Test',
      passed,
      duration,
      assertions,
      artifacts,
      coverage: { repositoryContracts: 1.0, databaseTables: 1.0, migrationScripts: 0.8, dataModels: 1.0 }
    };
  }
  
  /** 测试完整的角色生命周期 */
  private async testCharacterLifecycle(assertions: TestAssertion[]): Promise<void> {
    console.log('  测试角色完整生命周期...');
    
    const window = this.electronController.getMainWindow();
    
    // 创建角色
    const createResult = await window.evaluate(async () => {
      const { characterService } = (window as any).electronAPI;
      return await characterService.createCharacter({
        name: 'SmokeTestHero',
        stats: { attack: 10, defense: 8, health: 100, magic: 5, level: 1 }
      });
    });
    
    assertions.push({
      description: '角色创建应该成功',
      passed: createResult.success && createResult.character?.id,
      actual: createResult.success,
      expected: true
    });
    
    const characterId = createResult.character.id;
    
    // 角色升级
    const levelUpResult = await window.evaluate(async (id) => {
      const { characterService } = (window as any).electronAPI;
      return await characterService.levelUpCharacter(id);
    }, characterId);
    
    assertions.push({
      description: '角色升级应该成功',
      passed: levelUpResult.success,
      actual: levelUpResult.success,
      expected: true
    });
    
    // 获取升级后的角色
    const updatedCharacter = await window.evaluate(async (id) => {
      const { characterService } = (window as any).electronAPI;
      const result = await characterService.findCharacterById(id);
      return result.character;
    }, characterId);
    
    assertions.push({
      description: '角色等级应该已经提升',
      passed: updatedCharacter.level > 1,
      actual: updatedCharacter.level,
      expected: '>1'
    });
  }
}
```

### 5.5 就地验收测试运行器

#### 5.5.1 测试编排和执行

```typescript
// ============================================================================
// 就地验收测试运行器
// ============================================================================

/** 就地验收测试运行器 */
class InPlaceAcceptanceTestRunner {
  private testEnvironment: InPlaceTestEnvironment;
  private electronController: ElectronTestController;
  private testResults: AcceptanceTestResult[] = [];
  
  constructor(testEnvironment: InPlaceTestEnvironment) {
    this.testEnvironment = testEnvironment;
    this.electronController = new ElectronTestController(testEnvironment);
  }
  
  /** 执行所有就地验收测试 */
  async runAllTests(): Promise<AcceptanceTestSuite> {
    console.log('🎯 开始执行数据模型与存储端口就地验收测试...');
    console.log(`📍 测试环境: ${this.testEnvironment.testType}`);
    console.log(`📂 用户数据路径: ${this.testEnvironment.userDataPath}`);
    console.log(`🗄️ 数据库路径: ${this.testEnvironment.databasePath}`);
    
    const overallStartTime = Date.now();
    
    try {
      // 1. 启动Electron应用
      await this.electronController.launchApp();
      
      // 2. 执行数据库迁移验收测试
      console.log('\n📊 执行数据库迁移验收测试...');
      const migrationValidator = new DatabaseMigrationValidator(this.electronController);
      const migrationResult = await migrationValidator.validateDatabaseMigrations();
      this.testResults.push(migrationResult);
      
      // 3. 执行Repository契约验收测试
      console.log('\n🔗 执行Repository契约验收测试...');
      const contractTest = new RepositoryContractAcceptanceTest(this.electronController);
      const contractResults = await contractTest.executeAllContractTests();
      this.testResults.push(...contractResults);
      
      // 4. 执行数据完整性烟雾测试
      console.log('\n💨 执行数据完整性烟雾测试...');
      const smokeTest = new DataIntegritySmokeTest(this.electronController);
      const smokeResult = await smokeTest.executeDataIntegritySmokeTests();
      this.testResults.push(smokeResult);
      
      // 5. 生成综合测试报告
      const overallDuration = Date.now() - overallStartTime;
      const testSuite = await this.generateTestSuite(overallDuration);
      
      console.log('\n📋 生成最终测试报告...');
      await this.generateFinalReport(testSuite);
      
      console.log('\n✅ 所有就地验收测试执行完成！');
      return testSuite;
      
    } catch (error) {
      console.error('\n❌ 就地验收测试执行失败:', error);
      throw error;
      
    } finally {
      // 6. 清理资源
      await this.electronController.closeApp();
    }
  }
}

/** 验收测试套件结果 */
interface AcceptanceTestSuite {
  readonly suiteName: string;
  readonly environment: InPlaceTestEnvironment;
  readonly startTime: Date;
  readonly endTime: Date;
  readonly duration: number;
  readonly overallPassed: boolean;
  readonly successRate: number;
  readonly totalTests: number;
  readonly passedTests: number;
  readonly failedTests: number;
  readonly testResults: AcceptanceTestResult[];
  readonly artifacts: TestArtifact[];
  readonly coverage: TestCoverage;
}
```

### 5.6 CI/CD集成和自动化

#### 5.6.1 GitHub Actions集成

```yaml
# .github/workflows/in-place-acceptance-tests.yml
name: 数据模型与存储端口就地验收测试

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  in-place-acceptance-test:
    runs-on: windows-latest
    
    steps:
    - name: 检出代码
      uses: actions/checkout@v4
      
    - name: 设置Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: 安装依赖
      run: npm ci
      
    - name: 构建Electron应用
      run: npm run build:electron
      
    - name: 安装Playwright依赖
      run: npx playwright install --with-deps
      
    - name: 运行就地验收测试
      run: npm run test:in-place-acceptance
      env:
        CI: true
        HEADLESS: true
        
    - name: 上传测试报告
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: in-place-acceptance-test-reports
        path: |
          test-artifacts/
          logs/
        retention-days: 30
        
    - name: 上传测试视频
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: test-videos
        path: test-artifacts/*/test-videos/
        retention-days: 7
        
    - name: 评论PR测试结果
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const path = './test-artifacts/test-status.json';
          
          if (fs.existsSync(path)) {
            const status = JSON.parse(fs.readFileSync(path, 'utf8'));
            const emoji = status.passed ? '✅' : '❌';
            const result = status.passed ? '通过' : '失败';
            
            const comment = `## ${emoji} 数据模型与存储端口就地验收测试
            
            **测试结果**: ${result}
            **成功率**: ${status.successRate.toFixed(1)}%
            **执行时长**: ${(status.duration / 1000).toFixed(2)}s
            
            详细报告请查看Actions产物。`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }
```

#### 5.6.2 NPM脚本配置

```json
{
  "scripts": {
    "test:in-place-acceptance": "node scripts/run-in-place-acceptance-tests.js",
    "test:in-place-acceptance:local": "cross-env HEADLESS=false npm run test:in-place-acceptance",
    "test:in-place-acceptance:ci": "cross-env CI=true HEADLESS=true npm run test:in-place-acceptance"
  },
  "devDependencies": {
    "playwright": "^1.40.0",
    "@playwright/test": "^1.40.0",
    "better-sqlite3": "^9.0.0",
    "cross-env": "^7.0.3"
  }
}
```

### 5.7 测试最佳实践和指导原则

#### 5.7.1 测试设计原则

**1. 测试隔离性**
- 每个测试用例应该独立运行，不依赖其他测试的状态
- 使用独立的测试数据库和用户数据目录
- 测试结束后完全清理测试环境

**2. 真实环境模拟**
- 使用与生产环境相同的Electron版本和配置
- 测试真实的数据库迁移脚本和表结构
- 验证实际的文件路径和权限设置

**3. 全面的错误处理**
- 测试正常流程和异常情况
- 验证错误信息的准确性和有用性
- 确保异常不会导致数据损坏

**4. 性能意识**
- 监控测试执行时间
- 识别性能瓶颈和内存泄漏
- 设置合理的超时时间

#### 5.7.2 测试维护指南

**1. 定期更新测试**
- 当数据模型变更时，同步更新验收测试
- 定期检查测试覆盖率，补充缺失的测试场景
- 移除过时的测试案例

**2. 测试文档维护**
- 记录每个测试套件的目的和覆盖范围
- 维护测试失败的常见原因和解决方案
- 提供新开发者的测试运行指南

**3. 持续改进**
- 分析测试失败模式，改进测试稳定性
- 收集开发团队反馈，优化测试流程
- 监控测试执行效率，优化运行时间

### 5.8 总结

通过本章的数据模型与存储端口就地验收测试设计，我们为《公会经理》游戏构建了一套**完整、可靠、自动化**的数据验收体系。

#### 5.8.1 核心优势

1. **真实环境验证**：在实际Electron应用环境中测试，确保与生产环境一致性
2. **全栈覆盖**：从UI层到数据库层的完整数据流验证
3. **自动化集成**：与CI/CD流水线无缝集成，实现自动化验收
4. **详细报告**：提供全面的测试报告和失败诊断信息
5. **持续监控**：通过定期运行确保数据模型的长期稳定性

#### 5.8.2 实施建议

1. **渐进式部署**：先从关键数据模型开始，逐步扩展测试覆盖范围
2. **团队培训**：确保所有开发者了解就地验收测试的重要性和运行方法
3. **质量门禁**：将验收测试作为代码合并的必要条件
4. **性能监控**：持续关注测试执行性能，优化测试效率

#### 5.8.3 扩展方向

1. **多平台支持**：扩展到macOS和Linux平台的验收测试
2. **性能基准**：建立数据操作的性能基准线
3. **安全测试**：集成数据安全和权限验证测试
4. **负载测试**：在高并发场景下验证数据一致性

这套就地验收测试框架为项目提供了**企业级的数据质量保障**，确保数据模型和存储端口在各种场景下都能可靠运行，为游戏的长期稳定运营奠定了坚实基础。

---