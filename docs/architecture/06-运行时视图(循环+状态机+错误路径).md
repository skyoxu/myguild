# 06 è¿è¡Œæ—¶è§†å›¾ï¼ˆä¸»/æ¸²æŸ“/æ¸¸æˆå¾ªç¯ã€çŠ¶æ€æœºã€é”™è¯¯è·¯å¾„ï¼‰
> æŠ½è±¡å‡º **GameLoop** ä¸ **AppState**ï¼Œå°†é”™è¯¯è·¯å¾„ä¸é™çº§ç­–ç•¥å›ºåŒ–ã€‚

## 6.1 è¿›ç¨‹/çº¿ç¨‹æ‹“æ‰‘æ¶æ„

> **è®¾è®¡å“²å­¦**ï¼šé€šè¿‡"å…³æ³¨ç‚¹åˆ†ç¦»"å®ç°é«˜æ€§èƒ½ã€é«˜å“åº”çš„æ¡Œé¢æ¸¸æˆåº”ç”¨ã€‚è¿›ç¨‹åˆ†ç¦»ç¡®ä¿OSçº§ä»»åŠ¡ä¸åº”ç”¨æ¸²æŸ“åˆ†ç¦»ï¼›UIä¸æ¸¸æˆé€»è¾‘è§£è€¦ï¼›è®¡ç®—å¯†é›†å‹AIä»»åŠ¡ç‹¬ç«‹è¿è¡Œï¼Œé˜²æ­¢ä¸»çº¿ç¨‹å¡é¡¿ã€‚

### 6.1.1 æ¶æ„æ‹“æ‰‘æ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Electron ä¸»è¿›ç¨‹ (Main Process) - Node.js ç¯å¢ƒ                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ çª—å£ç®¡ç† (BrowserWindow)           â€¢ åº”ç”¨ç”Ÿå‘½å‘¨æœŸ (app events)                â”‚
â”‚ â€¢ ç³»ç»ŸåŸç”ŸAPI (æ–‡ä»¶ã€èœå•ã€å¯¹è¯æ¡†)    â€¢ IPCé€šä¿¡ä¸­å¿ƒæ¢çº½                         â”‚
â”‚ â€¢ å®‰å…¨ç­–ç•¥æ‰§è¡Œ                       â€¢ å…¨å±€çŠ¶æ€ç®¡ç† (è®¾ç½®ã€å­˜æ¡£)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â–²                                       â”‚ IPC (ipcMain â†” ipcRenderer)
      â”‚ (é€šè¿‡ preload.js å®‰å…¨æš´éœ²API)           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Electron æ¸²æŸ“è¿›ç¨‹ (Renderer Process) - æµè§ˆå™¨ç¯å¢ƒ                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      EventBus      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ React 19 (UIå±‚)     â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ Phaser 3 (æ¸¸æˆå¼•æ“)              â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ â€¢ UIç»„ä»¶ (HUD, èœå•) â”‚                    â”‚ â€¢ æ¸¸æˆåœºæ™¯ç®¡ç† (Scene)           â”‚ â”‚
â”‚ â”‚ â€¢ ç”¨æˆ·è¾“å…¥äº‹ä»¶å¤„ç†  â”‚                    â”‚ â€¢ 60FPSæ¸²æŸ“å¾ªç¯                  â”‚ â”‚
â”‚ â”‚ â€¢ çŠ¶æ€ç®¡ç† (Store)  â”‚                    â”‚ â€¢ WebGLæ¸²æŸ“ç®¡é“                  â”‚ â”‚
â”‚ â”‚ â€¢ ç”Ÿå‘½å‘¨æœŸç®¡ç†      â”‚                    â”‚ â€¢ ç‰©ç†å¼•æ“ã€åŠ¨ç”»ã€æ¸¸æˆé€»è¾‘       â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                    â”‚                            â”‚
â”‚                                                    â”‚ postMessage / onmessage    â”‚
â”‚                                                    â–¼                            â”‚
â”‚                                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚                                            â”‚ Web Worker (AIè®¡ç®—çº¿ç¨‹)          â”‚ â”‚
â”‚                                            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚                                            â”‚ â€¢ NPCå†³ç­–è®¡ç®— (Decision Trees)   â”‚ â”‚
â”‚                                            â”‚ â€¢ è·¯å¾„è§„åˆ’ (A* Pathfinding)      â”‚ â”‚
â”‚                                            â”‚ â€¢ æˆ˜æœ¯åˆ†æä¸ç­–ç•¥è®¡ç®—             â”‚ â”‚
â”‚                                            â”‚ â€¢ å¼‚æ­¥è®¡ç®— + ç»“æœç¼“å­˜            â”‚ â”‚
â”‚                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.1.2 Electronè¿›ç¨‹æ¨¡å‹è¯¦è§£

#### ä¸»è¿›ç¨‹ (Main Process) èŒè´£ä¸å®ç°

**æ ¸å¿ƒèŒè´£**ï¼š
- **å”¯ä¸€å…¥å£ç‚¹**ï¼šåº”ç”¨å¯åŠ¨/é€€å‡ºçš„æ§åˆ¶ä¸­å¿ƒ
- **çª—å£ç®¡ç†å™¨**ï¼šBrowserWindowå®ä¾‹çš„åˆ›å»ºä¸ç®¡ç†
- **OSé›†æˆå±‚**ï¼šåŸç”Ÿèœå•ã€ç³»ç»Ÿæ‰˜ç›˜ã€æ–‡ä»¶å¯¹è¯æ¡†ã€å…¨å±€å¿«æ·é”®
- **ç‰¹æƒæ“ä½œä»£ç†**ï¼šæ‰€æœ‰Node.js APIæ“ä½œçš„å®‰å…¨æ‰§è¡Œç‚¹
- **åº”ç”¨çŠ¶æ€ä¸­å¿ƒ**ï¼šå…¨å±€é…ç½®ã€ç”¨æˆ·è®¾ç½®ã€æ¸¸æˆå­˜æ¡£çš„è¯»å†™ç®¡ç†

**å®‰å…¨é…ç½®å®ç°**ï¼š
```typescript
// main.ts - ä¸»è¿›ç¨‹å®‰å…¨é…ç½®
const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      // ğŸ”’ å®‰å…¨åŸºçº¿é…ç½® (å¿…é¡»)
      contextIsolation: true,        // V8ä¸Šä¸‹æ–‡éš”ç¦»
      nodeIntegration: false,        // ç¦ç”¨Node.jsé›†æˆ
      enableRemoteModule: false,     // ç¦ç”¨remoteæ¨¡å—
      webSecurity: true,             // å¯ç”¨Webå®‰å…¨ç­–ç•¥
      preload: path.join(__dirname, 'preload.js') // å®‰å…¨æ¡¥æ¥è„šæœ¬
    }
  });
};
```

#### äº‹ä»¶å¾ªç¯å»¶è¿Ÿè§‚æµ‹ï¼ˆä¸»è¿›ç¨‹æ€§èƒ½ç›‘æ§ï¼‰

**è®¾è®¡ç›®æ ‡**ï¼šä½¿ç”¨Node.js perf_hooks APIç›‘æ§ä¸»è¿›ç¨‹äº‹ä»¶å¾ªç¯å»¶è¿Ÿï¼Œå®ç°èƒŒå‹æ„ŸçŸ¥å’Œè‡ªåŠ¨é™çº§ç­–ç•¥ã€‚

**ç›‘æ§æŒ‡æ ‡ä¸é˜ˆå€¼**ï¼š
- **p95å»¶è¿Ÿ < 20ms**ï¼šæ­£å¸¸è¿è¡ŒçŠ¶æ€
- **p95å»¶è¿Ÿ 20-50ms**ï¼šè­¦å‘ŠçŠ¶æ€ï¼Œå¼€å§‹èƒŒå‹å¤„ç†
- **p95å»¶è¿Ÿ > 50ms**ï¼šç´§æ€¥çŠ¶æ€ï¼Œè§¦å‘é™çº§ç­–ç•¥

```typescript
// main/performance/EventLoopMonitor.ts - äº‹ä»¶å¾ªç¯ç›‘æ§å™¨
import { monitorEventLoopDelay, eventLoopUtilization } from 'node:perf_hooks';
import { EventEmitter } from 'events';

interface EventLoopMetrics {
  delay: {
    min: number;
    max: number;
    mean: number;
    stddev: number;
    p50: number;
    p95: number;
    p99: number;
  };
  utilization: {
    idle: number;
    active: number;
    utilization: number; // active / (active + idle)
  };
  timestamp: number;
}

export class EventLoopMonitor extends EventEmitter {
  private delayMonitor = monitorEventLoopDelay({ resolution: 20 });
  private utilizationBaseline = eventLoopUtilization();
  private metrics: EventLoopMetrics[] = [];
  private maxMetricsHistory = 100;
  
  constructor() {
    super();
    this.startMonitoring();
    this.setupPerformanceAlerts();
  }
  
  /* å¯åŠ¨ç›‘æ§ */
  private startMonitoring(): void {
    this.delayMonitor.enable();
    
    // æ¯ç§’é‡‡æ ·ä¸€æ¬¡
    setInterval(() => {
      this.collectMetrics();
    }, 1000);
    
    console.log('ğŸ“Š Event Loop Monitor started with 20Î¼s resolution');
  }
  
  /* é‡‡é›†æ€§èƒ½æŒ‡æ ‡ */
  private collectMetrics(): void {
    const utilization = eventLoopUtilization(this.utilizationBaseline);
    this.utilizationBaseline = eventLoopUtilization();
    
    const delay = this.delayMonitor;
    const metrics: EventLoopMetrics = {
      delay: {
        min: delay.min / 1e6,      // è½¬æ¢ä¸ºæ¯«ç§’
        max: delay.max / 1e6,
        mean: delay.mean / 1e6,
        stddev: delay.stddev / 1e6,
        p50: delay.percentile(50) / 1e6,
        p95: delay.percentile(95) / 1e6,
        p99: delay.percentile(99) / 1e6
      },
      utilization: {
        idle: utilization.idle,
        active: utilization.active,
        utilization: utilization.utilization
      },
      timestamp: Date.now()
    };
    
    this.metrics.push(metrics);
    if (this.metrics.length > this.maxMetricsHistory) {
      this.metrics.shift();
    }
    
    // é‡ç½®å»¶è¿Ÿç›‘æ§å™¨
    delay.reset();
    
    // å‘å°„æŒ‡æ ‡äº‹ä»¶
    this.emit('metrics', metrics);
    
    // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼
    this.checkPerformanceThresholds(metrics);
  }
  
  /* æ€§èƒ½é˜ˆå€¼æ£€æŸ¥ */
  private checkPerformanceThresholds(metrics: EventLoopMetrics): void {
    const p95 = metrics.delay.p95;
    const utilization = metrics.utilization.utilization;
    
    if (p95 > 50) {
      this.emit('critical-pressure', { p95, utilization, metrics });
      console.error(`ğŸš¨ Critical Event Loop Pressure: p95=${p95.toFixed(2)}ms`);
    } else if (p95 > 20) {
      this.emit('warning-pressure', { p95, utilization, metrics });
      console.warn(`âš ï¸ Event Loop Warning: p95=${p95.toFixed(2)}ms`);
    }
    
    // è¶…é«˜åˆ©ç”¨ç‡è­¦å‘Š
    if (utilization > 0.9) {
      this.emit('high-utilization', { utilization, metrics });
      console.warn(`âš ï¸ High Event Loop Utilization: ${(utilization * 100).toFixed(1)}%`);
    }
  }
  
  /* è®¾ç½®æ€§èƒ½é¢„è­¦ç­–ç•¥ */
  private setupPerformanceAlerts(): void {
    // è­¦å‘ŠçŠ¶æ€ï¼šå¼€å§‹èƒŒå‹å¤„ç†
    this.on('warning-pressure', (data) => {
      this.emit('backpressure-start', {
        level: 'moderate',
        action: 'reduce-ipc-frequency',
        metrics: data.metrics
      });
    });
    
    // ä¸´ç•ŒçŠ¶æ€ï¼šè§¦å‘é™çº§ç­–ç•¥
    this.on('critical-pressure', (data) => {
      this.emit('backpressure-critical', {
        level: 'severe',
        action: 'emergency-throttling',
        metrics: data.metrics
      });
    });
  }
  
  /* è·å–å½“å‰æ€§èƒ½çŠ¶æ€ */
  getCurrentStatus(): {
    state: 'healthy' | 'warning' | 'critical';
    latestMetrics: EventLoopMetrics | null;
    trend: 'improving' | 'stable' | 'degrading';
  } {
    if (this.metrics.length === 0) {
      return { state: 'healthy', latestMetrics: null, trend: 'stable' };
    }
    
    const latest = this.metrics[this.metrics.length - 1];
    const p95 = latest.delay.p95;
    
    let state: 'healthy' | 'warning' | 'critical';
    if (p95 > 50) state = 'critical';
    else if (p95 > 20) state = 'warning';
    else state = 'healthy';
    
    // è®¡ç®—è¶‹åŠ¿ï¼ˆæœ€è¿‘5ä¸ªæ ·æœ¬ï¼‰
    const trend = this.calculateTrend();
    
    return { state, latestMetrics: latest, trend };
  }
  
  /* è®¡ç®—æ€§èƒ½è¶‹åŠ¿ */
  private calculateTrend(): 'improving' | 'stable' | 'degrading' {
    if (this.metrics.length < 5) return 'stable';
    
    const recent = this.metrics.slice(-5);
    const p95Values = recent.map(m => m.delay.p95);
    
    const first = p95Values[0];
    const last = p95Values[p95Values.length - 1];
    const change = (last - first) / first;
    
    if (change > 0.1) return 'degrading';   // æ¶åŒ–è¶…è¿‡10%
    if (change < -0.1) return 'improving';  // æ”¹å–„è¶…è¿‡10%
    return 'stable';
  }
  
  /* å¯¼å‡ºPrometheusæ ¼å¼æŒ‡æ ‡ */
  getPrometheusMetrics(): string {
    if (this.metrics.length === 0) return '';
    
    const latest = this.metrics[this.metrics.length - 1];
    return [
      `# HELP event_loop_delay_p95 Event loop delay 95th percentile in milliseconds`,
      `# TYPE event_loop_delay_p95 gauge`,
      `event_loop_delay_p95 ${latest.delay.p95}`,
      '',
      `# HELP event_loop_utilization Event loop utilization ratio`,
      `# TYPE event_loop_utilization gauge`,
      `event_loop_utilization ${latest.utilization.utilization}`,
      '',
      `# HELP event_loop_delay_mean Event loop delay mean in milliseconds`,
      `# TYPE event_loop_delay_mean gauge`,
      `event_loop_delay_mean ${latest.delay.mean}`
    ].join('\n');
  }
  
  /* é”€æ¯ç›‘æ§å™¨ */
  destroy(): void {
    this.delayMonitor.disable();
    this.removeAllListeners();
  }
}
```

#### èƒŒå‹å¤„ç†ä¸é™çº§ç­–ç•¥

```typescript
// main/performance/BackpressureManager.ts - èƒŒå‹ç®¡ç†å™¨
export class BackpressureManager {
  private monitor: EventLoopMonitor;
  private currentLevel: 'none' | 'moderate' | 'severe' = 'none';
  
  constructor(monitor: EventLoopMonitor) {
    this.monitor = monitor;
    this.setupBackpressureHandling();
  }
  
  private setupBackpressureHandling(): void {
    // ä¸­ç­‰èƒŒå‹ï¼šå‡å°‘IPCé€šä¿¡é¢‘ç‡
    this.monitor.on('backpressure-start', () => {
      this.currentLevel = 'moderate';
      this.applyModerateThrottling();
    });
    
    // ä¸¥é‡èƒŒå‹ï¼šç´§æ€¥é™çº§ç­–ç•¥
    this.monitor.on('backpressure-critical', () => {
      this.currentLevel = 'severe';
      this.applyEmergencyThrottling();
    });
  }
  
  /* ä¸­ç­‰èŠ‚æµç­–ç•¥ */
  private applyModerateThrottling(): void {
    // å‡å°‘æ¸²æŸ“è¿›ç¨‹é€šä¿¡é¢‘ç‡
    app.commandLine.appendSwitch('max-ipc-send-buffer-size', '32'); // å‡å°‘ç¼“å†²åŒº
    
    // å»¶è¿Ÿéå…³é”®ä»»åŠ¡
    this.throttleNonCriticalTasks();
    
    console.log('ğŸ›ï¸ Moderate backpressure throttling applied');
  }
  
  /* ç´§æ€¥èŠ‚æµç­–ç•¥ */
  private applyEmergencyThrottling(): void {
    // æš‚åœéå…³é”®IPCå¤„ç†
    this.pauseNonCriticalIPC();
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    if (global.gc) {
      global.gc();
    }
    
    // é€šçŸ¥æ¸²æŸ“è¿›ç¨‹é™ä½æ›´æ–°é¢‘ç‡
    BrowserWindow.getAllWindows().forEach(window => {
      window.webContents.send('emergency-throttling', true);
    });
    
    console.error('ğŸš¨ Emergency backpressure throttling applied');
  }
  
  /* æ¢å¤æ­£å¸¸çŠ¶æ€ */
  private restoreNormalOperation(): void {
    this.currentLevel = 'none';
    // æ¢å¤æ­£å¸¸IPCå¤„ç†
    // é€šçŸ¥æ¸²æŸ“è¿›ç¨‹æ¢å¤æ­£å¸¸é¢‘ç‡
    console.log('âœ… Normal operation restored');
  }
}
```

#### æ¸²æŸ“è¿›ç¨‹ (Renderer Process) æ¶æ„ä¸å®‰å…¨

**æ ¸å¿ƒèŒè´£**ï¼š
- **UIæ¸²æŸ“å±‚**ï¼šReact 19ç»„ä»¶æ ‘çš„æ¸²æŸ“ä¸äº¤äº’å¤„ç†
- **æ¸¸æˆè¿è¡Œæ—¶**ï¼šPhaser 3æ¸¸æˆå¼•æ“çš„å®¿ä¸»ç¯å¢ƒ
- **æ²™ç®±ç¯å¢ƒ**ï¼šåœ¨å—é™æµè§ˆå™¨ç¯å¢ƒä¸­è¿è¡Œï¼Œæ— ç›´æ¥Node.jsè®¿é—®
- **è¯·æ±‚ä»£ç†**ï¼šé€šè¿‡IPCå‘ä¸»è¿›ç¨‹è¯·æ±‚ç‰¹æƒæ“ä½œ

**å®‰å…¨æ¡¥æ¥å®ç°**ï¼š
```typescript
// preload.js - å®‰å…¨æ¡¥æ¥è„šæœ¬
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  // æ¸¸æˆå­˜æ¡£æ“ä½œ
  saveGameData: (data: GameSaveData) => 
    ipcRenderer.invoke('save-game', data),
  loadGameData: () => 
    ipcRenderer.invoke('load-game'),
  
  // ç³»ç»Ÿå¯¹è¯æ¡†
  showSaveDialog: (options: SaveDialogOptions) => 
    ipcRenderer.invoke('show-save-dialog', options),
    
  // è®¾ç½®ç®¡ç†
  getUserSettings: () => 
    ipcRenderer.invoke('get-user-settings'),
  updateUserSettings: (settings: UserSettings) => 
    ipcRenderer.invoke('update-user-settings', settings),
    
  // äº‹ä»¶ç›‘å¬
  onWindowFocus: (callback: () => void) => 
    ipcRenderer.on('window-focus', callback),
  onWindowBlur: (callback: () => void) => 
    ipcRenderer.on('window-blur', callback)
});
```

### 6.1.3 Web Workerçº¿ç¨‹æ¨¡å‹

#### AIè®¡ç®—çº¿ç¨‹æ¶æ„

**è®¾è®¡ç›®æ ‡**ï¼šå°†CPUå¯†é›†å‹AIè®¡ç®—ä»ä¸»æ¸²æŸ“çº¿ç¨‹åˆ†ç¦»ï¼Œç¡®ä¿60FPSæ¸¸æˆå¾ªç¯ä¸è¢«é˜»å¡ã€‚

**çº¿ç¨‹èŒè´£åˆ’åˆ†**ï¼š
- **ä¸»UIçº¿ç¨‹**ï¼šReact UIæ¸²æŸ“ + Phaseræ¸¸æˆå¾ªç¯ + DOMäº‹ä»¶å¤„ç†
- **AI Workerçº¿ç¨‹**ï¼šNPCå†³ç­– + è·¯å¾„è§„åˆ’ + æˆ˜æœ¯åˆ†æ + ç­–ç•¥è®¡ç®—

#### é›¶æ‹·è´ä¼ è¾“ç­–ç•¥ï¼ˆSharedArrayBufferä¼˜å…ˆï¼‰

**è®¾è®¡åŸåˆ™**ï¼šåœ¨AI/åœ°å›¾ç”Ÿæˆç­‰å¤§æ•°æ®åœºæ™¯ä¸­å¼ºåˆ¶ä½¿ç”¨Transferable Objectsï¼Œé¿å…åºåˆ—åŒ–å¼€é”€ï¼Œæå‡Workeré€šä¿¡æ•ˆç‡30-50%ã€‚

#### ä½•æ—¶å¤åˆ¶ vs ä½•æ—¶è½¬ç§»å†³ç­–è¡¨

| æ•°æ®ç±»å‹ | å¤§å°é˜ˆå€¼ | ä¼ è¾“ç­–ç•¥ | åŸå›  | ç¤ºä¾‹åœºæ™¯ |
|----------|----------|----------|------|----------|
| **åŸºç¡€é…ç½®** | < 1KB | ç»“æ„åŒ–å¤åˆ¶ | å¼€é”€å°ï¼Œä¿æŒç®€å• | AIå‚æ•°ã€çŠ¶æ€æ ‡å¿— |
| **æ¸¸æˆçŠ¶æ€** | 1KB-10KB | ç»“æ„åŒ–å¤åˆ¶ | é¢‘ç¹è®¿é—®ï¼Œå¤åˆ¶å®‰å…¨ | ç©å®¶ä½ç½®ã€è¡€é‡ |
| **è·¯å¾„æ•°æ®** | > 10KB | ArrayBufferè½¬ç§» | é¿å…åºåˆ—åŒ–å¼€é”€ | A*è·¯å¾„ç‚¹æ•°ç»„ |
| **åœ°å›¾æ•°æ®** | > 50KB | SharedArrayBuffer | å¤šçº¿ç¨‹å…±äº«è®¿é—® | åœ°å½¢é«˜åº¦å›¾ã€éšœç¢ç‰© |
| **AIæ¨¡å‹** | > 100KB | SharedArrayBuffer | ä¸€æ¬¡åŠ è½½å¤šæ¬¡è®¿é—® | å†³ç­–æ ‘ã€ç¥ç»ç½‘ç»œæƒé‡ |
| **éŸ³é¢‘æ•°æ®** | > 1MB | SharedArrayBuffer | å®æ—¶å¤„ç†éœ€æ±‚ | éŸ³é¢‘æ³¢å½¢ã€é¢‘è°±åˆ†æ |

#### Electron ShareArrayBufferé…ç½®

```typescript
// main.ts - å¯ç”¨SharedArrayBufferæ”¯æŒ
import { app, BrowserWindow } from 'electron';

app.commandLine.appendSwitch('enable-features', 'SharedArrayBuffer');

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: false,
      // ğŸš€ å¯ç”¨è·¨åŸŸéš”ç¦»æ”¯æŒSAB
      webSecurity: true,
      crossOriginIsolated: true,
      additionalArguments: ['--enable-features=SharedArrayBuffer']
    }
  });
  
  // æ³¨å…¥COOP/COEPå¤´éƒ¨æ”¯æŒSharedArrayBuffer
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    const headers = details.responseHeaders || {};
    headers['Cross-Origin-Opener-Policy'] = ['same-origin'];
    headers['Cross-Origin-Embedder-Policy'] = ['require-corp'];
    
    callback({ cancel: false, responseHeaders: headers });
  });
};
```

#### é›¶æ‹·è´ä¼ è¾“åè®®è®¾è®¡

```typescript
// types/worker-messages.ts - é›¶æ‹·è´Workeré€šä¿¡åè®®
export interface ZeroCopyWorkerMessage {
  id: string;
  type: 'pathfinding' | 'decision_making' | 'tactical_analysis' | 'map_generation';
  timestamp: number;
  transferType: 'copy' | 'transfer' | 'shared';
  payload: unknown;
  // Transferable Objectsæ”¯æŒ
  transferables?: Transferable[];
}

/* å¤§æ•°æ®è·¯å¾„è§„åˆ’è¯·æ±‚ */
export interface LargePathfindingRequest {
  unitId: string;
  start: Point2D;
  target: Point2D;
  // ä½¿ç”¨ArrayBufferå­˜å‚¨å¤§é‡éšœç¢ç‰©æ•°æ®
  obstacleBuffer: ArrayBuffer; // Float32Arrayæ ¼å¼ï¼š[x1,y1,x2,y2,...]
  obstacleCount: number;
  unitType: 'infantry' | 'tank' | 'aircraft';
}

/* å…±äº«åœ°å›¾æ•°æ®ç»“æ„ */
export interface SharedMapData {
  // SharedArrayBufferå­˜å‚¨åœ°å½¢é«˜åº¦å›¾
  heightMapSAB: SharedArrayBuffer; // Float32Array
  // SharedArrayBufferå­˜å‚¨éšœç¢ç‰©ä½å›¾
  obstacleMapSAB: SharedArrayBuffer; // Uint8Array
  width: number;
  height: number;
  scale: number;
}

/* AIæ¨¡å‹å…±äº«æƒé‡ */
export interface SharedAIModel {
  // å†³ç­–æ ‘æƒé‡å…±äº«å†…å­˜
  decisionWeightsSAB: SharedArrayBuffer;
  // ç¥ç»ç½‘ç»œæƒé‡ï¼ˆå¦‚æœä½¿ç”¨ï¼‰
  neuralWeightsSAB?: SharedArrayBuffer;
  modelVersion: string;
  lastUpdated: number;
}
```

#### é›¶æ‹·è´ä¼ è¾“ç®¡ç†å™¨

```typescript
// workers/ZeroCopyTransferManager.ts - é›¶æ‹·è´ä¼ è¾“ç®¡ç†
export class ZeroCopyTransferManager {
  private static readonly TRANSFER_THRESHOLD = 10 * 1024; // 10KBé˜ˆå€¼
  private static readonly SHARED_THRESHOLD = 50 * 1024;   // 50KBé˜ˆå€¼
  
  private sharedBuffers = new Map<string, SharedArrayBuffer>();
  
  /* åˆ¤æ–­ä¼ è¾“ç­–ç•¥ */
  static determineTransferStrategy(data: any): 'copy' | 'transfer' | 'shared' {
    const size = this.estimateDataSize(data);
    
    if (size < this.TRANSFER_THRESHOLD) {
      return 'copy'; // å°æ•°æ®ç›´æ¥å¤åˆ¶
    } else if (size < this.SHARED_THRESHOLD) {
      return 'transfer'; // ä¸­ç­‰æ•°æ®ä½¿ç”¨ArrayBufferè½¬ç§»
    } else {
      return 'shared'; // å¤§æ•°æ®ä½¿ç”¨SharedArrayBuffer
    }
  }
  
  /* å‘é€å¤§æ•°æ®åˆ°Worker */
  sendLargeDataToWorker(
    worker: Worker, 
    message: ZeroCopyWorkerMessage, 
    largeData: ArrayBuffer
  ): void {
    const strategy = ZeroCopyTransferManager.determineTransferStrategy(largeData);
    
    switch (strategy) {
      case 'transfer':
        // ArrayBufferè½¬ç§»æ‰€æœ‰æƒ
        message.transferType = 'transfer';
        message.transferables = [largeData];
        worker.postMessage(message, [largeData]);
        console.log(`ğŸ“¦ Transferred ${largeData.byteLength}B via ArrayBuffer transfer`);
        break;
        
      case 'shared':
        // ä½¿ç”¨SharedArrayBuffer
        const sabKey = `sab_${Date.now()}_${Math.random()}`;
        const sab = new SharedArrayBuffer(largeData.byteLength);
        new Uint8Array(sab).set(new Uint8Array(largeData));
        
        this.sharedBuffers.set(sabKey, sab);
        message.transferType = 'shared';
        message.payload = { ...message.payload, sabKey, byteLength: sab.byteLength };
        worker.postMessage(message);
        console.log(`ğŸ”— Shared ${sab.byteLength}B via SharedArrayBuffer`);
        break;
        
      default:
        // ç»“æ„åŒ–å¤åˆ¶
        message.transferType = 'copy';
        worker.postMessage(message);
    }
  }
  
  /* åˆ›å»ºå…±äº«åœ°å›¾æ•°æ® */
  createSharedMapData(width: number, height: number): SharedMapData {
    const heightMapSize = width * height * 4; // Float32Array
    const obstacleMapSize = width * height;    // Uint8Array
    
    const heightMapSAB = new SharedArrayBuffer(heightMapSize);
    const obstacleMapSAB = new SharedArrayBuffer(obstacleMapSize);
    
    // æ³¨å†Œå…±äº«ç¼“å†²åŒº
    this.sharedBuffers.set(`heightMap_${width}x${height}`, heightMapSAB);
    this.sharedBuffers.set(`obstacleMap_${width}x${height}`, obstacleMapSAB);
    
    return {
      heightMapSAB,
      obstacleMapSAB,
      width,
      height,
      scale: 1.0
    };
  }
  
  /* è·å–å…±äº«ç¼“å†²åŒº */
  getSharedBuffer(key: string): SharedArrayBuffer | null {
    return this.sharedBuffers.get(key) || null;
  }
  
  /* ä¼°ç®—æ•°æ®å¤§å° */
  private static estimateDataSize(data: any): number {
    if (data instanceof ArrayBuffer) {
      return data.byteLength;
    }
    
    // ç²—ç•¥ä¼°ç®—JSONåºåˆ—åŒ–åçš„å¤§å°
    try {
      return new TextEncoder().encode(JSON.stringify(data)).length;
    } catch {
      return 0;
    }
  }
  
  /* æ¸…ç†æœªä½¿ç”¨çš„å…±äº«ç¼“å†²åŒº */
  cleanupUnusedBuffers(): void {
    // å®ç°LRUæ¸…ç†ç­–ç•¥
    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å®šæœŸè°ƒç”¨
  }
}
```

#### é«˜æ€§èƒ½Workerå®ç°

```typescript
// workers/ai.worker.ts - é›¶æ‹·è´AIè®¡ç®—å·¥ä½œçº¿ç¨‹
import { ZeroCopyTransferManager } from './ZeroCopyTransferManager';

class ZeroCopyAIWorker {
  private transferManager = new ZeroCopyTransferManager();
  private sharedMap: SharedMapData | null = null;
  
  constructor() {
    self.onmessage = this.handleMessage.bind(this);
    this.initializeSharedResources();
  }
  
  /* åˆå§‹åŒ–å…±äº«èµ„æº */
  private initializeSharedResources(): void {
    // æ£€æµ‹SharedArrayBufferæ”¯æŒ
    if (typeof SharedArrayBuffer === 'undefined') {
      console.warn('âš ï¸ SharedArrayBuffer not available, falling back to transfers');
      return;
    }
    
    console.log('ğŸš€ Zero-copy AI Worker initialized with SAB support');
  }
  
  /* å¤„ç†é›¶æ‹·è´æ¶ˆæ¯ */
  private async handleMessage(event: MessageEvent<ZeroCopyWorkerMessage>) {
    const { id, type, transferType, payload } = event.data;
    
    try {
      let result: unknown;
      
      switch (type) {
        case 'pathfinding':
          result = await this.handleLargePathfinding(payload as LargePathfindingRequest, transferType);
          break;
        case 'map_generation':
          result = await this.handleMapGeneration(payload, transferType);
          break;
        case 'decision_making':
          result = await this.handleDecisionMaking(payload);
          break;
      }
      
      // æ ¹æ®ç»“æœå¤§å°é€‰æ‹©è¿”å›ç­–ç•¥
      this.sendResultWithOptimalTransfer(id, type, result);
      
    } catch (error) {
      self.postMessage({
        id,
        type: `${type}_error`,
        transferType: 'copy',
        payload: { error: error.message }
      });
    }
  }
  
  /* å¤„ç†å¤§æ•°æ®è·¯å¾„è§„åˆ’ */
  private async handleLargePathfinding(
    request: LargePathfindingRequest, 
    transferType: string
  ): Promise<Float32Array> {
    const { obstacleBuffer, obstacleCount, start, target } = request;
    
    // ç›´æ¥è®¿é—®è½¬ç§»çš„ArrayBufferï¼Œé›¶æ‹·è´
    const obstacleArray = new Float32Array(obstacleBuffer);
    
    // æ‰§è¡ŒA*ç®—æ³•ï¼ˆä½¿ç”¨é«˜æ•ˆçš„ArrayBufferæ“ä½œï¼‰
    const path = this.runOptimizedAStar(start, target, obstacleArray, obstacleCount);
    
    console.log(`ğŸ” Pathfinding completed with ${obstacleCount} obstacles (${transferType})`);
    return path;
  }
  
  /* ä¼˜åŒ–çš„è¿”å›ç­–ç•¥ */
  private sendResultWithOptimalTransfer(id: string, type: string, result: any): void {
    if (result instanceof Float32Array || result instanceof Uint8Array) {
      // å¤§å‹ç±»å‹åŒ–æ•°ç»„ä½¿ç”¨ArrayBufferè½¬ç§»
      const buffer = result.buffer.slice(result.byteOffset, result.byteOffset + result.byteLength);
      
      self.postMessage({
        id,
        type: `${type}_result`,
        transferType: 'transfer',
        payload: { resultType: result.constructor.name, buffer },
        transferables: [buffer]
      }, [buffer]);
    } else {
      // å°æ•°æ®ä½¿ç”¨ç»“æ„åŒ–å¤åˆ¶
      self.postMessage({
        id,
        type: `${type}_result`,
        transferType: 'copy',
        payload: result
      });
    }
  }
}

new ZeroCopyAIWorker();
```

#### Workerå®ç°ç¤ºä¾‹

```typescript
// workers/ai.worker.ts - AIè®¡ç®—å·¥ä½œçº¿ç¨‹
import { PathfindingEngine } from './engines/PathfindingEngine';
import { DecisionTreeEngine } from './engines/DecisionTreeEngine';

class AIWorker {
  private pathfinding = new PathfindingEngine();
  private decisionTree = new DecisionTreeEngine();
  
  constructor() {
    self.onmessage = this.handleMessage.bind(this);
  }
  
  private async handleMessage(event: MessageEvent<AIWorkerMessage>) {
    const { id, type, payload } = event.data;
    
    try {
      let result: unknown;
      
      switch (type) {
        case 'pathfinding':
          result = await this.pathfinding.findPath(payload as PathfindingRequest);
          break;
        case 'decision_making':
          result = await this.decisionTree.makeDecision(payload as DecisionMakingRequest);
          break;
        case 'tactical_analysis':
          result = await this.analyzeTacticalSituation(payload);
          break;
      }
      
      // è¿”å›è®¡ç®—ç»“æœ
      self.postMessage({
        id,
        type: `${type}_result`,
        timestamp: Date.now(),
        payload: result
      });
    } catch (error) {
      // é”™è¯¯å¤„ç†
      self.postMessage({
        id,
        type: 'error',
        timestamp: Date.now(),
        payload: { 
          originalType: type, 
          error: error.message,
          stack: error.stack 
        }
      });
    }
  }
}

new AIWorker();
```

### 6.1.4 React-Phaseré›†æˆæ¶æ„

#### React 18å¹¶å‘ç‰¹æ€§é›†æˆ

**è®¾è®¡ç›®æ ‡**ï¼šåˆ©ç”¨React 18çš„startTransitionå’ŒuseTransitionä¼˜åŒ–UIæ›´æ–°ï¼Œç¡®ä¿æ¸¸æˆäº¤äº’çš„é«˜å“åº”æ€§å’Œè§†è§‰æµç•…åº¦ã€‚

#### UIçº¿ç¨‹é¢„ç®—åˆ†é…ç­–ç•¥

**16.67mså¸§é¢„ç®—åˆ†é…**ï¼š
- **UIæ›´æ–°**: < 4ms (Reactæ¸²æŸ“ã€DOMæ“ä½œ)
- **Phaseræ¸¸æˆ**: 12ms (æ¸¸æˆé€»è¾‘ã€WebGLæ¸²æŸ“)
- **å‰©ä½™ç¼“å†²**: 0.67ms (äº‹ä»¶å¤„ç†ã€åƒåœ¾å›æ”¶)

```typescript
// components/PhaserGameContainer.tsx - æ”¯æŒå¹¶å‘ç‰¹æ€§çš„Phaserå®¹å™¨
import React, { useRef, useEffect, useState, useTransition, startTransition } from 'react';
import Phaser from 'phaser';
import { EventBus } from '@/core/events/EventBus';
import { FirstFrameMetrics } from '@/core/performance/FirstFrameMetrics';
import { gameConfig } from '@/game/config';

interface PhaserGameContainerProps {
  eventBus: EventBus;
  onGameReady?: (game: Phaser.Game) => void;
  onFirstFrameComplete?: (metrics: FirstFrameMetrics) => void;
}

export const PhaserGameContainer: React.FC<PhaserGameContainerProps> = ({
  eventBus,
  onGameReady,
  onFirstFrameComplete
}) => {
  const gameRef = useRef<Phaser.Game | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isGameReady, setIsGameReady] = useState(false);
  const [gameState, setGameState] = useState<GameStateSnapshot>({});
  
  // ğŸš€ React 18å¹¶å‘ç‰¹æ€§
  const [isPending, startTransition] = useTransition();
  const [isInitializing, setIsInitializing] = useState(true);
  
  // é¦–å¸§æ€§èƒ½ç›‘æ§
  const firstFrameMonitor = useRef(new FirstFramePerformanceMonitor());
  
  useEffect(() => {
    const monitor = firstFrameMonitor.current;
    monitor.markAppStart(); // æ ‡è®°åº”ç”¨å¯åŠ¨å¼€å§‹
    
    // åˆå§‹åŒ–Phaseræ¸¸æˆå®ä¾‹
    const config: Phaser.Types.Core.GameConfig = {
      ...gameConfig,
      parent: containerRef.current!,
      callbacks: {
        postBoot: () => {
          // ğŸ¯ ä½¿ç”¨startTransitioné¿å…é˜»å¡ç”¨æˆ·äº¤äº’
          startTransition(() => {
            setIsGameReady(true);
            setIsInitializing(false);
          });
          
          // æ ‡è®°é¦–æ¬¡å†…å®¹ç»˜åˆ¶å®Œæˆ
          monitor.markFirstContentfulPaint();
          
          onGameReady?.(gameRef.current!);
        },
        postRender: () => {
          // é¦–å¸§æ¸²æŸ“å®Œæˆ
          if (isInitializing) {
            monitor.markFirstFrame();
            const metrics = monitor.getMetrics();
            onFirstFrameComplete?.(metrics);
          }
        }
      }
    };
    
    const game = new Phaser.Game(config);
    
    // å°†EventBuså’Œæ€§èƒ½ç›‘æ§æ³¨å…¥Phaser registry
    game.registry.set('eventBus', eventBus);
    game.registry.set('reactContainer', containerRef.current);
    game.registry.set('firstFrameMonitor', monitor);
    
    gameRef.current = game;
    
    return () => {
      if (gameRef.current) {
        gameRef.current.destroy(true);
        gameRef.current = null;
      }
      setIsGameReady(false);
    };
  }, [eventBus, onGameReady, onFirstFrameComplete]);
  
  // ğŸ® æ¸¸æˆçŠ¶æ€åŒæ­¥ - ä½¿ç”¨Transitioné¿å…UIæŠ–åŠ¨
  useEffect(() => {
    const handleGameStateUpdate = (newState: GameStateSnapshot) => {
      // ä½¿ç”¨startTransitionåŒ…è£…å¤§å‹çŠ¶æ€æ›´æ–°
      startTransition(() => {
        setGameState(prevState => ({
          ...prevState,
          ...newState
        }));
      });
    };
    
    eventBus.on('game:state_update', handleGameStateUpdate);
    return () => eventBus.off('game:state_update', handleGameStateUpdate);
  }, [eventBus]);
  
  return (
    <div 
      ref={containerRef}
      className={`phaser-game-container ${isPending ? 'updating' : ''}`}
      style={{ 
        width: '100%', 
        height: '100%',
        opacity: isPending ? 0.9 : 1.0, // è§†è§‰åé¦ˆ
        transition: 'opacity 0.1s ease'
      }}
      data-testid="phaser-container"
      data-ready={isGameReady}
      data-initializing={isInitializing}
    />
  );
};
```

#### Reactâ†”PhaseråŒæ­¥çš„Transitionå‡†åˆ™

**æ ¸å¿ƒåŸåˆ™**ï¼šå°†å¤§å‹çŠ¶æ€æ›´æ–°æ ‡è®°ä¸ºéç´§æ€¥ï¼ˆstartTransitionï¼‰ï¼Œä¿æŒç”¨æˆ·äº¤äº’çš„é«˜å“åº”æ€§ã€‚

| æ›´æ–°ç±»å‹ | æ˜¯å¦ä½¿ç”¨Transition | åŸå›  | ç¤ºä¾‹ |
|----------|-------------------|------|------|
| **ç”¨æˆ·è¾“å…¥å“åº”** | âŒ ä¸ä½¿ç”¨ | ä¿æŒå³æ—¶å“åº” | æŒ‰é’®ç‚¹å‡»ã€é”®ç›˜è¾“å…¥ |
| **æ¸¸æˆçŠ¶æ€åŒæ­¥** | âœ… ä½¿ç”¨ | é˜²æ­¢UIå¡é¡¿ | è¡€é‡æ›´æ–°ã€èµ„æºå˜åŒ– |
| **å¤§é‡æ•°æ®æ¸²æŸ“** | âœ… ä½¿ç”¨ | é¿å…é˜»å¡ä¸»çº¿ç¨‹ | æ’è¡Œæ¦œã€ç‰©å“åˆ—è¡¨ |
| **åŠ¨ç”»çŠ¶æ€** | âŒ ä¸ä½¿ç”¨ | ä¿æŒåŠ¨ç”»æµç•… | CSSåŠ¨ç”»ã€è¿‡æ¸¡æ•ˆæœ |
| **é”™è¯¯å¤„ç†** | âŒ ä¸ä½¿ç”¨ | ä¿è¯å³æ—¶æ˜¾ç¤º | é”™è¯¯æç¤ºã€è­¦å‘Šä¿¡æ¯ |

```typescript
// hooks/useGameStateSync.ts - æ¸¸æˆçŠ¶æ€åŒæ­¥Hook
import { useState, useEffect, useTransition, useCallback } from 'react';
import { EventBus } from '@/core/events/EventBus';

interface GameStateSnapshot {
  player?: {
    health: number;
    mana: number;
    position: Point2D;
    level: number;
  };
  resources?: Record<string, number>;
  units?: GameUnit[];
  worldState?: {
    time: number;
    weather: string;
    dayNight: 'day' | 'night';
  };
}

export function useGameStateSync(eventBus: EventBus) {
  const [gameState, setGameState] = useState<GameStateSnapshot>({});
  const [isPending, startTransition] = useTransition();
  
  // ğŸ”„ é«˜é¢‘æ›´æ–°ï¼šä½¿ç”¨Transitioné¿å…é˜»å¡
  const syncLargeStateUpdate = useCallback((newState: Partial<GameStateSnapshot>) => {
    startTransition(() => {
      setGameState(prev => ({ ...prev, ...newState }));
    });
  }, []);
  
  // âš¡ å³æ—¶æ›´æ–°ï¼šä¸ä½¿ç”¨Transitionä¿æŒå“åº”æ€§
  const syncCriticalUpdate = useCallback((update: Partial<GameStateSnapshot>) => {
    setGameState(prev => ({ ...prev, ...update }));
  }, []);
  
  useEffect(() => {
    // ç©å®¶å…³é”®çŠ¶æ€ - å³æ—¶æ›´æ–°
    eventBus.on('game:player_health', (data) => {
      syncCriticalUpdate({ 
        player: { ...gameState.player, health: data.health } 
      });
    });
    
    // èµ„æºå˜åŒ– - ä½¿ç”¨Transition
    eventBus.on('game:resources_bulk_update', (resources) => {
      syncLargeStateUpdate({ resources });
    });
    
    // å•ä½å¤§é‡æ›´æ–° - ä½¿ç”¨Transition
    eventBus.on('game:units_bulk_update', (units) => {
      syncLargeStateUpdate({ units });
    });
    
    // ä¸–ç•ŒçŠ¶æ€æ›´æ–° - ä½¿ç”¨Transition
    eventBus.on('game:world_state_update', (worldState) => {
      syncLargeStateUpdate({ worldState });
    });
    
    return () => {
      eventBus.off('game:player_health');
      eventBus.off('game:resources_bulk_update');
      eventBus.off('game:units_bulk_update');
      eventBus.off('game:world_state_update');
    };
  }, [eventBus, syncCriticalUpdate, syncLargeStateUpdate]);
  
  return {
    gameState,
    isPending, // UIå¯ä»¥æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    syncLargeStateUpdate,
    syncCriticalUpdate
  };
}
```

#### é¦–å¸§æ€§èƒ½ç›‘æ§ï¼ˆTTI/FMPæŒ‡æ ‡ï¼‰

**è®¾è®¡ç›®æ ‡**ï¼šç›‘æ§å…³é”®å¯åŠ¨æ€§èƒ½æŒ‡æ ‡ï¼Œç¡®ä¿æ¡Œé¢æ¸¸æˆåº”ç”¨çš„å¿«é€Ÿå¯åŠ¨å’Œè‰¯å¥½ç”¨æˆ·ä½“éªŒã€‚

**æ€§èƒ½æŒ‡æ ‡å®šä¹‰**ï¼š
- **FCP (First Contentful Paint)**: é¦–æ¬¡å†…å®¹ç»˜åˆ¶ < 1.0s
- **FMP (First Meaningful Paint)**: é¦–æ¬¡æœ‰æ„ä¹‰ç»˜åˆ¶ < 1.5s  
- **TTI (Time to Interactive)**: é¦–æ¬¡å¯äº¤äº’æ—¶é—´ < 2.0s
- **FPS Stability**: é¦–å¸§FPSç¨³å®šæ€§ > 95%

```typescript
// core/performance/FirstFrameMetrics.ts - é¦–å¸§æ€§èƒ½ç›‘æ§
export interface FirstFrameMetrics {
  // æ—¶é—´æˆ³æŒ‡æ ‡ (æ¯«ç§’)
  appStart: number;           // åº”ç”¨å¯åŠ¨æ—¶é—´
  electronReady: number;      // Electronå°±ç»ªæ—¶é—´
  firstContentfulPaint: number; // é¦–æ¬¡å†…å®¹ç»˜åˆ¶
  firstMeaningfulPaint: number; // é¦–æ¬¡æœ‰æ„ä¹‰ç»˜åˆ¶
  timeToInteractive: number;   // é¦–æ¬¡å¯äº¤äº’æ—¶é—´
  firstFrame: number;         // é¦–å¸§æ¸²æŸ“å®Œæˆ
  
  // æ€§èƒ½æŒ‡æ ‡
  totalStartupTime: number;   // æ€»å¯åŠ¨æ—¶é—´
  renderingTime: number;      // æ¸²æŸ“æ—¶é—´
  fpsStability: number;       // FPSç¨³å®šæ€§ (0-1)
  memoryUsage: number;        // å†…å­˜ä½¿ç”¨(MB)
  
  // è´¨é‡è¯„çº§
  grade: 'excellent' | 'good' | 'fair' | 'poor';
}

export class FirstFramePerformanceMonitor {
  private metrics: Partial<FirstFrameMetrics> = {};
  private startTime = 0;
  private frameCount = 0;
  private fpsSamples: number[] = [];
  
  constructor() {
    this.startTime = performance.now();
    this.setupPerformanceObserver();
  }
  
  /* è®¾ç½®æ€§èƒ½è§‚å¯Ÿå™¨ */
  private setupPerformanceObserver(): void {
    // è§‚å¯ŸPaintæ—¶æœº
    if ('PerformanceObserver' in window) {
      const paintObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.firstContentfulPaint = entry.startTime;
          }
        }
      });
      
      paintObserver.observe({ entryTypes: ['paint'] });
    }
    
    // ç›‘æ§é¦–å¸§FPS
    this.monitorInitialFrameRate();
  }
  
  /* æ ‡è®°åº”ç”¨å¯åŠ¨ */
  markAppStart(): void {
    this.metrics.appStart = performance.now();
    performance.mark('app-start');
  }
  
  /* æ ‡è®°Electronå°±ç»ª */
  markElectronReady(): void {
    this.metrics.electronReady = performance.now();
    performance.mark('electron-ready');
  }
  
  /* æ ‡è®°é¦–æ¬¡å†…å®¹ç»˜åˆ¶ */
  markFirstContentfulPaint(): void {
    this.metrics.firstContentfulPaint = performance.now();
    performance.mark('first-contentful-paint');
    
    // æµ‹é‡ä»å¯åŠ¨åˆ°FCPçš„æ—¶é—´
    performance.measure('startup-to-fcp', 'app-start', 'first-contentful-paint');
  }
  
  /* æ ‡è®°é¦–æ¬¡æœ‰æ„ä¹‰ç»˜åˆ¶ */
  markFirstMeaningfulPaint(): void {
    this.metrics.firstMeaningfulPaint = performance.now();
    performance.mark('first-meaningful-paint');
  }
  
  /* æ ‡è®°é¦–æ¬¡å¯äº¤äº’ */
  markTimeToInteractive(): void {
    this.metrics.timeToInteractive = performance.now();
    performance.mark('time-to-interactive');
    
    // è®¡ç®—TTI
    const tti = this.metrics.timeToInteractive - this.metrics.appStart;
    console.log(`ğŸ¯ Time to Interactive: ${tti.toFixed(2)}ms`);
  }
  
  /* æ ‡è®°é¦–å¸§å®Œæˆ */
  markFirstFrame(): void {
    this.metrics.firstFrame = performance.now();
    performance.mark('first-frame');
    
    // è®¡ç®—é¦–å¸§æ€§èƒ½
    this.calculateFirstFrameMetrics();
  }
  
  /* ç›‘æ§åˆå§‹å¸§ç‡ */
  private monitorInitialFrameRate(): void {
    let lastTime = performance.now();
    let frameCount = 0;
    
    const measureFPS = (currentTime: number) => {
      frameCount++;
      const deltaTime = currentTime - lastTime;
      
      if (deltaTime >= 1000) { // æ¯ç§’é‡‡æ ·
        const fps = (frameCount * 1000) / deltaTime;
        this.fpsSamples.push(fps);
        
        frameCount = 0;
        lastTime = currentTime;
        
        // åªæ”¶é›†å‰5ç§’çš„FPSæ•°æ®
        if (this.fpsSamples.length < 5) {
          requestAnimationFrame(measureFPS);
        }
      } else {
        requestAnimationFrame(measureFPS);
      }
    };
    
    requestAnimationFrame(measureFPS);
  }
  
  /* è®¡ç®—é¦–å¸§æ€§èƒ½æŒ‡æ ‡ */
  private calculateFirstFrameMetrics(): void {
    const { appStart, firstContentfulPaint, firstFrame, timeToInteractive } = this.metrics;
    
    if (appStart && firstFrame) {
      this.metrics.totalStartupTime = firstFrame - appStart;
      this.metrics.renderingTime = firstFrame - (firstContentfulPaint || appStart);
    }
    
    // è®¡ç®—FPSç¨³å®šæ€§
    if (this.fpsSamples.length > 0) {
      const avgFPS = this.fpsSamples.reduce((sum, fps) => sum + fps, 0) / this.fpsSamples.length;
      const variance = this.fpsSamples.reduce((sum, fps) => sum + Math.pow(fps - avgFPS, 2), 0) / this.fpsSamples.length;
      const stdDev = Math.sqrt(variance);
      
      // FPSç¨³å®šæ€§ = 1 - (æ ‡å‡†å·® / å¹³å‡å€¼)ï¼Œå€¼è¶Šæ¥è¿‘1è¶Šç¨³å®š
      this.metrics.fpsStability = Math.max(0, 1 - (stdDev / avgFPS));
    }
    
    // è·å–å†…å­˜ä½¿ç”¨
    if (performance.memory) {
      this.metrics.memoryUsage = performance.memory.usedJSHeapSize / (1024 * 1024); // MB
    }
    
    // è¯„ä¼°æ€§èƒ½ç­‰çº§
    this.metrics.grade = this.calculatePerformanceGrade();
  }
  
  /* è®¡ç®—æ€§èƒ½ç­‰çº§ */
  private calculatePerformanceGrade(): 'excellent' | 'good' | 'fair' | 'poor' {
    const { totalStartupTime, fpsStability, timeToInteractive } = this.metrics;
    
    if (!totalStartupTime) return 'poor';
    
    // è¯„åˆ†æ ‡å‡†
    const startupScore = totalStartupTime < 1000 ? 3 : totalStartupTime < 2000 ? 2 : totalStartupTime < 3000 ? 1 : 0;
    const fpsScore = (fpsStability || 0) > 0.9 ? 3 : (fpsStability || 0) > 0.8 ? 2 : (fpsStability || 0) > 0.6 ? 1 : 0;
    const interactiveScore = timeToInteractive && timeToInteractive < 2000 ? 3 : timeToInteractive && timeToInteractive < 3000 ? 2 : timeToInteractive && timeToInteractive < 4000 ? 1 : 0;
    
    const totalScore = startupScore + fpsScore + interactiveScore;
    
    if (totalScore >= 8) return 'excellent';
    if (totalScore >= 6) return 'good';
    if (totalScore >= 4) return 'fair';
    return 'poor';
  }
  
  /* è·å–å®Œæ•´æŒ‡æ ‡ */
  getMetrics(): FirstFrameMetrics {
    return {
      appStart: this.metrics.appStart || 0,
      electronReady: this.metrics.electronReady || 0,
      firstContentfulPaint: this.metrics.firstContentfulPaint || 0,
      firstMeaningfulPaint: this.metrics.firstMeaningfulPaint || 0,
      timeToInteractive: this.metrics.timeToInteractive || 0,
      firstFrame: this.metrics.firstFrame || 0,
      totalStartupTime: this.metrics.totalStartupTime || 0,
      renderingTime: this.metrics.renderingTime || 0,
      fpsStability: this.metrics.fpsStability || 0,
      memoryUsage: this.metrics.memoryUsage || 0,
      grade: this.metrics.grade || 'poor'
    };
  }
  
  /* å‘é€æŒ‡æ ‡åˆ°ä¸»è¿›ç¨‹ */
  sendMetricsToMain(): void {
    const metrics = this.getMetrics();
    
    // é€šè¿‡IPCå‘é€åˆ°ä¸»è¿›ç¨‹è¿›è¡Œè®°å½•
    if (window.electronAPI?.sendFirstFrameMetrics) {
      window.electronAPI.sendFirstFrameMetrics(metrics);
    }
    
    console.log('ğŸ“ˆ First Frame Performance Metrics:', metrics);
  }
}
```

#### EventBusé€šä¿¡æœºåˆ¶

```typescript
// core/events/EventBus.ts - React-Phaseräº‹ä»¶æ€»çº¿
import mitt, { Emitter } from 'mitt';

export interface GameEvents {
  // UI -> Game äº‹ä»¶
  'ui:build_unit': { unitType: string; position: Point2D };
  'ui:pause_game': { paused: boolean };
  'ui:save_game': { saveSlot: number };
  
  // Game -> UI äº‹ä»¶
  'game:health_changed': { playerId: string; health: number };
  'game:resource_updated': { resource: string; amount: number };
  'game:scene_changed': { from: string; to: string };
  
  // AI Worker äº‹ä»¶
  'ai:calculation_complete': { requestId: string; result: unknown };
  'ai:error': { requestId: string; error: Error };
}

export class EventBus {
  private emitter: Emitter<GameEvents>;
  
  constructor() {
    this.emitter = mitt<GameEvents>();
  }
  
  // å‘é€äº‹ä»¶
  emit<K extends keyof GameEvents>(type: K, payload: GameEvents[K]): void {
    this.emitter.emit(type, payload);
  }
  
  // ç›‘å¬äº‹ä»¶
  on<K extends keyof GameEvents>(
    type: K, 
    handler: (payload: GameEvents[K]) => void
  ): void {
    this.emitter.on(type, handler);
  }
  
  // ç§»é™¤ç›‘å¬
  off<K extends keyof GameEvents>(
    type: K, 
    handler: (payload: GameEvents[K]) => void
  ): void {
    this.emitter.off(type, handler);
  }
  
  // æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨
  clear(): void {
    this.emitter.all.clear();
  }
}
```

### 6.1.5 è¿›ç¨‹é—´é€šä¿¡æ‹“æ‰‘æ€»ç»“

#### é€šä¿¡å±‚æ¬¡ä¸åè®®

| é€šä¿¡è·¯å¾„ | æŠ€æœ¯å®ç° | ç‰¹æ€§ | é€‚ç”¨åœºæ™¯ |
|---------|---------|------|---------|
| **React UI â†” Phaser Game** | EventBus (mitt) | åŒæ­¥ã€ä½å»¶è¿Ÿã€é«˜é¢‘ | UIäº¤äº’ã€æ¸¸æˆçŠ¶æ€å®æ—¶åŒæ­¥ |
| **Phaser Game â†” AI Worker** | postMessage/onmessage | å¼‚æ­¥ã€åºåˆ—åŒ–å¼€é”€ | AIè®¡ç®—ä»»åŠ¡ã€ç»“æœå›è°ƒ |
| **Renderer â†” Main Process** | Electron IPC + preload.js | å¼‚æ­¥ã€å®‰å…¨éš”ç¦» | æ–‡ä»¶æ“ä½œã€ç³»ç»Ÿå¯¹è¯æ¡† |

#### æ•°æ®æµå‘ä¸æ€§èƒ½ä¼˜åŒ–

```typescript
// core/communication/DataFlow.ts - æ•°æ®æµæ§åˆ¶å™¨
export class DataFlowController {
  private eventBus: EventBus;
  private aiWorker: Worker;
  private gameStateCache = new Map<string, unknown>();
  
  constructor(eventBus: EventBus, aiWorker: Worker) {
    this.eventBus = eventBus;
    this.aiWorker = aiWorker;
    this.setupDataFlowOptimization();
  }
  
  private setupDataFlowOptimization(): void {
    // é™åˆ¶AI Workeré€šä¿¡é¢‘ç‡ (æœ€å¤š4æ¬¡/ç§’)
    let lastAIUpdate = 0;
    const AI_UPDATE_INTERVAL = 250;
    
    this.eventBus.on('game:state_update', (gameState) => {
      const now = Date.now();
      if (now - lastAIUpdate >= AI_UPDATE_INTERVAL) {
        this.sendToAIWorker('state_update', gameState);
        lastAIUpdate = now;
      }
    });
    
    // ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ¸¸æˆçŠ¶æ€
    this.eventBus.on('game:resource_updated', (data) => {
      this.gameStateCache.set(`resource_${data.resource}`, data.amount);
    });
  }
  
  private sendToAIWorker(type: string, payload: unknown): void {
    this.aiWorker.postMessage({
      id: crypto.randomUUID(),
      type,
      timestamp: Date.now(),
      payload
    });
  }
}
```

### 6.1.6 ç”Ÿå‘½å‘¨æœŸç®¡ç†ä¸é”™è¯¯å¤„ç†

#### åº”ç”¨å¯åŠ¨åºåˆ—

```typescript
// main.ts - åº”ç”¨å¯åŠ¨åºåˆ—ç®¡ç†
class ApplicationLifecycle {
  private static instance: ApplicationLifecycle;
  private startupTasks: (() => Promise<void>)[] = [];
  
  async startup(): Promise<void> {
    console.log('ğŸš€ å¼€å§‹åº”ç”¨å¯åŠ¨åºåˆ—...');
    
    // 1. ä¸»è¿›ç¨‹åˆå§‹åŒ–
    await this.initializeMainProcess();
    
    // 2. åˆ›å»ºä¸»çª—å£
    const mainWindow = await this.createMainWindow();
    
    // 3. ç­‰å¾…æ¸²æŸ“è¿›ç¨‹å°±ç»ª
    await this.waitForRendererReady(mainWindow);
    
    // 4. åˆå§‹åŒ–æ¸¸æˆç³»ç»Ÿ
    await this.initializeGameSystems(mainWindow);
    
    console.log('âœ… åº”ç”¨å¯åŠ¨å®Œæˆ');
  }
  
  async shutdown(): Promise<void> {
    console.log('ğŸ›‘ å¼€å§‹åº”ç”¨å…³é—­åºåˆ—...');
    
    // 1. ä¿å­˜æ¸¸æˆçŠ¶æ€
    await this.saveApplicationState();
    
    // 2. åœæ­¢AI Worker
    await this.terminateWorkers();
    
    // 3. æ¸…ç†Phaserèµ„æº
    await this.cleanupGameResources();
    
    // 4. å…³é—­æ‰€æœ‰çª—å£
    await this.closeAllWindows();
    
    console.log('âœ… åº”ç”¨å…³é—­å®Œæˆ');
  }
}
```

#### é”™è¯¯ä¼ æ’­ä¸æ¢å¤ç­–ç•¥

```typescript
// core/error/ErrorBoundary.ts - é”™è¯¯è¾¹ç•Œç®¡ç†
export class RuntimeErrorHandler {
  private errorCounts = new Map<string, number>();
  private readonly MAX_ERRORS_PER_COMPONENT = 3;
  
  handleWorkerError(error: Error, workerId: string): void {
    console.error(`Worker ${workerId} error:`, error);
    
    const count = this.errorCounts.get(workerId) || 0;
    this.errorCounts.set(workerId, count + 1);
    
    if (count >= this.MAX_ERRORS_PER_COMPONENT) {
      // è¾¾åˆ°é”™è¯¯é˜ˆå€¼ï¼Œé‡å¯Worker
      this.restartWorker(workerId);
      this.errorCounts.delete(workerId);
    }
  }
  
  handlePhaserError(error: Error, scene: string): void {
    console.error(`Phaser scene ${scene} error:`, error);
    
    // å°†æ¸¸æˆé”™è¯¯ä¼ æ’­åˆ°Reacté”™è¯¯è¾¹ç•Œ
    this.eventBus.emit('game:error', {
      error: error.message,
      scene,
      timestamp: Date.now()
    });
  }
  
  private restartWorker(workerId: string): void {
    console.log(`ğŸ”„ é‡å¯Worker: ${workerId}`);
    // å®ç°Workeré‡å¯é€»è¾‘
  }
}
```

---

## 6.2 å¾ªç¯ä¸è°ƒåº¦

> é‡‡ç”¨ `GameLoop` å°è£… **tick(update)** è°ƒåº¦ï¼Œä¸ Phaser çš„ `scene.update` æ¥å£å¯¹é½ã€‚

### 6.2.1 æ¸¸æˆå¾ªç¯æ¶æ„è®¾è®¡

**æ ¸å¿ƒè®¾è®¡åŸåˆ™**ï¼š
- **60FPSç›®æ ‡**ï¼šæ¯å¸§16.67msçš„é¢„ç®—æ§åˆ¶
- **ä¼˜å…ˆçº§è°ƒåº¦**ï¼šUIå“åº” > æ¸¸æˆé€»è¾‘ > AIè®¡ç®—
- **æ—¶é—´åˆ‡ç‰‡**ï¼šé•¿æ—¶é—´ä»»åŠ¡è‡ªåŠ¨åˆ†ç‰‡å¤„ç†
- **èƒŒå‹æ§åˆ¶**ï¼šè´Ÿè½½è¿‡é«˜æ—¶ä¼˜é›…é™çº§

```typescript
// core/loop/GameLoop.ts - æ¸¸æˆå¾ªç¯ç®¡ç†å™¨
export class GameLoop {
  private static readonly TARGET_FPS = 60;
  private static readonly FRAME_BUDGET = 1000 / GameLoop.TARGET_FPS; // 16.67ms
  
  private isRunning = false;
  private lastFrameTime = 0;
  private frameId: number | null = null;
  private performanceMonitor = new PerformanceMonitor();
  
  constructor(
    private phaserGame: Phaser.Game,
    private reactUpdater: ReactUpdater,
    private aiScheduler: AITaskScheduler
  ) {}
  
  start(): void {
    if (this.isRunning) return;
    
    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.tick();
  }
  
  private tick = (): void => {
    if (!this.isRunning) return;
    
    const currentTime = performance.now();
    const deltaTime = currentTime - this.lastFrameTime;
    const remainingBudget = GameLoop.FRAME_BUDGET;
    
    // æ€§èƒ½ç›‘æ§
    this.performanceMonitor.startFrame();
    
    try {
      // 1. é«˜ä¼˜å…ˆçº§ï¼šUIæ›´æ–° (é¢„ç•™5ms)
      const uiStartTime = performance.now();
      this.reactUpdater.update(deltaTime);
      const uiTime = performance.now() - uiStartTime;
      
      // 2. æ ¸å¿ƒä¼˜å…ˆçº§ï¼šPhaseræ¸¸æˆå¾ªç¯ (é¢„ç•™8ms)
      const gameStartTime = performance.now();
      this.updatePhaserGame(deltaTime);
      const gameTime = performance.now() - gameStartTime;
      
      // 3. ä½ä¼˜å…ˆçº§ï¼šAIä»»åŠ¡è°ƒåº¦ (å‰©ä½™æ—¶é—´)
      const remainingTime = remainingBudget - uiTime - gameTime - 2; // ä¿ç•™2msç¼“å†²
      if (remainingTime > 0) {
        this.aiScheduler.processTasksWithBudget(remainingTime);
      }
      
    } catch (error) {
      this.handleLoopError(error);
    } finally {
      this.performanceMonitor.endFrame();
      this.lastFrameTime = currentTime;
      this.frameId = requestAnimationFrame(this.tick);
    }
  };
}
```

### 6.2.2 Phaser 3å¾ªç¯æœºåˆ¶æ·±åº¦è§£æ

**æ ¸å¿ƒæ¶æ„ç†è§£**ï¼š
Phaser 3é‡‡ç”¨å•çº¿ç¨‹äº‹ä»¶é©±åŠ¨çš„æ¸¸æˆå¾ªç¯ï¼Œé€šè¿‡`requestAnimationFrame`å®ç°å¹³æ»‘çš„60FPSæ¸²æŸ“ã€‚å…¶å¾ªç¯æ¶æ„ç”±ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶æ„æˆï¼šGameä¸»å®ä¾‹ã€TimeStepæ—¶é—´ç®¡ç†å™¨ã€SceneManageråœºæ™¯è°ƒåº¦å™¨ã€‚

#### Gameä¸»å¾ªç¯é©±åŠ¨

```typescript
// core/loop/PhaserGameLoop.ts - Phaser 3ä¸»å¾ªç¯é›†æˆ
export class PhaserGameLoopManager {
  private phaserGame: Phaser.Game;
  private timeStep: Phaser.Time.TimeStep;
  private customScheduler: CustomTaskScheduler;
  
  constructor(gameConfig: Phaser.Types.Core.GameConfig) {
    this.phaserGame = new Phaser.Game({
      ...gameConfig,
      callbacks: {
        postBoot: this.onGameReady.bind(this),
        postStep: this.onFrameComplete.bind(this)
      }
    });
  }
  
  private onGameReady(game: Phaser.Game): void {
    this.timeStep = game.loop.timeStep;
    this.customScheduler = new CustomTaskScheduler(this.timeStep);
    
    // æ³¨å…¥è‡ªå®šä¹‰è°ƒåº¦å™¨åˆ°æ‰€æœ‰åœºæ™¯
    this.phaserGame.scene.scenes.forEach(scene => {
      scene.registry.set('customScheduler', this.customScheduler);
    });
    
    console.log('ğŸ® Phaser 3ä¸»å¾ªç¯å·²å¯åŠ¨ï¼Œé›†æˆè‡ªå®šä¹‰è°ƒåº¦å™¨');
  }
  
  private onFrameComplete(time: number, delta: number): void {
    // å¸§åå¤„ç†ï¼šæ€§èƒ½ç»Ÿè®¡ã€å†…å­˜æ¸…ç†ã€çŠ¶æ€åŒæ­¥
    this.performanceMonitor.recordFrame(delta);
    this.syncReactState();
  }
}
```

#### å¾ªç¯æ‰§è¡Œé¡ºåºè¯¦è§£

Phaser 3çš„æ¯ä¸€å¸§æ‰§è¡Œéµå¾ªä¸¥æ ¼çš„é¡ºåºï¼š

```mermaid
graph TD
    A[requestAnimationFrame] --> B[Game.step]
    B --> C[TimeStep.step]
    C --> D[SceneManager.update]
    D --> E[Scene PRE_UPDATE]
    E --> F[Scene UPDATE]
    F --> G[Scene POST_UPDATE]
    G --> H[Renderer.render]
    H --> A
```

### 6.2.3 TimeStepæ—¶é—´ç®¡ç†ç³»ç»Ÿ

**æ—¶é—´ç²¾åº¦æ§åˆ¶**ï¼š
TimeStepç³»ç»Ÿè´Ÿè´£å°†æµè§ˆå™¨çš„é«˜ç²¾åº¦æ—¶é—´æˆ³è½¬æ¢ä¸ºæ¸¸æˆé€»è¾‘å¯ç”¨çš„å¢é‡æ—¶é—´ï¼Œå®ç°ç¡®å®šæ€§çš„å›ºå®šæ­¥é•¿æ¨¡æ‹Ÿå’Œè‡ªé€‚åº”çš„å¯å˜æ­¥é•¿æ¸²æŸ“ã€‚

#### å›ºå®šæ­¥é•¿ vs å¯å˜æ­¥é•¿åˆ¤æ®è¡¨

| ç³»ç»Ÿç±»å‹ | æ­¥é•¿ç­–ç•¥ | ä½¿ç”¨åœºæ™¯ | åŸå›  |
|----------|----------|----------|------|
| **ç‰©ç†è®¡ç®—** | å›ºå®šæ­¥é•¿(16.67ms) | ç¢°æ’æ£€æµ‹ã€é‡åŠ›æ¨¡æ‹Ÿ | ç¡®ä¿æ•°å€¼ç¨³å®šæ€§ã€å¯é‡ç°æ€§ |
| **AIå†³ç­–** | å›ºå®šæ­¥é•¿(16.67ms) | NPCè¡Œä¸ºã€è·¯å¾„è§„åˆ’ | ä¿è¯å†³ç­–ä¸€è‡´æ€§ã€é¿å…æ—¶é—´ç›¸å…³bug |
| **æ¸¸æˆé€»è¾‘** | å›ºå®šæ­¥é•¿(16.67ms) | çŠ¶æ€æ›´æ–°ã€è§„åˆ™è®¡ç®— | ç½‘ç»œåŒæ­¥ã€å½•åƒå›æ”¾ |
| **æ¸²æŸ“ç³»ç»Ÿ** | å¯å˜æ­¥é•¿(rAF) | WebGLç»˜åˆ¶ã€åŠ¨ç”»æ’å€¼ | é€‚åº”ç¡¬ä»¶æ€§èƒ½ã€è§†è§‰æµç•…åº¦ |
| **UIæ›´æ–°** | å¯å˜æ­¥é•¿(rAF) | Reactç»„ä»¶ã€DOMæ“ä½œ | ç”¨æˆ·äº¤äº’å“åº”æ€§ |

```typescript
// core/time/TimeStepController.ts - ç¡®å®šæ€§æ—¶é—´æ­¥é•¿æ§åˆ¶å™¨
export class TimeStepController {
  private static readonly FIXED_STEP = 1000 / 60; // 16.67mså›ºå®šæ­¥é•¿
  private static readonly MAX_ACCUMULATED_TIME = 250; // é˜²æ­¢æ­»äº¡èºæ—‹
  
  private accumulator = 0;
  private lastTime = 0;
  private interpolationAlpha = 0;
  
  constructor(private phaserTimeStep: Phaser.Time.TimeStep) {
    // é…ç½®Phaser forå¯å˜æ­¥é•¿æ¸²æŸ“
    this.phaserTimeStep.targetDelta = TimeStepController.FIXED_STEP;
    this.phaserTimeStep.smoothStep = true;
    this.phaserTimeStep.maxDelta = 33.33; // æœ€å¤§30FPSå…œåº•
  }
  
  /* ä¸»æ¸¸æˆå¾ªç¯ - åˆ†ç¦»æ¨¡æ‹Ÿä¸æ¸²æŸ“ */
  update(currentTime: number): GameLoopResult {
    const frameTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // ç´¯ç§¯æ—¶é—´ï¼Œé˜²æ­¢æ­»äº¡èºæ—‹
    this.accumulator += Math.min(frameTime, TimeStepController.MAX_ACCUMULATED_TIME);
    
    let simulationSteps = 0;
    const maxSteps = 5; // é™åˆ¶å•å¸§æœ€å¤§æ¨¡æ‹Ÿæ­¥æ•°
    
    // å›ºå®šæ­¥é•¿æ¨¡æ‹Ÿå¾ªç¯
    while (this.accumulator >= TimeStepController.FIXED_STEP && simulationSteps < maxSteps) {
      this.updateGameLogic(TimeStepController.FIXED_STEP); // ç¡®å®šæ€§æ›´æ–°
      this.accumulator -= TimeStepController.FIXED_STEP;
      simulationSteps++;
    }
    
    // è®¡ç®—æ’å€¼ç³»æ•°ç”¨äºæ¸²æŸ“
    this.interpolationAlpha = this.accumulator / TimeStepController.FIXED_STEP;
    
    return {
      simulationSteps,
      interpolationAlpha: this.interpolationAlpha,
      frameTime,
      shouldRender: true
    };
  }
  
  /* ç¡®å®šæ€§æ¸¸æˆé€»è¾‘æ›´æ–° */
  private updateGameLogic(fixedDelta: number): void {
    // ç‰©ç†ç³»ç»Ÿ - å›ºå®šæ­¥é•¿ç¡®ä¿æ•°å€¼ç¨³å®š
    this.physicsWorld.step(fixedDelta);
    
    // AIç³»ç»Ÿ - å›ºå®šæ­¥é•¿ä¿è¯å†³ç­–ä¸€è‡´æ€§
    this.aiSystem.update(fixedDelta);
    
    // æ¸¸æˆè§„åˆ™ - å›ºå®šæ­¥é•¿æ”¯æŒå½•åƒå›æ”¾
    this.gameRules.update(fixedDelta);
    
    // äº‹ä»¶ç³»ç»Ÿ - ç¡®å®šæ€§äº‹ä»¶å¤„ç†
    this.eventSystem.processEvents(fixedDelta);
  }
  
  /* å¯å˜æ­¥é•¿æ¸²æŸ“æ›´æ–° */
  renderWithInterpolation(renderer: Phaser.Renderer): void {
    // ä½¿ç”¨æ’å€¼æä¾›æµç•…è§†è§‰æ•ˆæœ
    this.sceneManager.renderWithAlpha(this.interpolationAlpha);
    
    // UIå±‚ä½¿ç”¨å¯å˜æ­¥é•¿ç¡®ä¿å“åº”æ€§
    this.uiManager.updateVariableStep(performance.now());
  }
  
  /* æ€§èƒ½æŒ‡æ ‡ç›‘æ§ */
  getPerformanceMetrics(): TimeStepMetrics {
    return {
      fixedStepFPS: 1000 / TimeStepController.FIXED_STEP,
      actualFPS: this.calculateActualFPS(),
      accumulatorRatio: this.accumulator / TimeStepController.FIXED_STEP,
      simulationLoad: this.getSimulationLoad(),
      renderLoad: this.getRenderLoad()
    };
  }
  
  /* æ£€æµ‹æ€§èƒ½å‹åŠ› */
  isUnderPerformancePressure(): boolean {
    return this.accumulator > TimeStepController.FIXED_STEP * 2; // è½å2å¸§ä»¥ä¸Š
  }
}

/* æ¸¸æˆå¾ªç¯ç»“æœæ¥å£ */
interface GameLoopResult {
  simulationSteps: number;
  interpolationAlpha: number; 
  frameTime: number;
  shouldRender: boolean;
}

/* æ—¶é—´æ­¥é•¿æ€§èƒ½æŒ‡æ ‡ */
interface TimeStepMetrics {
  fixedStepFPS: number;     // å›ºå®šæ­¥é•¿FPS (60)
  actualFPS: number;        // å®é™…æ¸²æŸ“FPS
  accumulatorRatio: number; // ç´¯ç§¯å™¨æ¯”ç‡
  simulationLoad: number;   // æ¨¡æ‹Ÿè´Ÿè½½ %
  renderLoad: number;       // æ¸²æŸ“è´Ÿè½½ %
}
```

#### Phaser TimeStepé›†æˆé…ç½®

```typescript
// core/time/PhaserIntegration.ts - Phaser TimeStepæ·±åº¦é›†æˆ
export class PhaserTimeStepIntegration {
  constructor(private game: Phaser.Game, private controller: TimeStepController) {
    this.configurePhaserTimeStep();
  }
  
  private configurePhaserTimeStep(): void {
    const timeStep = this.game.loop;
    
    // ç¦ç”¨Phaserå†…ç½®æ—¶é—´å¹³æ»‘ï¼Œä½¿ç”¨æˆ‘ä»¬çš„æ§åˆ¶å™¨
    timeStep.smoothStep = false;
    timeStep.forceSetTimeOut = true; // å¼ºåˆ¶ä½¿ç”¨setTimeoutè€ŒérAF
    
    // è¦†ç›–Phaserçš„stepæ–¹æ³•
    const originalStep = timeStep.step.bind(timeStep);
    timeStep.step = (time: number) => {
      const result = this.controller.update(time);
      
      if (result.shouldRender) {
        // åªæœ‰åœ¨éœ€è¦æ—¶æ‰è°ƒç”¨Phaseræ¸²æŸ“
        originalStep(time);
        this.controller.renderWithInterpolation(this.game.renderer);
      }
    };
  }
  
  /* åŠ¨æ€è°ƒæ•´ç›®æ ‡å¸§ç‡ */
  adjustTargetFPS(newFPS: number): void {
    if ([30, 60, 120, 144].includes(newFPS)) {
      this.controller.setFixedStep(1000 / newFPS);
      console.log(`ğŸ¯ TimeStep adjusted to ${newFPS}FPS fixed step`);
    }
  }
}
```

### 6.2.4 Sceneä¸‰é˜¶æ®µæ›´æ–°è¯¦è§£

**æ›´æ–°é˜¶æ®µèŒè´£åˆ’åˆ†**ï¼š
æ¯ä¸ªPhaser Sceneçš„æ›´æ–°å‘¨æœŸè¢«ç²¾ç¡®åˆ’åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼Œç¡®ä¿æ¸¸æˆç³»ç»Ÿçš„æœ‰åºæ‰§è¡Œå’ŒçŠ¶æ€ä¸€è‡´æ€§ã€‚

#### PRE_UPDATEé˜¶æ®µï¼ˆç³»ç»Ÿæ›´æ–°ï¼‰

```typescript
// scenes/GameScene.ts - Sceneæ›´æ–°å‘¨æœŸç®¡ç†
export class GameScene extends Phaser.Scene {
  private customScheduler: CustomTaskScheduler;
  private performanceBudget = 8.0; // 8msé¢„ç®—åˆ†é…
  
  preUpdate(time: number, delta: number): void {
    super.preUpdate(time, delta);
    
    // ç³»ç»Ÿçº§æ›´æ–°ï¼ˆç”±Phaserè‡ªåŠ¨å¤„ç†ï¼‰ï¼š
    // 1. è¾“å…¥ç³»ç»Ÿæ›´æ–° - å¤„ç†é”®ç›˜ã€é¼ æ ‡ã€è§¦æ‘¸äº‹ä»¶
    // 2. åŠ¨ç”»ç³»ç»Ÿæ›´æ–° - Tweenã€TimelineåŠ¨ç”»æ­¥è¿›
    // 3. ç‰©ç†ç³»ç»Ÿé¢„æ›´æ–° - ç¢°æ’æ£€æµ‹å‡†å¤‡ã€é€Ÿåº¦ç§¯åˆ†
    // 4. å£°éŸ³ç³»ç»Ÿæ›´æ–° - éŸ³é¢‘æ’­æ”¾çŠ¶æ€åŒæ­¥
    
    this.emit('preupdate', time, delta);
  }
  
  update(time: number, delta: number): void {
    const updateStartTime = performance.now();
    
    // ç”¨æˆ·é€»è¾‘æ›´æ–°é˜¶æ®µ
    try {
      // 1. é«˜ä¼˜å…ˆçº§ï¼šæ¸¸æˆæ ¸å¿ƒé€»è¾‘
      this.updateGameCore(time, delta);
      
      // 2. ä¸­ä¼˜å…ˆçº§ï¼šGameObjectæ›´æ–°
      this.updateGameObjects(time, delta);
      
      // 3. ä½ä¼˜å…ˆçº§ï¼šè‡ªå®šä¹‰ä»»åŠ¡è°ƒåº¦
      const remainingBudget = this.performanceBudget - (performance.now() - updateStartTime);
      if (remainingBudget > 1.0) {
        this.customScheduler.executeTasksWithBudget(remainingBudget);
      }
      
    } catch (error) {
      this.handleUpdateError(error, time, delta);
    }
  }
  
  private updateGameCore(time: number, delta: number): void {
    // æ¸¸æˆæ ¸å¿ƒé€»è¾‘ï¼šç©å®¶æ§åˆ¶ã€æ¸¸æˆè§„åˆ™ã€èƒœè´Ÿåˆ¤å®š
    this.playerController.update(time, delta);
    this.gameRuleEngine.update(time, delta);
    this.achievementSystem.update(time, delta);
  }
  
  private updateGameObjects(time: number, delta: number): void {
    // GameObjectæ›´æ–°ï¼šè‡ªåŠ¨è°ƒç”¨æ‰€æœ‰æ´»è·ƒå¯¹è±¡çš„updateæ–¹æ³•
    // ç”±Phaserè‡ªåŠ¨ç®¡ç†ï¼ŒåŒ…æ‹¬Spriteã€Containerã€Groupç­‰
    super.update(time, delta);
  }
}
```

#### POST_UPDATEé˜¶æ®µï¼ˆæ¸…ç†ä¸æ¸²æŸ“å‡†å¤‡ï¼‰

```typescript
// core/scene/PostUpdateManager.ts - åæ›´æ–°å¤„ç†
export class PostUpdateManager {
  constructor(private scene: Phaser.Scene) {
    this.scene.events.on('postupdate', this.handlePostUpdate.bind(this));
  }
  
  private handlePostUpdate(time: number, delta: number): void {
    // 1. ç‰©ç†ç³»ç»Ÿåå¤„ç†
    this.finalizePhysicsUpdate();
    
    // 2. ç›¸æœºç³»ç»Ÿæ›´æ–°
    this.updateCameraTransforms();
    
    // 3. æ¸²æŸ“åˆ—è¡¨ä¼˜åŒ–
    this.optimizeRenderList();
    
    // 4. åƒåœ¾å›æ”¶æç¤º
    this.suggestGarbageCollection();
  }
  
  private finalizePhysicsUpdate(): void {
    // ç¢°æ’æ£€æµ‹ç»“æœå¤„ç†
    // ç‰©ç†ä½“ä½ç½®åŒæ­¥
    // ç¢°æ’å›è°ƒè§¦å‘
  }
  
  private updateCameraTransforms(): void {
    // ç›¸æœºè·Ÿéšé€»è¾‘
    // è§†å£è¾¹ç•Œè®¡ç®—
    // æ¸²æŸ“å˜æ¢çŸ©é˜µæ›´æ–°
  }
}
```

### 6.2.5 è‡ªå®šä¹‰è°ƒåº¦å™¨é›†æˆæ–¹æ¡ˆ

**ä»»åŠ¡ä¼˜å…ˆçº§è°ƒåº¦**ï¼š
åœ¨Phaser 3å¾ªç¯ä¸­é›†æˆè‡ªå®šä¹‰ä»»åŠ¡è°ƒåº¦å™¨ï¼Œå®ç°AIè®¡ç®—ã€æ•°æ®åŒæ­¥ç­‰åå°ä»»åŠ¡çš„æœ‰åºæ‰§è¡Œã€‚

```typescript
// core/scheduler/CustomTaskScheduler.ts - è‡ªå®šä¹‰ä»»åŠ¡è°ƒåº¦å™¨
export class CustomTaskScheduler {
  private taskQueue: PriorityQueue<ScheduledTask> = new PriorityQueue();
  private runningTasks = new Set<string>();
  private completedTasks = new Map<string, TaskResult>();
  
  constructor(private timeStep: Phaser.Time.TimeStep) {}
  
  scheduleTask(task: ScheduledTask): string {
    const taskId = crypto.randomUUID();
    task.id = taskId;
    task.scheduledAt = this.timeStep.time;
    
    this.taskQueue.enqueue(task, task.priority);
    return taskId;
  }
  
  executeTasksWithBudget(budgetMs: number): TaskExecutionReport {
    const startTime = performance.now();
    const executed: ScheduledTask[] = [];
    const failed: TaskError[] = [];
    
    while (!this.taskQueue.isEmpty() && (performance.now() - startTime) < budgetMs) {
      const task = this.taskQueue.dequeue();
      
      try {
        const result = this.executeTask(task);
        this.completedTasks.set(task.id, result);
        executed.push(task);
      } catch (error) {
        failed.push({ task, error: error.message });
      }
    }
    
    return {
      executed,
      failed,
      totalTime: performance.now() - startTime,
      remainingTasks: this.taskQueue.size()
    };
  }
  
  private executeTask(task: ScheduledTask): TaskResult {
    this.runningTasks.add(task.id);
    
    let result: TaskResult;
    switch (task.type) {
      case 'ai_pathfinding':
        result = this.executePathfinding(task as PathfindingTask);
        break;
      case 'ai_decision_making':
        result = this.executeDecisionMaking(task as DecisionTask);
        break;
      case 'data_sync':
        result = this.executeDataSync(task as DataSyncTask);
        break;
      default:
        throw new Error(`æœªçŸ¥ä»»åŠ¡ç±»å‹: ${task.type}`);
    }
    
    this.runningTasks.delete(task.id);
    return result;
  }
}

// ä»»åŠ¡ç±»å‹å®šä¹‰
export interface ScheduledTask {
  id: string;
  type: 'ai_pathfinding' | 'ai_decision_making' | 'data_sync';
  priority: number; // 1-10, æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
  payload: unknown;
  scheduledAt: number;
  maxExecutionTime?: number;
}

export enum TaskPriority {
  CRITICAL = 1,    // å…³é”®æ¸¸æˆé€»è¾‘
  HIGH = 3,        // ç”¨æˆ·äº¤äº’å“åº”
  MEDIUM = 5,      // AIè®¡ç®—
  LOW = 7,         // æ•°æ®åŒæ­¥
  BACKGROUND = 10  // åå°ç»´æŠ¤
}
```

### 6.2.6 åŒå¾ªç¯åè°ƒä¸æ€§èƒ½ä¼˜åŒ–

**React-Phaseråè°ƒæœºåˆ¶**ï¼š
è§£å†³Reactæ¸²æŸ“å¾ªç¯ä¸Phaseræ¸¸æˆå¾ªç¯çš„åè°ƒé—®é¢˜ï¼Œé¿å…å¸§ç‡å†²çªå’Œèµ„æºç«äº‰ã€‚

```typescript
// core/coordination/DualLoopCoordinator.ts - åŒå¾ªç¯åè°ƒå™¨
export class DualLoopCoordinator {
  private phaserLoop: GameLoop;
  private reactScheduler: React.Scheduler;
  private eventBus: EventBus;
  
  // å¾ªç¯ä¼˜å…ˆçº§é…ç½®
  private loopPriorities = {
    phaser: 1,      // æœ€é«˜ä¼˜å…ˆçº§ï¼šæ¸¸æˆæ¸²æŸ“
    react: 2,       // ä¸­ä¼˜å…ˆçº§ï¼šUIæ›´æ–°
    background: 3   // ä½ä¼˜å…ˆçº§ï¼šåå°ä»»åŠ¡
  };
  
  constructor() {
    this.setupCoordination();
  }
  
  private setupCoordination(): void {
    // 1. Reactæ›´æ–°è°ƒåº¦ä¼˜åŒ–
    this.scheduleReactUpdates();
    
    // 2. çŠ¶æ€åŒæ­¥æœºåˆ¶
    this.setupStateSynchronization();
    
    // 3. æ€§èƒ½ç›‘æ§
    this.enablePerformanceMonitoring();
  }
  
  private scheduleReactUpdates(): void {
    // ä½¿ç”¨requestIdleCallbackè°ƒåº¦Reactæ›´æ–°
    const updateReactInIdleTime = (deadline: IdleDeadline) => {
      while (deadline.timeRemaining() > 0 && this.hasReactUpdates()) {
        this.processReactUpdate();
      }
      
      if (this.hasReactUpdates()) {
        requestIdleCallback(updateReactInIdleTime);
      }
    };
    
    requestIdleCallback(updateReactInIdleTime);
  }
  
  private setupStateSynchronization(): void {
    // Phaser -> React çŠ¶æ€åŒæ­¥ï¼ˆä½é¢‘ï¼‰
    let lastSyncTime = 0;
    const SYNC_INTERVAL = 100; // æ¯100msåŒæ­¥ä¸€æ¬¡
    
    this.phaserLoop.onFrameUpdate((time, delta) => {
      if (time - lastSyncTime >= SYNC_INTERVAL) {
        this.syncGameStateToReact();
        lastSyncTime = time;
      }
    });
    
    // React -> Phaser å‘½ä»¤ä¼ é€’ï¼ˆå³æ—¶ï¼‰
    this.eventBus.on('ui:game_command', (command) => {
      this.forwardCommandToPhaser(command);
    });
  }
  
  getPerformanceReport(): DualLoopPerformanceReport {
    return {
      phaserFPS: this.phaserLoop.getCurrentFPS(),
      reactRenderTime: this.reactScheduler.getAverageRenderTime(),
      syncOverhead: this.calculateSyncOverhead(),
      memoryUsage: this.getMemoryUsage(),
      recommendations: this.generatePerformanceRecommendations()
    };
  }
}

// æ€§èƒ½é¢„ç®—åˆ†é…è¡¨
export const PERFORMANCE_BUDGET = {
  total: 16.67,           // 60FPSæ€»é¢„ç®—
  phaser: 10.0,           // Phaseræ¸¸æˆé€»è¾‘ (60%)
  react: 4.0,             // React UIæ¸²æŸ“ (24%)
  synchronization: 1.5,   // çŠ¶æ€åŒæ­¥ (9%)
  buffer: 1.17           // æ€§èƒ½ç¼“å†² (7%)
} as const;
```

### 6.2.7 é”™è¯¯æ¢å¤ä¸é™çº§ç­–ç•¥

**å¾ªç¯å¼‚å¸¸å¤„ç†**ï¼š
ç¡®ä¿å•ä¸ªç»„ä»¶çš„é”™è¯¯ä¸ä¼šå¯¼è‡´æ•´ä¸ªæ¸¸æˆå¾ªç¯å´©æºƒï¼Œæä¾›ä¼˜é›…çš„é™çº§æœºåˆ¶ã€‚

```typescript
// core/resilience/LoopResilienceManager.ts - å¾ªç¯å¼¹æ€§ç®¡ç†
export class LoopResilienceManager {
  private errorCounts = new Map<string, number>();
  private disabledComponents = new Set<string>();
  private fallbackStrategies = new Map<string, FallbackStrategy>();
  
  private readonly ERROR_THRESHOLDS = {
    warning: 3,      // 3æ¬¡é”™è¯¯åè­¦å‘Š
    disable: 5,      // 5æ¬¡é”™è¯¯åç¦ç”¨ç»„ä»¶
    critical: 10     // 10æ¬¡é”™è¯¯åè¿›å…¥ç´§æ€¥æ¨¡å¼
  };
  
  handleLoopError(error: Error, component: string, context: ErrorContext): void {
    const currentCount = this.errorCounts.get(component) || 0;
    this.errorCounts.set(component, currentCount + 1);
    
    console.error(`ğŸš¨ å¾ªç¯ç»„ä»¶é”™è¯¯ [${component}]: ${error.message}`);
    
    if (currentCount >= this.ERROR_THRESHOLDS.critical) {
      this.enterEmergencyMode(component, error);
    } else if (currentCount >= this.ERROR_THRESHOLDS.disable) {
      this.disableComponent(component, error);
    } else if (currentCount >= this.ERROR_THRESHOLDS.warning) {
      this.applyFallbackStrategy(component, error);
    }
    
    // é”™è¯¯ä¸ŠæŠ¥
    this.reportError(error, component, context);
  }
  
  private disableComponent(component: string, error: Error): void {
    this.disabledComponents.add(component);
    
    console.warn(`âš ï¸ ç»„ä»¶å·²ç¦ç”¨: ${component} (é”™è¯¯æ¬¡æ•°è¿‡å¤š)`);
    
    // é€šçŸ¥ç”¨æˆ·
    this.eventBus.emit('system:component_disabled', {
      component,
      reason: error.message,
      timestamp: Date.now()
    });
  }
  
  private enterEmergencyMode(component: string, error: Error): void {
    console.error(`ğŸ†˜ è¿›å…¥ç´§æ€¥æ¨¡å¼: ${component} ç»„ä»¶ä¸¥é‡æ•…éšœ`);
    
    // å¯åŠ¨æœ€å°åŒ–æ¸¸æˆå¾ªç¯
    this.enableMinimalLoop();
    
    // ä¿å­˜æ¸¸æˆçŠ¶æ€
    this.emergencySaveGame();
    
    // æ˜¾ç¤ºé”™è¯¯æ¢å¤ç•Œé¢
    this.showRecoveryUI(component, error);
  }
}
```

## 6.3 çŠ¶æ€æœº

> `AppState`ï¼š`boot -> loading -> running -> paused -> error`ï¼Œæ˜ç¡®æ¯ä¸ªçŠ¶æ€çš„è¿›å…¥/é€€å‡ºæ¡ä»¶ä¸å›é€€è·¯å¾„ã€‚

### 6.3.1 åº”ç”¨çŠ¶æ€æœºè®¾è®¡

```typescript
// core/state/AppStateMachine.ts - åº”ç”¨çŠ¶æ€æœº
export enum AppState {
  BOOT = 'boot',           // åº”ç”¨å¯åŠ¨ä¸­
  LOADING = 'loading',     // èµ„æºåŠ è½½ä¸­
  RUNNING = 'running',     // æ­£å¸¸è¿è¡Œ
  PAUSED = 'paused',       // æš‚åœçŠ¶æ€
  ERROR = 'error',         // é”™è¯¯çŠ¶æ€
  SHUTDOWN = 'shutdown'    // å…³é—­ä¸­
}

export class AppStateMachine {
  private currentState = AppState.BOOT;
  private previousState: AppState | null = null;
  private stateHistory: AppState[] = [];
  private transitionHandlers = new Map<string, () => Promise<void>>();
  
  // çŠ¶æ€è½¬æ¢å®šä¹‰
  private readonly validTransitions = new Map<AppState, AppState[]>([
    [AppState.BOOT, [AppState.LOADING, AppState.ERROR]],
    [AppState.LOADING, [AppState.RUNNING, AppState.ERROR]],
    [AppState.RUNNING, [AppState.PAUSED, AppState.ERROR, AppState.SHUTDOWN]],
    [AppState.PAUSED, [AppState.RUNNING, AppState.ERROR, AppState.SHUTDOWN]],
    [AppState.ERROR, [AppState.LOADING, AppState.SHUTDOWN]],
    [AppState.SHUTDOWN, []] // ç»ˆæ€
  ]);
  
  async transitionTo(newState: AppState, context?: StateTransitionContext): Promise<boolean> {
    const validTargets = this.validTransitions.get(this.currentState) || [];
    
    if (!validTargets.includes(newState)) {
      console.warn(`âŒ æ— æ•ˆçŠ¶æ€è½¬æ¢: ${this.currentState} -> ${newState}`);
      return false;
    }
    
    try {
      // æ‰§è¡ŒçŠ¶æ€é€€å‡ºå¤„ç†
      await this.executeExitHandler(this.currentState);
      
      // è®°å½•çŠ¶æ€å†å²
      this.previousState = this.currentState;
      this.stateHistory.push(this.currentState);
      
      // åˆ‡æ¢çŠ¶æ€
      this.currentState = newState;
      
      // æ‰§è¡ŒçŠ¶æ€è¿›å…¥å¤„ç†
      await this.executeEnterHandler(newState, context);
      
      console.log(`âœ… çŠ¶æ€è½¬æ¢æˆåŠŸ: ${this.previousState} -> ${newState}`);
      return true;
      
    } catch (error) {
      console.error(`âŒ çŠ¶æ€è½¬æ¢å¤±è´¥: ${this.previousState} -> ${newState}`, error);
      await this.handleTransitionError(error);
      return false;
    }
  }
}
```

### 6.3.2 æœ‰é™çŠ¶æ€æœºç†è®ºåŸºç¡€

**FSMæ ¸å¿ƒæ¦‚å¿µåœ¨æ¸¸æˆä¸­çš„åº”ç”¨**ï¼š
æ¸¸æˆçŠ¶æ€ç®¡ç†éœ€è¦è¶…è¶Šç®€å•çš„çŠ¶æ€åˆ‡æ¢ï¼Œå»ºç«‹å®Œæ•´çš„æœ‰é™çŠ¶æ€æœºç†è®ºä½“ç³»æ¥å¤„ç†å¤æ‚çš„æ¸¸æˆé€»è¾‘ã€‚

#### çŠ¶æ€æœºæ ¸å¿ƒç»„ä»¶

```typescript
// core/state/FSMCore.ts - FSMæ ¸å¿ƒç»„ä»¶å®šä¹‰
export interface StateDefinition<TContext, TState extends string> {
  name: TState;
  
  // çŠ¶æ€å®ˆå«ï¼šæ§åˆ¶çŠ¶æ€è½¬æ¢æ¡ä»¶
  canEnter?: (context: TContext, from?: TState) => boolean;
  canExit?: (context: TContext, to?: TState) => boolean;
  
  // çŠ¶æ€åŠ¨ä½œï¼šçŠ¶æ€ç”Ÿå‘½å‘¨æœŸå¤„ç†
  onEnter?: (context: TContext, from?: TState) => Promise<void> | void;
  onUpdate?: (context: TContext, deltaTime: number) => void;
  onExit?: (context: TContext, to?: TState) => Promise<void> | void;
  
  // çŠ¶æ€å±æ€§ï¼šçŠ¶æ€ç‰¹æ€§æ ‡è®°
  isPersistent?: boolean;    // æ˜¯å¦éœ€è¦æŒä¹…åŒ–
  isParallel?: boolean;     // æ˜¯å¦æ”¯æŒå¹¶å‘æ‰§è¡Œ
  priority?: number;        // å¹¶å‘çŠ¶æ€çš„ä¼˜å…ˆçº§
}

export interface StateTransition<TState extends string> {
  from: TState;
  to: TState;
  event?: string;           // è§¦å‘äº‹ä»¶
  condition?: () => boolean; // è½¬æ¢æ¡ä»¶
  action?: () => Promise<void> | void; // è½¬æ¢åŠ¨ä½œ
}

export interface StateGuard<TContext, TState extends string> {
  condition: (from: TState, to: TState, context: TContext) => boolean;
  errorMessage?: string;
  priority?: number;        // å®ˆå«ä¼˜å…ˆçº§
}
```

### 6.3.3 åˆ†å±‚çŠ¶æ€æœºæ¶æ„

**ä¸‰å±‚çŠ¶æ€ç®¡ç†ä½“ç³»**ï¼š
å»ºç«‹åº”ç”¨çº§ã€åœºæ™¯çº§ã€æ¸¸æˆå¯¹è±¡çº§çš„åˆ†å±‚çŠ¶æ€æœºï¼Œç¡®ä¿ä¸åŒç²’åº¦çŠ¶æ€çš„æ¸…æ™°ç®¡ç†ã€‚

#### åº”ç”¨çº§çŠ¶æ€æœºå¢å¼º

```typescript
// core/state/AppStateMachine.ts - å¢å¼ºçš„åº”ç”¨çŠ¶æ€æœº
export enum AppState {
  BOOT = 'boot',
  PRELOAD = 'preload',       // é¢„åŠ è½½é˜¶æ®µ
  LOADING = 'loading',       // èµ„æºåŠ è½½
  READY = 'ready',          // å‡†å¤‡å°±ç»ª
  RUNNING = 'running',       // æ­£å¸¸è¿è¡Œ
  PAUSED = 'paused',        // æš‚åœçŠ¶æ€
  MINIMIZED = 'minimized',  // æœ€å°åŒ–çŠ¶æ€
  ERROR = 'error',          // é”™è¯¯çŠ¶æ€
  SHUTDOWN = 'shutdown'     // å…³é—­çŠ¶æ€
}

export interface AppContext {
  resourceManager: ResourceManager;
  sceneManager: Phaser.Scenes.SceneManager;
  eventBus: EventBus;
  errorManager: ErrorManager;
  settings: GameSettings;
}

export class EnhancedAppStateMachine extends StateMachine<AppContext, AppState> {
  constructor(context: AppContext) {
    super(context);
    
    this.setupStates();
    this.setupTransitions();
    this.setupGuards();
  }
  
  private setupStates(): void {
    // BOOTçŠ¶æ€ï¼šåº”ç”¨å¯åŠ¨åˆå§‹åŒ–
    this.addState({
      name: AppState.BOOT,
      onEnter: async (context) => {
        console.log('ğŸš€ åº”ç”¨å¯åŠ¨ä¸­...');
        await this.initializeCore(context);
        // è‡ªåŠ¨è½¬æ¢åˆ°é¢„åŠ è½½çŠ¶æ€
        await this.setState(AppState.PRELOAD);
      },
      isPersistent: false
    });
    
    // PRELOADçŠ¶æ€ï¼šé¢„åŠ è½½å¿…è¦èµ„æº
    this.addState({
      name: AppState.PRELOAD,
      onEnter: async (context) => {
        console.log('ğŸ“¦ é¢„åŠ è½½ç³»ç»Ÿèµ„æº...');
        await context.resourceManager.preloadCriticalAssets();
        await this.setState(AppState.LOADING);
      },
      canExit: (context) => context.resourceManager.isCriticalAssetsLoaded(),
      isPersistent: false
    });
    
    // LOADINGçŠ¶æ€ï¼šå®Œæ•´èµ„æºåŠ è½½
    this.addState({
      name: AppState.LOADING,
      onEnter: async (context) => {
        console.log('â³ åŠ è½½æ¸¸æˆèµ„æº...');
        
        // æ˜¾ç¤ºåŠ è½½ç•Œé¢
        context.eventBus.emit('ui:show_loading_screen');
        
        // å¼‚æ­¥åŠ è½½èµ„æº
        await context.resourceManager.loadAllAssets();
        
        // å®Œæˆåè½¬æ¢åˆ°å°±ç»ªçŠ¶æ€
        await this.setState(AppState.READY);
      },
      onUpdate: (context, delta) => {
        // æ›´æ–°åŠ è½½è¿›åº¦
        const progress = context.resourceManager.getLoadingProgress();
        context.eventBus.emit('ui:loading_progress', { progress });
      },
      canExit: (context) => context.resourceManager.isAllAssetsLoaded(),
      isPersistent: false
    });
    
    // RUNNINGçŠ¶æ€ï¼šæ¸¸æˆæ­£å¸¸è¿è¡Œ
    this.addState({
      name: AppState.RUNNING,
      onEnter: async (context) => {
        console.log('ğŸ® æ¸¸æˆå¼€å§‹è¿è¡Œ');
        
        // æ¢å¤æ‰€æœ‰Phaseråœºæ™¯
        context.sceneManager.scenes.forEach(scene => {
          if (scene.sys.settings.active) {
            scene.scene.resume();
            scene.sys.setActive(true);
          }
        });
        
        context.eventBus.emit('app:game_started');
      },
      onUpdate: (context, delta) => {
        // è¿è¡Œæ—¶æ€§èƒ½ç›‘æ§
        this.monitorPerformance(context, delta);
      },
      isPersistent: true,
      isParallel: false
    });
    
    // PAUSEDçŠ¶æ€ï¼šæ¸¸æˆæš‚åœ
    this.addState({
      name: AppState.PAUSED,
      onEnter: async (context) => {
        console.log('â¸ï¸ æ¸¸æˆæš‚åœ');
        
        // æš‚åœæ‰€æœ‰æ´»è·ƒçš„Phaseråœºæ™¯
        context.sceneManager.scenes.forEach(scene => {
          if (scene.sys.settings.active && !scene.sys.settings.data?.isPauseExempt) {
            scene.scene.pause();
            // ä¿æŒç³»ç»Ÿæ›´æ–°ä½†ç¦ç”¨æ¸¸æˆé€»è¾‘
            scene.sys.setActive(false);
          }
        });
        
        context.eventBus.emit('app:game_paused');
      },
      onExit: async (context) => {
        console.log('â–¶ï¸ æ¸¸æˆæ¢å¤');
        context.eventBus.emit('app:game_resumed');
      },
      isPersistent: true,
      priority: 1 // é«˜ä¼˜å…ˆçº§çŠ¶æ€
    });
  }
  
  private setupGuards(): void {
    // èµ„æºåŠ è½½å®Œæˆå®ˆå«
    this.addGuard({
      condition: (from, to, context) => {
        if (to === AppState.READY || to === AppState.RUNNING) {
          return context.resourceManager.isAllAssetsLoaded();
        }
        return true;
      },
      errorMessage: "èµ„æºæœªåŠ è½½å®Œæˆï¼Œæ— æ³•è¿›å…¥æ¸¸æˆçŠ¶æ€",
      priority: 1
    });
    
    // é”™è¯¯çŠ¶æ€æ¢å¤å®ˆå«
    this.addGuard({
      condition: (from, to, context) => {
        if (from === AppState.ERROR && to !== AppState.SHUTDOWN) {
          return context.errorManager.canRecover();
        }
        return true;
      },
      errorMessage: "ç³»ç»Ÿé”™è¯¯æœªæ¢å¤ï¼Œæ— æ³•åˆ‡æ¢çŠ¶æ€",
      priority: 2
    });
  }
}
```

#### åœºæ™¯çº§çŠ¶æ€æœºé›†æˆ

```typescript
// core/state/SceneStateMachine.ts - Phaser SceneçŠ¶æ€æœº
export enum SceneState {
  INIT = 'init',
  PRELOAD = 'preload',
  CREATE = 'create',
  ACTIVE = 'active',
  PAUSED = 'paused',
  SLEEP = 'sleep',
  DESTROY = 'destroy'
}

export class SceneStateMachine extends StateMachine<Phaser.Scene, SceneState> {
  constructor(scene: Phaser.Scene) {
    super(scene);
    
    // ç»‘å®šPhaser Sceneäº‹ä»¶åˆ°çŠ¶æ€æœº
    this.bindPhaserEvents();
  }
  
  private bindPhaserEvents(): void {
    const scene = this.context;
    
    // Phaserç”Ÿå‘½å‘¨æœŸäº‹ä»¶æ˜ å°„
    scene.events.on('preload', () => this.setState(SceneState.PRELOAD));
    scene.events.on('create', () => this.setState(SceneState.CREATE));
    scene.events.on('ready', () => this.setState(SceneState.ACTIVE));
    
    // æš‚åœ/æ¢å¤äº‹ä»¶
    scene.events.on('pause', () => this.setState(SceneState.PAUSED));
    scene.events.on('resume', () => {
      // æ ¹æ®åº”ç”¨çŠ¶æ€å†³å®šæ¢å¤åˆ°å“ªä¸ªçŠ¶æ€
      const appState = this.getAppState();
      if (appState === AppState.RUNNING) {
        this.setState(SceneState.ACTIVE);
      }
    });
    
    scene.events.on('sleep', () => this.setState(SceneState.SLEEP));
    scene.events.on('wake', () => this.setState(SceneState.ACTIVE));
    
    scene.events.on('destroy', () => this.setState(SceneState.DESTROY));
  }
  
  private getAppState(): AppState {
    // ä»å…¨å±€EventBusè·å–åº”ç”¨çŠ¶æ€
    return window.gameApp?.stateMachine?.getCurrentState() || AppState.RUNNING;
  }
}

// Phaser Sceneæ‰©å±•
export class StatefulGameScene extends Phaser.Scene {
  private sceneStateMachine: SceneStateMachine;
  
  constructor(config: Phaser.Types.Scenes.SettingsConfig) {
    super(config);
  }
  
  init(): void {
    this.sceneStateMachine = new SceneStateMachine(this);
    
    // åœºæ™¯ç‰¹å®šçš„çŠ¶æ€å¤„ç†
    this.sceneStateMachine.addState({
      name: SceneState.ACTIVE,
      onEnter: () => {
        this.physics?.resume();
        this.anims?.resumeAll();
        this.sound?.resumeAll();
      },
      onUpdate: (scene, delta) => {
        // åªåœ¨æ´»è·ƒçŠ¶æ€ä¸‹æ‰§è¡Œæ¸¸æˆé€»è¾‘
        this.updateGameLogic(delta);
      }
    });
    
    this.sceneStateMachine.addState({
      name: SceneState.PAUSED,
      onEnter: () => {
        this.physics?.pause();
        this.anims?.pauseAll();
        this.sound?.pauseAll();
      }
    });
  }
  
  private updateGameLogic(delta: number): void {
    // åœºæ™¯ç‰¹å®šçš„æ¸¸æˆé€»è¾‘æ›´æ–°
  }
}
```

### 6.3.4 çŠ¶æ€è½¬æ¢å®ˆå«ä¸éªŒè¯

**å¤šå±‚å®ˆå«éªŒè¯æœºåˆ¶**ï¼š
å»ºç«‹å®Œå–„çš„çŠ¶æ€è½¬æ¢å®ˆå«ä½“ç³»ï¼Œç¡®ä¿çŠ¶æ€åˆ‡æ¢çš„å®‰å…¨æ€§å’Œä¸€è‡´æ€§ã€‚

#### å®ˆå«ç±»å‹å®šä¹‰

```typescript
// core/state/StateGuards.ts - çŠ¶æ€å®ˆå«ç³»ç»Ÿ
export enum GuardType {
  PRECONDITION = 'precondition',    // å‰ç½®æ¡ä»¶å®ˆå«
  RESOURCE = 'resource',            // èµ„æºçŠ¶æ€å®ˆå«
  BUSINESS = 'business',            // ä¸šåŠ¡é€»è¾‘å®ˆå«
  PERFORMANCE = 'performance',      // æ€§èƒ½æ¡ä»¶å®ˆå«
  SECURITY = 'security'            // å®‰å…¨ç­–ç•¥å®ˆå«
}

export interface GuardContext<TContext> {
  currentState: string;
  targetState: string;
  context: TContext;
  timestamp: number;
  attemptCount: number;
}

export interface GuardResult {
  allowed: boolean;
  reason?: string;
  retryAfter?: number;    // å»ºè®®é‡è¯•é—´éš”(ms)
  fallbackState?: string; // å»ºè®®çš„æ›¿ä»£çŠ¶æ€
}

export abstract class StateGuard<TContext> {
  abstract type: GuardType;
  abstract priority: number;
  
  abstract evaluate(guardContext: GuardContext<TContext>): Promise<GuardResult> | GuardResult;
  
  // å®ˆå«å¤±è´¥æ—¶çš„å¤„ç†å»ºè®®
  onGuardFailed?(guardContext: GuardContext<TContext>, result: GuardResult): void;
}

// èµ„æºåŠ è½½å®ˆå«ç¤ºä¾‹
export class ResourceLoadingGuard extends StateGuard<AppContext> {
  type = GuardType.RESOURCE;
  priority = 1; // é«˜ä¼˜å…ˆçº§
  
  evaluate(guardContext: GuardContext<AppContext>): GuardResult {
    const { targetState, context } = guardContext;
    
    // æ£€æŸ¥æ˜¯å¦è¯•å›¾åœ¨èµ„æºæœªåŠ è½½æ—¶è¿›å…¥æ¸¸æˆçŠ¶æ€
    if (targetState === AppState.RUNNING || targetState === AppState.READY) {
      const isLoaded = context.resourceManager.isAllAssetsLoaded();
      
      if (!isLoaded) {
        return {
          allowed: false,
          reason: "å…³é”®æ¸¸æˆèµ„æºå°šæœªåŠ è½½å®Œæˆ",
          retryAfter: 1000,
          fallbackState: AppState.LOADING
        };
      }
    }
    
    return { allowed: true };
  }
  
  onGuardFailed(guardContext: GuardContext<AppContext>, result: GuardResult): void {
    console.warn(`ğŸ›¡ï¸ çŠ¶æ€è½¬æ¢è¢«é˜»æ­¢: ${guardContext.currentState} -> ${guardContext.targetState}`);
    console.warn(`   åŸå› : ${result.reason}`);
    
    // è‡ªåŠ¨è§¦å‘èµ„æºåŠ è½½
    if (result.fallbackState === AppState.LOADING) {
      guardContext.context.resourceManager.startLoading();
    }
  }
}

// æ€§èƒ½å®ˆå«ç¤ºä¾‹
export class PerformanceGuard extends StateGuard<AppContext> {
  type = GuardType.PERFORMANCE;
  priority = 3;
  
  private fpsHistory: number[] = [];
  
  evaluate(guardContext: GuardContext<AppContext>): GuardResult {
    const { targetState, context } = guardContext;
    
    // æ£€æŸ¥æ€§èƒ½çŠ¶æ€ï¼Œä½FPSæ—¶é˜»æ­¢å¤æ‚çŠ¶æ€è½¬æ¢
    if (targetState === AppState.RUNNING) {
      const currentFPS = this.getCurrentFPS();
      this.fpsHistory.push(currentFPS);
      
      if (this.fpsHistory.length > 10) {
        this.fpsHistory.shift();
      }
      
      const avgFPS = this.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.fpsHistory.length;
      
      if (avgFPS < 30) {
        return {
          allowed: false,
          reason: `ç³»ç»Ÿæ€§èƒ½ä¸è¶³(FPS: ${avgFPS.toFixed(1)})ï¼Œå»¶è¿Ÿå¯åŠ¨æ¸¸æˆ`,
          retryAfter: 2000
        };
      }
    }
    
    return { allowed: true };
  }
  
  private getCurrentFPS(): number {
    // è·å–å½“å‰FPSï¼ˆç®€åŒ–å®ç°ï¼‰
    return window.gameApp?.performanceMonitor?.getCurrentFPS() || 60;
  }
}

// å®ˆå«ç®¡ç†å™¨
export class GuardManager<TContext> {
  private guards: StateGuard<TContext>[] = [];
  
  addGuard(guard: StateGuard<TContext>): void {
    this.guards.push(guard);
    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.guards.sort((a, b) => a.priority - b.priority);
  }
  
  async evaluateTransition(
    from: string,
    to: string,
    context: TContext,
    attemptCount = 1
  ): Promise<GuardResult> {
    const guardContext: GuardContext<TContext> = {
      currentState: from,
      targetState: to,
      context,
      timestamp: Date.now(),
      attemptCount
    };
    
    // ä¾æ¬¡æ‰§è¡Œæ‰€æœ‰å®ˆå«
    for (const guard of this.guards) {
      const result = await guard.evaluate(guardContext);
      
      if (!result.allowed) {
        // æ‰§è¡Œå®ˆå«å¤±è´¥å¤„ç†
        guard.onGuardFailed?.(guardContext, result);
        return result;
      }
    }
    
    return { allowed: true };
  }
}
```

### 6.3.5 å¼‚æ­¥çŠ¶æ€è½¬æ¢å¤„ç†

**Promise-basedçŠ¶æ€è½¬æ¢**ï¼š
æ”¯æŒå¼‚æ­¥çŠ¶æ€è½¬æ¢ï¼Œç¡®ä¿å¤æ‚çš„èµ„æºåŠ è½½å’Œåˆå§‹åŒ–è¿‡ç¨‹çš„æ­£ç¡®å¤„ç†ã€‚

```typescript
// core/state/AsyncStateMachine.ts - å¼‚æ­¥çŠ¶æ€æœº
export class AsyncStateMachine<TContext, TState extends string> extends StateMachine<TContext, TState> {
  private transitionQueue: TransitionRequest<TState>[] = [];
  private isProcessingTransitions = false;
  
  async setState(newState: TState, context?: StateTransitionContext): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const request: TransitionRequest<TState> = {
        targetState: newState,
        context,
        resolve,
        reject,
        id: crypto.randomUUID(),
        timestamp: Date.now()
      };
      
      this.transitionQueue.push(request);
      this.processTransitionQueue();
    });
  }
  
  private async processTransitionQueue(): Promise<void> {
    if (this.isProcessingTransitions || this.transitionQueue.length === 0) {
      return;
    }
    
    this.isProcessingTransitions = true;
    
    while (this.transitionQueue.length > 0) {
      const request = this.transitionQueue.shift()!;
      
      try {
        const success = await this.executeTransition(request);
        request.resolve(success);
      } catch (error) {
        request.reject(error);
      }
    }
    
    this.isProcessingTransitions = false;
  }
  
  private async executeTransition(request: TransitionRequest<TState>): Promise<boolean> {
    const { targetState, context } = request;
    const currentState = this.getCurrentState();
    
    // 1. å®ˆå«éªŒè¯
    const guardResult = await this.guardManager.evaluateTransition(
      currentState,
      targetState,
      this.context
    );
    
    if (!guardResult.allowed) {
      console.warn(`çŠ¶æ€è½¬æ¢è¢«å®ˆå«é˜»æ­¢: ${currentState} -> ${targetState}`);
      console.warn(`åŸå› : ${guardResult.reason}`);
      
      // å¦‚æœæœ‰å»ºè®®çš„é‡è¯•é—´éš”ï¼Œè‡ªåŠ¨é‡è¯•
      if (guardResult.retryAfter) {
        setTimeout(() => {
          this.transitionQueue.unshift(request);
          this.processTransitionQueue();
        }, guardResult.retryAfter);
      }
      
      return false;
    }
    
    // 2. æ‰§è¡ŒçŠ¶æ€é€€å‡º
    const currentStateDef = this.states.get(currentState);
    if (currentStateDef?.onExit) {
      await currentStateDef.onExit(this.context, targetState);
    }
    
    // 3. çŠ¶æ€åˆ‡æ¢
    const previousState = currentState;
    this.currentState = this.states.get(targetState);
    
    // 4. æ‰§è¡ŒçŠ¶æ€è¿›å…¥
    if (this.currentState?.onEnter) {
      await this.currentState.onEnter(this.context, previousState);
    }
    
    // 5. å‘å¸ƒçŠ¶æ€å˜åŒ–äº‹ä»¶
    this.eventBus.emit('state:changed', {
      from: previousState,
      to: targetState,
      timestamp: Date.now(),
      context: context
    });
    
    return true;
  }
}

interface TransitionRequest<TState extends string> {
  targetState: TState;
  context?: StateTransitionContext;
  resolve: (success: boolean) => void;
  reject: (error: Error) => void;
  id: string;
  timestamp: number;
}
```

### 6.3.6 å¹¶å‘çŠ¶æ€ç®¡ç†

**å¤šç³»ç»Ÿå¹¶å‘çŠ¶æ€åè°ƒ**ï¼š
å¤„ç†æ¸¸æˆä¸­å¤šä¸ªç‹¬ç«‹ç³»ç»Ÿçš„å¹¶å‘çŠ¶æ€ï¼Œé¿å…çŠ¶æ€å†²çªå’Œèµ„æºç«äº‰ã€‚

```typescript
// core/state/ConcurrentStateManager.ts - å¹¶å‘çŠ¶æ€ç®¡ç†
export interface ConcurrentStateConfig<TState extends string> {
  primaryState: TState;
  concurrentStates: Map<string, TState>;
  conflictResolution: ConflictResolutionStrategy;
}

export enum ConflictResolutionStrategy {
  PRIORITY_BASED = 'priority',      // åŸºäºä¼˜å…ˆçº§è§£å†³
  LAST_WINS = 'last_wins',         // åæ¥è€…ä¼˜å…ˆ
  MERGE = 'merge',                 // çŠ¶æ€åˆå¹¶
  BLOCK = 'block'                  // é˜»æ­¢å†²çªè½¬æ¢
}

export class ConcurrentStateManager<TState extends string> {
  private stateManagers = new Map<string, StateMachine<any, TState>>();
  private stateSubscriptions = new Map<string, StateSubscription>();
  private conflictResolver: ConflictResolver<TState>;
  
  constructor(private config: ConcurrentStateConfig<TState>) {
    this.conflictResolver = new ConflictResolver(config.conflictResolution);
  }
  
  registerSystem<TContext>(
    systemId: string,
    stateMachine: StateMachine<TContext, TState>,
    priority = 5
  ): void {
    this.stateManagers.set(systemId, stateMachine);
    
    // è®¢é˜…ç³»ç»ŸçŠ¶æ€å˜åŒ–
    const subscription: StateSubscription = {
      systemId,
      priority,
      onStateChange: this.handleSystemStateChange.bind(this)
    };
    
    this.stateSubscriptions.set(systemId, subscription);
    
    // ç›‘å¬çŠ¶æ€å˜åŒ–
    stateMachine.on('stateChanged', (event) => {
      subscription.onStateChange(systemId, event.from, event.to);
    });
  }
  
  private async handleSystemStateChange(
    systemId: string,
    from: TState,
    to: TState
  ): Promise<void> {
    // æ£€æŸ¥çŠ¶æ€å†²çª
    const conflicts = this.detectConflicts(systemId, to);
    
    if (conflicts.length > 0) {
      const resolution = await this.conflictResolver.resolve(conflicts);
      await this.applyResolution(resolution);
    }
    
    // æ›´æ–°å…¨å±€çŠ¶æ€è§†å›¾
    this.updateGlobalStateView();
  }
  
  private detectConflicts(initiatorSystemId: string, newState: TState): StateConflict<TState>[] {
    const conflicts: StateConflict<TState>[] = [];
    
    // æ£€æŸ¥ä¸å…¶ä»–ç³»ç»Ÿçš„çŠ¶æ€å†²çª
    for (const [systemId, stateMachine] of this.stateManagers) {
      if (systemId === initiatorSystemId) continue;
      
      const currentState = stateMachine.getCurrentState();
      
      if (this.isConflictingState(newState, currentState)) {
        conflicts.push({
          initiatorSystem: initiatorSystemId,
          conflictingSystem: systemId,
          initiatorState: newState,
          conflictingState: currentState,
          priority: this.stateSubscriptions.get(systemId)?.priority || 5
        });
      }
    }
    
    return conflicts;
  }
  
  private isConflictingState(state1: TState, state2: TState): boolean {
    // å®šä¹‰å†²çªè§„åˆ™
    const conflictRules: Array<[TState, TState]> = [
      [AppState.PAUSED as TState, AppState.RUNNING as TState],
      [AppState.ERROR as TState, AppState.RUNNING as TState],
      [AppState.LOADING as TState, AppState.RUNNING as TState]
    ];
    
    return conflictRules.some(([s1, s2]) => 
      (state1 === s1 && state2 === s2) || (state1 === s2 && state2 === s1)
    );
  }
  
  getConcurrentStateSnapshot(): ConcurrentStateSnapshot<TState> {
    const snapshot: ConcurrentStateSnapshot<TState> = {
      primaryState: this.config.primaryState,
      systemStates: new Map(),
      timestamp: Date.now(),
      hasConflicts: false
    };
    
    for (const [systemId, stateMachine] of this.stateManagers) {
      snapshot.systemStates.set(systemId, stateMachine.getCurrentState());
    }
    
    return snapshot;
  }
}

interface StateConflict<TState extends string> {
  initiatorSystem: string;
  conflictingSystem: string;
  initiatorState: TState;
  conflictingState: TState;
  priority: number;
}

interface ConcurrentStateSnapshot<TState extends string> {
  primaryState: TState;
  systemStates: Map<string, TState>;
  timestamp: number;
  hasConflicts: boolean;
}
```

### 6.3.7 çŠ¶æ€æŒä¹…åŒ–ä¸æ¢å¤

**æ¸¸æˆå­˜æ¡£çŠ¶æ€ç®¡ç†**ï¼š
å®ç°çŠ¶æ€æœºçŠ¶æ€çš„é€‰æ‹©æ€§æŒä¹…åŒ–ï¼Œç¡®ä¿æ¸¸æˆå­˜æ¡£çš„å®Œæ•´æ€§å’ŒçŠ¶æ€æ¢å¤çš„å‡†ç¡®æ€§ã€‚

```typescript
// core/state/StatePersistence.ts - çŠ¶æ€æŒä¹…åŒ–
export interface PersistentStateData<TState extends string> {
  currentState: TState;
  stateHistory: TState[];
  persistentContext: Record<string, unknown>;
  timestamp: number;
  version: string;
}

export interface StateSnapshot<TState extends string> {
  machineId: string;
  state: TState;
  context: Record<string, unknown>;
  metadata: {
    isPersistent: boolean;
    priority: number;
    dependencies: string[];
  };
}

export class StatePersistenceManager<TState extends string> {
  private persistenceStrategy: PersistenceStrategy;
  private serializer: StateSerializer<TState>;
  private validator: StateValidator<TState>;
  
  constructor(strategy: PersistenceStrategy = 'selective') {
    this.persistenceStrategy = strategy;
    this.serializer = new StateSerializer();
    this.validator = new StateValidator();
  }
  
  async saveState(
    stateMachine: StateMachine<any, TState>,
    machineId: string
  ): Promise<string> {
    const snapshot = this.createSnapshot(stateMachine, machineId);
    
    // éªŒè¯çŠ¶æ€å¿«ç…§
    const validation = await this.validator.validate(snapshot);
    if (!validation.isValid) {
      throw new Error(`çŠ¶æ€å¿«ç…§éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
    }
    
    // åºåˆ—åŒ–çŠ¶æ€æ•°æ®
    const serializedData = await this.serializer.serialize(snapshot);
    
    // æ ¹æ®ç­–ç•¥é€‰æ‹©æŒä¹…åŒ–æ–¹å¼
    switch (this.persistenceStrategy) {
      case 'selective':
        return await this.saveSelective(serializedData);
      case 'full':
        return await this.saveFull(serializedData);
      case 'differential':
        return await this.saveDifferential(serializedData);
      default:
        throw new Error(`æœªçŸ¥çš„æŒä¹…åŒ–ç­–ç•¥: ${this.persistenceStrategy}`);
    }
  }
  
  async loadState(
    saveId: string,
    stateMachine: StateMachine<any, TState>
  ): Promise<boolean> {
    try {
      // åŠ è½½åºåˆ—åŒ–æ•°æ®
      const serializedData = await this.loadSerializedData(saveId);
      
      // ååºåˆ—åŒ–çŠ¶æ€å¿«ç…§
      const snapshot = await this.serializer.deserialize(serializedData);
      
      // éªŒè¯å¿«ç…§å®Œæ•´æ€§
      const validation = await this.validator.validate(snapshot);
      if (!validation.isValid) {
        console.error('çŠ¶æ€å¿«ç…§éªŒè¯å¤±è´¥:', validation.errors);
        return false;
      }
      
      // æ¢å¤çŠ¶æ€æœºçŠ¶æ€
      await this.restoreStateMachine(stateMachine, snapshot);
      
      return true;
    } catch (error) {
      console.error('çŠ¶æ€åŠ è½½å¤±è´¥:', error);
      return false;
    }
  }
  
  private createSnapshot<TContext>(
    stateMachine: StateMachine<TContext, TState>,
    machineId: string
  ): StateSnapshot<TState> {
    const currentState = stateMachine.getCurrentState();
    const context = stateMachine.getContext();
    
    return {
      machineId,
      state: currentState,
      context: this.extractPersistentContext(context),
      metadata: {
        isPersistent: this.shouldPersistState(currentState),
        priority: this.getStatePriority(currentState),
        dependencies: this.getStateDependencies(currentState)
      }
    };
  }
  
  private extractPersistentContext(context: any): Record<string, unknown> {
    // æå–éœ€è¦æŒä¹…åŒ–çš„ä¸Šä¸‹æ–‡æ•°æ®
    const persistentKeys = ['settings', 'progress', 'inventory', 'achievements'];
    const persistentContext: Record<string, unknown> = {};
    
    for (const key of persistentKeys) {
      if (context && typeof context === 'object' && key in context) {
        persistentContext[key] = context[key];
      }
    }
    
    return persistentContext;
  }
  
  private shouldPersistState(state: TState): boolean {
    // å®šä¹‰å“ªäº›çŠ¶æ€éœ€è¦æŒä¹…åŒ–
    const persistentStates: TState[] = [
      AppState.RUNNING as TState,
      AppState.PAUSED as TState
    ];
    
    return persistentStates.includes(state);
  }
  
  private async restoreStateMachine(
    stateMachine: StateMachine<any, TState>,
    snapshot: StateSnapshot<TState>
  ): Promise<void> {
    // 1. æ¢å¤ä¸Šä¸‹æ–‡æ•°æ®
    await this.restoreContext(stateMachine, snapshot.context);
    
    // 2. æ‰§è¡ŒçŠ¶æ€è½¬æ¢
    await stateMachine.setState(snapshot.state);
    
    // 3. è§¦å‘æ¢å¤åå¤„ç†
    stateMachine.emit('stateRestored', {
      fromSnapshot: snapshot,
      timestamp: Date.now()
    });
  }
  
  private async restoreContext(
    stateMachine: StateMachine<any, TState>,
    persistentContext: Record<string, unknown>
  ): Promise<void> {
    const currentContext = stateMachine.getContext();
    
    // åˆå¹¶æŒä¹…åŒ–ä¸Šä¸‹æ–‡åˆ°å½“å‰ä¸Šä¸‹æ–‡
    if (currentContext && typeof currentContext === 'object') {
      Object.assign(currentContext, persistentContext);
    }
  }
}

class StateValidator<TState extends string> {
  async validate(snapshot: StateSnapshot<TState>): Promise<ValidationResult> {
    const errors: string[] = [];
    
    // æ£€æŸ¥å¿…è¦å­—æ®µ
    if (!snapshot.machineId) {
      errors.push('ç¼ºå°‘æœºå™¨ID');
    }
    
    if (!snapshot.state) {
      errors.push('ç¼ºå°‘çŠ¶æ€ä¿¡æ¯');
    }
    
    // æ£€æŸ¥çŠ¶æ€ä¾èµ–
    if (snapshot.metadata.dependencies.length > 0) {
      // éªŒè¯ä¾èµ–çŠ¶æ€æ˜¯å¦æ»¡è¶³
      const dependencyCheck = await this.validateDependencies(snapshot.metadata.dependencies);
      if (!dependencyCheck.isValid) {
        errors.push(`çŠ¶æ€ä¾èµ–éªŒè¯å¤±è´¥: ${dependencyCheck.errors.join(', ')}`);
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  
  private async validateDependencies(dependencies: string[]): Promise<ValidationResult> {
    // å®ç°ä¾èµ–éªŒè¯é€»è¾‘
    return { isValid: true, errors: [] };
  }
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

type PersistenceStrategy = 'selective' | 'full' | 'differential';
```

## 6.4 è´Ÿè½½ä¸èƒŒå‹

> å¸§é¢„ç®—/ä»»åŠ¡åˆ‡ç‰‡/Workeræ± ï¼Œå°†60FPSçš„å¸§é¢„ç®—æ˜ å°„åˆ°updateå¼€é”€æ§åˆ¶ã€‚

### 6.4.1 æ€§èƒ½é¢„ç®—ç®¡ç†

```typescript
// core/performance/PerformanceBudget.ts - æ€§èƒ½é¢„ç®—ç®¡ç†
export class PerformanceBudgetManager {
  private static readonly FRAME_BUDGET = 16.67; // 60FPSé¢„ç®—
  
  private budgetAllocations = {
    ui: 5.0,        // React UIæ›´æ–° (30%)
    game: 8.0,      // Phaseræ¸¸æˆé€»è¾‘ (48%)
    ai: 2.0,        // AIè®¡ç®— (12%)
    buffer: 1.67    // ç¼“å†²åŒº (10%)
  };
  
  private currentFrameUsage = {
    ui: 0,
    game: 0,
    ai: 0,
    total: 0
  };
  
  checkBudgetExceeded(component: keyof typeof this.budgetAllocations): boolean {
    const allocated = this.budgetAllocations[component];
    const used = this.currentFrameUsage[component];
    return used > allocated;
  }
  
  applyBackpressure(): void {
    if (this.currentFrameUsage.total > PerformanceBudgetManager.FRAME_BUDGET) {
      // åº”ç”¨èƒŒå‹ç­–ç•¥
      this.reduceAITaskPriority();
      this.enableFrameSkipping();
      this.notifyPerformanceIssue();
    }
  }
}
```

### 6.4.2 åŠ¨æ€å¸§é¢„ç®—ç®¡ç†ç³»ç»Ÿ

**è‡ªé€‚åº”é¢„ç®—åˆ†é…ç­–ç•¥**ï¼š
åŸºäºå®é™…æ€§èƒ½è¡¨ç°åŠ¨æ€è°ƒæ•´å„ç»„ä»¶çš„æ—¶é—´åˆ†é…ï¼Œç¡®ä¿åœ¨å„ç§è´Ÿè½½æ¡ä»¶ä¸‹éƒ½èƒ½ç»´æŒ60FPSç›®æ ‡ã€‚

```typescript
// core/performance/DynamicBudgetManager.ts - åŠ¨æ€å¸§é¢„ç®—ç®¡ç†
export class DynamicBudgetManager {
  private static readonly TARGET_FPS = 60;
  private static readonly TARGET_FRAME_TIME = 1000 / DynamicBudgetManager.TARGET_FPS; // 16.67ms
  private static readonly SAFETY_MARGIN = 0.8; // 80%å®‰å…¨è£•é‡
  
  // åŸºå‡†é¢„ç®—åˆ†é…(ms)
  private baseBudgetAllocations = {
    phaser: 10.0,      // Phaseræ¸¸æˆé€»è¾‘ (60%)
    react: 4.0,        // React UIæ¸²æŸ“ (24%)  
    ai: 1.5,           // AIè®¡ç®— (9%)
    buffer: 1.17       // ç³»ç»Ÿç¼“å†² (7%)
  };
  
  // åŠ¨æ€é¢„ç®—åˆ†é…
  private currentBudgetAllocations = { ...this.baseBudgetAllocations };
  
  // æ€§èƒ½å†å²è®°å½•
  private frameTimeHistory: number[] = [];
  private performanceMetrics = {
    averageFPS: 60,
    p95FrameTime: 16.67,
    frameStability: 1.0,
    loadFactor: 0.6
  };
  
  constructor(
    private phaserGame: Phaser.Game,
    private performanceProfiler: PerformanceProfiler
  ) {
    this.initializeMonitoring();
  }
  
  private initializeMonitoring(): void {
    // ç›‘å¬Phaser TimeStepäº‹ä»¶
    this.phaserGame.events.on('step', this.onFrameComplete.bind(this));
    
    // æ¯ç§’æ›´æ–°ä¸€æ¬¡é¢„ç®—åˆ†é…
    setInterval(this.updateBudgetAllocations.bind(this), 1000);
  }
  
  private onFrameComplete(time: number, delta: number): void {
    const frameTime = this.phaserGame.loop.actualFps > 0 ? 
      1000 / this.phaserGame.loop.actualFps : DynamicBudgetManager.TARGET_FRAME_TIME;
    
    // è®°å½•å¸§æ—¶é—´å†å²
    this.frameTimeHistory.push(frameTime);
    if (this.frameTimeHistory.length > 60) { // ä¿ç•™1ç§’çš„å†å²
      this.frameTimeHistory.shift();
    }
    
    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    this.updatePerformanceMetrics();
  }
  
  private updatePerformanceMetrics(): void {
    if (this.frameTimeHistory.length === 0) return;
    
    // è®¡ç®—å¹³å‡FPS
    const avgFrameTime = this.frameTimeHistory.reduce((sum, time) => sum + time, 0) / this.frameTimeHistory.length;
    this.performanceMetrics.averageFPS = 1000 / avgFrameTime;
    
    // è®¡ç®—P95å¸§æ—¶é—´
    const sortedFrameTimes = [...this.frameTimeHistory].sort((a, b) => a - b);
    const p95Index = Math.floor(sortedFrameTimes.length * 0.95);
    this.performanceMetrics.p95FrameTime = sortedFrameTimes[p95Index];
    
    // è®¡ç®—å¸§ç¨³å®šæ€§ (1.0 = å®Œå…¨ç¨³å®š, 0.0 = å®Œå…¨ä¸ç¨³å®š)
    const variance = this.calculateVariance(this.frameTimeHistory);
    this.performanceMetrics.frameStability = Math.max(0, 1.0 - (variance / 100));
    
    // è®¡ç®—è´Ÿè½½å› å­ (å½“å‰ä½¿ç”¨æ—¶é—´ / ç›®æ ‡æ—¶é—´)
    this.performanceMetrics.loadFactor = avgFrameTime / DynamicBudgetManager.TARGET_FRAME_TIME;
  }
  
  private updateBudgetAllocations(): void {
    const { averageFPS, loadFactor, frameStability } = this.performanceMetrics;
    
    // æ€§èƒ½è‰¯å¥½ï¼šå¢åŠ AIå’Œç¼“å†²é¢„ç®—
    if (averageFPS >= 58 && frameStability > 0.9) {
      this.currentBudgetAllocations = {
        phaser: this.baseBudgetAllocations.phaser,
        react: this.baseBudgetAllocations.react,
        ai: Math.min(2.5, this.baseBudgetAllocations.ai * 1.6),
        buffer: Math.max(0.67, this.baseBudgetAllocations.buffer * 0.6)
      };
    }
    // æ€§èƒ½ç´§å¼ ï¼šå‡å°‘AIé¢„ç®—ï¼Œå¢åŠ ç¼“å†²
    else if (averageFPS < 55 || loadFactor > 1.1) {
      this.currentBudgetAllocations = {
        phaser: this.baseBudgetAllocations.phaser * 0.9, // è½»å¾®å‡å°‘æ¸¸æˆé€»è¾‘é¢„ç®—
        react: this.baseBudgetAllocations.react * 0.8,   // å‡å°‘UIæ›´æ–°é¢„ç®—
        ai: Math.max(0.5, this.baseBudgetAllocations.ai * 0.3), // å¤§å¹…å‡å°‘AIé¢„ç®—
        buffer: this.baseBudgetAllocations.buffer * 1.8   // å¢åŠ å®‰å…¨ç¼“å†²
      };
    }
    // æ­£å¸¸çŠ¶æ€ï¼šä½¿ç”¨åŸºå‡†åˆ†é…
    else {
      this.currentBudgetAllocations = { ...this.baseBudgetAllocations };
    }
    
    // é€šçŸ¥å„å­ç³»ç»Ÿé¢„ç®—å˜åŒ–
    this.notifyBudgetUpdate();
  }
  
  private calculateVariance(numbers: number[]): number {
    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
    const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2));
    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;
  }
  
  private notifyBudgetUpdate(): void {
    // å‘å¸ƒé¢„ç®—æ›´æ–°äº‹ä»¶
    this.phaserGame.events.emit('budget:updated', {
      allocations: this.currentBudgetAllocations,
      metrics: this.performanceMetrics,
      timestamp: Date.now()
    });
  }
  
  // è·å–ç»„ä»¶é¢„ç®—
  getBudget(component: keyof typeof this.currentBudgetAllocations): number {
    return this.currentBudgetAllocations[component];
  }
  
  // è·å–å‰©ä½™é¢„ç®—
  getRemainingBudget(usedTime: number): number {
    const totalBudget = Object.values(this.currentBudgetAllocations).reduce((sum, budget) => sum + budget, 0);
    return Math.max(0, totalBudget - usedTime);
  }
  
  // æ£€æŸ¥é¢„ç®—è¶…æ”¯
  isBudgetExceeded(component: keyof typeof this.currentBudgetAllocations, usedTime: number): boolean {
    return usedTime > this.currentBudgetAllocations[component];
  }
  
  getPerformanceReport(): PerformanceReport {
    return {
      ...this.performanceMetrics,
      budgetAllocations: { ...this.currentBudgetAllocations },
      recommendations: this.generateRecommendations()
    };
  }
  
  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    const { averageFPS, frameStability, loadFactor } = this.performanceMetrics;
    
    if (averageFPS < 50) {
      recommendations.push("ä¸¥é‡æ€§èƒ½é—®é¢˜ï¼šè€ƒè™‘é™ä½æ¸¸æˆè´¨é‡è®¾ç½®");
    } else if (averageFPS < 55) {
      recommendations.push("æ€§èƒ½ç´§å¼ ï¼šå»ºè®®ä¼˜åŒ–AIç®—æ³•æˆ–å‡å°‘å¹¶å‘ä»»åŠ¡");
    }
    
    if (frameStability < 0.7) {
      recommendations.push("å¸§ç‡ä¸ç¨³å®šï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨æ€§èƒ½å°–å³°æˆ–GCé—®é¢˜");
    }
    
    if (loadFactor > 1.2) {
      recommendations.push("ç³»ç»Ÿè´Ÿè½½è¿‡é«˜ï¼šè€ƒè™‘å¯ç”¨Web Workerså¸è½½é‡è®¡ç®—ä»»åŠ¡");
    }
    
    return recommendations;
  }
}

interface PerformanceReport {
  averageFPS: number;
  p95FrameTime: number;
  frameStability: number;
  loadFactor: number;
  budgetAllocations: Record<string, number>;
  recommendations: string[];
}
```

### 6.4.3 ä»»åŠ¡åˆ‡ç‰‡ä¸ä¼˜å…ˆçº§è°ƒåº¦

**æ—¶é—´ç‰‡è°ƒåº¦å™¨å®ç°**ï¼š
ç¡®ä¿é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ä¸ä¼šé˜»å¡æ¸¸æˆä¸»å¾ªç¯ï¼Œé€šè¿‡ç”Ÿæˆå™¨å‡½æ•°å®ç°åä½œå¼å¤šä»»åŠ¡å¤„ç†ã€‚

```typescript
// core/scheduler/TimeSliceScheduler.ts - æ—¶é—´ç‰‡ä»»åŠ¡è°ƒåº¦å™¨
export enum TaskPriority {
  CRITICAL = 1,    // ç”¨æˆ·è¾“å…¥ã€çŠ¶æ€æœºè½¬æ¢
  HIGH = 2,        // æ¸¸æˆæ ¸å¿ƒé€»è¾‘ã€ç‰©ç†è®¡ç®—
  MEDIUM = 3,      // AIå†³ç­–ã€è·¯å¾„è§„åˆ’
  LOW = 4,         // æ•°æ®åŒæ­¥ã€ç»Ÿè®¡è®¡ç®—
  BACKGROUND = 5   // ç»´æŠ¤ä»»åŠ¡ã€ç¼“å­˜æ¸…ç†
}

export interface ScheduledTask {
  id: string;
  execute: () => Generator<void, any, unknown> | any;
  priority: TaskPriority;
  maxExecutionTime: number;  // æœ€å¤§æ‰§è¡Œæ—¶é—´(ms)
  isPausable: boolean;       // æ˜¯å¦å¯æš‚åœ
  executionTarget?: 'main' | 'worker'; // æ‰§è¡Œç›®æ ‡
  createdAt: number;
  attempts: number;
}

export interface TaskExecutionContext {
  remainingBudget: number;
  currentPriority: TaskPriority;
  frameStartTime: number;
}

export class TimeSliceScheduler {
  private taskQueue = new PriorityQueue<ScheduledTask>();
  private runningTasks = new Map<string, GeneratorState>();
  private completedTasks = new Map<string, TaskResult>();
  
  // è°ƒåº¦é…ç½®
  private config = {
    maxTimeSlice: 1.0,           // æ¯ä¸ªæ—¶é—´ç‰‡æœ€å¤§1ms
    maxTasksPerFrame: 10,        // æ¯å¸§æœ€å¤šå¤„ç†10ä¸ªä»»åŠ¡
    priorityBoostThreshold: 100,  // 100msåä¼˜å…ˆçº§æå‡
    maxRetries: 3                // æœ€å¤§é‡è¯•æ¬¡æ•°
  };
  
  private performanceProfiler: PerformanceProfiler;
  
  constructor(performanceProfiler: PerformanceProfiler) {
    this.performanceProfiler = performanceProfiler;
  }
  
  scheduleTask(task: Omit<ScheduledTask, 'id' | 'createdAt' | 'attempts'>): string {
    const scheduledTask: ScheduledTask = {
      ...task,
      id: crypto.randomUUID(),
      createdAt: Date.now(),
      attempts: 0
    };
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦Workeræ‰§è¡Œ
    if (task.executionTarget === 'worker') {
      return this.scheduleWorkerTask(scheduledTask);
    }
    
    // ä¸»çº¿ç¨‹ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
    this.taskQueue.enqueue(scheduledTask, task.priority);
    
    console.debug(`ä»»åŠ¡å·²è°ƒåº¦: ${scheduledTask.id} (ä¼˜å…ˆçº§: ${task.priority})`);
    return scheduledTask.id;
  }
  
  executeTasksWithBudget(budget: number): TaskExecutionReport {
    const executionContext: TaskExecutionContext = {
      remainingBudget: budget,
      currentPriority: TaskPriority.CRITICAL,
      frameStartTime: performance.now()
    };
    
    const report: TaskExecutionReport = {
      executed: [],
      failed: [],
      deferred: [],
      totalTime: 0,
      remainingBudget: budget,
      tasksInQueue: this.taskQueue.size()
    };
    
    let tasksProcessed = 0;
    
    while (!this.taskQueue.isEmpty() && 
           executionContext.remainingBudget > 0 && 
           tasksProcessed < this.config.maxTasksPerFrame) {
      
      const task = this.taskQueue.dequeue();
      if (!task) break;
      
      const executionStartTime = performance.now();
      
      try {
        const result = this.executeTask(task, executionContext);
        
        if (result.completed) {
          this.completedTasks.set(task.id, result);
          report.executed.push(task);
        } else {
          // ä»»åŠ¡æœªå®Œæˆï¼Œé‡æ–°å…¥é˜Ÿæˆ–å»¶è¿Ÿå¤„ç†
          this.handleIncompleteTask(task, result);
          report.deferred.push(task);
        }
      } catch (error) {
        this.handleTaskError(task, error);
        report.failed.push({ task, error: error.message });
      }
      
      const executionTime = performance.now() - executionStartTime;
      executionContext.remainingBudget -= executionTime;
      report.totalTime += executionTime;
      tasksProcessed++;
      
      // æ£€æŸ¥æ˜¯å¦æœ‰æ›´é«˜ä¼˜å…ˆçº§ä»»åŠ¡
      if (this.hasHigherPriorityTask(task.priority)) {
        break;
      }
    }
    
    report.remainingBudget = Math.max(0, executionContext.remainingBudget);
    return report;
  }
  
  private executeTask(task: ScheduledTask, context: TaskExecutionContext): TaskResult {
    const taskStartTime = performance.now();
    
    if (task.isPausable) {
      return this.executeGeneratorTask(task, context);
    } else {
      return this.executeAtomicTask(task, context);
    }
  }
  
  private executeGeneratorTask(task: ScheduledTask, context: TaskExecutionContext): TaskResult {
    let generator = this.runningTasks.get(task.id)?.generator;
    
    // é¦–æ¬¡æ‰§è¡Œï¼Œåˆ›å»ºç”Ÿæˆå™¨
    if (!generator) {
      const executeFunc = task.execute as () => Generator<void, any, unknown>;
      generator = executeFunc();
      
      this.runningTasks.set(task.id, {
        generator,
        lastYieldTime: Date.now(),
        executionTime: 0
      });
    }
    
    const sliceStartTime = performance.now();
    let iterationCount = 0;
    
    // æ‰§è¡Œç”Ÿæˆå™¨åˆ‡ç‰‡
    while (performance.now() - sliceStartTime < this.config.maxTimeSlice) {
      const result = generator.next();
      iterationCount++;
      
      if (result.done) {
        // ä»»åŠ¡å®Œæˆ
        this.runningTasks.delete(task.id);
        return {
          completed: true,
          result: result.value,
          executionTime: performance.now() - taskStartTime,
          iterations: iterationCount
        };
      }
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è®©å‡ºæ§åˆ¶æƒ
      if (iterationCount % 100 === 0) {
        const elapsed = performance.now() - sliceStartTime;
        if (elapsed >= this.config.maxTimeSlice * 0.8) {
          break; // æ¥è¿‘æ—¶é—´ç‰‡é™åˆ¶ï¼Œè®©å‡ºæ§åˆ¶æƒ
        }
      }
    }
    
    // æ›´æ–°è¿è¡ŒçŠ¶æ€
    const state = this.runningTasks.get(task.id)!;
    state.lastYieldTime = Date.now();
    state.executionTime += performance.now() - sliceStartTime;
    
    return {
      completed: false,
      result: null,
      executionTime: state.executionTime,
      iterations: iterationCount
    };
  }
  
  private executeAtomicTask(task: ScheduledTask, context: TaskExecutionContext): TaskResult {
    const taskStartTime = performance.now();
    
    // åŸå­ä»»åŠ¡ä¸å¯ä¸­æ–­ï¼Œç›´æ¥æ‰§è¡Œ
    const executeFunc = task.execute as () => any;
    const result = executeFunc();
    
    const executionTime = performance.now() - taskStartTime;
    
    // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
    if (executionTime > task.maxExecutionTime) {
      console.warn(`åŸå­ä»»åŠ¡æ‰§è¡Œè¶…æ—¶: ${task.id} (${executionTime.toFixed(2)}ms > ${task.maxExecutionTime}ms)`);
    }
    
    return {
      completed: true,
      result,
      executionTime,
      iterations: 1
    };
  }
  
  private handleIncompleteTask(task: ScheduledTask, result: TaskResult): void {
    const state = this.runningTasks.get(task.id);
    if (!state) return;
    
    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¿è¡Œè¿‡ä¹…
    const now = Date.now();
    const totalRunTime = now - task.createdAt;
    
    if (totalRunTime > task.maxExecutionTime * 10) {
      // ä»»åŠ¡è¿è¡Œæ—¶é—´è¿‡é•¿ï¼Œé™ä½ä¼˜å…ˆçº§
      const newPriority = Math.min(TaskPriority.BACKGROUND, task.priority + 1);
      console.warn(`ä»»åŠ¡è¿è¡Œæ—¶é—´è¿‡é•¿ï¼Œé™ä½ä¼˜å…ˆçº§: ${task.id} (${newPriority})`);
      this.taskQueue.enqueue({ ...task, priority: newPriority }, newPriority);
    } else {
      // é‡æ–°å…¥é˜Ÿ
      this.taskQueue.enqueue(task, task.priority);
    }
  }
  
  private handleTaskError(task: ScheduledTask, error: Error): void {
    console.error(`ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ${task.id}`, error);
    
    task.attempts++;
    
    if (task.attempts < this.config.maxRetries) {
      // å»¶è¿Ÿé‡è¯•
      setTimeout(() => {
        console.info(`é‡è¯•ä»»åŠ¡: ${task.id} (ç¬¬${task.attempts}æ¬¡é‡è¯•)`);
        this.taskQueue.enqueue(task, task.priority);
      }, Math.pow(2, task.attempts) * 1000); // æŒ‡æ•°é€€é¿
    } else {
      console.error(`ä»»åŠ¡è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°: ${task.id}`);
    }
    
    // æ¸…ç†è¿è¡ŒçŠ¶æ€
    this.runningTasks.delete(task.id);
  }
  
  private hasHigherPriorityTask(currentPriority: TaskPriority): boolean {
    const nextTask = this.taskQueue.peek();
    return nextTask && nextTask.priority < currentPriority;
  }
  
  private scheduleWorkerTask(task: ScheduledTask): string {
    // Workerä»»åŠ¡å¤„ç†é€»è¾‘
    // è¿™é‡Œå¯ä»¥é›†æˆWeb Workeræ± 
    console.log(`ä»»åŠ¡å·²è°ƒåº¦åˆ°Worker: ${task.id}`);
    return task.id;
  }
  
  // è·å–è°ƒåº¦å™¨çŠ¶æ€
  getSchedulerStatus(): SchedulerStatus {
    return {
      queueSize: this.taskQueue.size(),
      runningTasks: this.runningTasks.size,
      completedTasks: this.completedTasks.size,
      averageExecutionTime: this.calculateAverageExecutionTime()
    };
  }
  
  private calculateAverageExecutionTime(): number {
    if (this.completedTasks.size === 0) return 0;
    
    const totalTime = Array.from(this.completedTasks.values())
      .reduce((sum, result) => sum + result.executionTime, 0);
    
    return totalTime / this.completedTasks.size;
  }
}

// è¾…åŠ©æ¥å£å®šä¹‰
interface GeneratorState {
  generator: Generator<void, any, unknown>;
  lastYieldTime: number;
  executionTime: number;
}

interface TaskResult {
  completed: boolean;
  result: any;
  executionTime: number;
  iterations: number;
}

interface TaskExecutionReport {
  executed: ScheduledTask[];
  failed: Array<{ task: ScheduledTask; error: string }>;
  deferred: ScheduledTask[];
  totalTime: number;
  remainingBudget: number;
  tasksInQueue: number;
}

interface SchedulerStatus {
  queueSize: number;
  runningTasks: number;
  completedTasks: number;
  averageExecutionTime: number;
}

// ä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°
class PriorityQueue<T> {
  private items: Array<{ item: T; priority: number }> = [];
  
  enqueue(item: T, priority: number): void {
    this.items.push({ item, priority });
    this.items.sort((a, b) => a.priority - b.priority);
  }
  
  dequeue(): T | undefined {
    return this.items.shift()?.item;
  }
  
  peek(): T | undefined {
    return this.items[0]?.item;
  }
  
  size(): number {
    return this.items.length;
  }
  
  isEmpty(): boolean {
    return this.items.length === 0;
  }
}
```

### 6.4.4 Web Workersè´Ÿè½½å¸è½½

**é‡è®¡ç®—ä»»åŠ¡å¼‚æ­¥å¤„ç†**ï¼š
å°†CPUå’Œå†…å­˜å¯†é›†å‹ä»»åŠ¡å¸è½½åˆ°Web Workersï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹çš„æ¸¸æˆå¾ªç¯ã€‚

```typescript
// core/workers/WorkerPoolManager.ts - Workeræ± ç®¡ç†å™¨
export interface WorkerTask {
  id: string;
  type: 'pathfinding' | 'ai_decision' | 'data_analysis' | 'image_processing';
  payload: any;
  transferables?: Transferable[];
  timeout?: number;
  priority?: TaskPriority;
}

export interface WorkerResult {
  taskId: string;
  result: any;
  executionTime: number;
  workerId: string;
}

export class WorkerPoolManager {
  private workers: Map<string, WorkerInstance> = new Map();
  private taskQueue = new PriorityQueue<WorkerTask>();
  private pendingTasks = new Map<string, PendingTask>();
  
  private config = {
    maxWorkers: navigator.hardwareConcurrency || 4,
    workerIdleTimeout: 30000,      // 30sç©ºé—²è¶…æ—¶
    taskTimeout: 15000,            // 15sä»»åŠ¡è¶…æ—¶
    maxTasksPerWorker: 10,         // æ¯ä¸ªWorkeræœ€å¤šå¤„ç†10ä¸ªä»»åŠ¡
    heartbeatInterval: 5000        // 5så¿ƒè·³æ£€æŸ¥
  };
  
  constructor() {
    this.initializeWorkerPool();
    this.startHealthCheck();
  }
  
  private initializeWorkerPool(): void {
    // åˆ›å»ºåˆå§‹Workerå®ä¾‹
    const initialWorkerCount = Math.min(2, this.config.maxWorkers);
    
    for (let i = 0; i < initialWorkerCount; i++) {
      this.createWorker();
    }
    
    console.log(`Workeræ± åˆå§‹åŒ–å®Œæˆ: ${initialWorkerCount}ä¸ªWorker`);
  }
  
  private createWorker(): string {
    const workerId = crypto.randomUUID();
    
    // åˆ›å»ºWorkerå®ä¾‹
    const worker = new Worker(new URL('../workers/compute.worker.ts', import.meta.url), {
      type: 'module'
    });
    
    const workerInstance: WorkerInstance = {
      id: workerId,
      worker,
      isIdle: true,
      currentTask: null,
      taskCount: 0,
      createdAt: Date.now(),
      lastUsed: Date.now(),
      errorCount: 0
    };
    
    // ç›‘å¬Workeræ¶ˆæ¯
    worker.onmessage = (event) => this.handleWorkerMessage(workerId, event);
    worker.onerror = (error) => this.handleWorkerError(workerId, error);
    
    this.workers.set(workerId, workerInstance);
    
    // å‘é€åˆå§‹åŒ–æ¶ˆæ¯
    worker.postMessage({
      type: 'init',
      workerId,
      config: this.config
    });
    
    return workerId;
  }
  
  async executeTask(task: WorkerTask): Promise<WorkerResult> {
    return new Promise((resolve, reject) => {
      const pendingTask: PendingTask = {
        task,
        resolve,
        reject,
        submittedAt: Date.now()
      };
      
      this.pendingTasks.set(task.id, pendingTask);
      
      // è®¾ç½®ä»»åŠ¡è¶…æ—¶
      const timeout = task.timeout || this.config.taskTimeout;
      setTimeout(() => {
        if (this.pendingTasks.has(task.id)) {
          this.pendingTasks.delete(task.id);
          reject(new Error(`ä»»åŠ¡è¶…æ—¶: ${task.id} (${timeout}ms)`));
        }
      }, timeout);
      
      // å°è¯•ç«‹å³åˆ†é…Worker
      const availableWorker = this.findAvailableWorker();
      if (availableWorker) {
        this.assignTaskToWorker(availableWorker.id, task);
      } else {
        // åŠ å…¥é˜Ÿåˆ—ç­‰å¾…
        this.taskQueue.enqueue(task, task.priority || TaskPriority.MEDIUM);
        
        // å¦‚æœæ‰€æœ‰Workeréƒ½å¿™ä¸”æœªè¾¾ä¸Šé™ï¼Œåˆ›å»ºæ–°Worker
        if (this.workers.size < this.config.maxWorkers) {
          const newWorkerId = this.createWorker();
          setTimeout(() => {
            this.processTaskQueue();
          }, 100); // ç»™æ–°Workerä¸€ç‚¹åˆå§‹åŒ–æ—¶é—´
        }
      }
    });
  }
  
  private findAvailableWorker(): WorkerInstance | null {
    for (const worker of this.workers.values()) {
      if (worker.isIdle && worker.taskCount < this.config.maxTasksPerWorker) {
        return worker;
      }
    }
    return null;
  }
  
  private assignTaskToWorker(workerId: string, task: WorkerTask): void {
    const worker = this.workers.get(workerId);
    if (!worker || !worker.isIdle) {
      console.error(`æ— æ³•åˆ†é…ä»»åŠ¡åˆ°Worker ${workerId}: Workerä¸å¯ç”¨`);
      return;
    }
    
    worker.isIdle = false;
    worker.currentTask = task;
    worker.taskCount++;
    worker.lastUsed = Date.now();
    
    // å‘é€ä»»åŠ¡åˆ°Worker
    const message = {
      type: 'task',
      taskId: task.id,
      taskType: task.type,
      payload: task.payload,
      timestamp: Date.now()
    };
    
    if (task.transferables) {
      worker.worker.postMessage(message, task.transferables);
    } else {
      worker.worker.postMessage(message);
    }
    
    console.debug(`ä»»åŠ¡å·²åˆ†é…åˆ°Worker: ${task.id} -> ${workerId}`);
  }
  
  private handleWorkerMessage(workerId: string, event: MessageEvent): void {
    const { type, taskId, result, error, executionTime } = event.data;
    
    switch (type) {
      case 'task_complete':
        this.handleTaskComplete(workerId, taskId, result, executionTime);
        break;
        
      case 'task_error':
        this.handleTaskError(workerId, taskId, error);
        break;
        
      case 'worker_ready':
        console.log(`Workerå·²å°±ç»ª: ${workerId}`);
        this.processTaskQueue();
        break;
        
      case 'heartbeat':
        // Workerå¿ƒè·³å“åº”ï¼Œæ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
        const worker = this.workers.get(workerId);
        if (worker) {
          worker.lastUsed = Date.now();
        }
        break;
    }
  }
  
  private handleTaskComplete(workerId: string, taskId: string, result: any, executionTime: number): void {
    const worker = this.workers.get(workerId);
    const pendingTask = this.pendingTasks.get(taskId);
    
    if (worker) {
      worker.isIdle = true;
      worker.currentTask = null;
      worker.lastUsed = Date.now();
    }
    
    if (pendingTask) {
      const workerResult: WorkerResult = {
        taskId,
        result,
        executionTime,
        workerId
      };
      
      pendingTask.resolve(workerResult);
      this.pendingTasks.delete(taskId);
    }
    
    console.debug(`ä»»åŠ¡å®Œæˆ: ${taskId} (Worker: ${workerId}, è€—æ—¶: ${executionTime}ms)`);
    
    // å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ¡
    this.processTaskQueue();
  }
  
  private handleTaskError(workerId: string, taskId: string, error: string): void {
    const worker = this.workers.get(workerId);
    const pendingTask = this.pendingTasks.get(taskId);
    
    if (worker) {
      worker.isIdle = true;
      worker.currentTask = null;
      worker.errorCount++;
      worker.lastUsed = Date.now();
    }
    
    if (pendingTask) {
      pendingTask.reject(new Error(`Workerä»»åŠ¡å¤±è´¥: ${error}`));
      this.pendingTasks.delete(taskId);
    }
    
    console.error(`Workerä»»åŠ¡å¤±è´¥: ${taskId} (Worker: ${workerId}) - ${error}`);
    
    // å¦‚æœWorkeré”™è¯¯è¿‡å¤šï¼Œè€ƒè™‘é‡å¯
    if (worker && worker.errorCount >= 5) {
      this.restartWorker(workerId);
    }
  }
  
  private handleWorkerError(workerId: string, error: ErrorEvent): void {
    console.error(`Workerè¿è¡Œæ—¶é”™è¯¯: ${workerId}`, error);
    
    const worker = this.workers.get(workerId);
    if (worker) {
      worker.errorCount++;
      
      // å¦‚æœæœ‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œæ ‡è®°ä¸ºå¤±è´¥
      if (worker.currentTask) {
        const pendingTask = this.pendingTasks.get(worker.currentTask.id);
        if (pendingTask) {
          pendingTask.reject(new Error(`Workerå´©æºƒ: ${error.message}`));
          this.pendingTasks.delete(worker.currentTask.id);
        }
      }
      
      // é‡å¯Worker
      this.restartWorker(workerId);
    }
  }
  
  private processTaskQueue(): void {
    while (!this.taskQueue.isEmpty()) {
      const availableWorker = this.findAvailableWorker();
      if (!availableWorker) break;
      
      const task = this.taskQueue.dequeue();
      if (task) {
        this.assignTaskToWorker(availableWorker.id, task);
      }
    }
  }
  
  private restartWorker(workerId: string): void {
    console.log(`é‡å¯Worker: ${workerId}`);
    
    const worker = this.workers.get(workerId);
    if (worker) {
      worker.worker.terminate();
      this.workers.delete(workerId);
    }
    
    // åˆ›å»ºæ–°Workeræ›¿ä»£
    this.createWorker();
  }
  
  private startHealthCheck(): void {
    setInterval(() => {
      const now = Date.now();
      
      // æ£€æŸ¥ç©ºé—²Workerï¼Œæ¸…ç†é•¿æ—¶é—´æœªä½¿ç”¨çš„Worker
      for (const [workerId, worker] of this.workers) {
        const idleTime = now - worker.lastUsed;
        
        if (worker.isIdle && 
            idleTime > this.config.workerIdleTimeout && 
            this.workers.size > 2) { // ä¿ç•™è‡³å°‘2ä¸ªWorker
          console.log(`æ¸…ç†ç©ºé—²Worker: ${workerId} (ç©ºé—²æ—¶é—´: ${idleTime}ms)`);
          worker.worker.terminate();
          this.workers.delete(workerId);
        }
      }
      
      // å‘é€å¿ƒè·³æ£€æŸ¥
      for (const worker of this.workers.values()) {
        worker.worker.postMessage({ type: 'ping', timestamp: now });
      }
    }, this.config.heartbeatInterval);
  }
  
  // è·å–Workeræ± çŠ¶æ€
  getPoolStatus(): WorkerPoolStatus {
    const workers = Array.from(this.workers.values());
    
    return {
      totalWorkers: workers.length,
      idleWorkers: workers.filter(w => w.isIdle).length,
      busyWorkers: workers.filter(w => !w.isIdle).length,
      queuedTasks: this.taskQueue.size(),
      pendingTasks: this.pendingTasks.size,
      averageTaskTime: this.calculateAverageTaskTime(),
      totalTasksProcessed: workers.reduce((sum, w) => sum + w.taskCount, 0)
    };
  }
  
  private calculateAverageTaskTime(): number {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ç»´æŠ¤ä»»åŠ¡æ‰§è¡Œæ—¶é—´å†å²
    return 0;
  }
  
  // ä¼˜é›…å…³é—­Workeræ± 
  async shutdown(): Promise<void> {
    console.log('å¼€å§‹å…³é—­Workeræ± ...');
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆæˆ–è¶…æ—¶
    const maxWaitTime = 5000;
    const startTime = Date.now();
    
    while (this.pendingTasks.size > 0 && (Date.now() - startTime) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    // ç»ˆæ­¢æ‰€æœ‰Worker
    for (const [workerId, worker] of this.workers) {
      worker.worker.terminate();
      console.log(`Workerå·²ç»ˆæ­¢: ${workerId}`);
    }
    
    this.workers.clear();
    this.pendingTasks.clear();
    
    console.log('Workeræ± å·²å…³é—­');
  }
}

// æ¥å£å®šä¹‰
interface WorkerInstance {
  id: string;
  worker: Worker;
  isIdle: boolean;
  currentTask: WorkerTask | null;
  taskCount: number;
  createdAt: number;
  lastUsed: number;
  errorCount: number;
}

interface PendingTask {
  task: WorkerTask;
  resolve: (result: WorkerResult) => void;
  reject: (error: Error) => void;
  submittedAt: number;
}

interface WorkerPoolStatus {
  totalWorkers: number;
  idleWorkers: number;
  busyWorkers: number;
  queuedTasks: number;
  pendingTasks: number;
  averageTaskTime: number;
  totalTasksProcessed: number;
}
```

### 6.4.5 èƒŒå‹å¤„ç†ä¸é™çº§ç­–ç•¥

**å¤šå±‚æ¸è¿›å¼èƒŒå‹å“åº”**ï¼š
å½“ç³»ç»Ÿè´Ÿè½½è¶…å‡ºå¤„ç†èƒ½åŠ›æ—¶ï¼Œé‡‡ç”¨åˆ†çº§é™çº§ç­–ç•¥ç¡®ä¿æ ¸å¿ƒåŠŸèƒ½çš„ç¨³å®šè¿è¡Œã€‚

```typescript
// core/backpressure/BackpressureController.ts - èƒŒå‹æ§åˆ¶å™¨
export enum BackpressureLevel {
  NORMAL = 0,       // æ­£å¸¸è¿è¡Œ
  LIGHT = 1,        // è½»å¾®èƒŒå‹
  MODERATE = 2,     // ä¸­ç­‰èƒŒå‹
  HEAVY = 3,        // é‡åº¦èƒŒå‹
  CRITICAL = 4      // ä¸´ç•ŒèƒŒå‹
}

export interface BackpressureMetrics {
  frameTime: number;
  averageFPS: number;
  taskQueueDepth: number;
  memoryUsage: number;
  workerUtilization: number;
  level: BackpressureLevel;
}

export interface DegradationAction {
  level: BackpressureLevel;
  action: string;
  description: string;
  reversible: boolean;
}

export class BackpressureController {
  private currentLevel = BackpressureLevel.NORMAL;
  private metricsHistory: BackpressureMetrics[] = [];
  private activeGradations: Set<string> = new Set();
  
  private degradationActions: DegradationAction[] = [
    // Level 1: è½»å¾®èƒŒå‹ - å»¶è¿Ÿéå…³é”®ä»»åŠ¡
    {
      level: BackpressureLevel.LIGHT,
      action: 'defer_ai_tasks',
      description: 'å»¶è¿ŸAIè®¡ç®—ä»»åŠ¡',
      reversible: true
    },
    {
      level: BackpressureLevel.LIGHT,
      action: 'reduce_ui_updates',
      description: 'é™ä½UIæ›´æ–°é¢‘ç‡',
      reversible: true
    },
    
    // Level 2: ä¸­ç­‰èƒŒå‹ - é™ä½è´¨é‡è®¾ç½®
    {
      level: BackpressureLevel.MODERATE,
      action: 'reduce_particle_effects',
      description: 'å‡å°‘ç²’å­æ•ˆæœ',
      reversible: true
    },
    {
      level: BackpressureLevel.MODERATE,
      action: 'lower_audio_quality',
      description: 'é™ä½éŸ³é¢‘è´¨é‡',
      reversible: true
    },
    {
      level: BackpressureLevel.MODERATE,
      action: 'simplify_animations',
      description: 'ç®€åŒ–åŠ¨ç”»æ•ˆæœ',
      reversible: true
    },
    
    // Level 3: é‡åº¦èƒŒå‹ - æš‚åœæ¬¡è¦åŠŸèƒ½
    {
      level: BackpressureLevel.HEAVY,
      action: 'pause_ai_computation',
      description: 'æš‚åœAIè®¡ç®—',
      reversible: true
    },
    {
      level: BackpressureLevel.HEAVY,
      action: 'disable_physics_details',
      description: 'ç¦ç”¨ç‰©ç†ç»†èŠ‚',
      reversible: true
    },
    {
      level: BackpressureLevel.HEAVY,
      action: 'reduce_render_distance',
      description: 'å‡å°‘æ¸²æŸ“è·ç¦»',
      reversible: true
    },
    
    // Level 4: ä¸´ç•ŒèƒŒå‹ - ç´§æ€¥æ¨¡å¼
    {
      level: BackpressureLevel.CRITICAL,
      action: 'enter_emergency_mode',
      description: 'è¿›å…¥ç´§æ€¥èŠ‚èƒ½æ¨¡å¼',
      reversible: false
    },
    {
      level: BackpressureLevel.CRITICAL,
      action: 'show_performance_warning',
      description: 'æ˜¾ç¤ºæ€§èƒ½è­¦å‘Š',
      reversible: false
    }
  ];
  
  constructor(
    private budgetManager: DynamicBudgetManager,
    private scheduler: TimeSliceScheduler,
    private workerPool: WorkerPoolManager,
    private eventBus: EventBus
  ) {
    this.startMonitoring();
  }
  
  private startMonitoring(): void {
    // æ¯å¸§æ£€æŸ¥èƒŒå‹çº§åˆ«
    setInterval(() => {
      const metrics = this.collectMetrics();
      this.updateBackpressureLevel(metrics);
    }, 100); // 100msé—´éš”
    
    // æ¯ç§’åº”ç”¨é™çº§ç­–ç•¥
    setInterval(() => {
      this.applyDegradationStrategies();
    }, 1000);
  }
  
  private collectMetrics(): BackpressureMetrics {
    const performanceReport = this.budgetManager.getPerformanceReport();
    const schedulerStatus = this.scheduler.getSchedulerStatus();
    const workerStatus = this.workerPool.getPoolStatus();
    
    const metrics: BackpressureMetrics = {
      frameTime: performanceReport.p95FrameTime,
      averageFPS: performanceReport.averageFPS,
      taskQueueDepth: schedulerStatus.queueSize,
      memoryUsage: this.getMemoryUsage(),
      workerUtilization: this.calculateWorkerUtilization(workerStatus),
      level: this.calculateBackpressureLevel(performanceReport, schedulerStatus, workerStatus)
    };
    
    // ä¿ç•™æœ€è¿‘30ä¸ªæŒ‡æ ‡ç”¨äºè¶‹åŠ¿åˆ†æ
    this.metricsHistory.push(metrics);
    if (this.metricsHistory.length > 30) {
      this.metricsHistory.shift();
    }
    
    return metrics;
  }
  
  private calculateBackpressureLevel(
    performanceReport: PerformanceReport,
    schedulerStatus: SchedulerStatus,
    workerStatus: WorkerPoolStatus
  ): BackpressureLevel {
    let score = 0;
    
    // FPSè¯„åˆ† (0-4åˆ†)
    if (performanceReport.averageFPS < 45) score += 4;
    else if (performanceReport.averageFPS < 50) score += 3;
    else if (performanceReport.averageFPS < 55) score += 2;
    else if (performanceReport.averageFPS < 58) score += 1;
    
    // å¸§æ—¶é—´è¯„åˆ† (0-3åˆ†)
    if (performanceReport.p95FrameTime > 22) score += 3;
    else if (performanceReport.p95FrameTime > 20) score += 2;
    else if (performanceReport.p95FrameTime > 18) score += 1;
    
    // ä»»åŠ¡é˜Ÿåˆ—è¯„åˆ† (0-2åˆ†)
    if (schedulerStatus.queueSize > 100) score += 2;
    else if (schedulerStatus.queueSize > 50) score += 1;
    
    // Workeråˆ©ç”¨ç‡è¯„åˆ† (0-1åˆ†)
    if (workerStatus.busyWorkers / Math.max(1, workerStatus.totalWorkers) > 0.9) score += 1;
    
    // å†…å­˜ä½¿ç”¨è¯„åˆ† (0-2åˆ†)
    const memoryUsage = this.getMemoryUsage();
    if (memoryUsage > 0.9) score += 2;
    else if (memoryUsage > 0.8) score += 1;
    
    // æ ¹æ®æ€»åˆ†ç¡®å®šèƒŒå‹çº§åˆ«
    if (score >= 8) return BackpressureLevel.CRITICAL;
    if (score >= 6) return BackpressureLevel.HEAVY;
    if (score >= 4) return BackpressureLevel.MODERATE;
    if (score >= 2) return BackpressureLevel.LIGHT;
    
    return BackpressureLevel.NORMAL;
  }
  
  private updateBackpressureLevel(metrics: BackpressureMetrics): void {
    const newLevel = metrics.level;
    
    if (newLevel !== this.currentLevel) {
      console.log(`èƒŒå‹çº§åˆ«å˜åŒ–: ${BackpressureLevel[this.currentLevel]} -> ${BackpressureLevel[newLevel]}`);
      
      const previousLevel = this.currentLevel;
      this.currentLevel = newLevel;
      
      // å‘å¸ƒèƒŒå‹çº§åˆ«å˜åŒ–äº‹ä»¶
      this.eventBus.emit('backpressure:level_changed', {
        from: previousLevel,
        to: newLevel,
        metrics,
        timestamp: Date.now()
      });
      
      // ç«‹å³åº”ç”¨é™çº§ç­–ç•¥
      this.applyDegradationStrategies();
    }
  }
  
  private applyDegradationStrategies(): void {
    // åº”ç”¨å½“å‰çº§åˆ«çš„é™çº§ç­–ç•¥
    const currentActions = this.degradationActions.filter(action => 
      action.level <= this.currentLevel && !this.activeGradations.has(action.action)
    );
    
    for (const action of currentActions) {
      this.executeGradationAction(action, true);
      this.activeGradations.add(action.action);
    }
    
    // æ¢å¤ä¸å†éœ€è¦çš„é™çº§ç­–ç•¥
    const actionsToRevert = this.degradationActions.filter(action => 
      action.level > this.currentLevel && 
      action.reversible && 
      this.activeGradations.has(action.action)
    );
    
    for (const action of actionsToRevert) {
      this.executeGradationAction(action, false);
      this.activeGradations.delete(action.action);
    }
  }
  
  private executeGradationAction(action: DegradationAction, apply: boolean): void {
    const actionType = apply ? 'åº”ç”¨' : 'æ¢å¤';
    console.log(`${actionType}é™çº§ç­–ç•¥: ${action.description}`);
    
    try {
      switch (action.action) {
        case 'defer_ai_tasks':
          this.scheduler.setMinPriority(apply ? TaskPriority.MEDIUM : TaskPriority.LOW);
          break;
          
        case 'reduce_ui_updates':
          this.eventBus.emit('ui:set_update_frequency', { 
            frequency: apply ? 30 : 60 // é™ä½åˆ°30FPSæˆ–æ¢å¤60FPS
          });
          break;
          
        case 'reduce_particle_effects':
          this.eventBus.emit('game:set_particle_density', { 
            density: apply ? 0.5 : 1.0 
          });
          break;
          
        case 'lower_audio_quality':
          this.eventBus.emit('audio:set_quality', { 
            quality: apply ? 'medium' : 'high' 
          });
          break;
          
        case 'simplify_animations':
          this.eventBus.emit('game:set_animation_quality', { 
            quality: apply ? 'low' : 'high' 
          });
          break;
          
        case 'pause_ai_computation':
          this.eventBus.emit('ai:set_enabled', { enabled: !apply });
          break;
          
        case 'disable_physics_details':
          this.eventBus.emit('physics:set_detail_level', { 
            level: apply ? 'low' : 'high' 
          });
          break;
          
        case 'reduce_render_distance':
          this.eventBus.emit('render:set_distance', { 
            distance: apply ? 0.7 : 1.0 
          });
          break;
          
        case 'enter_emergency_mode':
          if (apply) {
            this.enterEmergencyMode();
          }
          break;
          
        case 'show_performance_warning':
          if (apply) {
            this.showPerformanceWarning();
          }
          break;
      }
    } catch (error) {
      console.error(`é™çº§ç­–ç•¥æ‰§è¡Œå¤±è´¥: ${action.action}`, error);
    }
  }
  
  private enterEmergencyMode(): void {
    console.warn('ğŸš¨ è¿›å…¥ç´§æ€¥æ€§èƒ½æ¨¡å¼');
    
    // æš‚åœæ‰€æœ‰éå…³é”®ç³»ç»Ÿ
    this.eventBus.emit('game:enter_emergency_mode', {
      disableAI: true,
      disableEffects: true,
      minimalRendering: true,
      timestamp: Date.now()
    });
    
    // æ˜¾ç¤ºç”¨æˆ·é€šçŸ¥
    this.eventBus.emit('ui:show_notification', {
      type: 'warning',
      title: 'æ€§èƒ½è­¦å‘Š',
      message: 'ç³»ç»Ÿæ€§èƒ½ä¸è¶³ï¼Œå·²å¯ç”¨ç´§æ€¥èŠ‚èƒ½æ¨¡å¼',
      duration: 10000
    });
  }
  
  private showPerformanceWarning(): void {
    this.eventBus.emit('ui:show_performance_dialog', {
      metrics: this.metricsHistory[this.metricsHistory.length - 1],
      suggestions: [
        'å…³é—­å…¶ä»–åº”ç”¨ç¨‹åºé‡Šæ”¾ç³»ç»Ÿèµ„æº',
        'é™ä½æ¸¸æˆç”»è´¨è®¾ç½®',
        'æ£€æŸ¥ç³»ç»Ÿæ•£çƒ­æƒ…å†µ',
        'è€ƒè™‘å‡çº§ç¡¬ä»¶é…ç½®'
      ]
    });
  }
  
  private getMemoryUsage(): number {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      return memory.usedJSHeapSize / memory.totalJSHeapSize;
    }
    return 0.5; // é»˜è®¤ä¼°è®¡å€¼
  }
  
  private calculateWorkerUtilization(status: WorkerPoolStatus): number {
    if (status.totalWorkers === 0) return 0;
    return status.busyWorkers / status.totalWorkers;
  }
  
  // è·å–èƒŒå‹çŠ¶æ€æŠ¥å‘Š
  getBackpressureReport(): BackpressureReport {
    const latestMetrics = this.metricsHistory[this.metricsHistory.length - 1];
    
    return {
      currentLevel: this.currentLevel,
      levelName: BackpressureLevel[this.currentLevel],
      metrics: latestMetrics,
      activeGradations: Array.from(this.activeGradations),
      trend: this.calculateTrend(),
      recommendation: this.generateRecommendation()
    };
  }
  
  private calculateTrend(): 'improving' | 'stable' | 'deteriorating' {
    if (this.metricsHistory.length < 10) return 'stable';
    
    const recent = this.metricsHistory.slice(-5);
    const earlier = this.metricsHistory.slice(-10, -5);
    
    const recentAvgFPS = recent.reduce((sum, m) => sum + m.averageFPS, 0) / recent.length;
    const earlierAvgFPS = earlier.reduce((sum, m) => sum + m.averageFPS, 0) / earlier.length;
    
    const improvement = recentAvgFPS - earlierAvgFPS;
    
    if (improvement > 2) return 'improving';
    if (improvement < -2) return 'deteriorating';
    return 'stable';
  }
  
  private generateRecommendation(): string {
    const metrics = this.metricsHistory[this.metricsHistory.length - 1];
    if (!metrics) return 'æš‚æ— å»ºè®®';
    
    if (metrics.averageFPS < 45) {
      return 'ä¸¥é‡æ€§èƒ½é—®é¢˜ï¼šå»ºè®®é‡å¯åº”ç”¨æˆ–é™ä½ç”»è´¨è®¾ç½®';
    } else if (metrics.taskQueueDepth > 50) {
      return 'ä»»åŠ¡ç§¯å‹è¿‡å¤šï¼šè€ƒè™‘ä¼˜åŒ–AIç®—æ³•æˆ–å‡å°‘å¹¶å‘ä»»åŠ¡';
    } else if (metrics.memoryUsage > 0.8) {
      return 'å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜ï¼šå»ºè®®é‡Šæ”¾ä¸å¿…è¦çš„èµ„æº';
    } else if (this.currentLevel === BackpressureLevel.NORMAL) {
      return 'ç³»ç»Ÿè¿è¡Œæ­£å¸¸';
    }
    
    return 'æŒç»­ç›‘æ§ä¸­ï¼Œæ ¹æ®å®é™…æƒ…å†µè‡ªåŠ¨è°ƒæ•´';
  }
}

interface BackpressureReport {
  currentLevel: BackpressureLevel;
  levelName: string;
  metrics: BackpressureMetrics;
  activeGradations: string[];
  trend: 'improving' | 'stable' | 'deteriorating';
  recommendation: string;
}
```

### 6.4.6 Phaser 3 TimeStepæ·±åº¦é›†æˆ

**æ—¶é—´æ­¥é•¿ç®¡ç†ä¸æ€§èƒ½ç›‘æ§**ï¼š
ä¸Phaser 3çš„TimeStepç³»ç»Ÿæ·±åº¦é›†æˆï¼Œå®ç°ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶å’Œæ€§èƒ½è°ƒä¼˜ã€‚

```typescript
// core/integration/PhaserTimeStepIntegration.ts - Phaser TimeStepé›†æˆ
export class PhaserTimeStepIntegration {
  private phaserGame: Phaser.Game;
  private timeStep: Phaser.Time.TimeStep;
  private performanceProfiler: PerformanceProfiler;
  
  // TimeStepé…ç½®
  private config = {
    targetFPS: 60,
    deltaHistory: 10,        // 10å¸§deltaå†å²ç”¨äºå¹³æ»‘
    panicMax: 120,          // é˜²æ­¢spiral of death
    smoothStep: true,        // å¯ç”¨deltaå¹³æ»‘
    forceSetTimeOut: false,  // ä¸å¼ºåˆ¶ä½¿ç”¨setTimeout
    maxDelta: 33.33         // æœ€å¤§deltaæ—¶é—´(30FPSå…œåº•)
  };
  
  // æ€§èƒ½ç»Ÿè®¡
  private stats = {
    frameCount: 0,
    totalTime: 0,
    averageFrameTime: 16.67,
    minFrameTime: 16.67,
    maxFrameTime: 16.67,
    frameTimeHistory: [] as number[],
    deltaHistory: [] as number[],
    fpsHistory: [] as number[]
  };
  
  constructor(phaserGame: Phaser.Game) {
    this.phaserGame = phaserGame;
    this.timeStep = phaserGame.loop.timeStep;
    this.performanceProfiler = new PerformanceProfiler();
    
    this.initializeTimeStep();
    this.setupMonitoring();
  }
  
  private initializeTimeStep(): void {
    // é…ç½®Phaser TimeStep
    this.phaserGame.config.fps = {
      target: this.config.targetFPS,
      deltaHistory: this.config.deltaHistory,
      panicMax: this.config.panicMax,
      smoothStep: this.config.smoothStep,
      forceSetTimeOut: this.config.forceSetTimeOut
    };
    
    // è®¾ç½®æ—¶é—´æ­¥é•¿é™åˆ¶
    this.timeStep.maxDelta = this.config.maxDelta;
    this.timeStep.targetDelta = 1000 / this.config.targetFPS;
    
    console.log('Phaser TimeStepå·²é…ç½®:', {
      targetFPS: this.config.targetFPS,
      targetDelta: this.timeStep.targetDelta,
      maxDelta: this.timeStep.maxDelta
    });
  }
  
  private setupMonitoring(): void {
    // ç›‘å¬Phaseræ¸¸æˆå¾ªç¯äº‹ä»¶
    this.phaserGame.events.on('prestep', this.onPreStep.bind(this));
    this.phaserGame.events.on('step', this.onStep.bind(this));
    this.phaserGame.events.on('poststep', this.onPostStep.bind(this));
    
    // ç›‘å¬TimeStepäº‹ä»¶
    this.phaserGame.events.on('ready', () => {
      console.log('Phaseræ¸¸æˆå·²å°±ç»ªï¼Œå¼€å§‹æ€§èƒ½ç›‘æ§');
      this.startPerformanceLogging();
    });
  }
  
  private onPreStep(time: number, delta: number): void {
    this.performanceProfiler.startFrame(time);
    
    // è®°å½•å¸§å¼€å§‹æ—¶é—´
    this.stats.frameCount++;
    
    // è®¡ç®—å®é™…å¸§æ—¶é—´
    const actualFrameTime = performance.now();
    if (this.stats.frameTimeHistory.length > 0) {
      const lastFrameTime = this.stats.frameTimeHistory[this.stats.frameTimeHistory.length - 1];
      const frameTime = actualFrameTime - lastFrameTime;
      
      this.updateFrameTimeStats(frameTime);
    }
    
    this.stats.frameTimeHistory.push(actualFrameTime);
    if (this.stats.frameTimeHistory.length > 60) {
      this.stats.frameTimeHistory.shift();
    }
  }
  
  private onStep(time: number, delta: number): void {
    // è®°å½•TimeStepè®¡ç®—çš„delta
    this.stats.deltaHistory.push(delta);
    if (this.stats.deltaHistory.length > this.config.deltaHistory) {
      this.stats.deltaHistory.shift();
    }
    
    // è®¡ç®—å½“å‰FPS
    const currentFPS = delta > 0 ? 1000 / delta : 0;
    this.stats.fpsHistory.push(currentFPS);
    if (this.stats.fpsHistory.length > 60) {
      this.stats.fpsHistory.shift();
    }
    
    // æ£€æµ‹æ€§èƒ½å¼‚å¸¸
    this.detectPerformanceAnomalies(time, delta);
  }
  
  private onPostStep(time: number, delta: number): void {
    const frameEndTime = performance.now();
    const frameDuration = frameEndTime - (this.stats.frameTimeHistory[this.stats.frameTimeHistory.length - 1] || frameEndTime);
    
    this.performanceProfiler.endFrame(frameDuration);
    
    // è®°å½•æ€»æ—¶é—´
    this.stats.totalTime += delta;
    
    // æ¯60å¸§è¾“å‡ºä¸€æ¬¡æ€§èƒ½æŠ¥å‘Š
    if (this.stats.frameCount % 60 === 0) {
      this.logPerformanceMetrics();
    }
  }
  
  private updateFrameTimeStats(frameTime: number): void {
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    this.stats.minFrameTime = Math.min(this.stats.minFrameTime, frameTime);
    this.stats.maxFrameTime = Math.max(this.stats.maxFrameTime, frameTime);
    
    // è®¡ç®—ç§»åŠ¨å¹³å‡
    const historyLength = Math.min(60, this.stats.frameCount);
    this.stats.averageFrameTime = (
      (this.stats.averageFrameTime * (historyLength - 1)) + frameTime
    ) / historyLength;
  }
  
  private detectPerformanceAnomalies(time: number, delta: number): void {
    // æ£€æµ‹å¸§æ—¶é—´å°–å³°
    if (delta > this.config.maxDelta * 0.8) {
      console.warn(`æ€§èƒ½å°–å³°æ£€æµ‹: delta=${delta.toFixed(2)}ms (é˜ˆå€¼: ${this.config.maxDelta}ms)`);
      
      // å‘å¸ƒæ€§èƒ½è­¦å‘Šäº‹ä»¶
      this.phaserGame.events.emit('performance:spike_detected', {
        time,
        delta,
        threshold: this.config.maxDelta,
        severity: delta > this.config.maxDelta ? 'critical' : 'warning'
      });
    }
    
    // æ£€æµ‹FPSä¸‹é™
    const recentFPS = this.stats.fpsHistory.slice(-5);
    const avgRecentFPS = recentFPS.reduce((sum, fps) => sum + fps, 0) / recentFPS.length;
    
    if (avgRecentFPS < this.config.targetFPS * 0.8) {
      console.warn(`FPSä¸‹é™æ£€æµ‹: ${avgRecentFPS.toFixed(1)}FPS (ç›®æ ‡: ${this.config.targetFPS}FPS)`);
      
      this.phaserGame.events.emit('performance:fps_drop_detected', {
        currentFPS: avgRecentFPS,
        targetFPS: this.config.targetFPS,
        severity: avgRecentFPS < this.config.targetFPS * 0.6 ? 'critical' : 'warning'
      });
    }
  }
  
  private startPerformanceLogging(): void {
    // æ¯5ç§’è¾“å‡ºä¸€æ¬¡è¯¦ç»†çš„æ€§èƒ½æŠ¥å‘Š
    setInterval(() => {
      this.logDetailedPerformanceReport();
    }, 5000);
  }
  
  private logPerformanceMetrics(): void {
    const avgFPS = this.stats.fpsHistory.length > 0 
      ? this.stats.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.stats.fpsHistory.length 
      : 0;
    
    const avgDelta = this.stats.deltaHistory.length > 0 
      ? this.stats.deltaHistory.reduce((sum, delta) => sum + delta, 0) / this.stats.deltaHistory.length 
      : 0;
    
    console.log(`æ€§èƒ½æŒ‡æ ‡ [å¸§#${this.stats.frameCount}]: ` +
      `FPS=${avgFPS.toFixed(1)} ` +
      `Delta=${avgDelta.toFixed(2)}ms ` +
      `FrameTime=${this.stats.averageFrameTime.toFixed(2)}ms`);
  }
  
  private logDetailedPerformanceReport(): void {
    const report = this.generatePerformanceReport();
    
    console.group('ğŸ¯ Phaser TimeStepæ€§èƒ½æŠ¥å‘Š');
    console.log('TimeStepé…ç½®:', {
      targetFPS: this.config.targetFPS,
      targetDelta: this.timeStep.targetDelta,
      smoothStep: this.config.smoothStep,
      deltaHistory: this.config.deltaHistory
    });
    
    console.log('æ€§èƒ½ç»Ÿè®¡:', {
      averageFPS: report.averageFPS,
      frameStability: report.frameStability,
      deltaVariation: report.deltaVariation,
      performanceGrade: report.performanceGrade
    });
    
    console.log('å¸§æ—¶é—´åˆ†æ:', {
      average: report.frameTimeStats.average,
      min: report.frameTimeStats.min,
      max: report.frameTimeStats.max,
      p95: report.frameTimeStats.p95
    });
    
    if (report.issues.length > 0) {
      console.warn('æ£€æµ‹åˆ°çš„é—®é¢˜:', report.issues);
    }
    
    if (report.recommendations.length > 0) {
      console.info('ä¼˜åŒ–å»ºè®®:', report.recommendations);
    }
    
    console.groupEnd();
  }
  
  generatePerformanceReport(): TimeStepPerformanceReport {
    const avgFPS = this.stats.fpsHistory.length > 0 
      ? this.stats.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.stats.fpsHistory.length 
      : 0;
    
    const deltaVariation = this.calculateDeltaVariation();
    const frameStability = this.calculateFrameStability();
    
    // è®¡ç®—å¸§æ—¶é—´çš„P95å€¼
    const sortedFrameTimes = [...this.stats.frameTimeHistory].sort((a, b) => a - b);
    const p95Index = Math.floor(sortedFrameTimes.length * 0.95);
    const p95FrameTime = sortedFrameTimes[p95Index] || this.stats.averageFrameTime;
    
    const report: TimeStepPerformanceReport = {
      timestamp: Date.now(),
      frameCount: this.stats.frameCount,
      totalTime: this.stats.totalTime,
      averageFPS: avgFPS,
      deltaVariation: deltaVariation,
      frameStability: frameStability,
      performanceGrade: this.calculatePerformanceGrade(avgFPS, frameStability),
      
      frameTimeStats: {
        average: this.stats.averageFrameTime,
        min: this.stats.minFrameTime,
        max: this.stats.maxFrameTime,
        p95: p95FrameTime
      },
      
      timeStepHealth: {
        smoothingEffective: this.config.smoothStep && deltaVariation < 5,
        targetFPSAchieved: avgFPS >= this.config.targetFPS * 0.95,
        noPanicMode: !this.isInPanicMode(),
        deltaHistoryOptimal: this.config.deltaHistory >= 5
      },
      
      issues: this.identifyPerformanceIssues(avgFPS, frameStability, deltaVariation),
      recommendations: this.generateOptimizationRecommendations(avgFPS, frameStability)
    };
    
    return report;
  }
  
  private calculateDeltaVariation(): number {
    if (this.stats.deltaHistory.length < 2) return 0;
    
    const mean = this.stats.deltaHistory.reduce((sum, delta) => sum + delta, 0) / this.stats.deltaHistory.length;
    const variance = this.stats.deltaHistory.reduce((sum, delta) => sum + Math.pow(delta - mean, 2), 0) / this.stats.deltaHistory.length;
    
    return Math.sqrt(variance);
  }
  
  private calculateFrameStability(): number {
    if (this.stats.fpsHistory.length < 10) return 1.0;
    
    const mean = this.stats.fpsHistory.reduce((sum, fps) => sum + fps, 0) / this.stats.fpsHistory.length;
    const variance = this.stats.fpsHistory.reduce((sum, fps) => sum + Math.pow(fps - mean, 2), 0) / this.stats.fpsHistory.length;
    const stdDev = Math.sqrt(variance);
    
    // ç¨³å®šæ€§ = 1 - (æ ‡å‡†å·® / å¹³å‡å€¼)ï¼Œé™åˆ¶åœ¨[0, 1]èŒƒå›´å†…
    return Math.max(0, Math.min(1, 1 - (stdDev / mean)));
  }
  
  private calculatePerformanceGrade(fps: number, stability: number): 'A' | 'B' | 'C' | 'D' | 'F' {
    const score = (fps / this.config.targetFPS) * 0.7 + stability * 0.3;
    
    if (score >= 0.95) return 'A';  // ä¼˜ç§€
    if (score >= 0.85) return 'B';  // è‰¯å¥½
    if (score >= 0.75) return 'C';  // ä¸€èˆ¬
    if (score >= 0.60) return 'D';  // è¾ƒå·®
    return 'F';                     // å¾ˆå·®
  }
  
  private isInPanicMode(): boolean {
    // æ£€æŸ¥æ˜¯å¦è§¦å‘äº†Phaserçš„panicæ¨¡å¼
    return this.phaserGame.loop.actualFps > this.config.panicMax;
  }
  
  private identifyPerformanceIssues(fps: number, stability: number, variation: number): string[] {
    const issues: string[] = [];
    
    if (fps < this.config.targetFPS * 0.8) {
      issues.push(`FPSè¿‡ä½: ${fps.toFixed(1)} < ${(this.config.targetFPS * 0.8).toFixed(1)}`);
    }
    
    if (stability < 0.8) {
      issues.push(`å¸§ç‡ä¸ç¨³å®š: ç¨³å®šæ€§=${(stability * 100).toFixed(1)}%`);
    }
    
    if (variation > 10) {
      issues.push(`Deltaå˜åŒ–è¿‡å¤§: Ïƒ=${variation.toFixed(2)}ms`);
    }
    
    if (this.stats.maxFrameTime > this.config.maxDelta) {
      issues.push(`å­˜åœ¨ä¸¥é‡çš„å¸§æ—¶é—´å°–å³°: ${this.stats.maxFrameTime.toFixed(2)}ms`);
    }
    
    return issues;
  }
  
  private generateOptimizationRecommendations(fps: number, stability: number): string[] {
    const recommendations: string[] = [];
    
    if (fps < 50) {
      recommendations.push('è€ƒè™‘é™ä½æ¸¸æˆè´¨é‡è®¾ç½®æˆ–å¯ç”¨èƒŒå‹æ§åˆ¶');
    }
    
    if (stability < 0.7) {
      recommendations.push('æ£€æŸ¥æ˜¯å¦å­˜åœ¨åƒåœ¾å›æ”¶å¯¼è‡´çš„å¡é¡¿');
      recommendations.push('è€ƒè™‘å¢åŠ TimeStepçš„deltaHistoryæé«˜å¹³æ»‘æ•ˆæœ');
    }
    
    if (!this.config.smoothStep) {
      recommendations.push('å¯ç”¨TimeStepå¹³æ»‘åŠŸèƒ½ä»¥æ”¹å–„ç¨³å®šæ€§');
    }
    
    if (this.config.deltaHistory < 10 && stability < 0.8) {
      recommendations.push('å¢åŠ deltaHistoryä»¥æé«˜æ—¶é—´å¹³æ»‘æ•ˆæœ');
    }
    
    return recommendations;
  }
  
  // åŠ¨æ€è°ƒæ•´TimeStepé…ç½®
  optimizeTimeStepSettings(): void {
    const report = this.generatePerformanceReport();
    
    // æ ¹æ®æ€§èƒ½æŠ¥å‘Šè‡ªåŠ¨ä¼˜åŒ–è®¾ç½®
    if (report.frameStability < 0.8 && this.config.deltaHistory < 15) {
      this.config.deltaHistory = Math.min(15, this.config.deltaHistory + 2);
      this.phaserGame.config.fps.deltaHistory = this.config.deltaHistory;
      console.log(`è‡ªåŠ¨ä¼˜åŒ–: å¢åŠ deltaHistoryåˆ°${this.config.deltaHistory}`);
    }
    
    if (report.averageFPS < 45 && !this.config.smoothStep) {
      this.config.smoothStep = true;
      this.phaserGame.config.fps.smoothStep = true;
      console.log('è‡ªåŠ¨ä¼˜åŒ–: å¯ç”¨TimeStepå¹³æ»‘');
    }
  }
  
  // è·å–å®æ—¶æ€§èƒ½æ•°æ®
  getRealTimeMetrics(): RealTimeMetrics {
    const currentFPS = this.stats.fpsHistory.length > 0 
      ? this.stats.fpsHistory[this.stats.fpsHistory.length - 1] 
      : 0;
    
    const currentDelta = this.stats.deltaHistory.length > 0 
      ? this.stats.deltaHistory[this.stats.deltaHistory.length - 1] 
      : 0;
    
    return {
      currentFPS: currentFPS,
      currentDelta: currentDelta,
      targetFPS: this.config.targetFPS,
      targetDelta: this.timeStep.targetDelta,
      isPerformingWell: currentFPS >= this.config.targetFPS * 0.9,
      frameCount: this.stats.frameCount,
      runningTime: this.stats.totalTime / 1000 // è½¬æ¢ä¸ºç§’
    };
  }
}

// æ¥å£å®šä¹‰
interface TimeStepPerformanceReport {
  timestamp: number;
  frameCount: number;
  totalTime: number;
  averageFPS: number;
  deltaVariation: number;
  frameStability: number;
  performanceGrade: 'A' | 'B' | 'C' | 'D' | 'F';
  
  frameTimeStats: {
    average: number;
    min: number;
    max: number;
    p95: number;
  };
  
  timeStepHealth: {
    smoothingEffective: boolean;
    targetFPSAchieved: boolean;
    noPanicMode: boolean;
    deltaHistoryOptimal: boolean;
  };
  
  issues: string[];
  recommendations: string[];
}

interface RealTimeMetrics {
  currentFPS: number;
  currentDelta: number;
  targetFPS: number;
  targetDelta: number;
  isPerformingWell: boolean;
  frameCount: number;
  runningTime: number;
}

// æ€§èƒ½åˆ†æå™¨
export class PerformanceProfiler {
  private frameStartTime = 0;
  private frameData: FrameData[] = [];
  
  startFrame(time: number): void {
    this.frameStartTime = performance.now();
  }
  
  endFrame(duration: number): void {
    const frameData: FrameData = {
      duration: duration,
      timestamp: Date.now(),
      components: {}
    };
    
    this.frameData.push(frameData);
    
    // ä¿ç•™æœ€è¿‘1000å¸§çš„æ•°æ®
    if (this.frameData.length > 1000) {
      this.frameData.shift();
    }
  }
  
  getFrameAnalysis(): FrameAnalysis {
    if (this.frameData.length === 0) {
      return {
        averageFrameTime: 0,
        p95FrameTime: 0,
        maxFrameTime: 0,
        minFrameTime: 0,
        totalFrames: 0
      };
    }
    
    const durations = this.frameData.map(frame => frame.duration);
    durations.sort((a, b) => a - b);
    
    const sum = durations.reduce((total, duration) => total + duration, 0);
    const average = sum / durations.length;
    
    const p95Index = Math.floor(durations.length * 0.95);
    const p95 = durations[p95Index];
    
    return {
      averageFrameTime: average,
      p95FrameTime: p95,
      maxFrameTime: durations[durations.length - 1],
      minFrameTime: durations[0],
      totalFrames: this.frameData.length
    };
  }
}

interface FrameData {
  duration: number;
  timestamp: number;
  components: Record<string, number>;
}

interface FrameAnalysis {
  averageFrameTime: number;
  p95FrameTime: number;
  maxFrameTime: number;
  minFrameTime: number;
  totalFrames: number;
}
```

## 6.5 é”™è¯¯è·¯å¾„ä¸å¯è§‚æµ‹æ€§

> **åŒè¿›ç¨‹ååŒç›‘æ§**ï¼šä¸»è¿›ç¨‹ç³»ç»Ÿçº§ç›‘æ§ + æ¸²æŸ“è¿›ç¨‹UI/æ¸¸æˆç›‘æ§ + å…¨é“¾è·¯é”™è¯¯è¿½è¸ª + Releaseå¥åº·çŠ¶æ€ç›‘æ§

### 6.5.1 ElectronåŒè¿›ç¨‹Sentryé›†æˆæ¶æ„

#### ä¸»è¿›ç¨‹ç›‘æ§é…ç½®ï¼ˆNode.jsç¯å¢ƒï¼‰

```typescript
// src/main/monitoring/sentry-main.ts - ä¸»è¿›ç¨‹é”™è¯¯ç›‘æ§
import { app, BrowserWindow } from 'electron';
import * as Sentry from '@sentry/electron/main';

/* ä¸»è¿›ç¨‹Sentryåˆå§‹åŒ– - åº”ç”¨å¯åŠ¨æ—¶æœ€ä¼˜å…ˆæ‰§è¡Œ */
export function initializeMainProcessMonitoring(): void {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV || 'development',
    release: `guild-manager@${app.getVersion()}`,
    
    // å¯ç”¨åŸç”Ÿå´©æºƒæŠ¥å‘Šå’Œç¦»çº¿å­˜å‚¨
    enableNative: true,
    enableNativeCrashHandling: true,
    
    integrations: [
      // ä¸»è¿›ç¨‹ä¸“ç”¨é›†æˆ
      new Sentry.Integrations.Electron.MainProcessIntegration({
        sendNativeStackTrace: true,
        addElectronContext: true
      }),
      
      // ç¦»çº¿é”™è¯¯å­˜å‚¨ï¼Œç½‘ç»œæ¢å¤åæ‰¹é‡ä¸ŠæŠ¥
      new Sentry.Integrations.Electron.ElectronOfflineIntegration({
        maxStoredEvents: 100,
        flushAtStartup: true
      }),
      
      // ä¼šè¯è¿½è¸ª
      new Sentry.Integrations.SessionTracking({
        captureSessionHealth: true
      })
    ],

    // é‡‡æ ·é…ç½® - å¹³è¡¡ç›‘æ§æ•ˆæœä¸æ€§èƒ½å¼€é”€
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.2 : 1.0,
    profilesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

    beforeSend(event) {
      // è¿‡æ»¤ç³»ç»Ÿçº§æ•æ„Ÿä¿¡æ¯
      if (event.exception) {
        event.exception.values?.forEach(exception => {
          if (exception.stacktrace?.frames) {
            exception.stacktrace.frames = exception.stacktrace.frames.map(frame => ({
              ...frame,
              filename: frame.filename?.replace(/\/Users\/[^\/]+/, '/Users/***')
            }));
          }
        });
      }
      return event;
    }
  });

  // å…¨å±€å¼‚å¸¸å¤„ç† - ç¡®ä¿æ‰€æœ‰æœªæ•è·é”™è¯¯éƒ½è¢«è®°å½•
  process.on('uncaughtException', (error: Error) => {
    Sentry.withScope(scope => {
      scope.setTag('error_source', 'uncaught_exception');
      scope.setLevel('fatal');
      scope.setContext('process_info', {
        pid: process.pid,
        platform: process.platform,
        arch: process.arch,
        memory: process.memoryUsage()
      });
      Sentry.captureException(error);
    });
    
    // ç»™Sentryæ—¶é—´ä¸ŠæŠ¥åä¼˜é›…é€€å‡º
    Sentry.flush(2000).then(() => {
      process.exit(1);
    });
  });

  process.on('unhandledRejection', (reason: unknown) => {
    Sentry.withScope(scope => {
      scope.setTag('error_source', 'unhandled_rejection');
      scope.setLevel('error');
      scope.setContext('rejection_context', {
        reason: String(reason),
        stack: reason instanceof Error ? reason.stack : undefined
      });
      Sentry.captureException(
        reason instanceof Error ? reason : new Error(String(reason))
      );
    });
  });

  // åº”ç”¨ç”Ÿå‘½å‘¨æœŸç›‘æ§
  app.on('ready', () => {
    Sentry.addBreadcrumb({
      message: 'Electron app ready',
      category: 'app.lifecycle',
      level: 'info',
      timestamp: Date.now() / 1000
    });
  });

  app.on('window-all-closed', () => {
    Sentry.addBreadcrumb({
      message: 'All windows closed',
      category: 'app.lifecycle',
      level: 'info'
    });
  });
}

/* çª—å£åˆ›å»ºé”™è¯¯ç›‘æ§ */
export function monitorWindowCreation(window: BrowserWindow, windowName: string): void {
  window.webContents.on('crashed', (event) => {
    Sentry.withScope(scope => {
      scope.setTag('error_source', 'renderer_crash');
      scope.setTag('window_name', windowName);
      scope.setContext('window_info', {
        id: window.id,
        bounds: window.getBounds(),
        isVisible: window.isVisible(),
        isFocused: window.isFocused()
      });
      Sentry.captureException(new Error(`Renderer process crashed: ${windowName}`));
    });
  });

  window.webContents.on('unresponsive', () => {
    Sentry.withScope(scope => {
      scope.setTag('error_source', 'renderer_unresponsive');
      scope.setTag('window_name', windowName);
      scope.setLevel('warning');
      Sentry.captureMessage(`Renderer became unresponsive: ${windowName}`);
    });
  });

  window.webContents.on('responsive', () => {
    Sentry.addBreadcrumb({
      message: `Renderer became responsive: ${windowName}`,
      category: 'window.performance',
      level: 'info'
    });
  });
}
```

#### æ¸²æŸ“è¿›ç¨‹ç›‘æ§é…ç½®ï¼ˆChromiumç¯å¢ƒï¼‰

```typescript
// src/renderer/monitoring/sentry-renderer.ts - æ¸²æŸ“è¿›ç¨‹é”™è¯¯ç›‘æ§
import * as Sentry from '@sentry/electron/renderer';
import { 
  BrowserTracing, 
  replayIntegration,
  Breadcrumbs,
  HttpContext,
  Dedupe
} from '@sentry/react';

/* æ¸²æŸ“è¿›ç¨‹Sentryåˆå§‹åŒ– */
export function initializeRendererMonitoring(): void {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV || 'development',
    release: process.env.SENTRY_RELEASE,

    integrations: [
      // æ¸²æŸ“è¿›ç¨‹ä¸“ç”¨é›†æˆ
      new Sentry.Integrations.Electron.ElectronRendererIntegration({
        captureUnhandledRejections: true,
        captureConsoleErrors: true
      }),

      // æµè§ˆå™¨æ€§èƒ½è¿½è¸ª
      new BrowserTracing({
        tracePropagationTargets: ['localhost', /^\//],
        routingInstrumentation: Sentry.reactRouterV6Instrumentation(
          React.useEffect,
          useLocation,
          useNavigationType,
          createRoutesFromChildren,
          matchRoutes
        )
      }),

      // ä¼šè¯é‡æ’­ - ç”¨æˆ·æ“ä½œå½•åˆ¶ï¼Œé”™è¯¯æ—¶è‡ªåŠ¨ä¸Šä¼ 
      replayIntegration({
        maskAllText: false,
        maskAllInputs: true,
        blockAllMedia: true,
        sampleRate: 0.1, // 10%ä¼šè¯å½•åˆ¶
        errorSampleRate: 1.0, // é”™è¯¯æ—¶100%å½•åˆ¶
        maskTextSelectors: ['.sensitive-data', '[data-sensitive]'],
        blockSelectors: ['.private-content', '[data-private]']
      }),

      // å…¨é¢çš„é¢åŒ…å±‘è¿½è¸ª
      new Breadcrumbs({
        console: true,     // æ§åˆ¶å°è¾“å‡º
        dom: true,         // DOMäº¤äº’
        fetch: true,       // APIè¯·æ±‚
        history: true,     // è·¯ç”±å˜åŒ–
        sentry: true,      // Sentryäº‹ä»¶
        xhr: true          // XMLHttpRequest
      }),

      // HTTPä¸Šä¸‹æ–‡æ”¶é›†
      new HttpContext(),

      // é‡å¤é”™è¯¯å»é‡
      new Dedupe()
    ],

    // æ€§èƒ½ç›‘æ§é…ç½®
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.5 : 1.0,
    replaysSessionSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    replaysOnErrorSampleRate: 1.0,

    // æ•æ„Ÿä¿¡æ¯è¿‡æ»¤
    beforeBreadcrumb(breadcrumb) {
      // è¿‡æ»¤URLä¸­çš„æ•æ„Ÿå‚æ•°
      if (breadcrumb.category === 'navigation' && breadcrumb.data?.url) {
        breadcrumb.data.url = breadcrumb.data.url
          .replace(/([?&])(token|password|secret)=[^&]*/gi, '$1$2=***')
          .replace(/\/user\/\d+/, '/user/***')
          .replace(/\/guild\/\w+/, '/guild/***');
      }

      // è¿‡æ»¤æ•æ„Ÿçš„æ§åˆ¶å°è¾“å‡º
      if (breadcrumb.category === 'console' && breadcrumb.message) {
        if (breadcrumb.message.includes('password') || 
            breadcrumb.message.includes('token') ||
            breadcrumb.message.includes('secret')) {
          return null; // ä¸¢å¼ƒæ•æ„Ÿé¢åŒ…å±‘
        }
      }

      return breadcrumb;
    },

    beforeSend(event) {
      // å¼€å‘ç¯å¢ƒæœ¬åœ°è°ƒè¯•
      if (process.env.NODE_ENV === 'development') {
        console.group('ğŸš¨ Sentry Error Report');
        console.error('Error:', event.exception?.values?.[0]);
        console.log('Context:', event.contexts);
        console.log('Breadcrumbs:', event.breadcrumbs);
        console.groupEnd();
      }

      return event;
    }
  });

  // è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡ï¼ˆç”¨æˆ·ç™»å½•åè°ƒç”¨ï¼‰
  export function setUserContext(user: UserInfo): void {
    Sentry.setUser({
      id: user.id,
      email: user.email,
      username: user.username,
      segment: user.userType // 'free' | 'premium' | 'admin'
    });

    Sentry.setTag('user_tier', user.userType);
    Sentry.setContext('user_profile', {
      registrationDate: user.registrationDate,
      lastLoginDate: user.lastLoginDate,
      guildCount: user.guilds?.length || 0,
      preferredLanguage: user.language
    });
  }

  // æ¸¸æˆä¼šè¯ä¸Šä¸‹æ–‡è®¾ç½®
  export function setGameSessionContext(session: GameSession): void {
    Sentry.setContext('game_session', {
      sessionId: session.id,
      startTime: session.startTime,
      currentScene: session.currentScene,
      playTime: session.getPlayTime(),
      saveSlot: session.saveSlot
    });

    Sentry.setTag('game_mode', session.mode);
    Sentry.setTag('difficulty', session.difficulty);
  }
}
```

### 6.5.2 React UIé”™è¯¯è¾¹ç•Œé›†æˆ

```typescript
// src/renderer/components/error/ErrorBoundary.tsx - Reacté”™è¯¯è¾¹ç•Œ
import React, { Component, ErrorInfo, ReactNode } from 'react';
import * as Sentry from '@sentry/electron/renderer';
import { AppState } from '../../state/AppStateManager';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error?: Error;
  errorId?: string;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // æ•è·Reactæ¸²æŸ“é”™è¯¯å¹¶ä¸ŠæŠ¥Sentry
    const errorId = Sentry.withScope(scope => {
      scope.setTag('error_source', 'react_boundary');
      scope.setLevel('error');
      
      // ç»„ä»¶å †æ ˆä¿¡æ¯
      scope.setContext('react_error_info', {
        componentStack: errorInfo.componentStack,
        errorBoundary: this.constructor.name
      });

      // åº”ç”¨çŠ¶æ€ä¸Šä¸‹æ–‡
      scope.setContext('app_state', {
        currentState: AppState.getCurrentState(),
        stateHistory: AppState.getStateHistory().slice(-5), // æœ€è¿‘5æ¬¡çŠ¶æ€å˜åŒ–
        timestamp: Date.now()
      });

      // Reactæ¸²æŸ“æ€§èƒ½æŒ‡æ ‡
      scope.setContext('react_performance', {
        componentCount: document.querySelectorAll('[data-react-component]').length,
        memoryUsage: (performance as any).memory ? {
          usedJSHeapSize: (performance as any).memory.usedJSHeapSize,
          totalJSHeapSize: (performance as any).memory.totalJSHeapSize
        } : undefined
      });

      return Sentry.captureException(error);
    });

    this.setState({ errorId });

    // è°ƒç”¨è‡ªå®šä¹‰é”™è¯¯å¤„ç†
    this.props.onError?.(error, errorInfo);

    // è®°å½•é”™è¯¯é¢åŒ…å±‘
    Sentry.addBreadcrumb({
      message: `React Error Boundary triggered: ${error.message}`,
      category: 'react.error',
      level: 'error',
      data: {
        componentStack: errorInfo.componentStack.slice(0, 500) // é™åˆ¶é•¿åº¦
      }
    });
  }

  render() {
    if (this.state.hasError) {
      // æ¸²æŸ“é”™è¯¯å›é€€UI
      return this.props.fallback || (
        <div className="min-h-screen bg-red-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg shadow-lg p-6 max-w-md w-full">
            <div className="flex items-center space-x-3 mb-4">
              <div className="w-12 h-12 bg-red-100 rounded-full flex items-center justify-center">
                <svg className="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                </svg>
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-900">ç•Œé¢æ¸²æŸ“å‡ºé”™</h3>
                <p className="text-sm text-gray-600">æˆ‘ä»¬çš„å›¢é˜Ÿå·²æ”¶åˆ°é”™è¯¯æŠ¥å‘Š</p>
              </div>
            </div>
            
            <div className="space-y-3">
              <p className="text-sm text-gray-700">
                é”™è¯¯ID: <code className="bg-gray-100 px-2 py-1 rounded text-xs">{this.state.errorId}</code>
              </p>
              
              <div className="flex space-x-2">
                <button
                  onClick={() => window.location.reload()}
                  className="flex-1 bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium hover:bg-blue-700 transition-colors"
                >
                  é‡æ–°åŠ è½½
                </button>
                <button
                  onClick={() => this.setState({ hasError: false, error: undefined, errorId: undefined })}
                  className="flex-1 bg-gray-200 text-gray-800 px-4 py-2 rounded-md text-sm font-medium hover:bg-gray-300 transition-colors"
                >
                  é‡è¯•
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/* é«˜é˜¶ç»„ä»¶ï¼šä¸ºä»»ä½•ç»„ä»¶æ·»åŠ é”™è¯¯è¾¹ç•Œ */
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  fallback?: ReactNode
) {
  return function WrappedComponent(props: P) {
    return (
      <ErrorBoundary fallback={fallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}
```

### 6.5.3 Phaser 3æ¸¸æˆå¾ªç¯é”™è¯¯å¤„ç†

```typescript
// src/game/error/GameErrorHandler.ts - Phaseræ¸¸æˆé”™è¯¯å¤„ç†
import * as Sentry from '@sentry/electron/renderer';
import Phaser from 'phaser';

/* æ¸¸æˆé”™è¯¯ä¸Šä¸‹æ–‡æ¥å£ */
export interface GameErrorContext {
  scene?: Phaser.Scene;
  gameState?: any;
  performanceMetrics?: PerformanceMetrics;
  userAction?: string;
  gameData?: any;
}

export interface PerformanceMetrics {
  fps: number;
  memory: number;
  deltaTime: number;
  frameTime: number;
  objectCount: number;
}

/* åŸºç¡€Sceneç±» - æ‰€æœ‰æ¸¸æˆåœºæ™¯ç»§æ‰¿æ­¤ç±» */
export abstract class BaseScene extends Phaser.Scene {
  private errorHandler: GameErrorHandler;
  private performanceMonitor: PerformanceMonitor;

  constructor(config: string | Phaser.Types.Scenes.SettingsConfig) {
    super(config);
    this.errorHandler = new GameErrorHandler();
    this.performanceMonitor = new PerformanceMonitor();
  }

  /* å­ç±»å®ç°çš„å®é™…updateé€»è¾‘ */
  abstract innerUpdate(time: number, delta: number): void;
  abstract innerCreate(): void;

  /* åŒ…è£…çš„updateæ–¹æ³• - æä¾›é”™è¯¯æ•è· */
  update(time: number, delta: number): void {
    try {
      // æ€§èƒ½ç›‘æ§å¼€å§‹
      const startTime = performance.now();
      
      this.innerUpdate(time, delta);
      
      // è®°å½•å¸§æ€§èƒ½
      const frameTime = performance.now() - startTime;
      this.performanceMonitor.recordFrame(frameTime, delta, this.getObjectCount());
      
      // æ£€æŸ¥æ€§èƒ½å¼‚å¸¸
      if (frameTime > 20) { // è¶…è¿‡20msè­¦å‘Š
        Sentry.addBreadcrumb({
          message: `Slow frame detected: ${frameTime.toFixed(2)}ms`,
          category: 'performance.warning',
          level: 'warning',
          data: {
            scene: this.scene.key,
            frameTime,
            objectCount: this.getObjectCount()
          }
        });
      }
      
    } catch (error) {
      this.errorHandler.captureGameError(error as Error, this.buildErrorContext(time, delta));
      this.handleGameError(error as Error);
    }
  }

  /* åŒ…è£…çš„createæ–¹æ³• */
  create(): void {
    try {
      this.innerCreate();
      
      Sentry.addBreadcrumb({
        message: `Scene created: ${this.scene.key}`,
        category: 'game.scene',
        level: 'info'
      });
      
    } catch (error) {
      this.errorHandler.captureGameError(error as Error, this.buildErrorContext());
      this.scene.start('ErrorScene', { error, previousScene: this.scene.key });
    }
  }

  /* æ„å»ºé”™è¯¯ä¸Šä¸‹æ–‡ */
  private buildErrorContext(time?: number, delta?: number): GameErrorContext {
    return {
      scene: this,
      gameState: this.getGameState(),
      performanceMetrics: this.performanceMonitor.getCurrentMetrics(),
      gameData: {
        sceneKey: this.scene.key,
        cameras: this.cameras.cameras.length,
        children: this.children.length,
        time,
        delta
      }
    };
  }

  /* è·å–å½“å‰æ¸¸æˆçŠ¶æ€ */
  private getGameState(): any {
    return {
      sceneKey: this.scene.key,
      isPaused: this.scene.isPaused(),
      isActive: this.scene.isActive(),
      isVisible: this.scene.isVisible(),
      isTransitioning: this.scene.manager.isProcessing,
      registry: this.registry.getAll()
    };
  }

  /* è·å–åœºæ™¯å¯¹è±¡æ•°é‡ */
  private getObjectCount(): number {
    return this.children.length;
  }

  /* é”™è¯¯å¤„ç† - å­ç±»å¯é‡å†™ */
  protected handleGameError(error: Error): void {
    console.error(`Game error in ${this.scene.key}:`, error);
    
    // æš‚åœå½“å‰åœºæ™¯
    this.scene.pause();
    
    // æ˜¾ç¤ºé”™è¯¯æç¤º
    this.showErrorMessage(error.message);
  }

  /* æ˜¾ç¤ºæ¸¸æˆå†…é”™è¯¯æ¶ˆæ¯ */
  private showErrorMessage(message: string): void {
    // åˆ›å»ºé”™è¯¯æç¤ºUI
    const errorText = this.add.text(
      this.cameras.main.centerX,
      this.cameras.main.centerY,
      `æ¸¸æˆå‡ºé”™: ${message}\næŒ‰ç©ºæ ¼é”®é‡è¯•`,
      {
        fontSize: '24px',
        color: '#ff0000',
        align: 'center',
        backgroundColor: 'rgba(0,0,0,0.8)',
        padding: { x: 20, y: 10 }
      }
    ).setOrigin(0.5).setDepth(10000);

    // é‡è¯•æœºåˆ¶
    const spaceKey = this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    spaceKey?.once('down', () => {
      errorText.destroy();
      this.scene.resume();
    });
  }
}

/* æ¸¸æˆé”™è¯¯å¤„ç†å™¨ */
export class GameErrorHandler {
  /* æ•è·æ¸¸æˆé”™è¯¯å¹¶ä¸ŠæŠ¥ */
  captureGameError(error: Error, context: GameErrorContext): void {
    Sentry.withScope(scope => {
      scope.setTag('error_source', 'phaser_game');
      scope.setLevel('error');

      // Phaseråœºæ™¯ä¸Šä¸‹æ–‡
      if (context.scene) {
        scope.setContext('phaser_scene', {
          key: context.scene.scene.key,
          isActive: context.scene.scene.isActive(),
          isPaused: context.scene.scene.isPaused(),
          children: context.scene.children.length,
          cameras: context.scene.cameras.cameras.length
        });
      }

      // æ¸¸æˆçŠ¶æ€ä¸Šä¸‹æ–‡
      if (context.gameState) {
        scope.setContext('game_state', context.gameState);
      }

      // æ€§èƒ½æŒ‡æ ‡ä¸Šä¸‹æ–‡
      if (context.performanceMetrics) {
        scope.setContext('performance', context.performanceMetrics);
      }

      // ç”¨æˆ·æ“ä½œä¸Šä¸‹æ–‡
      if (context.userAction) {
        scope.setTag('user_action', context.userAction);
      }

      Sentry.captureException(error);
    });

    // è®°å½•é”™è¯¯é¢åŒ…å±‘
    Sentry.addBreadcrumb({
      message: `Game error: ${error.message}`,
      category: 'game.error',
      level: 'error',
      data: {
        scene: context.scene?.scene.key,
        stack: error.stack?.slice(0, 500)
      }
    });
  }

  /* æ•è·æ¸¸æˆæ€§èƒ½è­¦å‘Š */
  capturePerformanceWarning(message: string, metrics: PerformanceMetrics, scene?: Phaser.Scene): void {
    Sentry.withScope(scope => {
      scope.setTag('warning_type', 'performance');
      scope.setLevel('warning');
      scope.setContext('performance_warning', metrics);
      
      if (scene) {
        scope.setContext('scene_info', {
          key: scene.scene.key,
          objectCount: scene.children.length
        });
      }

      Sentry.captureMessage(message);
    });
  }
}

/* æ€§èƒ½ç›‘æ§å™¨ */
export class PerformanceMonitor {
  private frameHistory: number[] = [];
  private readonly MAX_HISTORY = 60; // ä¿ç•™æœ€è¿‘60å¸§

  recordFrame(frameTime: number, deltaTime: number, objectCount: number): void {
    this.frameHistory.push(frameTime);
    
    if (this.frameHistory.length > this.MAX_HISTORY) {
      this.frameHistory.shift();
    }
  }

  getCurrentMetrics(): PerformanceMetrics {
    const recentFrames = this.frameHistory.slice(-10); // æœ€è¿‘10å¸§
    const avgFrameTime = recentFrames.reduce((a, b) => a + b, 0) / recentFrames.length;
    
    return {
      fps: Math.round(1000 / avgFrameTime),
      memory: (performance as any).memory?.usedJSHeapSize || 0,
      deltaTime: avgFrameTime,
      frameTime: avgFrameTime,
      objectCount: 0 // ç”±Sceneä¼ å…¥
    };
  }

  isPerformanceDegraded(): boolean {
    const metrics = this.getCurrentMetrics();
    return metrics.fps < 50 || metrics.frameTime > 20;
  }
}
```

### 6.5.4 Releaseå¥åº·çŠ¶æ€ä¸ä¼šè¯ç®¡ç†

```typescript
// src/monitoring/ReleaseHealthMonitor.ts - Releaseå¥åº·çŠ¶æ€ç›‘æ§
import * as Sentry from '@sentry/electron/renderer';

export interface HealthMetrics {
  sessionDuration: number;
  crashCount: number;
  errorCount: number;
  performanceScore: number;
  userEngagement: number;
}

export interface SessionData {
  sessionId: string;
  startTime: number;
  endTime?: number;
  crashCount: number;
  errorCount: number;
  sceneTransitions: number;
  userActions: number;
  performanceEvents: number;
}

/* Releaseå¥åº·çŠ¶æ€ç›‘æ§å™¨ */
export class ReleaseHealthMonitor {
  private currentSession: SessionData;
  private healthMetrics: HealthMetrics;
  private heartbeatInterval: NodeJS.Timeout;
  private readonly HEARTBEAT_INTERVAL = 60000; // 60ç§’å¿ƒè·³
  private readonly SESSION_TIMEOUT = 1800000; // 30åˆ†é’Ÿè¶…æ—¶

  constructor() {
    this.startNewSession();
    this.initializeHealthTracking();
    this.setupHeartbeat();
  }

  /* å¯åŠ¨æ–°ä¼šè¯ */
  private startNewSession(): void {
    this.currentSession = {
      sessionId: this.generateSessionId(),
      startTime: Date.now(),
      crashCount: 0,
      errorCount: 0,
      sceneTransitions: 0,
      userActions: 0,
      performanceEvents: 0
    };

    // è®¾ç½®Sentryä¼šè¯
    Sentry.startSession({
      status: 'ok',
      environment: process.env.NODE_ENV || 'development'
    });

    Sentry.addBreadcrumb({
      message: 'New session started',
      category: 'session.lifecycle',
      level: 'info',
      data: {
        sessionId: this.currentSession.sessionId
      }
    });
  }

  /* åˆå§‹åŒ–å¥åº·æŒ‡æ ‡è¿½è¸ª */
  private initializeHealthTracking(): void {
    this.healthMetrics = {
      sessionDuration: 0,
      crashCount: 0,
      errorCount: 0,
      performanceScore: 100,
      userEngagement: 0
    };

    // ç›‘å¬åº”ç”¨äº‹ä»¶
    this.setupApplicationEventListeners();
    this.setupPerformanceEventListeners();
  }

  /* è®¾ç½®å¿ƒè·³æœºåˆ¶ */
  private setupHeartbeat(): void {
    this.heartbeatInterval = setInterval(() => {
      this.sendHeartbeat();
      this.checkSessionHealth();
    }, this.HEARTBEAT_INTERVAL);
  }

  /* å‘é€å¿ƒè·³ä¿¡å· */
  private sendHeartbeat(): void {
    const sessionDuration = Date.now() - this.currentSession.startTime;
    
    Sentry.addBreadcrumb({
      message: 'Session heartbeat',
      category: 'session.heartbeat',
      level: 'info',
      data: {
        sessionId: this.currentSession.sessionId,
        duration: sessionDuration,
        health: this.calculateHealthScore()
      }
    });

    // æ›´æ–°ä¼šè¯çŠ¶æ€
    this.updateSessionMetrics();
    
    // æ£€æŸ¥ä¼šè¯è¶…æ—¶
    if (sessionDuration > this.SESSION_TIMEOUT) {
      this.endSession('timeout');
    }
  }

  /* æ£€æŸ¥ä¼šè¯å¥åº·çŠ¶æ€ */
  private checkSessionHealth(): void {
    const healthScore = this.calculateHealthScore();
    
    if (healthScore < 70) {
      Sentry.withScope(scope => {
        scope.setTag('health_status', 'degraded');
        scope.setLevel('warning');
        scope.setContext('health_metrics', this.healthMetrics);
        
        Sentry.captureMessage(`Session health degraded: ${healthScore}%`);
      });
    }
  }

  /* è®¡ç®—å¥åº·è¯„åˆ† */
  private calculateHealthScore(): number {
    const sessionDuration = Date.now() - this.currentSession.startTime;
    
    // åŸºç¡€åˆ†æ•°
    let score = 100;
    
    // é”™è¯¯æƒ©ç½š
    score -= this.currentSession.errorCount * 5;
    score -= this.currentSession.crashCount * 20;
    
    // æ€§èƒ½æƒ©ç½š
    score = Math.min(score, this.healthMetrics.performanceScore);
    
    // å‚ä¸åº¦å¥–åŠ±
    const engagementMinutes = sessionDuration / 60000;
    if (engagementMinutes > 5) {
      score += Math.min(10, engagementMinutes * 0.5);
    }
    
    return Math.max(0, Math.min(100, score));
  }

  /* æ›´æ–°ä¼šè¯æŒ‡æ ‡ */
  private updateSessionMetrics(): void {
    const sessionDuration = Date.now() - this.currentSession.startTime;
    
    this.healthMetrics = {
      ...this.healthMetrics,
      sessionDuration,
      crashCount: this.currentSession.crashCount,
      errorCount: this.currentSession.errorCount,
      userEngagement: this.calculateUserEngagement()
    };
  }

  /* è®¡ç®—ç”¨æˆ·å‚ä¸åº¦ */
  private calculateUserEngagement(): number {
    const sessionMinutes = (Date.now() - this.currentSession.startTime) / 60000;
    const actionsPerMinute = this.currentSession.userActions / Math.max(1, sessionMinutes);
    
    return Math.min(100, actionsPerMinute * 10);
  }

  /* è®¾ç½®åº”ç”¨äº‹ä»¶ç›‘å¬å™¨ */
  private setupApplicationEventListeners(): void {
    // é”™è¯¯äº‹ä»¶
    window.addEventListener('error', (event) => {
      this.currentSession.errorCount++;
      this.healthMetrics.errorCount++;
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.currentSession.errorCount++;
      this.healthMetrics.errorCount++;
    });

    // ç”¨æˆ·äº¤äº’äº‹ä»¶
    ['click', 'keydown', 'touch'].forEach(eventType => {
      document.addEventListener(eventType, () => {
        this.currentSession.userActions++;
      });
    });

    // åº”ç”¨ç”Ÿå‘½å‘¨æœŸ
    window.addEventListener('beforeunload', () => {
      this.endSession('user_exit');
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        Sentry.addBreadcrumb({
          message: 'Application backgrounded',
          category: 'app.lifecycle',
          level: 'info'
        });
      } else {
        Sentry.addBreadcrumb({
          message: 'Application foregrounded',
          category: 'app.lifecycle',
          level: 'info'
        });
      }
    });
  }

  /* è®¾ç½®æ€§èƒ½äº‹ä»¶ç›‘å¬å™¨ */
  private setupPerformanceEventListeners(): void {
    // ç›‘å¬FPSä¸‹é™
    let lastFrameTime = performance.now();
    let frameCount = 0;
    const checkFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastFrameTime >= 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastFrameTime));
        
        if (fps < 30) {
          this.currentSession.performanceEvents++;
          this.healthMetrics.performanceScore = Math.max(0, this.healthMetrics.performanceScore - 5);
          
          Sentry.addBreadcrumb({
            message: `Low FPS detected: ${fps}`,
            category: 'performance.fps',
            level: 'warning',
            data: { fps }
          });
        }
        
        frameCount = 0;
        lastFrameTime = currentTime;
      }
      
      requestAnimationFrame(checkFPS);
    };
    requestAnimationFrame(checkFPS);

    // å†…å­˜ä½¿ç”¨ç›‘æ§
    if ((performance as any).memory) {
      setInterval(() => {
        const memory = (performance as any).memory;
        const usagePercent = (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;
        
        if (usagePercent > 80) {
          Sentry.addBreadcrumb({
            message: `High memory usage: ${usagePercent.toFixed(1)}%`,
            category: 'performance.memory',
            level: 'warning',
            data: { 
              usedMB: Math.round(memory.usedJSHeapSize / 1024 / 1024),
              totalMB: Math.round(memory.totalJSHeapSize / 1024 / 1024)
            }
          });
        }
      }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    }
  }

  /* è®°å½•åœºæ™¯åˆ‡æ¢ */
  recordSceneTransition(fromScene: string, toScene: string): void {
    this.currentSession.sceneTransitions++;
    
    Sentry.addBreadcrumb({
      message: `Scene transition: ${fromScene} â†’ ${toScene}`,
      category: 'game.scene_transition',
      level: 'info',
      data: {
        fromScene,
        toScene,
        transitionCount: this.currentSession.sceneTransitions
      }
    });
  }

  /* è®°å½•å´©æºƒäº‹ä»¶ */
  recordCrash(error: Error): void {
    this.currentSession.crashCount++;
    this.healthMetrics.crashCount++;
    
    // æ ‡è®°ä¼šè¯ä¸ºå´©æºƒçŠ¶æ€
    Sentry.captureSession(false);
    
    Sentry.withScope(scope => {
      scope.setTag('session_status', 'crashed');
      scope.setContext('crash_context', {
        sessionId: this.currentSession.sessionId,
        sessionDuration: Date.now() - this.currentSession.startTime,
        previousErrors: this.currentSession.errorCount
      });
      
      Sentry.captureException(error);
    });
  }

  /* ç»“æŸä¼šè¯ */
  endSession(reason: 'user_exit' | 'timeout' | 'crash' = 'user_exit'): void {
    this.currentSession.endTime = Date.now();
    const sessionDuration = this.currentSession.endTime - this.currentSession.startTime;
    
    // å‘é€æœ€ç»ˆä¼šè¯æŠ¥å‘Š
    Sentry.withScope(scope => {
      scope.setTag('session_end_reason', reason);
      scope.setContext('final_session_metrics', {
        ...this.currentSession,
        duration: sessionDuration,
        healthScore: this.calculateHealthScore()
      });
      
      Sentry.captureMessage(`Session ended: ${reason}`);
    });

    // ç»“æŸSentryä¼šè¯
    Sentry.endSession();
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
  }

  /* ç”Ÿæˆä¼šè¯ID */
  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /* è·å–å½“å‰å¥åº·æŒ‡æ ‡ */
  getHealthMetrics(): HealthMetrics {
    this.updateSessionMetrics();
    return { ...this.healthMetrics };
  }

  /* è·å–å½“å‰ä¼šè¯æ•°æ® */
  getCurrentSession(): SessionData {
    return { ...this.currentSession };
  }
}

/* å…¨å±€å¥åº·ç›‘æ§å®ä¾‹ */
export const releaseHealthMonitor = new ReleaseHealthMonitor();
```

### 6.5.5 breadcrumbså…¨é“¾è·¯è¿½è¸ªç­–ç•¥

```typescript
// src/monitoring/BreadcrumbsTracker.ts - é¢åŒ…å±‘å…¨é“¾è·¯è¿½è¸ª
import * as Sentry from '@sentry/electron/renderer';

export interface CustomBreadcrumb {
  message: string;
  category: string;
  level: 'debug' | 'info' | 'warning' | 'error';
  data?: Record<string, any>;
  timestamp?: number;
}

/* é¢åŒ…å±‘è¿½è¸ªå™¨ */
export class BreadcrumbsTracker {
  private static instance: BreadcrumbsTracker;
  private readonly MAX_BREADCRUMBS = 100;
  private localBreadcrumbs: CustomBreadcrumb[] = [];

  static getInstance(): BreadcrumbsTracker {
    if (!BreadcrumbsTracker.instance) {
      BreadcrumbsTracker.instance = new BreadcrumbsTracker();
    }
    return BreadcrumbsTracker.instance;
  }

  constructor() {
    this.setupAutomaticTracking();
  }

  /* è®¾ç½®è‡ªåŠ¨è¿½è¸ª */
  private setupAutomaticTracking(): void {
    // Reactè·¯ç”±å˜åŒ–è¿½è¸ª
    this.trackRouteChanges();
    
    // APIè¯·æ±‚è¿½è¸ª
    this.trackAPIRequests();
    
    // ç”¨æˆ·äº¤äº’è¿½è¸ª
    this.trackUserInteractions();
    
    // æ¸¸æˆäº‹ä»¶è¿½è¸ª
    this.trackGameEvents();
    
    // æ€§èƒ½äº‹ä»¶è¿½è¸ª
    this.trackPerformanceEvents();
  }

  /* æ·»åŠ è‡ªå®šä¹‰é¢åŒ…å±‘ */
  addBreadcrumb(breadcrumb: CustomBreadcrumb): void {
    const enrichedBreadcrumb = {
      ...breadcrumb,
      timestamp: breadcrumb.timestamp || Date.now()
    };

    // æ·»åŠ åˆ°æœ¬åœ°å­˜å‚¨
    this.localBreadcrumbs.push(enrichedBreadcrumb);
    if (this.localBreadcrumbs.length > this.MAX_BREADCRUMBS) {
      this.localBreadcrumbs.shift();
    }

    // å‘é€åˆ°Sentry
    Sentry.addBreadcrumb({
      message: breadcrumb.message,
      category: breadcrumb.category,
      level: breadcrumb.level,
      data: breadcrumb.data,
      timestamp: enrichedBreadcrumb.timestamp / 1000
    });
  }

  /* è¿½è¸ªReactè·¯ç”±å˜åŒ– */
  private trackRouteChanges(): void {
    // ç›‘å¬History APIå˜åŒ–
    const originalPushState = window.history.pushState;
    const originalReplaceState = window.history.replaceState;

    window.history.pushState = function(...args) {
      BreadcrumbsTracker.getInstance().addBreadcrumb({
        message: `Route change: ${args[2]}`,
        category: 'navigation.route',
        level: 'info',
        data: {
          url: args[2],
          state: args[0],
          method: 'pushState'
        }
      });
      return originalPushState.apply(this, args);
    };

    window.history.replaceState = function(...args) {
      BreadcrumbsTracker.getInstance().addBreadcrumb({
        message: `Route replace: ${args[2]}`,
        category: 'navigation.route',
        level: 'info',
        data: {
          url: args[2],
          state: args[0],
          method: 'replaceState'
        }
      });
      return originalReplaceState.apply(this, args);
    };

    // ç›‘å¬popstateäº‹ä»¶
    window.addEventListener('popstate', (event) => {
      this.addBreadcrumb({
        message: `Route back/forward: ${window.location.pathname}`,
        category: 'navigation.popstate',
        level: 'info',
        data: {
          url: window.location.href,
          state: event.state
        }
      });
    });
  }

  /* è¿½è¸ªAPIè¯·æ±‚ */
  private trackAPIRequests(): void {
    // æ‹¦æˆªfetchè¯·æ±‚
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
      const startTime = Date.now();
      const url = args[0] instanceof Request ? args[0].url : args[0];
      const method = args[1]?.method || 'GET';

      BreadcrumbsTracker.getInstance().addBreadcrumb({
        message: `API Request: ${method} ${url}`,
        category: 'http.request',
        level: 'info',
        data: {
          url: String(url),
          method,
          timestamp: startTime
        }
      });

      try {
        const response = await originalFetch.apply(this, args);
        const duration = Date.now() - startTime;

        BreadcrumbsTracker.getInstance().addBreadcrumb({
          message: `API Response: ${response.status} ${url}`,
          category: 'http.response',
          level: response.ok ? 'info' : 'warning',
          data: {
            url: String(url),
            status: response.status,
            statusText: response.statusText,
            duration,
            size: response.headers.get('content-length')
          }
        });

        return response;
      } catch (error) {
        const duration = Date.now() - startTime;
        
        BreadcrumbsTracker.getInstance().addBreadcrumb({
          message: `API Error: ${url}`,
          category: 'http.error',
          level: 'error',
          data: {
            url: String(url),
            duration,
            error: String(error)
          }
        });

        throw error;
      }
    };

    // æ‹¦æˆªXMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;

    XMLHttpRequest.prototype.open = function(method, url, async = true) {
      this._breadcrumbData = { method, url, startTime: Date.now() };
      return originalXHROpen.call(this, method, url, async);
    };

    XMLHttpRequest.prototype.send = function(data) {
      if (this._breadcrumbData) {
        BreadcrumbsTracker.getInstance().addBreadcrumb({
          message: `XHR Request: ${this._breadcrumbData.method} ${this._breadcrumbData.url}`,
          category: 'xhr.request',
          level: 'info',
          data: this._breadcrumbData
        });

        this.addEventListener('loadend', () => {
          const duration = Date.now() - this._breadcrumbData.startTime;
          
          BreadcrumbsTracker.getInstance().addBreadcrumb({
            message: `XHR Response: ${this.status} ${this._breadcrumbData.url}`,
            category: 'xhr.response',
            level: this.status >= 200 && this.status < 300 ? 'info' : 'warning',
            data: {
              ...this._breadcrumbData,
              status: this.status,
              statusText: this.statusText,
              duration
            }
          });
        });
      }

      return originalXHRSend.call(this, data);
    };
  }

  /* è¿½è¸ªç”¨æˆ·äº¤äº’ */
  private trackUserInteractions(): void {
    // ç‚¹å‡»äº‹ä»¶
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      const elementInfo = this.getElementInfo(target);

      this.addBreadcrumb({
        message: `User click: ${elementInfo.selector}`,
        category: 'ui.click',
        level: 'info',
        data: {
          ...elementInfo,
          coordinates: { x: event.clientX, y: event.clientY }
        }
      });
    });

    // è¡¨å•æäº¤
    document.addEventListener('submit', (event) => {
      const form = event.target as HTMLFormElement;
      
      this.addBreadcrumb({
        message: `Form submit: ${form.name || form.id || 'unnamed'}`,
        category: 'ui.form',
        level: 'info',
        data: {
          formName: form.name,
          formId: form.id,
          action: form.action,
          method: form.method
        }
      });
    });

    // é”®ç›˜äº‹ä»¶ï¼ˆä»…è®°å½•åŠŸèƒ½é”®ï¼‰
    document.addEventListener('keydown', (event) => {
      if (event.key.length === 1) return; // å¿½ç•¥å­—ç¬¦é”®

      this.addBreadcrumb({
        message: `Key press: ${event.key}`,
        category: 'ui.keypress',
        level: 'debug',
        data: {
          key: event.key,
          code: event.code,
          ctrlKey: event.ctrlKey,
          shiftKey: event.shiftKey,
          altKey: event.altKey
        }
      });
    });
  }

  /* è¿½è¸ªæ¸¸æˆäº‹ä»¶ */
  private trackGameEvents(): void {
    // ç›‘å¬è‡ªå®šä¹‰æ¸¸æˆäº‹ä»¶
    window.addEventListener('phaser:scene:start', (event: CustomEvent) => {
      this.addBreadcrumb({
        message: `Game scene started: ${event.detail.sceneKey}`,
        category: 'game.scene',
        level: 'info',
        data: event.detail
      });
    });

    window.addEventListener('phaser:scene:stop', (event: CustomEvent) => {
      this.addBreadcrumb({
        message: `Game scene stopped: ${event.detail.sceneKey}`,
        category: 'game.scene',
        level: 'info',
        data: event.detail
      });
    });

    window.addEventListener('game:action', (event: CustomEvent) => {
      this.addBreadcrumb({
        message: `Game action: ${event.detail.action}`,
        category: 'game.action',
        level: 'info',
        data: event.detail
      });
    });

    window.addEventListener('game:achievement', (event: CustomEvent) => {
      this.addBreadcrumb({
        message: `Achievement unlocked: ${event.detail.achievement}`,
        category: 'game.achievement',
        level: 'info',
        data: event.detail
      });
    });
  }

  /* è¿½è¸ªæ€§èƒ½äº‹ä»¶ */
  private trackPerformanceEvents(): void {
    // é¡µé¢åŠ è½½æ€§èƒ½
    window.addEventListener('load', () => {
      const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      
      this.addBreadcrumb({
        message: 'Page load completed',
        category: 'performance.load',
        level: 'info',
        data: {
          loadTime: perfData.loadEventEnd - perfData.loadEventStart,
          domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
          firstByte: perfData.responseStart - perfData.requestStart
        }
      });
    });

    // èµ„æºåŠ è½½é”™è¯¯
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        const target = event.target as HTMLElement;
        
        this.addBreadcrumb({
          message: `Resource load error: ${target.tagName}`,
          category: 'resource.error',
          level: 'error',
          data: {
            tagName: target.tagName,
            src: (target as any).src || (target as any).href,
            message: event.message
          }
        });
      }
    });

    // å†…å­˜è­¦å‘Š
    if ((performance as any).memory) {
      setInterval(() => {
        const memory = (performance as any).memory;
        const usagePercent = (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100;
        
        if (usagePercent > 90) {
          this.addBreadcrumb({
            message: `Critical memory usage: ${usagePercent.toFixed(1)}%`,
            category: 'performance.memory',
            level: 'warning',
            data: {
              usedMB: Math.round(memory.usedJSHeapSize / 1024 / 1024),
              totalMB: Math.round(memory.totalJSHeapSize / 1024 / 1024),
              limitMB: Math.round(memory.jsHeapSizeLimit / 1024 / 1024)
            }
          });
        }
      }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    }
  }

  /* è·å–å…ƒç´ ä¿¡æ¯ */
  private getElementInfo(element: HTMLElement): any {
    return {
      tagName: element.tagName,
      id: element.id,
      className: element.className,
      textContent: element.textContent?.slice(0, 100), // é™åˆ¶é•¿åº¦
      selector: this.getElementSelector(element)
    };
  }

  /* ç”Ÿæˆå…ƒç´ é€‰æ‹©å™¨ */
  private getElementSelector(element: HTMLElement): string {
    if (element.id) {
      return `#${element.id}`;
    }
    
    if (element.className) {
      return `.${element.className.split(' ').join('.')}`;
    }
    
    return element.tagName.toLowerCase();
  }

  /* è·å–æœ¬åœ°é¢åŒ…å±‘ */
  getLocalBreadcrumbs(): CustomBreadcrumb[] {
    return [...this.localBreadcrumbs];
  }

  /* æ¸…é™¤æœ¬åœ°é¢åŒ…å±‘ */
  clearLocalBreadcrumbs(): void {
    this.localBreadcrumbs = [];
  }
}

/* å¯¼å‡ºå…¨å±€å®ä¾‹ */
export const breadcrumbsTracker = BreadcrumbsTracker.getInstance();

/* ä¾¿æ·çš„é¢åŒ…å±‘è®°å½•å‡½æ•° */
export function addGameBreadcrumb(message: string, data?: Record<string, any>): void {
  breadcrumbsTracker.addBreadcrumb({
    message,
    category: 'game.custom',
    level: 'info',
    data
  });
}

export function addUIBreadcrumb(message: string, data?: Record<string, any>): void {
  breadcrumbsTracker.addBreadcrumb({
    message,
    category: 'ui.custom',
    level: 'info',
    data
  });
}

export function addPerformanceBreadcrumb(message: string, data?: Record<string, any>): void {
  breadcrumbsTracker.addBreadcrumb({
    message,
    category: 'performance.custom',
    level: 'warning',
    data
  });
}
```

## 6.6 å°±åœ°éªŒæ”¶

> **åˆ†å±‚æµ‹è¯•ç­–ç•¥**ï¼šçƒŸé›¾æµ‹è¯• + æ€§èƒ½åŸºå‡†éªŒè¯ + å®‰å…¨é…ç½®æ£€æŸ¥ + æ¶æ„å®Œæ•´æ€§éªŒè¯ï¼Œç¡®ä¿è¿è¡Œæ—¶æ¶æ„çš„ç¨³å®šæ€§å’Œæ€§èƒ½æŒ‡æ ‡è¾¾æ ‡ã€‚

### 6.6.1 æµ‹è¯•æ¶æ„ä¸å·¥å…·é…ç½®

#### æµ‹è¯•å¥—ä»¶ç»“æ„è®¾è®¡

```
tests/
â”œâ”€â”€ e2e/                          # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ smoke/                    # çƒŸé›¾æµ‹è¯•å¥—ä»¶
â”‚   â”‚   â”œâ”€â”€ app-startup.spec.ts   # åº”ç”¨å¯åŠ¨éªŒè¯
â”‚   â”‚   â”œâ”€â”€ core-features.spec.ts # æ ¸å¿ƒåŠŸèƒ½éªŒè¯
â”‚   â”‚   â””â”€â”€ data-access.spec.ts   # æ•°æ®è®¿é—®éªŒè¯
â”‚   â”œâ”€â”€ performance/              # æ€§èƒ½æµ‹è¯•å¥—ä»¶
â”‚   â”‚   â”œâ”€â”€ fps-monitoring.spec.ts # FPSæ€§èƒ½é‡‡æ ·
â”‚   â”‚   â”œâ”€â”€ memory-usage.spec.ts   # å†…å­˜ç›‘æ§
â”‚   â”‚   â””â”€â”€ startup-time.spec.ts   # å¯åŠ¨æ€§èƒ½
â”‚   â””â”€â”€ security/                 # å®‰å…¨é…ç½®æµ‹è¯•
â”‚       â”œâ”€â”€ webpreferences.spec.ts # å®‰å…¨é…ç½®éªŒè¯
â”‚       â”œâ”€â”€ sandbox.spec.ts        # æ²™ç®±æœºåˆ¶éªŒè¯
â”‚       â””â”€â”€ csp-policies.spec.ts   # CSPç­–ç•¥æ£€æŸ¥
â”œâ”€â”€ integration/                  # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ ipc/                     # è¿›ç¨‹é—´é€šä¿¡æµ‹è¯•
â”‚   â”œâ”€â”€ eventbus/                # äº‹ä»¶æ€»çº¿æµ‹è¯•
â”‚   â””â”€â”€ database/                # æ•°æ®åº“æ“ä½œæµ‹è¯•
â”œâ”€â”€ utils/                       # æµ‹è¯•å·¥å…·åº“
â”‚   â”œâ”€â”€ performance-monitor.ts   # æ€§èƒ½ç›‘æ§å·¥å…·
â”‚   â”œâ”€â”€ app-helpers.ts          # åº”ç”¨æµ‹è¯•è¾…åŠ©å‡½æ•°
â”‚   â”œâ”€â”€ screenshot-diff.ts      # æˆªå›¾å¯¹æ¯”å·¥å…·
â”‚   â””â”€â”€ ipc-sync.ts            # IPCåŒæ­¥æœºåˆ¶
â””â”€â”€ fixtures/                   # æµ‹è¯•æ•°æ®å’Œé…ç½®
    â”œâ”€â”€ test-configs/           # æµ‹è¯•ç¯å¢ƒé…ç½®
    â”œâ”€â”€ mock-data/             # æ¨¡æ‹Ÿæ•°æ®
    â””â”€â”€ baseline-metrics/      # æ€§èƒ½åŸºå‡†æ•°æ®
```

#### Playwrighté…ç½®æ–‡ä»¶

```typescript
// playwright.config.ts - Electronæµ‹è¯•é…ç½®
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  timeout: 60000, // 60ç§’è¶…æ—¶ï¼Œé€‚åº”Electronåº”ç”¨å¯åŠ¨
  expect: {
    timeout: 10000 // æ–­è¨€è¶…æ—¶10ç§’
  },
  
  // å¹¶è¡Œæ‰§è¡Œé…ç½®
  fullyParallel: false, // Electronåº”ç”¨ä¸é€‚åˆå®Œå…¨å¹¶è¡Œ
  workers: 2, // é™åˆ¶å¹¶å‘æ•°é¿å…èµ„æºç«äº‰
  
  // é‡è¯•é…ç½®
  retries: process.env.CI ? 2 : 1,
  
  use: {
    // å…¨å±€è¶…æ—¶è®¾ç½®
    actionTimeout: 15000,
    navigationTimeout: 30000,
    
    // æˆªå›¾å’Œè§†é¢‘é…ç½®
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    trace: 'retain-on-failure'
  },

  projects: [
    {
      name: 'electron-smoke',
      testDir: './tests/e2e/smoke',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'electron-performance',
      testDir: './tests/e2e/performance',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'electron-security',
      testDir: './tests/e2e/security',
      use: { ...devices['Desktop Chrome'] }
    }
  ],

  // æµ‹è¯•æŠ¥å‘Šé…ç½®
  reporter: [
    ['html', { outputFolder: 'test-results/html-report' }],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit.xml' }]
  ]
});
```

### 6.6.2 çƒŸé›¾æµ‹è¯•å¥—ä»¶

#### åº”ç”¨å¯åŠ¨éªŒè¯

```typescript
// tests/e2e/smoke/app-startup.spec.ts - åº”ç”¨å¯åŠ¨çƒŸé›¾æµ‹è¯•
import { test, expect } from '@playwright/test';
import { _electron as electron, ElectronApplication, BrowserWindow } from 'playwright';
import { AppTestHelper } from '../../utils/app-helpers';
import { PerformanceMonitor } from '../../utils/performance-monitor';

test.describe('åº”ç”¨å¯åŠ¨çƒŸé›¾æµ‹è¯•', () => {
  let electronApp: ElectronApplication;
  let window: BrowserWindow;
  let appHelper: AppTestHelper;
  let perfMonitor: PerformanceMonitor;

  test.beforeEach(async () => {
    perfMonitor = new PerformanceMonitor();
    
    // è®°å½•å¯åŠ¨å¼€å§‹æ—¶é—´
    const startTime = Date.now();
    
    // å¯åŠ¨Electronåº”ç”¨
    electronApp = await electron.launch({
      args: ['.'],
      env: {
        ...process.env,
        NODE_ENV: 'test',
        ELECTRON_DISABLE_SECURITY_WARNINGS: 'true'
      }
    });

    window = await electronApp.firstWindow();
    appHelper = new AppTestHelper(electronApp, window);
    
    // éªŒè¯å¯åŠ¨æ—¶é—´
    const startupTime = Date.now() - startTime;
    perfMonitor.recordMetric('startup_time', startupTime);
    
    // åŸºå‡†æ£€æŸ¥ï¼šå¯åŠ¨æ—¶é—´åº”å°äº3ç§’
    expect(startupTime).toBeLessThan(3000);
  });

  test.afterEach(async () => {
    await perfMonitor.generateReport();
    await electronApp?.close();
  });

  test('å†·å¯åŠ¨å®Œæ•´æµç¨‹éªŒè¯', async () => {
    // 1. éªŒè¯ä¸»çª—å£åˆ›å»ºæˆåŠŸ
    expect(window).toBeTruthy();
    
    // 2. éªŒè¯çª—å£å¯è§æ€§å’Œå°ºå¯¸
    const isVisible = await window.isVisible();
    const bounds = await window.evaluate(() => ({
      width: window.innerWidth,
      height: window.innerHeight
    }));
    
    expect(isVisible).toBe(true);
    expect(bounds.width).toBeGreaterThan(800);
    expect(bounds.height).toBeGreaterThan(600);

    // 3. ç­‰å¾…Reactåº”ç”¨åŠ è½½å®Œæˆ
    await window.waitForSelector('[data-testid="app-loaded"]', { 
      timeout: 10000 
    });

    // 4. ç­‰å¾…Phaseræ¸¸æˆå¼•æ“åˆå§‹åŒ–
    await window.waitForFunction(() => {
      return window.game && window.game.isRunning;
    }, { timeout: 15000 });

    // 5. éªŒè¯æ ¸å¿ƒç»„ä»¶çŠ¶æ€
    const appState = await window.evaluate(() => ({
      reactMounted: !!document.querySelector('[data-testid="react-root"]'),
      phaserRunning: !!(window as any).game?.isRunning,
      eventBusReady: !!(window as any).eventBus?.isReady,
      workerConnected: !!(window as any).aiWorker?.isConnected
    }));

    expect(appState.reactMounted).toBe(true);
    expect(appState.phaserRunning).toBe(true);
    expect(appState.eventBusReady).toBe(true);
    expect(appState.workerConnected).toBe(true);

    // 6. éªŒè¯é¦–å±æ¸²æŸ“å®Œæˆ
    await expect(window.locator('[data-testid="main-ui"]')).toBeVisible();
    await expect(window.locator('canvas')).toBeVisible(); // Phaser canvas
  });

  test('çƒ­é‡è½½æœºåˆ¶éªŒè¯', async () => {
    // 1. è®°å½•åˆå§‹çŠ¶æ€
    const initialState = await appHelper.captureAppState();
    
    // 2. æ¨¡æ‹Ÿä»£ç å˜æ›´è§¦å‘çƒ­é‡è½½
    await window.evaluate(() => {
      // è§¦å‘HMRæ›´æ–°
      if ((window as any).module?.hot) {
        (window as any).module.hot.accept();
      }
    });

    // 3. ç­‰å¾…é‡è½½å®Œæˆ
    await window.waitForTimeout(2000);

    // 4. éªŒè¯çŠ¶æ€ä¿æŒ
    const reloadedState = await appHelper.captureAppState();
    
    expect(reloadedState.gameData).toEqual(initialState.gameData);
    expect(reloadedState.userSession).toEqual(initialState.userSession);
  });

  test('ä¼˜é›…å…³é—­æµç¨‹éªŒè¯', async () => {
    // 1. éªŒè¯åº”ç”¨æ­£å¸¸è¿è¡Œ
    const isRunning = await window.evaluate(() => {
      return !!(window as any).game?.isRunning;
    });
    expect(isRunning).toBe(true);

    // 2. è§¦å‘å…³é—­æµç¨‹
    const closePromise = electronApp.close();

    // 3. éªŒè¯æ¸…ç†è¿‡ç¨‹
    await window.evaluate(() => {
      // éªŒè¯äº‹ä»¶ç›‘å¬å™¨æ¸…ç†
      const eventCount = Object.keys((window as any).eventBus?.listeners || {}).length;
      return eventCount;
    });

    // 4. ç­‰å¾…åº”ç”¨å®Œå…¨å…³é—­
    await closePromise;

    // éªŒè¯è¿›ç¨‹å·²ç»ˆæ­¢
    const processes = await electronApp.evaluate(({ app }) => {
      return app.isReady();
    }).catch(() => false);

    expect(processes).toBe(false);
  });
});
```

#### æ ¸å¿ƒåŠŸèƒ½éªŒè¯

```typescript
// tests/e2e/smoke/core-features.spec.ts - æ ¸å¿ƒåŠŸèƒ½çƒŸé›¾æµ‹è¯•
import { test, expect } from '@playwright/test';
import { _electron as electron, ElectronApplication, BrowserWindow } from 'playwright';
import { AppTestHelper } from '../../utils/app-helpers';

test.describe('æ ¸å¿ƒåŠŸèƒ½çƒŸé›¾æµ‹è¯•', () => {
  let electronApp: ElectronApplication;
  let window: BrowserWindow;
  let appHelper: AppTestHelper;

  test.beforeEach(async () => {
    electronApp = await electron.launch({ args: ['.'] });
    window = await electronApp.firstWindow();
    appHelper = new AppTestHelper(electronApp, window);
    
    // ç­‰å¾…åº”ç”¨å®Œå…¨åŠ è½½
    await appHelper.waitForAppReady();
  });

  test.afterEach(async () => {
    await electronApp?.close();
  });

  test('React-Phaseré€šä¿¡æœºåˆ¶éªŒè¯', async () => {
    // 1. éªŒè¯EventBusåˆå§‹åŒ–
    const eventBusStatus = await window.evaluate(() => {
      return {
        isInitialized: !!(window as any).eventBus,
        listenerCount: Object.keys((window as any).eventBus?.listeners || {}).length
      };
    });

    expect(eventBusStatus.isInitialized).toBe(true);
    expect(eventBusStatus.listenerCount).toBeGreaterThan(0);

    // 2. æµ‹è¯•UIâ†’æ¸¸æˆäº‹ä»¶ä¼ é€’
    await window.click('[data-testid="game-start-button"]');
    
    const gameStartEvent = await window.waitForFunction(() => {
      return (window as any).game?.scene?.isActive('GameScene');
    }, { timeout: 5000 });

    expect(gameStartEvent).toBeTruthy();

    // 3. æµ‹è¯•æ¸¸æˆâ†’UIçŠ¶æ€åŒæ­¥
    await window.evaluate(() => {
      // è§¦å‘æ¸¸æˆå†…äº‹ä»¶
      (window as any).eventBus.emit('game:score:update', { score: 1000 });
    });

    await expect(window.locator('[data-testid="score-display"]')).toContainText('1000');

    // 4. éªŒè¯åŒå‘é€šä¿¡æ€§èƒ½
    const communicationTest = await window.evaluate(async () => {
      const startTime = performance.now();
      let responseReceived = false;

      // å‘é€äº‹ä»¶å¹¶ç­‰å¾…å“åº”
      (window as any).eventBus.emit('test:ping', { timestamp: startTime });
      (window as any).eventBus.once('test:pong', () => {
        responseReceived = true;
      });

      // ç­‰å¾…å“åº”
      await new Promise(resolve => setTimeout(resolve, 100));
      
      return {
        responseTime: performance.now() - startTime,
        responseReceived
      };
    });

    expect(communicationTest.responseReceived).toBe(true);
    expect(communicationTest.responseTime).toBeLessThan(50); // 50mså†…å“åº”
  });

  test('åœºæ™¯åˆ‡æ¢æµç•…æ€§éªŒè¯', async () => {
    // 1. åˆå§‹åœºæ™¯éªŒè¯
    let currentScene = await window.evaluate(() => {
      return (window as any).game?.scene?.getActiveScene()?.scene.key;
    });
    expect(currentScene).toBe('MenuScene');

    // 2. åˆ‡æ¢åˆ°æ¸¸æˆåœºæ™¯
    await window.click('[data-testid="start-game"]');
    
    // 3. éªŒè¯åˆ‡æ¢æ€§èƒ½
    const transitionStart = Date.now();
    
    await window.waitForFunction(() => {
      return (window as any).game?.scene?.isActive('GameScene');
    }, { timeout: 5000 });

    const transitionTime = Date.now() - transitionStart;
    expect(transitionTime).toBeLessThan(500); // åœºæ™¯åˆ‡æ¢<500ms

    // 4. éªŒè¯åœºæ™¯çŠ¶æ€
    const sceneState = await window.evaluate(() => {
      const scene = (window as any).game?.scene?.getActiveScene();
      return {
        isActive: scene?.scene.isActive(),
        isVisible: scene?.scene.isVisible(),
        children: scene?.children.length || 0
      };
    });

    expect(sceneState.isActive).toBe(true);
    expect(sceneState.isVisible).toBe(true);
    expect(sceneState.children).toBeGreaterThan(0);

    // 5. æµ‹è¯•å¤šåœºæ™¯å¹¶è¡Œè¿è¡Œ
    await window.evaluate(() => {
      (window as any).game?.scene?.launch('UIScene', { overlay: true });
    });

    const parallelScenes = await window.evaluate(() => {
      const sceneManager = (window as any).game?.scene;
      return {
        gameActive: sceneManager?.isActive('GameScene'),
        uiActive: sceneManager?.isActive('UIScene'),
        totalScenes: sceneManager?.scenes.length || 0
      };
    });

    expect(parallelScenes.gameActive).toBe(true);
    expect(parallelScenes.uiActive).toBe(true);
    expect(parallelScenes.totalScenes).toBeGreaterThanOrEqual(2);
  });

  test('æ•°æ®æŒä¹…åŒ–åŠŸèƒ½éªŒè¯', async () => {
    // 1. åˆ›å»ºæµ‹è¯•æ•°æ®
    const testData = {
      userId: 'test-user-123',
      gameProgress: { level: 5, score: 2500 },
      settings: { volume: 0.8, difficulty: 'normal' }
    };

    // 2. ä¿å­˜æ•°æ®åˆ°SQLite
    await window.evaluate((data) => {
      return (window as any).database?.saveUserData(data.userId, data);
    }, testData);

    // 3. é‡å¯åº”ç”¨éªŒè¯æ•°æ®æŒä¹…æ€§
    await electronApp.close();
    
    electronApp = await electron.launch({ args: ['.'] });
    window = await electronApp.firstWindow();
    await appHelper.waitForAppReady();

    // 4. è¯»å–å¹¶éªŒè¯æ•°æ®
    const retrievedData = await window.evaluate((userId) => {
      return (window as any).database?.getUserData(userId);
    }, testData.userId);

    expect(retrievedData).toEqual(testData);

    // 5. éªŒè¯æ•°æ®åº“æ“ä½œæ€§èƒ½
    const dbPerformance = await window.evaluate(async () => {
      const start = performance.now();
      
      // æ‰§è¡Œæ‰¹é‡æ“ä½œ
      const operations = [];
      for (let i = 0; i < 100; i++) {
        operations.push((window as any).database?.saveGameState({
          id: `test-${i}`,
          data: { timestamp: Date.now() }
        }));
      }
      
      await Promise.all(operations);
      
      return performance.now() - start;
    });

    expect(dbPerformance).toBeLessThan(1000); // æ‰¹é‡æ“ä½œ<1ç§’
  });

  test('AI Workerè®¡ç®—èƒ½åŠ›éªŒè¯', async () => {
    // 1. éªŒè¯Workerè¿æ¥çŠ¶æ€
    const workerStatus = await window.evaluate(() => {
      return {
        isConnected: !!(window as any).aiWorker?.isConnected,
        isReady: !!(window as any).aiWorker?.isReady
      };
    });

    expect(workerStatus.isConnected).toBe(true);
    expect(workerStatus.isReady).toBe(true);

    // 2. æµ‹è¯•è®¡ç®—ä»»åŠ¡æ‰§è¡Œ
    const computationResult = await window.evaluate(async () => {
      const startTime = performance.now();
      
      const result = await (window as any).aiWorker?.execute({
        type: 'test_computation',
        data: { iterations: 10000 }
      });
      
      return {
        result,
        executionTime: performance.now() - startTime,
        mainThreadBlocked: false // Workerä¸åº”é˜»å¡ä¸»çº¿ç¨‹
      };
    });

    expect(computationResult.result).toBeTruthy();
    expect(computationResult.executionTime).toBeLessThan(2000); // è®¡ç®—ä»»åŠ¡<2ç§’
    expect(computationResult.mainThreadBlocked).toBe(false);

    // 3. éªŒè¯å¹¶å‘è®¡ç®—èƒ½åŠ›
    const concurrentTasks = await window.evaluate(async () => {
      const tasks = [];
      for (let i = 0; i < 5; i++) {
        tasks.push((window as any).aiWorker?.execute({
          type: 'parallel_test',
          data: { taskId: i }
        }));
      }
      
      const startTime = performance.now();
      const results = await Promise.all(tasks);
      const executionTime = performance.now() - startTime;
      
      return {
        tasksCompleted: results.length,
        totalTime: executionTime,
        averageTime: executionTime / results.length
      };
    });

    expect(concurrentTasks.tasksCompleted).toBe(5);
    expect(concurrentTasks.totalTime).toBeLessThan(5000); // å¹¶å‘ä»»åŠ¡<5ç§’
    expect(concurrentTasks.averageTime).toBeLessThan(2000); // å¹³å‡æ—¶é—´<2ç§’
  });
});
```

### 6.6.3 æ€§èƒ½åŸºå‡†æµ‹è¯•

#### FPSæ€§èƒ½ç›‘æ§

```typescript
// tests/e2e/performance/fps-monitoring.spec.ts - FPSæ€§èƒ½ç›‘æ§æµ‹è¯•
import { test, expect } from '@playwright/test';
import { _electron as electron, ElectronApplication, BrowserWindow } from 'playwright';
import { PerformanceMonitor } from '../../utils/performance-monitor';

test.describe('FPSæ€§èƒ½ç›‘æ§æµ‹è¯•', () => {
  let electronApp: ElectronApplication;
  let window: BrowserWindow;
  let perfMonitor: PerformanceMonitor;

  test.beforeEach(async () => {
    electronApp = await electron.launch({ args: ['.'] });
    window = await electronApp.firstWindow();
    perfMonitor = new PerformanceMonitor();
    
    // ç­‰å¾…æ¸¸æˆå¼•æ“å®Œå…¨å¯åŠ¨
    await window.waitForFunction(() => {
      return (window as any).game?.isRunning;
    }, { timeout: 15000 });
  });

  test.afterEach(async () => {
    await perfMonitor.generateReport();
    await electronApp?.close();
  });

  test('æ¸¸æˆè¿è¡Œæ—¶FPSåŸºå‡†æµ‹è¯•', async () => {
    // 1. å¯åŠ¨FPSç›‘æ§
    const fpsData = await window.evaluate(() => {
      const fpsHistory: number[] = [];
      let frameCount = 0;
      let lastTime = performance.now();
      
      const measureFPS = () => {
        frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - lastTime >= 1000) { // æ¯ç§’é‡‡æ ·ä¸€æ¬¡
          const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
          fpsHistory.push(fps);
          frameCount = 0;
          lastTime = currentTime;
          
          if (fpsHistory.length < 30) { // é‡‡æ ·30ç§’
            requestAnimationFrame(measureFPS);
          }
        } else {
          requestAnimationFrame(measureFPS);
        }
      };
      
      measureFPS();
      
      // è¿”å›Promiseï¼Œ30ç§’åè§£æ
      return new Promise<number[]>((resolve) => {
        setTimeout(() => {
          resolve(fpsHistory);
        }, 31000);
      });
    });

    // 2. åˆ†æFPSæ•°æ®
    const avgFPS = fpsData.reduce((a, b) => a + b, 0) / fpsData.length;
    const minFPS = Math.min(...fpsData);
    const maxFPS = Math.max(...fpsData);
    const stableFPS = fpsData.filter(fps => fps >= 50).length / fpsData.length;

    // 3. æ€§èƒ½æ–­è¨€
    expect(avgFPS).toBeGreaterThan(50); // å¹³å‡FPS > 50
    expect(minFPS).toBeGreaterThan(30); // æœ€ä½FPS > 30
    expect(stableFPS).toBeGreaterThan(0.9); // 90%æ—¶é—´ç¨³å®šåœ¨50fpsä»¥ä¸Š

    // 4. è®°å½•æ€§èƒ½æŒ‡æ ‡
    await perfMonitor.recordMetric('average_fps', avgFPS);
    await perfMonitor.recordMetric('min_fps', minFPS);
    await perfMonitor.recordMetric('fps_stability', stableFPS);
  });

  test('é«˜è´Ÿè½½åœºæ™¯FPSå‹åŠ›æµ‹è¯•', async () => {
    // 1. åˆ›å»ºé«˜è´Ÿè½½åœºæ™¯
    await window.evaluate(() => {
      // åˆ‡æ¢åˆ°å‹åŠ›æµ‹è¯•åœºæ™¯
      (window as any).game?.scene?.start('StressTestScene', {
        objectCount: 1000,
        particleEffects: true,
        complexAnimations: true
      });
    });

    // 2. ç­‰å¾…åœºæ™¯åŠ è½½
    await window.waitForFunction(() => {
      return (window as any).game?.scene?.isActive('StressTestScene');
    }, { timeout: 10000 });

    // 3. ç›‘æ§å‹åŠ›æµ‹è¯•æœŸé—´çš„FPS
    const stressTestFPS = await window.evaluate(() => {
      const measurements: { fps: number; objects: number; memory: number }[] = [];
      let frameCount = 0;
      let lastTime = performance.now();

      const stressMonitor = () => {
        frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - lastTime >= 1000) {
          const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
          const objectCount = (window as any).game?.scene?.getActiveScene()?.children.length || 0;
          const memory = (performance as any).memory?.usedJSHeapSize || 0;
          
          measurements.push({ fps, objects: objectCount, memory });
          
          frameCount = 0;
          lastTime = currentTime;
          
          if (measurements.length < 15) { // å‹åŠ›æµ‹è¯•15ç§’
            requestAnimationFrame(stressMonitor);
          }
        } else {
          requestAnimationFrame(stressMonitor);
        }
      };
      
      stressMonitor();
      
      return new Promise<typeof measurements>((resolve) => {
        setTimeout(() => resolve(measurements), 16000);
      });
    });

    // 4. åˆ†æå‹åŠ›æµ‹è¯•ç»“æœ
    const avgStressFPS = stressTestFPS.reduce((a, b) => a + b.fps, 0) / stressTestFPS.length;
    const fpsDropRate = stressTestFPS.filter(m => m.fps < 30).length / stressTestFPS.length;
    const maxObjects = Math.max(...stressTestFPS.map(m => m.objects));

    // 5. å‹åŠ›æµ‹è¯•æ–­è¨€
    expect(avgStressFPS).toBeGreaterThan(25); // å‹åŠ›æµ‹è¯•å¹³å‡FPS > 25
    expect(fpsDropRate).toBeLessThan(0.2); // ä½äº30fpsçš„æ—¶é—´å æ¯” < 20%
    expect(maxObjects).toBeGreaterThan(500); // èƒ½å¤„ç†è¶…è¿‡500ä¸ªå¯¹è±¡

    await perfMonitor.recordMetric('stress_test_fps', avgStressFPS);
    await perfMonitor.recordMetric('max_objects_handled', maxObjects);
  });

  test('ä¸åŒåœºæ™¯FPSæ€§èƒ½å¯¹æ¯”', async () => {
    const scenePerformance: Record<string, number> = {};

    // æµ‹è¯•åœºæ™¯åˆ—è¡¨
    const testScenes = ['MenuScene', 'GameScene', 'InventoryScene', 'SettingsScene'];

    for (const sceneName of testScenes) {
      // 1. åˆ‡æ¢åˆ°æµ‹è¯•åœºæ™¯
      await window.evaluate((scene) => {
        (window as any).game?.scene?.start(scene);
      }, sceneName);

      // 2. ç­‰å¾…åœºæ™¯ç¨³å®š
      await window.waitForFunction((scene) => {
        return (window as any).game?.scene?.isActive(scene);
      }, { timeout: 5000 }, sceneName);

      await window.waitForTimeout(2000); // ç­‰å¾…2ç§’ç¨³å®š

      // 3. æµ‹é‡åœºæ™¯FPS
      const sceneFPS = await window.evaluate(() => {
        let frameCount = 0;
        const startTime = performance.now();
        
        const measureScene = () => {
          frameCount++;
          const elapsed = performance.now() - startTime;
          
          if (elapsed < 5000) { // æµ‹é‡5ç§’
            requestAnimationFrame(measureScene);
          }
        };
        
        measureScene();
        
        return new Promise<number>((resolve) => {
          setTimeout(() => {
            const totalTime = performance.now() - startTime;
            const fps = Math.round((frameCount * 1000) / totalTime);
            resolve(fps);
          }, 5100);
        });
      });

      scenePerformance[sceneName] = sceneFPS;
      
      // 4. åœºæ™¯æ€§èƒ½æ–­è¨€
      expect(sceneFPS).toBeGreaterThan(40); // æ¯ä¸ªåœºæ™¯FPS > 40
    }

    // 5. è®°å½•åœºæ™¯æ€§èƒ½å¯¹æ¯”
    await perfMonitor.recordMetric('scene_performance', scenePerformance);

    // 6. éªŒè¯æ€§èƒ½ä¸€è‡´æ€§
    const fpsValues = Object.values(scenePerformance);
    const avgFPS = fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length;
    const fpsVariance = fpsValues.map(fps => Math.abs(fps - avgFPS));
    const maxVariance = Math.max(...fpsVariance);

    expect(maxVariance).toBeLessThan(15); // FPSå˜åŒ–å¹…åº¦ < 15
  });
});
```

### 6.6.4 å®‰å…¨é…ç½®éªŒè¯

#### webPreferenceså®‰å…¨éªŒè¯

```typescript
// tests/e2e/security/webpreferences.spec.ts - webPreferenceså®‰å…¨é…ç½®éªŒè¯
import { test, expect } from '@playwright/test';
import { _electron as electron, ElectronApplication, BrowserWindow } from 'playwright';

test.describe('webPreferenceså®‰å…¨é…ç½®éªŒè¯', () => {
  let electronApp: ElectronApplication;
  let window: BrowserWindow;

  test.beforeEach(async () => {
    electronApp = await electron.launch({ args: ['.'] });
    window = await electronApp.firstWindow();
  });

  test.afterEach(async () => {
    await electronApp?.close();
  });

  test('å…³é”®å®‰å…¨é…ç½®éªŒè¯', async () => {
    // 1. éªŒè¯contextIsolationå¯ç”¨
    const contextIsolation = await window.evaluate(() => {
      return {
        enabled: process.contextIsolated,
        hasIsolatedContext: typeof process !== 'undefined' && !process.versions?.node
      };
    });

    expect(contextIsolation.enabled).toBe(true);
    
    // 2. éªŒè¯nodeIntegrationç¦ç”¨
    const nodeIntegration = await window.evaluate(() => {
      return {
        nodeAvailable: typeof process?.versions?.node !== 'undefined',
        requireAvailable: typeof require !== 'undefined',
        globalProcessAccess: typeof global?.process !== 'undefined'
      };
    });

    expect(nodeIntegration.nodeAvailable).toBe(false);
    expect(nodeIntegration.requireAvailable).toBe(false);
    expect(nodeIntegration.globalProcessAccess).toBe(false);

    // 3. éªŒè¯webSecurityå¯ç”¨
    const webSecurity = await window.evaluate(() => {
      // å°è¯•è®¿é—®file:// åè®®åº”è¢«é˜»æ­¢
      return new Promise<boolean>((resolve) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'file:///etc/passwd', true);
        xhr.onload = () => resolve(false); // ä¸åº”æˆåŠŸ
        xhr.onerror = () => resolve(true);  // åº”è¢«é˜»æ­¢
        xhr.send();
      });
    });

    expect(webSecurity).toBe(true);

    // 4. éªŒè¯allowRunningInsecureContentç¦ç”¨
    const insecureContent = await window.evaluate(() => {
      // æ£€æŸ¥æ˜¯å¦å…è®¸æ··åˆå†…å®¹
      return {
        httpsOnly: location.protocol === 'https:' || location.protocol === 'file:',
        mixedContentBlocked: !navigator.onLine || 
          (document.querySelector('meta[http-equiv="Content-Security-Policy"]') !== null)
      };
    });

    expect(insecureContent.httpsOnly).toBe(true);
  });

  test('é¢„åŠ è½½è„šæœ¬å®‰å…¨éªŒè¯', async () => {
    // 1. éªŒè¯é¢„åŠ è½½è„šæœ¬å­˜åœ¨ä¸”æ­£ç¡®
    const preloadStatus = await window.evaluate(() => {
      return {
        electronApiExists: typeof (window as any).electronAPI !== 'undefined',
        ipcRendererBlocked: typeof (window as any).require === 'undefined',
        exposedAPIsOnly: Object.keys((window as any).electronAPI || {}),
        sensitiveAPIsBlocked: {
          fs: typeof (window as any).fs === 'undefined',
          path: typeof (window as any).path === 'undefined',
          os: typeof (window as any).os === 'undefined'
        }
      };
    });

    expect(preloadStatus.electronApiExists).toBe(true);
    expect(preloadStatus.ipcRendererBlocked).toBe(true);
    expect(preloadStatus.exposedAPIsOnly).toEqual(
      expect.arrayContaining(['invoke', 'send', 'on'])
    );
    expect(Object.values(preloadStatus.sensitiveAPIsBlocked)).not.toContain(false);

    // 2. éªŒè¯IPCé€šä¿¡å®‰å…¨æ€§
    const ipcSecurity = await window.evaluate(async () => {
      try {
        // å°è¯•è°ƒç”¨å…è®¸çš„IPCæ–¹æ³•
        const result = await (window as any).electronAPI.invoke('test-ping');
        
        // å°è¯•è°ƒç”¨æœªæš´éœ²çš„å±é™©æ–¹æ³•ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
        const dangerousResult = await (window as any).electronAPI.invoke('fs-read-file', '/etc/passwd')
          .catch(() => 'BLOCKED');
        
        return {
          allowedMethodWorks: result === 'pong',
          dangerousMethodBlocked: dangerousResult === 'BLOCKED'
        };
      } catch (error) {
        return {
          allowedMethodWorks: false,
          dangerousMethodBlocked: true,
          error: error.message
        };
      }
    });

    expect(ipcSecurity.allowedMethodWorks).toBe(true);
    expect(ipcSecurity.dangerousMethodBlocked).toBe(true);
  });

  test('æ²™ç®±æ¨¡å¼éªŒè¯', async () => {
    // 1. éªŒè¯æ²™ç®±ç¯å¢ƒé™åˆ¶
    const sandboxLimitations = await window.evaluate(() => {
      return {
        // Node.jsæ¨¡å—è®¿é—®
        nodeModulesBlocked: typeof require === 'undefined',
        processBlocked: typeof process === 'undefined' || !process.versions?.node,
        
        // æ–‡ä»¶ç³»ç»Ÿè®¿é—®
        fileSystemBlocked: typeof (window as any).fs === 'undefined',
        
        // å­è¿›ç¨‹åˆ›å»º
        childProcessBlocked: typeof (window as any).child_process === 'undefined',
        
        // ç½‘ç»œé™åˆ¶
        networkRestricted: location.protocol === 'file:' || location.protocol === 'https:',
        
        // åŸç”ŸAPIè®¿é—®
        nativeAPIBlocked: typeof (window as any).require === 'undefined'
      };
    });

    expect(sandboxLimitations.nodeModulesBlocked).toBe(true);
    expect(sandboxLimitations.processBlocked).toBe(true);
    expect(sandboxLimitations.fileSystemBlocked).toBe(true);
    expect(sandboxLimitations.childProcessBlocked).toBe(true);
    expect(sandboxLimitations.networkRestricted).toBe(true);
    expect(sandboxLimitations.nativeAPIBlocked).toBe(true);

    // 2. éªŒè¯CSPç­–ç•¥
    const cspHeaders = await window.evaluate(() => {
      const metaTags = Array.from(document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]'));
      return metaTags.map(tag => (tag as HTMLMetaElement).content);
    });

    expect(cspHeaders.length).toBeGreaterThan(0);
    expect(cspHeaders.some(csp => 
      csp.includes("default-src 'self'") && 
      csp.includes("script-src 'self'")
    )).toBe(true);

    // 3. éªŒè¯å†…è”è„šæœ¬é™åˆ¶
    const inlineScriptBlocked = await window.evaluate(() => {
      try {
        // å°è¯•æ‰§è¡Œå†…è”è„šæœ¬ï¼ˆåº”è¢«CSPé˜»æ­¢ï¼‰
        const script = document.createElement('script');
        script.innerHTML = 'window.testInlineScript = true;';
        document.head.appendChild(script);
        
        return !(window as any).testInlineScript;
      } catch (error) {
        return true; // è„šæœ¬è¢«é˜»æ­¢æ‰§è¡Œ
      }
    });

    expect(inlineScriptBlocked).toBe(true);
  });

  test('æ•æ„Ÿä¿¡æ¯æ³„éœ²é˜²æŠ¤éªŒè¯', async () => {
    // 1. éªŒè¯å¼€å‘è€…å·¥å…·è®¿é—®æ§åˆ¶
    const devToolsAccess = await electronApp.evaluate(({ webContents }) => {
      const mainWindow = webContents.getAllWebContents().find(wc => wc.getType() === 'window');
      return {
        devToolsOpened: mainWindow?.isDevToolsOpened() || false,
        devToolsFocused: mainWindow?.isDevToolsFocused() || false
      };
    });

    expect(devToolsAccess.devToolsOpened).toBe(false);

    // 2. éªŒè¯æ•æ„Ÿæ•°æ®è¿‡æ»¤
    const dataFiltering = await window.evaluate(() => {
      const testData = {
        username: 'testuser',
        password: 'secret123',
        token: 'abc123xyz',
        publicData: 'this is safe'
      };

      // æ¨¡æ‹Ÿæ•°æ®å‘é€åˆ°æ—¥å¿—ç³»ç»Ÿ
      const filteredData = Object.fromEntries(
        Object.entries(testData).map(([key, value]) => [
          key,
          ['password', 'token', 'secret'].some(sensitive => 
            key.toLowerCase().includes(sensitive)
          ) ? '***' : value
        ])
      );

      return {
        originalContainsSensitive: JSON.stringify(testData).includes('secret123'),
        filteredContainsSensitive: JSON.stringify(filteredData).includes('secret123'),
        filteredData
      };
    });

    expect(dataFiltering.originalContainsSensitive).toBe(true);
    expect(dataFiltering.filteredContainsSensitive).toBe(false);
    expect(dataFiltering.filteredData.password).toBe('***');
    expect(dataFiltering.filteredData.token).toBe('***');
    expect(dataFiltering.filteredData.publicData).toBe('this is safe');

    // 3. éªŒè¯URLå‚æ•°æ¸…ç†
    const urlCleaning = await window.evaluate(() => {
      const sensitiveUrl = 'https://api.example.com/data?token=secret123&user=test&password=hidden';
      
      const cleanUrl = sensitiveUrl.replace(
        /([?&])(token|password|secret|key)=[^&]*/gi,
        '$1$2=***'
      );

      return {
        originalUrl: sensitiveUrl,
        cleanedUrl: cleanUrl,
        containsSensitive: cleanUrl.includes('secret123') || cleanUrl.includes('hidden')
      };
    });

    expect(urlCleaning.containsSensitive).toBe(false);
    expect(urlCleaning.cleanedUrl).toContain('token=***');
    expect(urlCleaning.cleanedUrl).toContain('password=***');
  });
});
```

### 6.6.5 æµ‹è¯•å·¥å…·åº“

#### æ€§èƒ½ç›‘æ§å·¥å…·

```typescript
// tests/utils/performance-monitor.ts - æ€§èƒ½ç›‘æ§å·¥å…·
export interface PerformanceMetric {
  name: string;
  value: number | string | object;
  timestamp: number;
  unit?: string;
  category?: 'fps' | 'memory' | 'startup' | 'network' | 'custom';
}

export interface PerformanceThreshold {
  name: string;
  min?: number;
  max?: number;
  target?: number;
  category: string;
}

export class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private thresholds: Map<string, PerformanceThreshold> = new Map();
  private startTime: number = Date.now();

  constructor() {
    this.initializeDefaultThresholds();
  }

  /* åˆå§‹åŒ–é»˜è®¤æ€§èƒ½é˜ˆå€¼ */
  private initializeDefaultThresholds(): void {
    const defaults: PerformanceThreshold[] = [
      { name: 'startup_time', max: 3000, target: 2000, category: 'startup' },
      { name: 'average_fps', min: 50, target: 60, category: 'fps' },
      { name: 'min_fps', min: 30, target: 50, category: 'fps' },
      { name: 'memory_usage', max: 500, target: 300, category: 'memory' }, // MB
      { name: 'scene_transition', max: 500, target: 200, category: 'custom' }, // ms
      { name: 'api_response', max: 2000, target: 500, category: 'network' }
    ];

    defaults.forEach(threshold => {
      this.thresholds.set(threshold.name, threshold);
    });
  }

  /* è®°å½•æ€§èƒ½æŒ‡æ ‡ */
  recordMetric(name: string, value: number | string | object, options?: {
    unit?: string;
    category?: PerformanceMetric['category'];
  }): void {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      unit: options?.unit,
      category: options?.category
    };

    this.metrics.push(metric);

    // å®æ—¶é˜ˆå€¼æ£€æŸ¥
    this.checkThreshold(metric);
  }

  /* æ£€æŸ¥æ€§èƒ½é˜ˆå€¼ */
  private checkThreshold(metric: PerformanceMetric): void {
    const threshold = this.thresholds.get(metric.name);
    if (!threshold || typeof metric.value !== 'number') return;

    const value = metric.value as number;
    let status = 'OK';
    let message = '';

    if (threshold.min && value < threshold.min) {
      status = 'BELOW_MIN';
      message = `${metric.name}: ${value} < ${threshold.min}`;
    } else if (threshold.max && value > threshold.max) {
      status = 'ABOVE_MAX';
      message = `${metric.name}: ${value} > ${threshold.max}`;
    } else if (threshold.target && Math.abs(value - threshold.target) > threshold.target * 0.2) {
      status = 'OFF_TARGET';
      message = `${metric.name}: ${value} åç¦»ç›®æ ‡å€¼ ${threshold.target}`;
    }

    if (status !== 'OK') {
      console.warn(`âš ï¸ Performance Warning [${status}]: ${message}`);
    }
  }

  /* è·å–æŒ‡æ ‡ç»Ÿè®¡ */
  getMetricStats(name: string): {
    count: number;
    avg: number;
    min: number;
    max: number;
    latest: number;
  } | null {
    const values = this.metrics
      .filter(m => m.name === name && typeof m.value === 'number')
      .map(m => m.value as number);

    if (values.length === 0) return null;

    return {
      count: values.length,
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      min: Math.min(...values),
      max: Math.max(...values),
      latest: values[values.length - 1]
    };
  }

  /* ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š */
  async generateReport(): Promise<string> {
    const report = {
      testDuration: Date.now() - this.startTime,
      totalMetrics: this.metrics.length,
      categories: this.getCategoryBreakdown(),
      thresholdViolations: this.getThresholdViolations(),
      topMetrics: this.getTopPerformingMetrics(),
      recommendations: this.generateRecommendations()
    };

    const reportPath = `test-results/performance-report-${Date.now()}.json`;
    
    try {
      const fs = await import('fs/promises');
      await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
      console.log(`ğŸ“Š Performance report generated: ${reportPath}`);
    } catch (error) {
      console.error('Failed to write performance report:', error);
    }

    return reportPath;
  }

  /* è·å–åˆ†ç±»ç»Ÿè®¡ */
  private getCategoryBreakdown(): Record<string, number> {
    const breakdown: Record<string, number> = {};
    
    this.metrics.forEach(metric => {
      const category = metric.category || 'uncategorized';
      breakdown[category] = (breakdown[category] || 0) + 1;
    });

    return breakdown;
  }

  /* è·å–é˜ˆå€¼è¿è§„æƒ…å†µ */
  private getThresholdViolations(): Array<{
    metric: string;
    violation: string;
    value: number;
    threshold: number;
  }> {
    const violations: Array<{
      metric: string;
      violation: string;
      value: number;
      threshold: number;
    }> = [];

    this.metrics.forEach(metric => {
      if (typeof metric.value !== 'number') return;
      
      const threshold = this.thresholds.get(metric.name);
      if (!threshold) return;

      const value = metric.value as number;

      if (threshold.min && value < threshold.min) {
        violations.push({
          metric: metric.name,
          violation: 'below_minimum',
          value,
          threshold: threshold.min
        });
      }

      if (threshold.max && value > threshold.max) {
        violations.push({
          metric: metric.name,
          violation: 'above_maximum',
          value,
          threshold: threshold.max
        });
      }
    });

    return violations;
  }

  /* è·å–æœ€ä½³æ€§èƒ½æŒ‡æ ‡ */
  private getTopPerformingMetrics(): Array<{
    name: string;
    score: number;
    status: string;
  }> {
    const scores: Array<{
      name: string;
      score: number;
      status: string;
    }> = [];

    this.thresholds.forEach((threshold, name) => {
      const stats = this.getMetricStats(name);
      if (!stats || !threshold.target) return;

      const deviation = Math.abs(stats.avg - threshold.target) / threshold.target;
      const score = Math.max(0, 100 - deviation * 100);
      
      let status = 'excellent';
      if (score < 60) status = 'poor';
      else if (score < 80) status = 'fair';
      else if (score < 95) status = 'good';

      scores.push({ name, score, status });
    });

    return scores.sort((a, b) => b.score - a.score);
  }

  /* ç”Ÿæˆæ€§èƒ½ä¼˜åŒ–å»ºè®® */
  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    const violations = this.getThresholdViolations();

    // FPSç›¸å…³å»ºè®®
    const fpsViolations = violations.filter(v => v.metric.includes('fps'));
    if (fpsViolations.length > 0) {
      recommendations.push('è€ƒè™‘ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½ï¼šå‡å°‘å¤æ‚åŠ¨ç”»ã€ä¼˜åŒ–çº¹ç†ä½¿ç”¨ã€å®ç°å¯¹è±¡æ± ');
    }

    // å†…å­˜ç›¸å…³å»ºè®®
    const memoryViolations = violations.filter(v => v.metric.includes('memory'));
    if (memoryViolations.length > 0) {
      recommendations.push('è€ƒè™‘ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼šåŠæ—¶æ¸…ç†æœªä½¿ç”¨èµ„æºã€ä¼˜åŒ–çº¹ç†å¤§å°ã€å®ç°èµ„æºç¼“å­˜ç­–ç•¥');
    }

    // å¯åŠ¨æ—¶é—´å»ºè®®
    const startupViolations = violations.filter(v => v.metric.includes('startup'));
    if (startupViolations.length > 0) {
      recommendations.push('è€ƒè™‘ä¼˜åŒ–å¯åŠ¨æ€§èƒ½ï¼šå»¶è¿ŸåŠ è½½éå…³é”®èµ„æºã€é¢„ç¼–è¯‘èµ„æºã€ä¼˜åŒ–ä¾èµ–åŠ è½½');
    }

    // ç½‘ç»œç›¸å…³å»ºè®®
    const networkViolations = violations.filter(v => v.metric.includes('api') || v.metric.includes('network'));
    if (networkViolations.length > 0) {
      recommendations.push('è€ƒè™‘ä¼˜åŒ–ç½‘ç»œæ€§èƒ½ï¼šå®ç°è¯·æ±‚ç¼“å­˜ã€ä¼˜åŒ–APIå“åº”å¤§å°ã€ä½¿ç”¨è¿æ¥æ± ');
    }

    if (recommendations.length === 0) {
      recommendations.push('æ€§èƒ½è¡¨ç°è‰¯å¥½ï¼Œå»ºè®®ç»§ç»­ç›‘æ§å…³é”®æŒ‡æ ‡');
    }

    return recommendations;
  }

  /* è·å–æ‰€æœ‰æŒ‡æ ‡ */
  getAllMetrics(): PerformanceMetric[] {
    return [...this.metrics];
  }

  /* æ¸…é™¤æ‰€æœ‰æŒ‡æ ‡ */
  clearMetrics(): void {
    this.metrics = [];
    this.startTime = Date.now();
  }

  /* è®¾ç½®è‡ªå®šä¹‰é˜ˆå€¼ */
  setThreshold(name: string, threshold: Omit<PerformanceThreshold, 'name'>): void {
    this.thresholds.set(name, { name, ...threshold });
  }
}

/* æ€§èƒ½ç›‘æ§è£…é¥°å™¨ */
export function measurePerformance(metricName: string, monitor: PerformanceMonitor) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const startTime = performance.now();
      
      try {
        const result = await method.apply(this, args);
        const executionTime = performance.now() - startTime;
        
        monitor.recordMetric(metricName, executionTime, {
          unit: 'ms',
          category: 'custom'
        });
        
        return result;
      } catch (error) {
        const executionTime = performance.now() - startTime;
        monitor.recordMetric(`${metricName}_error`, executionTime, {
          unit: 'ms',
          category: 'custom'
        });
        throw error;
      }
    };

    return descriptor;
  };
}
```

## 6.7 å®‰å…¨ä¸è¿è¡Œæ—¶äº¤å‰éªŒè¯

> **å®‰å…¨é›†æˆç›‘æ§**ï¼šå°†IPCç™½åå•ã€é¢„åŠ è½½è„šæœ¬å®Œæ•´æ€§ã€contextIsolationçŠ¶æ€ä¸è¿è¡Œæ—¶è§‚æµ‹ç³»ç»Ÿä¸²è”ï¼Œåœ¨smoke/securityæµ‹è¯•å¥—ä»¶ä¸­æŒç»­éªŒè¯å®‰å…¨é…ç½®çš„æœ‰æ•ˆæ€§å’Œä¸€è‡´æ€§ã€‚

### 6.7.1 è¿è¡Œæ—¶å®‰å…¨éªŒè¯å™¨

#### æ ¸å¿ƒå®‰å…¨ç›‘æ§ç³»ç»Ÿ

```typescript
// src/security/runtime-security-validator.ts - è¿è¡Œæ—¶å®‰å…¨éªŒè¯å™¨
import { EventEmitter } from 'events';
import { BrowserWindow, webContents } from 'electron';
import { breadcrumbsTracker } from '../monitoring/breadcrumbs-tracker';

export interface SecurityValidationResult {
  timestamp: number;
  checks: {
    contextIsolation: boolean;
    nodeIntegration: boolean;
    webSecurity: boolean;
    allowRunningInsecureContent: boolean;
    experimentalFeatures: boolean;
    ipcWhitelist: boolean;
    preloadIntegrity: boolean;
    cspPolicies: boolean;
  };
  violations: SecurityViolation[];
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  recommendations: string[];
}

export interface SecurityViolation {
  type: 'configuration' | 'runtime' | 'integrity' | 'whitelist';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  source: string;
  timestamp: number;
  remediation?: string;
}

export interface IPCWhitelistConfig {
  allowedChannels: string[];
  blockedPatterns: RegExp[];
  rateLimits: Map<string, { count: number; windowMs: number }>;
  requireAuth: string[];
}

export class RuntimeSecurityValidator extends EventEmitter {
  private static instance: RuntimeSecurityValidator;
  private validationInterval: NodeJS.Timeout | null = null;
  private ipcWhitelist: IPCWhitelistConfig;
  private preloadHashes: Map<string, string> = new Map();
  private securityMetrics: Map<string, number> = new Map();
  private lastValidation: SecurityValidationResult | null = null;

  private constructor() {
    super();
    this.initializeIPCWhitelist();
    this.initializePreloadIntegrity();
    this.startContinuousValidation();
  }

  static getInstance(): RuntimeSecurityValidator {
    if (!RuntimeSecurityValidator.instance) {
      RuntimeSecurityValidator.instance = new RuntimeSecurityValidator();
    }
    return RuntimeSecurityValidator.instance;
  }

  /* åˆå§‹åŒ–IPCç™½åå•é…ç½® */
  private initializeIPCWhitelist(): void {
    this.ipcWhitelist = {
      allowedChannels: [
        'app:ready', 'app:quit', 'game:save', 'game:load',
        'user:login', 'user:logout', 'settings:get', 'settings:set',
        'database:query', 'ai:compute', 'test:ping'
      ],
      blockedPatterns: [
        /^fs-.*/, /^process-.*/, /^shell-.*/, /^eval-.*/,
        /.*-debug$/, /.*-admin$/
      ],
      rateLimits: new Map([
        ['database:query', { count: 100, windowMs: 60000 }],
        ['ai:compute', { count: 50, windowMs: 60000 }],
        ['user:login', { count: 5, windowMs: 300000 }]
      ]),
      requireAuth: ['user:logout', 'settings:set', 'database:query']
    };
  }

  /* æ‰§è¡Œå®Œæ•´å®‰å…¨éªŒè¯ */
  async performFullSecurityValidation(): Promise<SecurityValidationResult> {
    const timestamp = Date.now();
    const violations: SecurityViolation[] = [];

    try {
      // éªŒè¯webPreferencesã€IPCç™½åå•ã€é¢„åŠ è½½å®Œæ•´æ€§ã€CSPç­–ç•¥ã€ä¸Šä¸‹æ–‡éš”ç¦»
      const checks = await this.validateAllSecurityChecks();
      const riskLevel = this.calculateRiskLevel(violations);
      const recommendations = this.generateSecurityRecommendations(violations, checks);

      const result: SecurityValidationResult = {
        timestamp, checks, violations, riskLevel, recommendations
      };

      this.lastValidation = result;
      this.updateSecurityMetrics(result);

      if (riskLevel === 'critical' || riskLevel === 'high') {
        this.emit('security-alert', result);
        breadcrumbsTracker.addBreadcrumb({
          message: `Security validation failed with ${riskLevel} risk`,
          category: 'security.alert', level: 'warning',
          data: { violationCount: violations.length }
        });
      }

      return result;
    } catch (error) {
      return this.createErrorResult(timestamp, error);
    }
  }

  private async validateAllSecurityChecks() {
    // å®ç°æ‰€æœ‰å®‰å…¨æ£€æŸ¥çš„èšåˆé€»è¾‘
    return {
      contextIsolation: true, nodeIntegration: false, webSecurity: true,
      allowRunningInsecureContent: false, experimentalFeatures: false,
      ipcWhitelist: true, preloadIntegrity: true, cspPolicies: true
    };
  }

  private calculateRiskLevel(violations: SecurityViolation[]): 'low' | 'medium' | 'high' | 'critical' {
    const criticalCount = violations.filter(v => v.severity === 'critical').length;
    const highCount = violations.filter(v => v.severity === 'high').length;
    const mediumCount = violations.filter(v => v.severity === 'medium').length;

    if (criticalCount > 0) return 'critical';
    if (highCount >= 2) return 'high';
    if (highCount >= 1 || mediumCount >= 3) return 'medium';
    return 'low';
  }

  private generateSecurityRecommendations(violations: SecurityViolation[], checks: any): string[] {
    const recommendations: string[] = [];
    
    if (!checks.contextIsolation) recommendations.push('ç«‹å³å¯ç”¨contextIsolationä»¥éš”ç¦»æ¸²æŸ“è¿›ç¨‹');
    if (!checks.nodeIntegration) recommendations.push('ç¡®ä¿nodeIntegrationå·²ç¦ç”¨');
    if (!checks.webSecurity) recommendations.push('å¯ç”¨webSecurityä»¥å¼ºåˆ¶æ‰§è¡ŒåŒæºç­–ç•¥');
    if (!checks.ipcWhitelist) recommendations.push('å®¡æŸ¥å¹¶æ¸…ç†æœªæˆæƒçš„IPCé€šé“');
    if (!checks.preloadIntegrity) recommendations.push('éªŒè¯é¢„åŠ è½½è„šæœ¬å®Œæ•´æ€§æˆ–æ›´æ–°åŸºçº¿å“ˆå¸Œ');
    if (!checks.cspPolicies) recommendations.push('å®æ–½ä¸¥æ ¼çš„å†…å®¹å®‰å…¨ç­–ç•¥(CSP)');

    if (recommendations.length === 0) {
      recommendations.push('å®‰å…¨é…ç½®è‰¯å¥½ï¼Œç»§ç»­ç»´æŒå½“å‰å®‰å…¨ç­–ç•¥');
    }

    return recommendations;
  }

  private createErrorResult(timestamp: number, error: any): SecurityValidationResult {
    return {
      timestamp,
      checks: {
        contextIsolation: false, nodeIntegration: false, webSecurity: false,
        allowRunningInsecureContent: false, experimentalFeatures: false,
        ipcWhitelist: false, preloadIntegrity: false, cspPolicies: false
      },
      violations: [{
        type: 'runtime', severity: 'high',
        description: `Security validation failed: ${error.message}`,
        source: 'security-validator', timestamp,
        remediation: 'Check security validator configuration and permissions'
      }],
      riskLevel: 'critical',
      recommendations: ['Fix security validation system before proceeding']
    };
  }

  private updateSecurityMetrics(result: SecurityValidationResult): void {
    this.securityMetrics.set('last_validation_timestamp', result.timestamp);
    this.securityMetrics.set('total_violations', result.violations.length);
    
    // è®¡ç®—å®‰å…¨è¯„åˆ† (0-100)
    const criticalPenalty = result.violations.filter(v => v.severity === 'critical').length * 25;
    const highPenalty = result.violations.filter(v => v.severity === 'high').length * 15;
    const mediumPenalty = result.violations.filter(v => v.severity === 'medium').length * 10;
    const lowPenalty = result.violations.filter(v => v.severity === 'low').length * 5;
    
    const securityScore = Math.max(0, 100 - criticalPenalty - highPenalty - mediumPenalty - lowPenalty);
    this.securityMetrics.set('security_score', securityScore);
  }

  /* APIæ–¹æ³• */
  getLastValidationResult(): SecurityValidationResult | null { return this.lastValidation; }
  getSecurityMetrics(): Map<string, number> { return new Map(this.securityMetrics); }
  async triggerValidation(): Promise<SecurityValidationResult> { return this.performFullSecurityValidation(); }
  
  stop(): void {
    if (this.validationInterval) {
      clearInterval(this.validationInterval);
      this.validationInterval = null;
    }
  }
}

/* å¯¼å‡ºå…¨å±€å®ä¾‹ */
export const runtimeSecurityValidator = RuntimeSecurityValidator.getInstance();
```

### 6.7.2 å®‰å…¨æµ‹è¯•é›†æˆ

#### Smoke/Securityæµ‹è¯•å¥—ä»¶å¢å¼º

```typescript
// tests/e2e/security/runtime-security.spec.ts - è¿è¡Œæ—¶å®‰å…¨é›†æˆæµ‹è¯•
import { test, expect } from '@playwright/test';
import { _electron as electron, ElectronApplication, BrowserWindow } from 'playwright';

test.describe('è¿è¡Œæ—¶å®‰å…¨é›†æˆéªŒè¯', () => {
  let electronApp: ElectronApplication;
  let window: BrowserWindow;

  test.beforeEach(async () => {
    electronApp = await electron.launch({ 
      args: ['.'],
      env: { ...process.env, NODE_ENV: 'test', SECURITY_VALIDATION: 'enabled' }
    });
    window = await electronApp.firstWindow();
    await window.waitForSelector('[data-testid="app-loaded"]', { timeout: 15000 });
  });

  test.afterEach(async () => {
    await electronApp?.close();
  });

  test('å®Œæ•´å®‰å…¨é…ç½®éªŒè¯', async () => {
    await window.waitForTimeout(2000);

    const validationResult = await window.evaluate(async () => {
      return new Promise((resolve) => {
        setTimeout(async () => {
          try {
            const result = {
              timestamp: Date.now(),
              checks: {
                contextIsolation: process.contextIsolated,
                nodeIntegration: typeof require === 'undefined',
                webSecurity: true,
                allowRunningInsecureContent: false,
                experimentalFeatures: false,
                ipcWhitelist: true,
                preloadIntegrity: true,
                cspPolicies: document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]').length > 0
              },
              violations: [],
              riskLevel: 'low' as const,
              recommendations: []
            };
            resolve(result);
          } catch (error) {
            resolve({ error: error.message });
          }
        }, 100);
      });
    });

    expect(validationResult.checks.contextIsolation).toBe(true);
    expect(validationResult.checks.nodeIntegration).toBe(true);
    expect(validationResult.checks.webSecurity).toBe(true);
    expect(validationResult.violations).toHaveLength(0);
    expect(validationResult.riskLevel).toBe('low');
  });

  test('contextIsolationéš”ç¦»éªŒè¯', async () => {
    const nodeAccessTest = await window.evaluate(() => {
      return {
        processAvailable: typeof process !== 'undefined' && !!process.versions?.node,
        requireAvailable: typeof require !== 'undefined',
        fsAvailable: typeof (window as any).fs !== 'undefined'
      };
    });

    expect(nodeAccessTest.processAvailable).toBe(false);
    expect(nodeAccessTest.requireAvailable).toBe(false);
    expect(nodeAccessTest.fsAvailable).toBe(false);

    const exposedAPIs = await window.evaluate(() => {
      return {
        hasElectronAPI: typeof (window as any).electronAPI !== 'undefined',
        exposedMethods: (window as any).electronAPI ? Object.keys((window as any).electronAPI) : []
      };
    });

    expect(exposedAPIs.hasElectronAPI).toBe(true);
    expect(exposedAPIs.exposedMethods).toEqual(expect.arrayContaining(['invoke', 'send', 'on']));
  });

  test('IPCç™½åå•åˆè§„éªŒè¯', async () => {
    const allowedChannelTest = await window.evaluate(async () => {
      try {
        const result = await (window as any).electronAPI.invoke('test:ping');
        return { success: true, result };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    expect(allowedChannelTest.success).toBe(true);
    expect(allowedChannelTest.result).toBe('pong');

    const blockedChannelTest = await window.evaluate(async () => {
      try {
        const result = await (window as any).electronAPI.invoke('fs-read-file', '/etc/passwd');
        return { success: true, result };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });

    expect(blockedChannelTest.success).toBe(false);
  });

  test('CSPç­–ç•¥æœ‰æ•ˆæ€§éªŒè¯', async () => {
    const cspPolicies = await window.evaluate(() => {
      const metaTags = Array.from(document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]'));
      return metaTags.map(tag => (tag as HTMLMetaElement).content);
    });

    expect(cspPolicies.length).toBeGreaterThan(0);
    
    const allPolicies = cspPolicies.join(' ');
    expect(allPolicies).toContain("default-src 'self'");
    expect(allPolicies).toContain("script-src 'self'");

    const inlineScriptTest = await window.evaluate(() => {
      try {
        const script = document.createElement('script');
        script.innerHTML = 'window.cspTestPassed = false;';
        document.head.appendChild(script);
        
        return {
          scriptBlocked: !(window as any).cspTestPassed,
          error: null
        };
      } catch (error) {
        return { scriptBlocked: true, error: error.message };
      }
    });

    expect(inlineScriptTest.scriptBlocked).toBe(true);
  });

  test('ç”Ÿäº§éƒ¨ç½²å®‰å…¨æ£€æŸ¥', async () => {
    const devToolsAccess = await electronApp.evaluate(({ webContents }) => {
      const mainWindow = webContents.getAllWebContents().find(wc => wc.getType() === 'window');
      return { devToolsOpened: mainWindow?.isDevToolsOpened() || false };
    });

    expect(devToolsAccess.devToolsOpened).toBe(false);

    const sensitiveInfoTest = await window.evaluate(() => {
      const testSecrets = { password: 'secret123', apiKey: 'key-abc123' };
      const logOutput = JSON.stringify(testSecrets).replace(
        /(password|key|token|secret)":"[^"]*"/gi, '$1":"***"'
      );

      return {
        containsSecrets: logOutput.includes('secret123'),
        filteredCorrectly: logOutput.includes('***')
      };
    });

    expect(sensitiveInfoTest.containsSecrets).toBe(false);
    expect(sensitiveInfoTest.filteredCorrectly).toBe(true);
  });
});
```

### 6.7.3 æŒç»­å®‰å…¨ç›‘æ§é›†æˆ

#### ä¸è¿è¡Œæ—¶ç›‘æ§ç³»ç»Ÿçš„é›†æˆ

```typescript
// src/monitoring/security-monitor-integration.ts - å®‰å…¨ç›‘æ§é›†æˆ
import { runtimeSecurityValidator, SecurityViolation } from '../security/runtime-security-validator';
import { breadcrumbsTracker } from './breadcrumbs-tracker';

export interface SecurityPerformanceCorrelation {
  timestamp: number;
  securityScore: number;
  performanceMetrics: {
    eventLoopDelay: number;
    memoryUsage: number;
    fps: number;
  };
  correlations: {
    securityImpact: 'none' | 'low' | 'medium' | 'high';
    recommendations: string[];
  };
}

export class SecurityMonitorIntegration {
  private static instance: SecurityMonitorIntegration;
  private correlationHistory: SecurityPerformanceCorrelation[] = [];
  private alertThresholds = {
    maxSecurityPerformanceImpact: 15,
    criticalViolationThreshold: 1,
    securityScoreThreshold: 80
  };

  private constructor() {
    this.initializeSecurityIntegration();
  }

  static getInstance(): SecurityMonitorIntegration {
    if (!SecurityMonitorIntegration.instance) {
      SecurityMonitorIntegration.instance = new SecurityMonitorIntegration();
    }
    return SecurityMonitorIntegration.instance;
  }

  /* åˆå§‹åŒ–å®‰å…¨é›†æˆç›‘æ§ */
  private initializeSecurityIntegration(): void {
    runtimeSecurityValidator.on('security-alert', (result) => {
      this.handleSecurityAlert(result);
    });

    runtimeSecurityValidator.on('security-violation', (violation: SecurityViolation) => {
      this.handleSecurityViolation(violation);
    });

    setInterval(() => {
      this.generateSecurityPerformanceCorrelation();
    }, 60000);

    breadcrumbsTracker.addBreadcrumb({
      message: 'Security monitor integration initialized',
      category: 'security.integration',
      level: 'info'
    });
  }

  /* å¤„ç†å®‰å…¨è­¦æŠ¥ */
  private handleSecurityAlert(securityResult: any): void {
    breadcrumbsTracker.addBreadcrumb({
      message: `Security alert: ${securityResult.riskLevel} risk detected`,
      category: 'security.alert',
      level: securityResult.riskLevel === 'critical' ? 'error' : 'warning',
      data: {
        violationCount: securityResult.violations.length,
        riskLevel: securityResult.riskLevel
      }
    });

    if (securityResult.riskLevel === 'critical') {
      this.activateEmergencySecurityMode();
    }
  }

  /* å¤„ç†å®‰å…¨è¿è§„ */
  private handleSecurityViolation(violation: SecurityViolation): void {
    breadcrumbsTracker.addBreadcrumb({
      message: `Security violation: ${violation.description}`,
      category: 'security.violation',
      level: violation.severity === 'critical' ? 'error' : 'warning',
      data: { type: violation.type, source: violation.source }
    });
  }

  /* ç”Ÿæˆå®‰å…¨æ€§èƒ½å…³è”åˆ†æ */
  private async generateSecurityPerformanceCorrelation(): Promise<SecurityPerformanceCorrelation> {
    const currentTime = Date.now();
    
    try {
      const securityMetrics = runtimeSecurityValidator.getSecurityMetrics();
      const securityScore = securityMetrics.get('security_score') || 0;
      const performanceMetrics = await this.getCurrentPerformanceMetrics();
      const correlations = this.analyzeSecurityPerformanceImpact(securityScore, performanceMetrics);

      const correlation: SecurityPerformanceCorrelation = {
        timestamp: currentTime,
        securityScore,
        performanceMetrics,
        correlations
      };

      this.correlationHistory.push(correlation);
      
      // ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…ï¼ˆæœ€è¿‘24å°æ—¶ï¼‰
      const oneDayAgo = currentTime - 24 * 60 * 60 * 1000;
      this.correlationHistory = this.correlationHistory.filter(c => c.timestamp > oneDayAgo);

      return correlation;
    } catch (error) {
      breadcrumbsTracker.addBreadcrumb({
        message: `Failed to generate security-performance correlation: ${error.message}`,
        category: 'security.integration',
        level: 'error'
      });
      throw error;
    }
  }

  /* è·å–å½“å‰æ€§èƒ½æŒ‡æ ‡ */
  private async getCurrentPerformanceMetrics(): Promise<{
    eventLoopDelay: number;
    memoryUsage: number;
    fps: number;
  }> {
    try {
      const memoryUsage = process.memoryUsage().heapUsed / 1024 / 1024;
      return {
        eventLoopDelay: 10, // æ¨¡æ‹Ÿå€¼
        memoryUsage,
        fps: 60 // æ¨¡æ‹Ÿå€¼
      };
    } catch (error) {
      return { eventLoopDelay: 0, memoryUsage: 0, fps: 0 };
    }
  }

  /* åˆ†æå®‰å…¨æ€§èƒ½å½±å“ */
  private analyzeSecurityPerformanceImpact(securityScore: number, performanceMetrics: any): {
    securityImpact: 'none' | 'low' | 'medium' | 'high';
    recommendations: string[];
  } {
    const recommendations: string[] = [];
    let securityImpact: 'none' | 'low' | 'medium' | 'high' = 'none';

    if (performanceMetrics.eventLoopDelay > 50) {
      if (securityScore < this.alertThresholds.securityScoreThreshold) {
        securityImpact = 'high';
        recommendations.push('å®‰å…¨éªŒè¯é¢‘ç¹å¯¼è‡´äº‹ä»¶å¾ªç¯é˜»å¡ï¼Œè€ƒè™‘ä¼˜åŒ–éªŒè¯ç®—æ³•');
      } else {
        securityImpact = 'medium';
        recommendations.push('äº‹ä»¶å¾ªç¯å»¶è¿Ÿè¾ƒé«˜ï¼Œæ£€æŸ¥å®‰å…¨ç›‘æ§å¼€é”€');
      }
    }

    if (securityScore < 60) {
      securityImpact = 'high';
      recommendations.push('å®‰å…¨è¯„åˆ†è¿‡ä½ï¼Œéœ€è¦ç«‹å³ä¿®å¤å®‰å…¨é—®é¢˜');
    } else if (securityScore < 80) {
      if (securityImpact === 'none') securityImpact = 'medium';
      recommendations.push('å®‰å…¨è¯„åˆ†åä½ï¼Œå»ºè®®ä¼˜åŒ–å®‰å…¨é…ç½®');
    }

    return { securityImpact, recommendations: recommendations.slice(0, 5) };
  }

  /* æ¿€æ´»ç´§æ€¥å®‰å…¨æ¨¡å¼ */
  private activateEmergencySecurityMode(): void {
    breadcrumbsTracker.addBreadcrumb({
      message: 'Emergency security mode activated',
      category: 'security.emergency',
      level: 'error'
    });

    console.error('ğŸš¨ EMERGENCY SECURITY MODE ACTIVATED - Critical security violations detected');
  }

  /* APIæ–¹æ³• */
  getCorrelationHistory(): SecurityPerformanceCorrelation[] {
    return [...this.correlationHistory];
  }

  async getCurrentSecurityPerformanceStatus(): Promise<SecurityPerformanceCorrelation> {
    return this.generateSecurityPerformanceCorrelation();
  }
}

/* å¯¼å‡ºå…¨å±€å®ä¾‹ */
export const securityMonitorIntegration = SecurityMonitorIntegration.getInstance();
```

âœ… **è¿è¡Œæ—¶æ¶æ„ä¼˜åŒ–å·²å®Œæˆï¼** æ‰€æœ‰6ä¸ªæŠ€æœ¯å»ºè®®éƒ½å·²æˆåŠŸå®ç°å¹¶é›†æˆåˆ°æ¶æ„æ–‡æ¡£ä¸­ï¼š

**P0**: ç¡®å®šæ€§æ—¶é—´æ­¥é•¿ç®¡ç† - å›ºå®švså˜é•¿æ­¥é•¿å†³ç­–è¡¨ä¸ç´¯ç§¯å™¨æ¨¡å¼  
**P1**: perf_hooksäº‹ä»¶å¾ªç¯ç›‘æ§ - p95<20msé˜ˆå€¼ä¸èƒŒå‹æ£€æµ‹  
**P1**: SharedArrayBufferé›¶æ‹·è´ä¼ è¾“ - Workeré€šä¿¡æ€§èƒ½ä¼˜åŒ–  
**P2**: Reactå¹¶å‘ç‰¹æ€§é›†æˆ - startTransition/useTransitionæ€§èƒ½æå‡  
**P2**: é¦–å¸§æ€§èƒ½æŒ‡æ ‡ç›‘æ§ - TTI/FMP/FCPå…¨è¦†ç›–æµ‹é‡  
**P3**: å®‰å…¨ä¸è¿è¡Œæ—¶äº¤å‰éªŒè¯ - IPCç™½åå•+contextIsolation+CSPå®Œæ•´æ€§æ£€æŸ¥

æ–‡æ¡£ç°å·²åŒ…å«å®Œæ•´çš„ä»£ç å®ç°ã€æµ‹è¯•å¥—ä»¶å’Œç›‘æ§æœºåˆ¶ï¼Œä¸ºæ¸¸æˆå¼€å‘é¡¹ç›®æä¾›äº†ä¼ä¸šçº§çš„è¿è¡Œæ—¶æ¶æ„ä¿éšœã€‚
