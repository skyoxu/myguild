 优先级总览（从收益最大→风险可控）

  - 0 基线与诊断: 建可视化与埋点，确认瓶颈定位与回归度量
  - 1 首屏与包体拆分: rollup 手工分块 + 动态导入，缩短冷启动/首帧
  - 2 交互异步化: 把重逻辑移出主线程/延后到空闲帧
  - 3 启动与场景加载优化: Phaser 延迟加载与资产压缩
  - 4 构建与门禁: 可视化报告 + 预算与 CI Gate
  - 5 观测与超框: 长任务监控与性能门槛拉通到 Release Health

  0) 基线与诊断（先做，1天内完成）

  - 现状: 失败用例显示“基本交互”> 200ms；构建有大块 phaser 1.48MB、react-vendor 356kB。
  - 建议
      - 性能埋点: 在触发 [data-testid="test-button"] 的事件处理链路插入 performance.mark/measure（点击开始/首个 DOM 反馈完成/状态计算结束），输出到控制台，
  Playwright 收集。
      - Trace 采集: 将失败用例打开 --trace=on，在 CI 失败时上传 artifacts 便于回溯。
      - 可视化: 运行 rollup-visualizer 产出 stats.html，作为 PR 附件（已在 devDeps 中）。

  1) 首屏与包体拆分（收益最大，低风险，优先）

  - 目标: 降低首屏解析/编译/执行成本，避免主线程阻塞。
  - 变更建议
      - vite 分块（vite.config.ts）
      - manualChunks: 拆出核心大包
        - react: ['react','react-dom']
        - phaser: ['phaser']
        - antd: ['antd','@ant-design/icons']
        - ui-chunks: 视业务模块再拆（如 guild-manager、raid-compose 等）
      - chunkSizeWarningLimit: 临时抬高阈值到 1500 以降低噪音，但配合预算 Gate（见第4点）。
  - 动态导入（src）
      - Phaser 及场景: 在“开始游戏/进入场景”点击后 `await import('phaser')` 与 `await import('./game/scenes/MainScene')`
      - 路由/功能切片: 用 `React.lazy`/`Suspense` 对“管理/编队/战斗”各大视图懒加载
      - 重型 UI 组件: antd 模块化导入，避免整包全量引入
  - Skeleton 占位: 首屏仅渲染轻量骨架与导航，异步加载重模块；确保“可交互”尽快发生（改善感知性能）
  - 验收
      - 首屏加载 JS 体积（initial chunks）较现状下降 ≥ 40%
      - electron-launch 启动时间与“应用启动并显示主窗口”稳定下降（在当前 runner 上可见）

  2) 交互异步化（修复 >200ms 的核心）

  - 目标: 交互触发到“可见反馈控件出现”P95 < 200ms。
  - 变更建议
      - 主线程释压
      - requestAnimationFrame 双帧或 requestIdleCallback: 将非关键计算延后到渲染后/空闲时
      - 避免同步 IO: 交互路径禁用同步 fs/JSON 解析；改为预热或后台异步准备
  - 计算移出主线程
      - Web Worker（渲染侧）/worker_threads（主进程侧）：AI/队伍编制/大数组聚合等重逻辑从事件回调剥离，交互先给轻提示（loading/进度），完成后再回填
      - 推荐封装: Renderer <-> Worker 用 Comlink 或自定义 RPC，主进程 IPC 仅用于系统资源
  - React 优化
      - 非阻塞更新: 使用 `useTransition`/`useDeferredValue` 将非紧急更新降级为“并发”更新
      - 渲染减载: 列表虚拟化（windowing），精准 selector/memo（`useMemo`/`useCallback`），避免大范围重渲染
  - 验收
      - Playwright “基本交互：应用响应性测试”通过；本地 P95 观测 < 200ms，截图与 mark/measure 日志一致

  3) 启动与场景加载优化（Phaser 专项）

  - 目标: 避免 Phaser 成为冷启动瓶颈，把成本迁移到“进入游戏”瞬间并可视觉过渡。
  - 变更建议
      - 延迟加载 Phaser: 不在首屏初始化 Phaser；用户进入游戏时动态导入，显示过渡动画（骨架/进度条）
      - 资产压缩与打包
      - 纹理打包: 使用 atlas/spritesheets 降低 draw call 与资源请求数
      - 纹理压缩: webp/avif；如支持 Basis（.basis/.ktx2），降低 GPU 上传与内存
  - 预热缓存: 进入游戏前的空闲窗口预热少量关键贴图/字体（后台帧10~16ms预算内逐步做）
  - 验收
      - 冷启动 P95 不受 Phaser 影响，进入游戏场景的加载体验平滑、总耗时受控

  4) 构建与预算门禁（拉入 CI）

  - 目标: 阻断包体回归，形成可追溯度量。
  - 变更建议
      - 可视化报告: rollup-plugin-visualizer 产物上传到 PR 附件
      - 预算门禁（脚本+阈值）
      - initial js 总量 ≤ 400kB（gzip）; phaser chunk ≤ 500kB（gzip）
      - react vendor ≤ 150kB（gzip）
      - 若超阈值则 PR Gate 失败（集成至 `guard:workflows` 或新 job）
  - E2E 性能 Gate
      - 将“基本交互 P95 < 200ms”“冷启动 P95 达标”加入 soft gate（先告警，1~2 周后转硬门）

  5) 观测与“超框建议”（提升洞察力与抗抖）

  - 事件循环卡顿监控（Long Tasks/ELD）
      - Renderer: PerformanceObserver('longtask') 若可用；否则用 performance.now() + 微任务检测粗略监控
      - Preload/Node: perf_hooks.monitorEventLoopDelay()（注意只在 Node 侧），contextBridge 上报指标
  - Sentry Performance + 版本门禁（ADR-0003）
      - 对冷启动/交互/场景切换上报 transaction + span，CI 读取 Release Health 对比上个基线
  - 真实硬件校准
      - 选定一台 Windows 参考机（中低配）定期跑基准；CI 基础设施数字仅做相对参考

  实施顺序与粒度（两周冲刺建议）

  - 第0天（准备/基线）
      - 接入 rollup-visualizer；为交互用例添加 performance.mark；开启失败用例 trace 上传
  - 第1~2天（首屏拆分）
      - vite manualChunks + 动态导入 Phaser/场景/大视图；antd 模块化导入；Skeleton 占位
  - 第3~4天（交互异步化）
      - 将交互路径重逻辑改用 Worker/Idle/双 rAF；引入 useTransition；修整渲染 diff 范围
  - 第5天（Phaser 专项）
      - 延迟加载 + 资产打包/压缩策略雏形；进入游戏进度条体验
  - 第6天（构建门禁）
      - 加入 bundle 预算 Gate + 性能 soft gate；PR 附可视化报告
  - 第7~10天（优化迭代）
      - 根据 trace/埋点数据逐步压降卡顿源；把较难的计算迁 Worker
  - 第11~12天（转硬门）
      - 评估两周数据，决定将软门转硬门的阈值与波动缓冲策略

  注意事项（安全/基线/ADR 对齐）

  - Electron 安全基线保持：nodeIntegration=false、contextIsolation=true、sandbox=true；Worker 场景不得绕开隔离（不要在 preload 中引重库）。
  - CSP：script-src 'self' 可支持动态导入（同源）；避免任何 unsafe-eval/new Function。
  - 文档与 ADR：本提案与 ADR‑0008（Windows-only 发布）/ADR‑0011（Windows-only 平台与 CI 策略）一致；更新 ADR‑0005 的质量门禁附录以收录性能预算与 Gate。

  
  已创建与更新

  - vite.config.ts: 手工分块增强（新增 antd-vendor），保留 phaser/react/vendor 分离与可视化插件。
  - src/game/lazy/phaser-loader.ts: Phaser 与场景动态导入工具（延迟加载核心库与场景）。
  - src/components/LazyGame.tsx: 懒加载示例组件（“Start Game”后再加载 Phaser/场景，含双 rAF 进入稳定帧）。
  - src/workers/computation.worker.ts + src/shared/workers/workerBridge.ts：计算密集任务迁移到 Worker 的最小桥接实现。
  - scripts/ci/bundle-budget-gate.mjs：bundle 预算 Gate（gzip 阈值：phaser ≤ 500kB、react-vendor ≤ 150kB、initial 合计 ≤ 400kB）。
  - package.json: 新增脚本 guard:bundle 以执行预算 Gate。

  建议执行顺序（落地与验证）

  - 运行构建与预算 Gate：npm run build && npm run guard:bundle（应输出各 chunk gzip 大小与是否达标）。
  - 将 LazyGame 集成到首屏或“开始游戏”入口，替换直接加载 Phaser 的路径（代码改造时优先这一处）。
  - 将交互中耗时逻辑改用 workerBridge.heavyTask() 或等价 Worker 封装，按钮点击路径先反馈再回填结果。
  - 按需将各大视图改为 React.lazy 懒加载；Antd 改为按需/模块化引入，避免整包打入首屏。
  - 若需 CI Gate，将 npm run guard:bundle 加入工作流的构建后阶段（或软门禁先告警）。
  
  
  
  验收标准（最小闭环）

  - 交互用例“<200ms”通过，重复 3 次无偶发失败
  - initial js gzip 降至 ≤400kB；phaser 独立 chunk；react vendor ≤150kB
  - 冷启动 P95 达标（现预算）并在 PR 中提供 visualizer 截图/报告
  - CI 出现性能回归时给出可定位的信息（trace + mark/measure）