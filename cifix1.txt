  - 你这次的 90s 超时，高概率是“在 app.whenReady() 之前访问了 session.defaultSession 或创建 BrowserWindow”，导致首窗未能稳定打开。次因候选是“预加载路径/沙箱
  不兼容导致渲染崩溃”。不要拉长超时，也不要 fixme，应修正时序与路径。

  最小修复 patch（文本 diff，按你的路径替换）

  - 目标：把所有 defaultSession 访问与首窗创建延后到 whenReady()，并加上关键崩溃/加载失败日志，确保 preload 路径在 dev/prod 均正确。

  1. src/main/index.ts（或同等主进程入口）
  --- a/src/main/index.ts
  +++ b/src/main/index.ts
  @@
  -import { app, session } from 'electron';
  -import { hardenSession } from '../shared/security/session'; // 假定已存在
  -import { createMainWindow } from './window';
  -
  -const ses = session.defaultSession;
  -hardenSession(ses);
  -createMainWindow();
  +import { app, session } from 'electron';
  +import { hardenSession } from '../shared/security/session';
  +import { createMainWindow } from './window';
  +
  +app.on('render-process-gone', (_e, wc, d) => {
  +  console.error('[main] render-process-gone:', d.reason, d.exitCode);
  +});
  +app.on('child-process-gone', (_e, d) => {
  +  console.error('[main] child-process-gone:', d.reason, d.exitCode);
  +});
  +app.on('web-contents-created', (_e, wc) => {
  +  wc.on('did-fail-load', (_e2, ec, ed) => {
  +    console.error('[main] did-fail-load:', ec, ed);
  +  });
  +});
  +
  +app.whenReady().then(async () => {
  +  const ses = session.defaultSession;
  +  await hardenSession(ses);      // 仅在 ready 之后调用
  +  await createMainWindow();      // 仅在 ready 之后创建首窗
  +});
  2. src/main/window.ts（或首窗创建处）
  --- a/src/main/window.ts
  +++ b/src/main/window.ts
  @@
  -import { BrowserWindow } from 'electron';
  +import { BrowserWindow } from 'electron';
  +import { join } from 'node:path';
  +
  +const isDev = !!process.env.VITE_DEV_SERVER_URL;

   export async function createMainWindow() {
  -  const win = new BrowserWindow({
  -    webPreferences: {
  -      contextIsolation: true,
  -      preload: '../preload/index.js'
  -    }
  -  });
  -  // ...
  +  const win = new BrowserWindow({
  +    show: false,
  +    webPreferences: {
  +      nodeIntegration: false,
  +      contextIsolation: true,
  +      sandbox: true,
  +      preload: isDev
  +        ? join(__dirname, '../preload/index.mjs') // dev 产物/源文件的真实后缀视你的打包而定
  +        : join(__dirname, '../preload/index.cjs'),
  +    },
  +  });
  +  win.once('ready-to-show', () => win.show());
  +  win.webContents.on('render-process-gone', (_e, d) => {
  +    console.error('[window] render-process-gone:', d.reason, d.exitCode);
  +  });
  +  // dev/prod URL 需区分，避免白屏
  +  if (isDev && process.env.VITE_DEV_SERVER_URL) {
  +    await win.loadURL(process.env.VITE_DEV_SERVER_URL);
  +  } else {
  +    await win.loadFile(join(__dirname, '../renderer/index.html')); // 按你构建结果修正
  +  }
  +  return win;
   }
  3. src/shared/security/session.ts（若你在模块导入时访问了 session，必须改）
  --- a/src/shared/security/session.ts
  +++ b/src/shared/security/session.ts
  @@
  -// ❌ 不要在模块顶层读取 defaultSession
  -const ses = session.defaultSession;
  -export function hardenSession() { /* 使用 ses ... */ }
  +// ✅ 通过参数传入，调用方在 whenReady 后传 defaultSession 进来
  +import type { Session } from 'electron';
  +export async function hardenSession(ses: Session) {
  +  // 仅在 ready 后被调用
  +  // setPermissionRequestHandler / setWindowOpenHandler / will-navigate 守卫等
  +}
  4. Playwright（仅修正 Electron 启动入口；具体文件名依你仓库为准）

  - 确保 Electron 项目使用构建后的主进程入口（而非源码），Windows 上路径必须存在：
  --- a/playwright.config.ts
  +++ b/playwright.config.ts
  @@
   export default defineConfig({
     projects: [
       {
         name: 'electron',
  -      use: { /* ... */ } // 你当前的配置
  +      use: {
  +        // 明确告诉测试代码从构建产物启动
  +        // 你的测试里通常用 `_electron.launch({ args: [MAIN_ENTRY] })`
  +        // 这里通过环境变量/fixtures 统一 MAIN_ENTRY
  +        launchOptions: {
  +          env: {
  +            MAIN_ENTRY: process.env.MAIN_ENTRY ?? 'build/main/index.cjs'
  +          }
  +        }
  +      }
       }
     ]
   });
  - 若你的测试已在代码里读取 process.env.MAIN_ENTRY，只需在 CI 设置该变量指向构建产物。

  5. 测试里（若等待条件过于宽松或无日志，增补等待“窗口可见/可交互”）

  - 示例（仅思路，别改变断言语义）：等待 electronApp.firstWindow() 且 isVisible()/isEnabled() 为真，超时用默认即可；不要简单拉长到 120–180s。

  CI 变更（防止“入口缺失”导致假失败）

  - 在 test:e2e 前添加 Electron 构建，并注入 MAIN_ENTRY。示例 GitHub Actions 片段：
  - name: Build Electron
    run: npm run build:electron
  - name: E2E (Electron)
    env:
      MAIN_ENTRY: build/main/index.cjs        # 与实际产物匹配
      ELECTRON_ENABLE_LOGGING: '1'
      DEBUG: 'electron*'
    run: npx playwright test -g "electron-security-audit" --trace on
  - name: Upload Playwright Trace
    if: failure()
    uses: actions/upload-artifact@v4
    with:
      name: pw-trace
      path: playwright-report
  验证步骤（本地优先）

  - 仅跑该用例，带 debug/trace 与日志：
      - ELECTRON_ENABLE_LOGGING=1 DEBUG=electron* MAIN_ENTRY=build/main/index.cjs npx playwright test tests/e2e/security/session-ready.spec.ts --debug
  --project=electron
      - 复跑 3 次，确保稳定通过且无 render-process-gone/did-fail-load。
  - 全量安全审计分组：
      - npx playwright test -g "electron-security-audit" --trace on

  验收标准（Acceptance）

  - 安全基线：nodeIntegration=false、contextIsolation=true、sandbox=true 在首窗生效；preload 仅白名单导出，无 remote。
  - 时序：仓库内无任何在 whenReady() 之前读取 session.defaultSession 或创建 BrowserWindow 的代码（含模块顶层副作用）。
  - E2E：session-ready.spec.ts 稳定通过（3/3），无白屏/崩溃日志。
  - CI：build:electron 在 test:e2e 前执行；失败时附带 Playwright trace。
  - 覆盖率：仍满足全局 ≥ 90%。

  止损机制（短期解堵，但不建议长期保留）

  - 如果 CI 仍偶发超时：保留测试，继续采集 trace+主进程日志，不要调高超时或 fixme。必要时仅在 CI 临时关闭 autoHideMenuBar/启用 show:false + ready-to-show 以
  稳定首帧展示，但同时附带问题追踪与回滚计划。

  你可能忽略的风险点（直言不讳）

  - 任何“在模块导入时”访问 session.defaultSession 的工具函数都会违背 ADR‑0002（通常藏在 security/session.ts 或 services/* 中），请全局检索并改为“注入 Session
  参数 + 在 ready 后调用”。
  - preload 若还在用 Node 直接能力（fs/path/net）且开启 sandbox:true，渲染会悄悄崩溃，表现即为“等不到首窗”。这类问题 E2E 会超时但日志很少，只有
  render-process-gone 能露出端倪。
  - CI 若未固定构建产物路径（不同 runner/OS 生成位置不同），会导致仅在 CI 失败、而本地通过的“玄学问题”。