我看了你这次 CI 的报错文件，失败点集中在**“guard:performance（User Timing 基准）整套门禁全红”**：5 个场景的 P95/P99 超过你设定阈值（例如 App Startup P95≈3749ms>3000ms；Game Scene Load P95≈1879ms>1500ms 等），最终以 exit code 1 终止流水线。下面给你一个“先保上线、再稳长期”的两段式修复方案：先让 CI 变绿（不放弃预警），再系统性把指标拉回到阈值以内。
MDN Web Docs
+1

A. 先让 CI 变绿，但继续给出“有牙齿”的预警

共享型 Windows Runner 的性能抖动明显（2 vCPU / 7GB RAM 的按需 VM），将绝对阈值作为硬门禁很容易误伤正常提交；建议把当前基准降为软门禁（不中断合并），或改成相对回归门禁（相对主分支基线）。
GitHub Docs
+1

把 job 改成“不中断，但要评审”（软门禁）

- name: Run performance guard
  id: perf
  run: npm run guard:performance
  continue-on-error: true   # 不阻断合并

# 失败就把结论写到 Job Summary / PR 评论（但不 fail）
- name: Summarize perf guard
  if: failure() && steps.perf.outcome == 'failure'
  shell: bash
  run: |
    {
      echo "## ⚠️ 性能门禁预警（未阻断）"
      echo "- 本次 P95/P99 超阈；请在合并前复核对照基线"
    } >> "$GITHUB_STEP_SUMMARY"


GitHub 的受保护分支可以把性能检查设为非 Required，失败时也不阻断合并；在你的主干保护上我们之前已建议把性能/包体积迁到软门禁，就是为了避免这类“噪声阻塞”。
web.dev

或改为“相对回归门禁”（更科学）

做 3～5 次重复取中位数做代表值（Lighthouse CI 的典型做法），把相对基线（最近 10 次 main 的中位数）+ 允许回归幅度（如 +20%）作为门禁标准；超过则fail，否则通过。
web.dev
DEV Community
Max Rozen

这比“绝对阈值”更抗噪声，也能真实抓住回归。

B. 系统性把数值拉回（技术 + 统计 + 运行环境三线齐进）
1) 统计与脚本层（立即见效）

升采样 + 预热：每个场景跑 30 次（至少 20 次），前 3 次丢掉当预热；以 P50/Median of Medians 和 P95 判定，重尾分布避免被极端值带偏。Lighthouse CI 也用“多次取中位数”降低抖动。
web.dev
Medium

将 User Timing 用法更规范：确保每个量度都是 performance.mark() + performance.measure() 的闭环，并且在同一上下文读取；浏览器侧参看 MDN User Timing，Node 侧用 perf_hooks 的 performance.mark/measure 对齐规范。
MDN Web Docs
+1
nodejs.org

输出结构化报告 + 稳定阈值：把每轮原始测量、分位数、IQR 一起产出到 JSON 里，门禁只读 P95/P99 与 IQR；避免“只看平均值”的误判（你日志已在看 P95/P99，这是对的）。

分离“Build 压力”和“Perf 量测”：性能测试跑在release 构建产物上（NODE_ENV=production），并且放在专门 job，避免与并发打包/上传抢 IO、CPU。

2) 运行环境层（把误差源降到最低）

Runner 规格与稳定性：共享 Windows Runner 为 2 核/7GB，抖动较大。若你要把“性能门禁”设为硬门禁，建议：
a) 切到 Larger Runner（更高配的托管机型），或
b) 用 自托管 Runner（固定硬件/独占 CPU）。
官方文档明确 runner 规格与“更大机型”的选项。
GitHub Docs
+1

浏览器/引擎一致性：若用浏览器测量（Electron/Chromium），固定版本与启动参数，避免后台更新导致差异；Playwright/Chromium 版本也建议锁定。

3) 代码与场景层（针对你 5 个失败场景）

App Startup（P95≈3.75s，>3s）

减少同步 require() 链、把重模块延迟加载/按需加载；“同步 require 在启动期是最大瓶颈”是 Electron 圈子里反复验证的经验（优先用 bundler / Vite 的代码拆分，避免主进程的 require 堆栈）。
Palette
Takuya Matsuyama

参考 Electron 官方性能指引：只做最小化启动工作、等 ready-to-show 再展示窗口、避免阻塞主进程（I/O、CPU 密集），必要时把重计算挪到 Worker/子进程。
electronjs.org

Game Scene Load（P95≈1.88s，>1.5s）

资源按需加载与预取（纹理、音频分批、使用压缩纹理），并把一次性对象改为对象池（减少 Scene 切换时的分配/回收）。Phaser 官方/社区都有使用 Group 做对象池的实践。
Ourcade Blog
phaser.io

UI Modal Open（P95≈281ms，>200ms）

预渲染/懒挂载 Modal 内部重组件，打开时只做显隐与少量测量；避免同步布局抖动（read→write→read 交错）。

若在浏览器环境量测，确保持久化 measure() 的起止标记只围绕必要代码段。
MDN Web Docs

Game Turn Process（P95≈968ms，>500ms；P99≈975ms，>800ms）

把大 O(n) 的 AI/寻路/规则评估移出主线程（Web Worker/Node Worker）；对频繁生成/销毁的实体使用对象池；调小帧内工作量（把部分逻辑拆分成多帧）。Phaser 的 TimeStep 基于 rAF，目标 60 FPS ≈16.7ms/帧，回合内工作必须“切片化”。
docs.phaser.io

Data Save（P95≈1.33s，>800ms；P99≈1.49s，>1200ms）

持久化路径（本地文件/IndexedDB）：异步批量写代替同步串行；把序列化与压缩移到 Worker；写入合并/去抖。Node 侧 perf_hooks 能帮助你把序列化、压缩、IO 分别打点定位瓶颈。
nodejs.org

C. 你可以直接落地的改动清单（最小化改造）

把性能门禁从“绝对阈值=硬阻断”切到“软门禁/相对回归”（上文 YAML 即插即用）。

在 scripts/benchmarks/user-timing-benchmark.mjs：

每个场景跑 30 次，丢 3 次预热；

输出 p50/p95/p99 与原始样本数组到 JSON；

新增“对照 main 最近 10 次中位数”的回归判断（>+20% 连续 2 次才失败）。
（这一套与 Lighthouse CI “多次运行取中位数 + budgets/回归”相吻合，稳定性显著提升。）
web.dev
DEV Community

App 启动/Scene Load 的代码侧：

把主进程/渲染进程的大依赖延迟加载，确认 bundler 做了代码拆分；

针对 Phaser 的实体/子弹等高频对象启用对象池；

把重计算放 Worker；

参考 Electron 官方性能页逐条排查主进程同步耗时。
electronjs.org
Ourcade Blog

Runner 稳定性（若仍需硬门禁）：把该 job 迁到更大规格 Runner或自托管 Runner。
GitHub Docs
+1

你这份日志里最“值回票价”的两个突破口

启动时同步加载链：把“非首屏”依赖统统推迟（import()/动态 chunk），缩短首屏关键路径（Electron 官方 + 社区经验都强调“少 require、多按需”）。
Palette
electronjs.org

Phaser 对象池 + 资源分批：Scene 切换与回合处理中的分配回收最容易形成 P95 长尾；对象池思路是 Phaser 官方/社区公认的“立竿见影”。