你这组 Electron 安全冒烟 / 红线测试（Windows）里，失败集中在三类症状，我把它们各自溯因→给出最小修复补丁（含 TypeScript 片段 + 测试侧调整）：

問题与根因速览

大量 page.waitForLoadState('domcontentloaded') 超时 & Execution context was destroyed
日志里多次出现 window.location.href 为 chrome-error://chromewebdata/，并在外部导航用例里反复报 “执行环境被销毁”。这基本指向发生了真实导航/加载失败（比如外链尝试或路径不合法），而不是被“拦截后留在原页”。要避免渲染上下文被丢弃，必须在导航触发之前就取消（onBeforeRequest），且在 will-navigate 上二次兜底；如果任其发起再失败，就会落到 chrome-error://chromewebdata/ 并导致上下文销毁。Electron 官方安全指引明确推荐在 will-navigate 阶段 event.preventDefault()，并建议配合 URL 白名单判断；更早的 webRequest.onBeforeRequest 则可直接 cancel 掉外部请求（无真实导航，自然不会销上下文）。
electronjs.org
+1
MDN网络文档

此外，chrome-error://chromewebdata/ 是 Chromium 在加载失败时的占位错误页，这与“无效 URL / 加载失败 / 外部导航被错误处理”一致。
Stack Overflow
安卓权威

electron.launch 超时（30s）
Playwright 已经“附加调试器”，但 firstWindow()/首窗没在时间内进入可用状态。常见诱因：主进程创建了窗口但初始 URL 加载失败（又回到了 chrome-error://chromewebdata/），或路径构造/协议注册在 Windows 上不稳。官方建议用 Electron 的 自定义安全协议（例如 app://）+ 注册为 standard + secure，再加载 app://index.html，既能配合 CSP 走 响应头，又能避免 file:// 在 headers/CSP 上的限制。
electronjs.org

Playwright 的 Electron 启动与取首窗流程参考文档如下。
Playwright

CSP 冒烟测试失败：meta[http-equiv=Content-Security-Policy] 取到 undefined
说明当前页面没有 <meta http-equiv="Content-Security-Policy" ...>。在 Electron 中设置 CSP有两种：

响应头（生产最推荐，配合自定义协议或本地服务）

<meta> 标签（file:// 无法加响应头时的退路）
安全工具（如 electronegativity）也明确了这两种途径。你的测试现在只认 <meta>，建议在 测试/开发注入 <meta>，在 生产通过响应头强制 CSP。
GitHub
Stack Overflow

补充：权限相关的用例（地理位置/通知）超时或状态异常，和 Electron 默认自动批准权限的行为差异有关（不同版本里 navigator.permissions 还曾有“总是返回 granted”的已知问题）。需要同时配置 setPermissionRequestHandler 与 setPermissionCheckHandler 双轨拒绝，确保在 Windows CI 上表现稳定。
blog.doyensec.com
GitHub

一次到位的主进程修复补丁（TypeScript）

目标：永不发生真实外部导航（上下文不销毁）、首窗始终可加载、CSP/COOP/COEP/CORP/Permissions-Policy 走响应头，并默认拒绝所有敏感权限。符合你 ADR-0002 的基线。

// electron/main.ts
import { app, BrowserWindow, session, shell, protocol } from 'electron';
import { join } from 'node:path';
import { pathToFileURL } from 'node:url';

const APP_SCHEME = 'app';

protocol.registerSchemesAsPrivileged([{
  scheme: APP_SCHEME,
  privileges: {
    standard: true, secure: true, supportFetchAPI: true,
    corsEnabled: true, // 需要跨源资源时打开
    bypassCSP: false
  }
}]); // 自定义安全协议，便于用响应头下发 CSP/COOP/COEP/CORP。:contentReference[oaicite:6]{index=6}

function createWindow() {
  const win = new BrowserWindow({
    width: 1024, height: 768, show: true,
    webPreferences: {
      preload: join(__dirname, 'preload.js'),
      nodeIntegration: false, contextIsolation: true, sandbox: true
    }
  });

  // —— 1) 彻底阻断外部导航（两层：beforeRequest + will-navigate） ——
  const ses = win.webContents.session;

  // 1a) 最早阶段 cancel（不会真正导航→不会销上下文）
  ses.webRequest.onBeforeRequest(
    { urls: ['http://*/*', 'https://*/*'] },
    (details, cb) => {
      // 允许清单（如 Sentry 接入页、你自管域），否则 cancel
      const allow = false; // 这里按需白名单
      cb({ cancel: !allow });
    }
  ); // 官方 WebRequest 文档：可在该阶段取消请求。:contentReference[oaicite:7]{index=7}

  // 1b) 二道闸：即使溜过，也在将要导航时拦下
  win.webContents.on('will-navigate', (event, url) => {
    event.preventDefault(); // 官方安全指引推荐。:contentReference[oaicite:8]{index=8}
    // 如需放行少量可信 URL，可在此白名单 + shell.openExternal(url)
  });

  // 新窗口一律拒绝或外部打开（防劫持）
  win.webContents.setWindowOpenHandler(({ url }) => {
    // 可选：shell.openExternal(url);
    return { action: 'deny' };
  }); // 官方文档：返回 {action:'deny'} 取消新窗。:contentReference[oaicite:9]{index=9}

  // —— 2) 生产用响应头下发 CSP / COOP / COEP / CORP / Permissions-Policy ——
  ses.webRequest.onHeadersReceived((details, cb) => {
    const headers = details.responseHeaders ?? {};
    const set = (k: string, v: string) => {
      headers[k] = [v];
    };

    // 最小可用 CSP（按需扩展 connect-src 等）
    set('Content-Security-Policy',
      "default-src 'self'; base-uri 'none'; object-src 'none'; " +
      "img-src 'self' data:; style-src 'self' 'unsafe-inline'; " +
      "script-src 'self'; connect-src 'self' https://o.sentry.io");

    // 相邻安全头
    set('Cross-Origin-Opener-Policy', 'same-origin');
    set('Cross-Origin-Embedder-Policy', 'require-corp');
    set('Cross-Origin-Resource-Policy', 'same-origin');
    set('Permissions-Policy',
      'geolocation=(), microphone=(), camera=(), notifications=(), ' +
      'fullscreen=(self)'); // 例子：全部拒绝，仅 fullscreen 自来源允许

    cb({ responseHeaders: headers });
  }); // Electron 支持在 onHeadersReceived 中修改/注入响应头。:contentReference[oaicite:10]{index=10}

  // —— 3) 权限默认拒绝（Request + Check 双保险） ——
  ses.setPermissionRequestHandler((_wc, _permission, callback) => callback(false));
  ses.setPermissionCheckHandler((_wc, _permission) => false);
  // 覆盖 geolocation / notifications / media 等权限类型。:contentReference[oaicite:11]{index=11}

  // —— 4) 健壮加载 + 错误自愈 —— 
  // 使用 app:// 协议（若你已经有静态服务，也可用 http://localhost）
  // 若你仍用 file://，建议至少把 URL 用 pathToFileURL 构造，避免 Windows 路径分隔问题。
  const indexUrl = `${APP_SCHEME}://- /index.html`; // 你在 protocol.registerFileProtocol 里映射
  // 如果暂未实现自定义协议，可退回：
  // const indexUrl = pathToFileURL(join(__dirname, '../renderer/index.html')).toString();

  win.webContents.on('did-fail-load', (_e, code, desc, url) => {
    // 避免停在 chrome-error://，回退到本地首页
    console.warn('[did-fail-load]', code, desc, url);
    if (!win.isDestroyed()) win.loadURL(indexUrl);
  }); // did-fail-load 是 load 失败时触发的事件。:contentReference[oaicite:12]{index=12}

  win.loadURL(indexUrl);
}

// 这里注册 app:// 映射（若使用自定义协议）
app.whenReady().then(() => {
  protocol.registerFileProtocol(APP_SCHEME, (request, cb) => {
    // 简单的静态文件映射示例（根据你的构建产物路径调整）
    const url = request.url.replace(`${APP_SCHEME}://-`, '');
    cb({ path: join(__dirname, '../renderer', url) });
  });
  createWindow();
});


说明：

为何双层拦截？ onBeforeRequest 在最早阶段取消请求，避免“真导航→销上下文”；will-navigate 则是官方安全建议的兜底（即使放过早期拦截，仍可阻断）。
electronjs.org
+1

为何响应头 CSP？ 生产环境用响应头最稳；但测试可继续保留 <meta> 以适配你现有断言（见下）。
GitHub

为何权限双处理？ Electron 缺省会“自动批准”权限；加上 setPermissionRequestHandler 与 setPermissionCheckHandler 后，CI 上地理位置/通知等用例能稳定呈现“拒绝”。
blog.doyensec.com

渲染页 / 测试侧微调
A. 在测试/开发环境额外加 meta CSP（兼容你现有 smoke 断言）
<!-- renderer/index.html - 仅 dev/test 注入；生产以响应头为准 -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self'; base-uri 'none'; object-src 'none';
               img-src 'self' data:; style-src 'self' 'unsafe-inline';
               script-src 'self'; connect-src 'self'">


为什么两套都保留：file:// 下无法用响应头下发 CSP（这也是许多项目测试时用 <meta> 的原因）；生产切到自定义协议/本地服务+响应头即可。
Stack Overflow

B. Playwright 等待策略与断言收敛

首窗 wait 策略：把 domcontentloaded 改成“readyState 判定 + URL 非 chrome-error://”，避免死等：

const page = await electronApp.firstWindow();
await page.waitForFunction(() =>
  ['interactive', 'complete'].includes(document.readyState), { timeout: 15000 });

const url = page.url();
expect(url.startsWith('chrome-error://')).toBeFalsy();


失败时可附加截图/trace，便于定位是哪一步落到错误页（现在日志已有 trace.zip）。

外链拦截测试：在 evaluate 里包一层 try/catch，并在行为层断言“URL 未变 & 无新窗”。有了 onBeforeRequest(cancel)，不会发生真导航，Execution context 也不再销毁。
官方建议的拦截方式见 setWindowOpenHandler 与 will-navigate。
electronjs.org
+1

通知/地理位置：把断言从 permissions.query（部分版本异常）换成行为断言（比如触发权限 API→预期抛错/拒绝）或检查 Notification.permission !== 'granted'。Electron 权限默认批准、以及 permissions.query 异常的讨论见：
blog.doyensec.com
GitHub

你关心的 9 个失败点，对应“改完后”的效果

CSP（增强）两条用例等待超时 → 初始 URL 将不再落到 chrome-error，readyState 等待可通过；内联脚本被 CSP 阻止（响应头或 <meta>），用例恢复。
GitHub

Electron 基线：渲染进程无法访问 Node API → 不变（nodeIntegration:false + contextIsolation:true + sandbox:true）。

红线 1：权限请求（地理位置） → Request/Check 双拒绝后，稳定拒绝；不再 electron.launch 超时。
Stack Overflow

红线 1：window.location / 链接点击 → 通过 onBeforeRequest(cancel) 避免真实导航 → 不再 “execution context destroyed”。
electronjs.org

红线 3：通知权限拒绝 → 通过 Permission 双处理保证拒绝分支稳定。
Stack Overflow

综合稳定性 / 持久性 → 上述拦截与权限、CSP 都是会话级设置（session.defaultSession），在单实例多轮验证中保持一致。
electronjs.org

安全冒烟（CSP & 禁用 Node） → 加 <meta> 后 csp 不再是 undefined；生产仍由响应头兜底。
Stack Overflow

小型就地验收（Vitest/Playwright 占位）
// tests/e2e/security/smoke-csp-header-or-meta.spec.ts
import { test, expect, _electron as electron } from '@playwright/test';

test('CSP 以 响应头 或 <meta> 其一存在即可', async () => {
  const app = await electron.launch({ args: ['./electron/main.js'] });
  const page = await app.firstWindow();

  // 1) readyState 守护 + 非 chrome-error
  await page.waitForFunction(() =>
    ['interactive','complete'].includes(document.readyState));
  expect(page.url().startsWith('chrome-error://')).toBeFalsy();

  // 2) dev/test: 允许 <meta> 作为满足条件之一
  const hasMeta = await page.$("meta[http-equiv='Content-Security-Policy']");
  const metaOk = !!hasMeta;

  // 3) 生产: 通过功能性断言验证 CSP 生效（内联脚本应被阻止）
  const inlineAllowed = await page.evaluate(() => {
    try { const s = document.createElement('script'); s.textContent = 'window.__x=1'; document.head.appendChild(s); return !!(window as any).__x; }
    catch { return false; }
  });

  expect(metaOk || !inlineAllowed).toBeTruthy();

  await app.close();
});

落地顺序建议

合入主进程补丁（导航双闸、响应头 CSP/COOP/COEP/CORP/Permissions-Policy、权限双处理、did-fail-load 自愈、app:// 协议）；

渲染页在 dev/test 注入 <meta>，生产不注入；

测试等待策略/断言微调（首窗 readyState、外链不真导航、权限行为断言）；

回归跑一轮 Electron 安全测试。

这样改完后：

不会再出现 chrome-error://chromewebdata/ 导致的上下文销毁；

红线用例稳定，不依赖网络/外部域；

CSP 在 CI（Windows）与生产均有兜底路径；

行为与 ADR-0002 的**“导航/权限双拦截 + 严格 CSP + 相邻安全头”**保持一致。