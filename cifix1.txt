你上传的最新日志里还在反复出现
TypeError: Session can only be received when app is ready（main.js 第 ~200 行）→ 说明主因 A（在 app 未 ready 前访问 session）尚未完全落实。

还出现 TypeError: Cannot read properties of undefined (reading 'launch') at tests/helpers/launch.ts:19 → 说明主因 B（Playwright Electron 启动 helper 的导入方式不统一）也未落实到所有用例/帮助函数。

另外，多处用例报 Execution context was destroyed, most likely because of a navigation 与页面 URL 跳到 chrome-error://chromewebdata/，这是因为你用 webRequest.onBeforeRequest 在 mainFrame 上“硬拦截”外部导航，Chromium 会把主文档替换成错误页，从而打断 Playwright 的执行上下文。应改为用 will-navigate 阻止主框架导航、setWindowOpenHandler 拒绝新窗，webRequest 仅用于子资源。相关机制与建议做法来自 Electron 官方文档（setWindowOpenHandler、protocol.handle、webContents 事件）与社区经验。
Electron
 
Electron
 
Stack Overflow

一、针对「主因 A」的落地修正（必须）
1) 把所有 session.* 访问延后到 app.whenReady() 之后

不要在模块顶层（import 副作用）里访问 session.defaultSession / session.fromPartition 或注册 webRequest。把它们封装成函数，待 await app.whenReady() 后再调用。官方也强调 protocol / session 相关注册要在 ready 之后（registerSchemesAsPrivileged 例外，需在 ready 之前调用一次）。
Electron

main.ts（示例片段）

// ✅ 放在 ready 之前：注册自定义协议的权限
protocol.registerSchemesAsPrivileged([
  { scheme: 'app', privileges: { standard: true, secure: true, supportFetchAPI: true } },
]);

async function boot() {
  await app.whenReady();

  // ✅ 只在 ready 后再访问 session / 注册 webRequest
  const ses = session.defaultSession;
  installNetworkGuards(ses); // 只处理子资源，见下节

  await protocol.handle('app', (req) => {
    const { pathname } = new URL(req.url);
    const file = pathname === '/' ? 'index.html' : pathname;
    return net.fetch(pathToFileURL(join(app.getAppPath(), 'dist', file)).toString());
  });

  const win = await createMainWindow();
  bindNavigationGuards(win); // will-navigate + setWindowOpenHandler（见下节）
}
boot();


上面 protocol.handle 与 registerSchemesAsPrivileged 的用法取自官方示例；新版本推荐 protocol.handle 取代旧的 register*Protocol。
Electron

二、针对「主因 B」的统一修正（Playwright Electron 启动）

所有 Electron 启动入口（测试与 helpers）统一成同一种导入：

// tests/helpers/launch.ts
import { _electron as electron, ElectronApplication } from 'playwright';
// 或：from '@playwright/test'，但全仓库需保持一致

export async function launchApp(entry?: string): Promise<ElectronApplication> {
  const main = entry ?? resolve(process.cwd(), 'dist-electron', 'main.js');
  return electron.launch({ args: [main], env: { CI: 'true', SECURITY_TEST_MODE: 'true' } });
}


Playwright 官方文档明确 _electron.launch({ args: ['main.js'] }) 的调用方式，务必避免把 _electron 解构漏成 electron 未定义。
Electron
Playwright

三、把“外部导航/弹窗拦截”从 webRequest(mainFrame) 改为 will-navigate / setWindowOpenHandler
目标

主框架外跳：在导航开始前阻止（保持当前文档，不触发错误页）。

新窗口：一律拒绝或转 shell.openExternal（白名单）。

子资源：可继续用 webRequest 做细粒度阻断/标记。

实施
function bindNavigationGuards(win: BrowserWindow) {
  // 1) 主框架导航：will-navigate 直接阻止（不让页面换成 chrome-error）
  win.webContents.on('will-navigate', (e, url) => {
    if (!isAppUrl(url)) {
      e.preventDefault();                 // ✅ 不进入导航 → 不会生成错误页
      // 可选择：记录审计、提示、或 shell.openExternal(url)（白名单）
    }
  });

  // 2) 新窗口：从主进程统一拒绝/放行
  win.webContents.setWindowOpenHandler(({ url }) => {
    return isAllowedExternal(url)
      ? (shell.openExternal(url), { action: 'deny' })
      : { action: 'deny' };               // ✅ 官方推荐入口
  });
}

// 仅对子资源做统一网络护栏，不要 cancel mainFrame
function installNetworkGuards(ses: Session) {
  ses.webRequest.onBeforeRequest(
    { urls: ['*://*/*'] },
    (details, callback) => {
      if (details.resourceType === 'mainFrame') {
        // 交给 will-navigate 处理，避免 chrome-error 页
        return callback({ cancel: false });
      }
      // 对子资源执行你的 CSP/域白名单等策略
      const blocked = shouldBlockSubresource(details);
      callback({ cancel: blocked });
    }
  );
}


setWindowOpenHandler 是 Electron 官方推荐在主进程统一控制 renderer 创建窗口的方式。
Electron

使用 will-navigate 阻止主文档跳转，可以避免 webRequest(cancel) 造成的 ERR_BLOCKED_BY_CLIENT → chrome-error://chromewebdata/ 错误页，从而不再打断 Playwright 的执行上下文。will-navigate 的做法是官方与社区长期建议的拦截主框架导航手段。
Stack Overflow

若仍偶发到错误页，可加一道保险：

win.webContents.on('did-fail-load', (_e, _code, _desc, url, isMain) => {
  if (isMain && url.startsWith('chrome-error://')) win.loadURL('app://index.html');
});


did-fail-load 用于捕捉加载失败事件并恢复。
Electron

四、app:// 协议的健壮性（避免首屏就进错误页）

在 ready 之前注册权限：registerSchemesAsPrivileged([{ scheme:'app', privileges:{ standard:true, secure:true, supportFetchAPI:true } }])。

在 ready 之后用 protocol.handle('app', handler) 提供资源（如 dist/index.html、静态文件等）。官方推荐 handle 替代旧 register*Protocol。
Electron

五、就地验收（片段）
1) TS 事件契约
// src/shared/contracts/security-events.ts
export type SecurityEvent =
  | { type: 'NAV_BLOCKED'; url: string }
  | { type: 'POPUP_BLOCKED'; url: string };

2) Playwright：外部导航应被阻止（不出现错误页）
// tests/e2e/security/redlines.navigation.spec.ts
import { test, expect, _electron as electron } from '@playwright/test';

test('外部导航阻止 - 不应落到 chrome-error', async () => {
  const app = await electron.launch({ args: ['dist-electron/main.js'] });
  const page = await app.firstWindow();
  await page.waitForLoadState('domcontentloaded');

  // 触发外部跳转
  await page.evaluate(() => (window.location.href = 'https://example.com'));

  // 仍停留在 app:// 协议；也不应是 chrome-error
  const url = page.url();
  expect(url.startsWith('app://')).toBeTruthy();
  expect(url.startsWith('chrome-error://')).toBeFalsy();

  await app.close();
});

3) Playwright：统一的启动 helper（防止 “electron 未定义”）
// tests/helpers/launch.spec.ts
import { test, expect } from '@playwright/test';
import { launchApp } from './launch';

test('能用统一 helper 启动应用', async () => {
  const app = await launchApp();
  const page = await app.firstWindow();
  await page.waitForLoadState('domcontentloaded');
  expect(await page.evaluate(() => document.readyState)).toBe('complete');
  await app.close();
});

六、补充：为什么这套改动能消除你现在的报错

Session 访问时机：Electron 明确要求在 app.ready 之后再获取 session，否则抛出你日志里的同款错误（“app is ready”）。把 session 相关注册延后，根因即解。
Electron

导航与错误页：当你用 webRequest.onBeforeRequest({cancel:true}) 去拦主文档导航时，Chromium 会把页面替换为错误文档（常见为 chrome-error://chromewebdata/），Playwright 执行上下文因此被销毁，出现 “Execution context was destroyed…”；改用 will-navigate 先期阻止主框架导航则不会进入错误页。
Stack Overflow
GitHub

新窗控制：统一用 setWindowOpenHandler（主进程）保证任何 target=_blank / window.open 都被拒绝或转系统浏览器，官方推荐。
Electron

自定义协议：registerSchemesAsPrivileged + protocol.handle 是官方当前推荐路径，既保证安全能力（standard/secure），又确保 fetch/相对路径解析正确，避免首屏 404/错误页。
Electron

Playwright 导入：官方范例要求通过 _electron 命名空间获取 launch，导入不统一会导致 “electron 未定义”。
Electron

七、顺手把 CI 里另一个坑也一并抹掉（PowerShell vs Bash）

你之前的 emergency_rollback 报错：在 Windows runner 下执行了 Bash 语法（if [ -z "$WEBHOOK_URL" ]），而默认 shell 是 PowerShell。
两种修法二选一：

在该 step 显式加 shell: bash；

或改为 PowerShell 语法：if (-not $env:WEBHOOK_URL) { … }。

（这正是“避免 shell 混用”的那条门禁。）

你现在要做的最小变更清单

把所有 session.* 访问从模块顶层移到 await app.whenReady() 之后；

将主框架外跳从 webRequest(cancel) 改为 will-navigate(e.preventDefault())；

统一 setWindowOpenHandler 拦新窗；

webRequest 仅用于子资源；

落实 protocol.registerSchemesAsPrivileged（pre-ready）+ protocol.handle（post-ready） ；

全仓库统一 Playwright 导入：import { _electron as electron } from 'playwright'（或 @playwright/test），修复 helpers/launch.ts 与复用它的所有 spec；

（可选保险） 在 did-fail-load 检测到 chrome-error:// 时自动回到 app://index.html。

按上面把主因 A/B 先修掉，你这条流水线里 “启动超时 / 执行上下文被销毁 / chrome-error 页面” 会一并消失，安全红线与冒烟都会稳定下来。